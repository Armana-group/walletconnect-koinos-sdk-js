var Ia = Object.defineProperty;
var Ma = (v, e, fe) => e in v ? Ia(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe;
var gi = (v, e, fe) => (Ma(v, typeof e != "symbol" ? e + "" : e, fe), fe);
const t = Symbol(), s = Object.getPrototypeOf, c$2 = /* @__PURE__ */ new WeakMap(), l$2 = (v) => v && (c$2.has(v) ? c$2.get(v) : s(v) === Object.prototype || s(v) === Array.prototype), y$4 = (v) => l$2(v) && v[t] || null, h$5 = (v, e = !0) => {
  c$2.set(v, e);
}, isObject = (v) => typeof v == "object" && v !== null, proxyStateMap = /* @__PURE__ */ new WeakMap(), refSet = /* @__PURE__ */ new WeakSet(), buildProxyFunction = (v = Object.is, e = (xe, me) => new Proxy(xe, me), fe = (xe) => isObject(xe) && !refSet.has(xe) && (Array.isArray(xe) || !(Symbol.iterator in xe)) && !(xe instanceof WeakMap) && !(xe instanceof WeakSet) && !(xe instanceof Error) && !(xe instanceof Number) && !(xe instanceof Date) && !(xe instanceof String) && !(xe instanceof RegExp) && !(xe instanceof ArrayBuffer), be = (xe) => {
  switch (xe.status) {
    case "fulfilled":
      return xe.value;
    case "rejected":
      throw xe.reason;
    default:
      throw xe;
  }
}, ye = /* @__PURE__ */ new WeakMap(), ve = (xe, me, we = be) => {
  const ur = ye.get(xe);
  if ((ur == null ? void 0 : ur[0]) === me)
    return ur[1];
  const lr = Array.isArray(xe) ? [] : Object.create(Object.getPrototypeOf(xe));
  return h$5(lr, !0), ye.set(xe, [me, lr]), Reflect.ownKeys(xe).forEach((Ar) => {
    if (Object.getOwnPropertyDescriptor(lr, Ar))
      return;
    const Br = Reflect.get(xe, Ar), Xr = {
      value: Br,
      enumerable: !0,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (refSet.has(Br))
      h$5(Br, !1);
    else if (Br instanceof Promise)
      delete Xr.value, Xr.get = () => we(Br);
    else if (proxyStateMap.has(Br)) {
      const [eo, jr] = proxyStateMap.get(
        Br
      );
      Xr.value = ve(
        eo,
        jr(),
        we
      );
    }
    Object.defineProperty(lr, Ar, Xr);
  }), Object.preventExtensions(lr);
}, Ee = /* @__PURE__ */ new WeakMap(), Se = [1, 1], Oe = (xe) => {
  if (!isObject(xe))
    throw new Error("object required");
  const me = Ee.get(xe);
  if (me)
    return me;
  let we = Se[0];
  const ur = /* @__PURE__ */ new Set(), lr = (Zr, Wr = ++Se[0]) => {
    we !== Wr && (we = Wr, ur.forEach((qr) => qr(Zr, Wr)));
  };
  let Ar = Se[1];
  const Br = (Zr = ++Se[1]) => (Ar !== Zr && !ur.size && (Ar = Zr, eo.forEach(([Wr]) => {
    const qr = Wr[1](Zr);
    qr > we && (we = qr);
  })), we), Xr = (Zr) => (Wr, qr) => {
    const Qr = [...Wr];
    Qr[1] = [Zr, ...Qr[1]], lr(Qr, qr);
  }, eo = /* @__PURE__ */ new Map(), jr = (Zr, Wr) => {
    if (ur.size) {
      const qr = Wr[3](Xr(Zr));
      eo.set(Zr, [Wr, qr]);
    } else
      eo.set(Zr, [Wr]);
  }, kr = (Zr) => {
    var Wr;
    const qr = eo.get(Zr);
    qr && (eo.delete(Zr), (Wr = qr[1]) == null || Wr.call(qr));
  }, $r = (Zr) => (ur.add(Zr), ur.size === 1 && eo.forEach(([qr, Qr], lo) => {
    const Nr = qr[3](Xr(lo));
    eo.set(lo, [qr, Nr]);
  }), () => {
    ur.delete(Zr), ur.size === 0 && eo.forEach(([qr, Qr], lo) => {
      Qr && (Qr(), eo.set(lo, [qr]));
    });
  }), Vr = Array.isArray(xe) ? [] : Object.create(Object.getPrototypeOf(xe)), gr = e(Vr, {
    deleteProperty(Zr, Wr) {
      const qr = Reflect.get(Zr, Wr);
      kr(Wr);
      const Qr = Reflect.deleteProperty(Zr, Wr);
      return Qr && lr(["delete", [Wr], qr]), Qr;
    },
    set(Zr, Wr, qr, Qr) {
      const lo = Reflect.has(Zr, Wr), Nr = Reflect.get(Zr, Wr, Qr);
      if (lo && (v(Nr, qr) || Ee.has(qr) && v(Nr, Ee.get(qr))))
        return !0;
      kr(Wr), isObject(qr) && (qr = y$4(qr) || qr);
      let Lr = qr;
      if (qr instanceof Promise)
        qr.then((so) => {
          qr.status = "fulfilled", qr.value = so, lr(["resolve", [Wr], so]);
        }).catch((so) => {
          qr.status = "rejected", qr.reason = so, lr(["reject", [Wr], so]);
        });
      else {
        !proxyStateMap.has(qr) && fe(qr) && (Lr = Oe(qr));
        const so = !refSet.has(Lr) && proxyStateMap.get(Lr);
        so && jr(Wr, so);
      }
      return Reflect.set(Zr, Wr, Lr, Qr), lr(["set", [Wr], qr, Nr]), !0;
    }
  });
  Ee.set(xe, gr);
  const Fr = [
    Vr,
    Br,
    ve,
    $r
  ];
  return proxyStateMap.set(gr, Fr), Reflect.ownKeys(xe).forEach((Zr) => {
    const Wr = Object.getOwnPropertyDescriptor(
      xe,
      Zr
    );
    "value" in Wr && (gr[Zr] = xe[Zr], delete Wr.value, delete Wr.writable), Object.defineProperty(Vr, Zr, Wr);
  }), gr;
}) => [
  // public functions
  Oe,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  v,
  e,
  fe,
  be,
  ye,
  ve,
  Ee,
  Se
], [defaultProxyFunction] = buildProxyFunction();
function proxy(v = {}) {
  return defaultProxyFunction(v);
}
function subscribe(v, e, fe) {
  const be = proxyStateMap.get(v);
  let ye;
  const ve = [], Ee = be[3];
  let Se = !1;
  const xe = Ee((me) => {
    if (ve.push(me), fe) {
      e(ve.splice(0));
      return;
    }
    ye || (ye = Promise.resolve().then(() => {
      ye = void 0, Se && e(ve.splice(0));
    }));
  });
  return Se = !0, () => {
    Se = !1, xe();
  };
}
function snapshot(v, e) {
  const fe = proxyStateMap.get(v), [be, ye, ve] = fe;
  return ve(be, ye(), e);
}
const o$1 = proxy({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 }), T$1 = { state: o$1, subscribe(v) {
  return subscribe(o$1, () => v(o$1));
}, push(v, e) {
  v !== o$1.view && (o$1.view = v, e && (o$1.data = e), o$1.history.push(v));
}, reset(v) {
  o$1.view = v, o$1.history = [v];
}, replace(v) {
  o$1.history.length > 1 && (o$1.history[o$1.history.length - 1] = v, o$1.view = v);
}, goBack() {
  if (o$1.history.length > 1) {
    o$1.history.pop();
    const [v] = o$1.history.slice(-1);
    o$1.view = v;
  }
}, setData(v) {
  o$1.data = v;
} }, a$2 = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", WCM_VERSION: "WCM_VERSION", RECOMMENDED_WALLET_AMOUNT: 9, isMobile() {
  return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
}, isAndroid() {
  return a$2.isMobile() && navigator.userAgent.toLowerCase().includes("android");
}, isIos() {
  const v = navigator.userAgent.toLowerCase();
  return a$2.isMobile() && (v.includes("iphone") || v.includes("ipad"));
}, isHttpUrl(v) {
  return v.startsWith("http://") || v.startsWith("https://");
}, isArray(v) {
  return Array.isArray(v) && v.length > 0;
}, formatNativeUrl(v, e, fe) {
  if (a$2.isHttpUrl(v))
    return this.formatUniversalUrl(v, e, fe);
  let be = v;
  be.includes("://") || (be = v.replaceAll("/", "").replaceAll(":", ""), be = `${be}://`), be.endsWith("/") || (be = `${be}/`), this.setWalletConnectDeepLink(be, fe);
  const ye = encodeURIComponent(e);
  return `${be}wc?uri=${ye}`;
}, formatUniversalUrl(v, e, fe) {
  if (!a$2.isHttpUrl(v))
    return this.formatNativeUrl(v, e, fe);
  let be = v;
  be.endsWith("/") || (be = `${be}/`), this.setWalletConnectDeepLink(be, fe);
  const ye = encodeURIComponent(e);
  return `${be}wc?uri=${ye}`;
}, async wait(v) {
  return new Promise((e) => {
    setTimeout(e, v);
  });
}, openHref(v, e) {
  window.open(v, e, "noreferrer noopener");
}, setWalletConnectDeepLink(v, e) {
  try {
    localStorage.setItem(a$2.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: v, name: e }));
  } catch {
    console.info("Unable to set WalletConnect deep link");
  }
}, setWalletConnectAndroidDeepLink(v) {
  try {
    const [e] = v.split("?");
    localStorage.setItem(a$2.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e, name: "Android" }));
  } catch {
    console.info("Unable to set WalletConnect android deep link");
  }
}, removeWalletConnectDeepLink() {
  try {
    localStorage.removeItem(a$2.WALLETCONNECT_DEEPLINK_CHOICE);
  } catch {
    console.info("Unable to remove WalletConnect deep link");
  }
}, setModalVersionInStorage() {
  try {
    typeof localStorage < "u" && localStorage.setItem(a$2.WCM_VERSION, "2.6.2");
  } catch {
    console.info("Unable to set Web3Modal version in storage");
  }
}, getWalletRouterData() {
  var v;
  const e = (v = T$1.state.data) == null ? void 0 : v.Wallet;
  if (!e)
    throw new Error('Missing "Wallet" view data');
  return e;
} }, _$4 = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), r$1 = proxy({ enabled: _$4, userSessionId: "", events: [], connectedWalletId: void 0 }), R$4 = { state: r$1, subscribe(v) {
  return subscribe(r$1.events, () => v(snapshot(r$1.events[r$1.events.length - 1])));
}, initialize() {
  r$1.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (r$1.userSessionId = crypto.randomUUID());
}, setConnectedWalletId(v) {
  r$1.connectedWalletId = v;
}, click(v) {
  if (r$1.enabled) {
    const e = { type: "CLICK", name: v.name, userSessionId: r$1.userSessionId, timestamp: Date.now(), data: v };
    r$1.events.push(e);
  }
}, track(v) {
  if (r$1.enabled) {
    const e = { type: "TRACK", name: v.name, userSessionId: r$1.userSessionId, timestamp: Date.now(), data: v };
    r$1.events.push(e);
  }
}, view(v) {
  if (r$1.enabled) {
    const e = { type: "VIEW", name: v.name, userSessionId: r$1.userSessionId, timestamp: Date.now(), data: v };
    r$1.events.push(e);
  }
} }, c$1 = proxy({ chains: void 0, walletConnectUri: void 0, isAuth: !1, isCustomDesktop: !1, isCustomMobile: !1, isDataLoaded: !1, isUiLoaded: !1 }), p$4 = { state: c$1, subscribe(v) {
  return subscribe(c$1, () => v(c$1));
}, setChains(v) {
  c$1.chains = v;
}, setWalletConnectUri(v) {
  c$1.walletConnectUri = v;
}, setIsCustomDesktop(v) {
  c$1.isCustomDesktop = v;
}, setIsCustomMobile(v) {
  c$1.isCustomMobile = v;
}, setIsDataLoaded(v) {
  c$1.isDataLoaded = v;
}, setIsUiLoaded(v) {
  c$1.isUiLoaded = v;
}, setIsAuth(v) {
  c$1.isAuth = v;
} }, W$2 = proxy({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chains: void 0, enableAuthMode: !1, enableExplorer: !0, explorerExcludedWalletIds: void 0, explorerRecommendedWalletIds: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 }), y$3 = { state: W$2, subscribe(v) {
  return subscribe(W$2, () => v(W$2));
}, setConfig(v) {
  var e, fe;
  R$4.initialize(), p$4.setChains(v.chains), p$4.setIsAuth(!!v.enableAuthMode), p$4.setIsCustomMobile(!!((e = v.mobileWallets) != null && e.length)), p$4.setIsCustomDesktop(!!((fe = v.desktopWallets) != null && fe.length)), a$2.setModalVersionInStorage(), Object.assign(W$2, v);
} };
var V$1 = Object.defineProperty, D$3 = Object.getOwnPropertySymbols, H$3 = Object.prototype.hasOwnProperty, B$2 = Object.prototype.propertyIsEnumerable, M$2 = (v, e, fe) => e in v ? V$1(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, K$2 = (v, e) => {
  for (var fe in e || (e = {}))
    H$3.call(e, fe) && M$2(v, fe, e[fe]);
  if (D$3)
    for (var fe of D$3(e))
      B$2.call(e, fe) && M$2(v, fe, e[fe]);
  return v;
};
const L$1 = "https://explorer-api.walletconnect.com", E$3 = "wcm", O$2 = "js-2.6.2";
async function w$4(v, e) {
  const fe = K$2({ sdkType: E$3, sdkVersion: O$2 }, e), be = new URL(v, L$1);
  return be.searchParams.append("projectId", y$3.state.projectId), Object.entries(fe).forEach(([ye, ve]) => {
    ve && be.searchParams.append(ye, String(ve));
  }), (await fetch(be)).json();
}
const m$3 = { async getDesktopListings(v) {
  return w$4("/w3m/v1/getDesktopListings", v);
}, async getMobileListings(v) {
  return w$4("/w3m/v1/getMobileListings", v);
}, async getInjectedListings(v) {
  return w$4("/w3m/v1/getInjectedListings", v);
}, async getAllListings(v) {
  return w$4("/w3m/v1/getAllListings", v);
}, getWalletImageUrl(v) {
  return `${L$1}/w3m/v1/getWalletImage/${v}?projectId=${y$3.state.projectId}&sdkType=${E$3}&sdkVersion=${O$2}`;
}, getAssetImageUrl(v) {
  return `${L$1}/w3m/v1/getAssetImage/${v}?projectId=${y$3.state.projectId}&sdkType=${E$3}&sdkVersion=${O$2}`;
} };
var z$2 = Object.defineProperty, j$4 = Object.getOwnPropertySymbols, J$3 = Object.prototype.hasOwnProperty, q$3 = Object.prototype.propertyIsEnumerable, k$1 = (v, e, fe) => e in v ? z$2(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, F$2 = (v, e) => {
  for (var fe in e || (e = {}))
    J$3.call(e, fe) && k$1(v, fe, e[fe]);
  if (j$4)
    for (var fe of j$4(e))
      q$3.call(e, fe) && k$1(v, fe, e[fe]);
  return v;
};
const N$4 = a$2.isMobile(), d$2 = proxy({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, recomendedWallets: [] }), te$2 = { state: d$2, async getRecomendedWallets() {
  const { explorerRecommendedWalletIds: v, explorerExcludedWalletIds: e } = y$3.state;
  if (v === "NONE" || e === "ALL" && !v)
    return d$2.recomendedWallets;
  if (a$2.isArray(v)) {
    const fe = { recommendedIds: v.join(",") }, { listings: be } = await m$3.getAllListings(fe), ye = Object.values(be);
    ye.sort((ve, Ee) => {
      const Se = v.indexOf(ve.id), Oe = v.indexOf(Ee.id);
      return Se - Oe;
    }), d$2.recomendedWallets = ye;
  } else {
    const { chains: fe, isAuth: be } = p$4.state, ye = fe == null ? void 0 : fe.join(","), ve = a$2.isArray(e), Ee = { page: 1, sdks: be ? "auth_v1" : void 0, entries: a$2.RECOMMENDED_WALLET_AMOUNT, chains: ye, version: 2, excludedIds: ve ? e.join(",") : void 0 }, { listings: Se } = N$4 ? await m$3.getMobileListings(Ee) : await m$3.getDesktopListings(Ee);
    d$2.recomendedWallets = Object.values(Se);
  }
  return d$2.recomendedWallets;
}, async getWallets(v) {
  const e = F$2({}, v), { explorerRecommendedWalletIds: fe, explorerExcludedWalletIds: be } = y$3.state, { recomendedWallets: ye } = d$2;
  if (be === "ALL")
    return d$2.wallets;
  ye.length ? e.excludedIds = ye.map((we) => we.id).join(",") : a$2.isArray(fe) && (e.excludedIds = fe.join(",")), a$2.isArray(be) && (e.excludedIds = [e.excludedIds, be].filter(Boolean).join(",")), p$4.state.isAuth && (e.sdks = "auth_v1");
  const { page: ve, search: Ee } = v, { listings: Se, total: Oe } = N$4 ? await m$3.getMobileListings(e) : await m$3.getDesktopListings(e), xe = Object.values(Se), me = Ee ? "search" : "wallets";
  return d$2[me] = { listings: [...d$2[me].listings, ...xe], total: Oe, page: ve ?? 1 }, { listings: xe, total: Oe };
}, getWalletImageUrl(v) {
  return m$3.getWalletImageUrl(v);
}, getAssetImageUrl(v) {
  return m$3.getAssetImageUrl(v);
}, resetSearch() {
  d$2.search = { listings: [], total: 0, page: 1 };
} }, I = proxy({ open: !1 }), se = { state: I, subscribe(v) {
  return subscribe(I, () => v(I));
}, async open(v) {
  return new Promise((e) => {
    const { isUiLoaded: fe, isDataLoaded: be } = p$4.state;
    if (a$2.removeWalletConnectDeepLink(), p$4.setWalletConnectUri(v == null ? void 0 : v.uri), p$4.setChains(v == null ? void 0 : v.chains), T$1.reset("ConnectWallet"), fe && be)
      I.open = !0, e();
    else {
      const ye = setInterval(() => {
        const ve = p$4.state;
        ve.isUiLoaded && ve.isDataLoaded && (clearInterval(ye), I.open = !0, e());
      }, 200);
    }
  });
}, close() {
  I.open = !1;
} };
var G$2 = Object.defineProperty, $$1 = Object.getOwnPropertySymbols, Q$3 = Object.prototype.hasOwnProperty, X$3 = Object.prototype.propertyIsEnumerable, S$2 = (v, e, fe) => e in v ? G$2(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, Y = (v, e) => {
  for (var fe in e || (e = {}))
    Q$3.call(e, fe) && S$2(v, fe, e[fe]);
  if ($$1)
    for (var fe of $$1(e))
      X$3.call(e, fe) && S$2(v, fe, e[fe]);
  return v;
};
function Z$2() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const C$2 = proxy({ themeMode: Z$2() ? "dark" : "light" }), ne$1 = { state: C$2, subscribe(v) {
  return subscribe(C$2, () => v(C$2));
}, setThemeConfig(v) {
  const { themeMode: e, themeVariables: fe } = v;
  e && (C$2.themeMode = e), fe && (C$2.themeVariables = Y({}, fe));
} }, g$4 = proxy({ open: !1, message: "", variant: "success" }), oe$2 = { state: g$4, subscribe(v) {
  return subscribe(g$4, () => v(g$4));
}, openToast(v, e) {
  g$4.open = !0, g$4.message = v, g$4.variant = e;
}, closeToast() {
  g$4.open = !1;
} };
let d$1 = class {
  constructor(e) {
    this.openModal = se.open, this.closeModal = se.close, this.subscribeModal = se.subscribe, this.setTheme = ne$1.setThemeConfig, ne$1.setThemeConfig(e), y$3.setConfig(e), this.initUi();
  }
  async initUi() {
    if (typeof window < "u") {
      await import("./index-5acdf7a3.mjs");
      const e = document.createElement("wcm-modal");
      document.body.insertAdjacentElement("beforeend", e), p$4.setIsUiLoaded(!0);
    }
  }
};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(v) {
  return v && v.__esModule && Object.prototype.hasOwnProperty.call(v, "default") ? v.default : v;
}
function getAugmentedNamespace(v) {
  if (v.__esModule)
    return v;
  var e = v.default;
  if (typeof e == "function") {
    var fe = function be() {
      if (this instanceof be) {
        var ye = [null];
        ye.push.apply(ye, arguments);
        var ve = Function.bind.apply(e, ye);
        return new ve();
      }
      return e.apply(this, arguments);
    };
    fe.prototype = e.prototype;
  } else
    fe = {};
  return Object.defineProperty(fe, "__esModule", { value: !0 }), Object.keys(v).forEach(function(be) {
    var ye = Object.getOwnPropertyDescriptor(v, be);
    Object.defineProperty(fe, be, ye.get ? ye : {
      enumerable: !0,
      get: function() {
        return v[be];
      }
    });
  }), fe;
}
var events = { exports: {} }, R$3 = typeof Reflect == "object" ? Reflect : null, ReflectApply = R$3 && typeof R$3.apply == "function" ? R$3.apply : function(e, fe, be) {
  return Function.prototype.apply.call(e, fe, be);
}, ReflectOwnKeys;
R$3 && typeof R$3.ownKeys == "function" ? ReflectOwnKeys = R$3.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : ReflectOwnKeys = function(e) {
  return Object.getOwnPropertyNames(e);
};
function ProcessEmitWarning(v) {
  console && console.warn && console.warn(v);
}
var NumberIsNaN = Number.isNaN || function(e) {
  return e !== e;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1;
events.exports.once = once;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(v) {
  if (typeof v != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof v);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(v) {
    if (typeof v != "number" || v < 0 || NumberIsNaN(v))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + v + ".");
    defaultMaxListeners = v;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || NumberIsNaN(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function _getMaxListeners(v) {
  return v._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : v._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function(e) {
  for (var fe = [], be = 1; be < arguments.length; be++)
    fe.push(arguments[be]);
  var ye = e === "error", ve = this._events;
  if (ve !== void 0)
    ye = ye && ve.error === void 0;
  else if (!ye)
    return !1;
  if (ye) {
    var Ee;
    if (fe.length > 0 && (Ee = fe[0]), Ee instanceof Error)
      throw Ee;
    var Se = new Error("Unhandled error." + (Ee ? " (" + Ee.message + ")" : ""));
    throw Se.context = Ee, Se;
  }
  var Oe = ve[e];
  if (Oe === void 0)
    return !1;
  if (typeof Oe == "function")
    ReflectApply(Oe, this, fe);
  else
    for (var xe = Oe.length, me = arrayClone(Oe, xe), be = 0; be < xe; ++be)
      ReflectApply(me[be], this, fe);
  return !0;
};
function _addListener(v, e, fe, be) {
  var ye, ve, Ee;
  if (checkListener(fe), ve = v._events, ve === void 0 ? (ve = v._events = /* @__PURE__ */ Object.create(null), v._eventsCount = 0) : (ve.newListener !== void 0 && (v.emit(
    "newListener",
    e,
    fe.listener ? fe.listener : fe
  ), ve = v._events), Ee = ve[e]), Ee === void 0)
    Ee = ve[e] = fe, ++v._eventsCount;
  else if (typeof Ee == "function" ? Ee = ve[e] = be ? [fe, Ee] : [Ee, fe] : be ? Ee.unshift(fe) : Ee.push(fe), ye = _getMaxListeners(v), ye > 0 && Ee.length > ye && !Ee.warned) {
    Ee.warned = !0;
    var Se = new Error("Possible EventEmitter memory leak detected. " + Ee.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    Se.name = "MaxListenersExceededWarning", Se.emitter = v, Se.type = e, Se.count = Ee.length, ProcessEmitWarning(Se);
  }
  return v;
}
EventEmitter$1.prototype.addListener = function(e, fe) {
  return _addListener(this, e, fe, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function(e, fe) {
  return _addListener(this, e, fe, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(v, e, fe) {
  var be = { fired: !1, wrapFn: void 0, target: v, type: e, listener: fe }, ye = onceWrapper.bind(be);
  return ye.listener = fe, be.wrapFn = ye, ye;
}
EventEmitter$1.prototype.once = function(e, fe) {
  return checkListener(fe), this.on(e, _onceWrap(this, e, fe)), this;
};
EventEmitter$1.prototype.prependOnceListener = function(e, fe) {
  return checkListener(fe), this.prependListener(e, _onceWrap(this, e, fe)), this;
};
EventEmitter$1.prototype.removeListener = function(e, fe) {
  var be, ye, ve, Ee, Se;
  if (checkListener(fe), ye = this._events, ye === void 0)
    return this;
  if (be = ye[e], be === void 0)
    return this;
  if (be === fe || be.listener === fe)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ye[e], ye.removeListener && this.emit("removeListener", e, be.listener || fe));
  else if (typeof be != "function") {
    for (ve = -1, Ee = be.length - 1; Ee >= 0; Ee--)
      if (be[Ee] === fe || be[Ee].listener === fe) {
        Se = be[Ee].listener, ve = Ee;
        break;
      }
    if (ve < 0)
      return this;
    ve === 0 ? be.shift() : spliceOne(be, ve), be.length === 1 && (ye[e] = be[0]), ye.removeListener !== void 0 && this.emit("removeListener", e, Se || fe);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function(e) {
  var fe, be, ye;
  if (be = this._events, be === void 0)
    return this;
  if (be.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : be[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete be[e]), this;
  if (arguments.length === 0) {
    var ve = Object.keys(be), Ee;
    for (ye = 0; ye < ve.length; ++ye)
      Ee = ve[ye], Ee !== "removeListener" && this.removeAllListeners(Ee);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (fe = be[e], typeof fe == "function")
    this.removeListener(e, fe);
  else if (fe !== void 0)
    for (ye = fe.length - 1; ye >= 0; ye--)
      this.removeListener(e, fe[ye]);
  return this;
};
function _listeners(v, e, fe) {
  var be = v._events;
  if (be === void 0)
    return [];
  var ye = be[e];
  return ye === void 0 ? [] : typeof ye == "function" ? fe ? [ye.listener || ye] : [ye] : fe ? unwrapListeners(ye) : arrayClone(ye, ye.length);
}
EventEmitter$1.prototype.listeners = function(e) {
  return _listeners(this, e, !0);
};
EventEmitter$1.prototype.rawListeners = function(e) {
  return _listeners(this, e, !1);
};
EventEmitter$1.listenerCount = function(v, e) {
  return typeof v.listenerCount == "function" ? v.listenerCount(e) : listenerCount.call(v, e);
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(v) {
  var e = this._events;
  if (e !== void 0) {
    var fe = e[v];
    if (typeof fe == "function")
      return 1;
    if (fe !== void 0)
      return fe.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(v, e) {
  for (var fe = new Array(e), be = 0; be < e; ++be)
    fe[be] = v[be];
  return fe;
}
function spliceOne(v, e) {
  for (; e + 1 < v.length; e++)
    v[e] = v[e + 1];
  v.pop();
}
function unwrapListeners(v) {
  for (var e = new Array(v.length), fe = 0; fe < e.length; ++fe)
    e[fe] = v[fe].listener || v[fe];
  return e;
}
function once(v, e) {
  return new Promise(function(fe, be) {
    function ye(Ee) {
      v.removeListener(e, ve), be(Ee);
    }
    function ve() {
      typeof v.removeListener == "function" && v.removeListener("error", ye), fe([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(v, e, ve, { once: !0 }), e !== "error" && addErrorHandlerIfEventEmitter(v, ye, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(v, e, fe) {
  typeof v.on == "function" && eventTargetAgnosticAddListener(v, "error", e, fe);
}
function eventTargetAgnosticAddListener(v, e, fe, be) {
  if (typeof v.on == "function")
    be.once ? v.once(e, fe) : v.on(e, fe);
  else if (typeof v.addEventListener == "function")
    v.addEventListener(e, function ye(ve) {
      be.once && v.removeEventListener(e, ye), fe(ve);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof v);
}
var eventsExports = events.exports;
const ke$2 = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports), suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(v, e) {
  if (v === "__proto__" || v === "constructor" && e && typeof e == "object" && "prototype" in e) {
    warnKeyDropped(v);
    return;
  }
  return e;
}
function warnKeyDropped(v) {
  console.warn(`[destr] Dropping "${v}" key to prevent prototype pollution.`);
}
function destr(v, e = {}) {
  if (typeof v != "string")
    return v;
  const fe = v.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    v[0] === '"' && v.at(-1) === '"' && !v.includes("\\")
  )
    return fe.slice(1, -1);
  if (fe.length <= 9) {
    const be = fe.toLowerCase();
    if (be === "true")
      return !0;
    if (be === "false")
      return !1;
    if (be === "undefined")
      return;
    if (be === "null")
      return null;
    if (be === "nan")
      return Number.NaN;
    if (be === "infinity")
      return Number.POSITIVE_INFINITY;
    if (be === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!JsonSigRx.test(v)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return v;
  }
  try {
    if (suspectProtoRx.test(v) || suspectConstructorRx.test(v)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(v, jsonParseTransform);
    }
    return JSON.parse(v);
  } catch (be) {
    if (e.strict)
      throw be;
    return v;
  }
}
function wrapToPromise(v) {
  return !v || typeof v.then != "function" ? Promise.resolve(v) : v;
}
function asyncCall(v, ...e) {
  try {
    return wrapToPromise(v(...e));
  } catch (fe) {
    return Promise.reject(fe);
  }
}
function isPrimitive(v) {
  const e = typeof v;
  return v === null || e !== "object" && e !== "function";
}
function isPureObject(v) {
  const e = Object.getPrototypeOf(v);
  return !e || e.isPrototypeOf(Object);
}
function stringify(v) {
  if (isPrimitive(v))
    return String(v);
  if (isPureObject(v) || Array.isArray(v))
    return JSON.stringify(v);
  if (typeof v.toJSON == "function")
    return stringify(v.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(v) {
  if (typeof v == "string")
    return v;
  checkBufferSupport();
  const e = Buffer.from(v).toString("base64");
  return BASE64_PREFIX + e;
}
function deserializeRaw(v) {
  return typeof v != "string" || !v.startsWith(BASE64_PREFIX) ? v : (checkBufferSupport(), Buffer.from(v.slice(BASE64_PREFIX.length), "base64"));
}
function normalizeKey(v) {
  return v ? v.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function joinKeys(...v) {
  return normalizeKey(v.join(":"));
}
function normalizeBaseKey(v) {
  return v = normalizeKey(v), v ? v + ":" : "";
}
function defineDriver(v) {
  return v;
}
const DRIVER_NAME = "memory", memory = () => {
  const v = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    options: {},
    hasItem(e) {
      return v.has(e);
    },
    getItem(e) {
      return v.get(e) || null;
    },
    getItemRaw(e) {
      return v.get(e) || null;
    },
    setItem(e, fe) {
      v.set(e, fe);
    },
    setItemRaw(e, fe) {
      v.set(e, fe);
    },
    removeItem(e) {
      v.delete(e);
    },
    getKeys() {
      return Array.from(v.keys());
    },
    clear() {
      v.clear();
    },
    dispose() {
      v.clear();
    }
  };
};
function createStorage(v = {}) {
  const e = {
    mounts: { "": v.driver || memory() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, fe = (xe) => {
    for (const me of e.mountpoints)
      if (xe.startsWith(me))
        return {
          base: me,
          relativeKey: xe.slice(me.length),
          driver: e.mounts[me]
        };
    return {
      base: "",
      relativeKey: xe,
      driver: e.mounts[""]
    };
  }, be = (xe, me) => e.mountpoints.filter(
    (we) => we.startsWith(xe) || me && xe.startsWith(we)
  ).map((we) => ({
    relativeBase: xe.length > we.length ? xe.slice(we.length) : void 0,
    mountpoint: we,
    driver: e.mounts[we]
  })), ye = (xe, me) => {
    if (e.watching) {
      me = normalizeKey(me);
      for (const we of e.watchListeners)
        we(xe, me);
    }
  }, ve = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const xe in e.mounts)
        e.unwatch[xe] = await watch$2(
          e.mounts[xe],
          ye,
          xe
        );
    }
  }, Ee = async () => {
    if (e.watching) {
      for (const xe in e.unwatch)
        await e.unwatch[xe]();
      e.unwatch = {}, e.watching = !1;
    }
  }, Se = (xe, me, we) => {
    const ur = /* @__PURE__ */ new Map(), lr = (Ar) => {
      let Br = ur.get(Ar.base);
      return Br || (Br = {
        driver: Ar.driver,
        base: Ar.base,
        items: []
      }, ur.set(Ar.base, Br)), Br;
    };
    for (const Ar of xe) {
      const Br = typeof Ar == "string", Xr = normalizeKey(Br ? Ar : Ar.key), eo = Br ? void 0 : Ar.value, jr = Br || !Ar.options ? me : { ...me, ...Ar.options }, kr = fe(Xr);
      lr(kr).items.push({
        key: Xr,
        value: eo,
        relativeKey: kr.relativeKey,
        options: jr
      });
    }
    return Promise.all([...ur.values()].map((Ar) => we(Ar))).then(
      (Ar) => Ar.flat()
    );
  }, Oe = {
    // Item
    hasItem(xe, me = {}) {
      xe = normalizeKey(xe);
      const { relativeKey: we, driver: ur } = fe(xe);
      return asyncCall(ur.hasItem, we, me);
    },
    getItem(xe, me = {}) {
      xe = normalizeKey(xe);
      const { relativeKey: we, driver: ur } = fe(xe);
      return asyncCall(ur.getItem, we, me).then(
        (lr) => destr(lr)
      );
    },
    getItems(xe, me) {
      return Se(xe, me, (we) => we.driver.getItems ? asyncCall(
        we.driver.getItems,
        we.items.map((ur) => ({
          key: ur.relativeKey,
          options: ur.options
        })),
        me
      ).then(
        (ur) => ur.map((lr) => ({
          key: joinKeys(we.base, lr.key),
          value: destr(lr.value)
        }))
      ) : Promise.all(
        we.items.map((ur) => asyncCall(
          we.driver.getItem,
          ur.relativeKey,
          ur.options
        ).then((lr) => ({
          key: ur.key,
          value: destr(lr)
        })))
      ));
    },
    getItemRaw(xe, me = {}) {
      xe = normalizeKey(xe);
      const { relativeKey: we, driver: ur } = fe(xe);
      return ur.getItemRaw ? asyncCall(ur.getItemRaw, we, me) : asyncCall(ur.getItem, we, me).then(
        (lr) => deserializeRaw(lr)
      );
    },
    async setItem(xe, me, we = {}) {
      if (me === void 0)
        return Oe.removeItem(xe);
      xe = normalizeKey(xe);
      const { relativeKey: ur, driver: lr } = fe(xe);
      lr.setItem && (await asyncCall(lr.setItem, ur, stringify(me), we), lr.watch || ye("update", xe));
    },
    async setItems(xe, me) {
      await Se(xe, me, async (we) => {
        we.driver.setItems && await asyncCall(
          we.driver.setItems,
          we.items.map((ur) => ({
            key: ur.relativeKey,
            value: stringify(ur.value),
            options: ur.options
          })),
          me
        ), we.driver.setItem && await Promise.all(
          we.items.map((ur) => asyncCall(
            we.driver.setItem,
            ur.relativeKey,
            stringify(ur.value),
            ur.options
          ))
        );
      });
    },
    async setItemRaw(xe, me, we = {}) {
      if (me === void 0)
        return Oe.removeItem(xe, we);
      xe = normalizeKey(xe);
      const { relativeKey: ur, driver: lr } = fe(xe);
      if (lr.setItemRaw)
        await asyncCall(lr.setItemRaw, ur, me, we);
      else if (lr.setItem)
        await asyncCall(lr.setItem, ur, serializeRaw(me), we);
      else
        return;
      lr.watch || ye("update", xe);
    },
    async removeItem(xe, me = {}) {
      typeof me == "boolean" && (me = { removeMeta: me }), xe = normalizeKey(xe);
      const { relativeKey: we, driver: ur } = fe(xe);
      ur.removeItem && (await asyncCall(ur.removeItem, we, me), (me.removeMeta || me.removeMata) && await asyncCall(ur.removeItem, we + "$", me), ur.watch || ye("remove", xe));
    },
    // Meta
    async getMeta(xe, me = {}) {
      typeof me == "boolean" && (me = { nativeOnly: me }), xe = normalizeKey(xe);
      const { relativeKey: we, driver: ur } = fe(xe), lr = /* @__PURE__ */ Object.create(null);
      if (ur.getMeta && Object.assign(lr, await asyncCall(ur.getMeta, we, me)), !me.nativeOnly) {
        const Ar = await asyncCall(
          ur.getItem,
          we + "$",
          me
        ).then((Br) => destr(Br));
        Ar && typeof Ar == "object" && (typeof Ar.atime == "string" && (Ar.atime = new Date(Ar.atime)), typeof Ar.mtime == "string" && (Ar.mtime = new Date(Ar.mtime)), Object.assign(lr, Ar));
      }
      return lr;
    },
    setMeta(xe, me, we = {}) {
      return this.setItem(xe + "$", me, we);
    },
    removeMeta(xe, me = {}) {
      return this.removeItem(xe + "$", me);
    },
    // Keys
    async getKeys(xe, me = {}) {
      xe = normalizeBaseKey(xe);
      const we = be(xe, !0);
      let ur = [];
      const lr = [];
      for (const Ar of we) {
        const Xr = (await asyncCall(
          Ar.driver.getKeys,
          Ar.relativeBase,
          me
        )).map((eo) => Ar.mountpoint + normalizeKey(eo)).filter((eo) => !ur.some((jr) => eo.startsWith(jr)));
        lr.push(...Xr), ur = [
          Ar.mountpoint,
          ...ur.filter((eo) => !eo.startsWith(Ar.mountpoint))
        ];
      }
      return xe ? lr.filter((Ar) => Ar.startsWith(xe) && !Ar.endsWith("$")) : lr.filter((Ar) => !Ar.endsWith("$"));
    },
    // Utils
    async clear(xe, me = {}) {
      xe = normalizeBaseKey(xe), await Promise.all(
        be(xe, !1).map(async (we) => {
          if (we.driver.clear)
            return asyncCall(we.driver.clear, we.relativeBase, me);
          if (we.driver.removeItem) {
            const ur = await we.driver.getKeys(we.relativeBase || "", me);
            return Promise.all(
              ur.map((lr) => we.driver.removeItem(lr, me))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((xe) => dispose(xe))
      );
    },
    async watch(xe) {
      return await ve(), e.watchListeners.push(xe), async () => {
        e.watchListeners = e.watchListeners.filter(
          (me) => me !== xe
        ), e.watchListeners.length === 0 && await Ee();
      };
    },
    async unwatch() {
      e.watchListeners = [], await Ee();
    },
    // Mount
    mount(xe, me) {
      if (xe = normalizeBaseKey(xe), xe && e.mounts[xe])
        throw new Error(`already mounted at ${xe}`);
      return xe && (e.mountpoints.push(xe), e.mountpoints.sort((we, ur) => ur.length - we.length)), e.mounts[xe] = me, e.watching && Promise.resolve(watch$2(me, ye, xe)).then((we) => {
        e.unwatch[xe] = we;
      }).catch(console.error), Oe;
    },
    async unmount(xe, me = !0) {
      xe = normalizeBaseKey(xe), !(!xe || !e.mounts[xe]) && (e.watching && xe in e.unwatch && (e.unwatch[xe](), delete e.unwatch[xe]), me && await dispose(e.mounts[xe]), e.mountpoints = e.mountpoints.filter((we) => we !== xe), delete e.mounts[xe]);
    },
    getMount(xe = "") {
      xe = normalizeKey(xe) + ":";
      const me = fe(xe);
      return {
        driver: me.driver,
        base: me.base
      };
    },
    getMounts(xe = "", me = {}) {
      return xe = normalizeKey(xe), be(xe, me.parents).map((ur) => ({
        driver: ur.driver,
        base: ur.mountpoint
      }));
    }
  };
  return Oe;
}
function watch$2(v, e, fe) {
  return v.watch ? v.watch((be, ye) => e(be, fe + ye)) : () => {
  };
}
async function dispose(v) {
  typeof v.dispose == "function" && await asyncCall(v.dispose);
}
function promisifyRequest(v) {
  return new Promise((e, fe) => {
    v.oncomplete = v.onsuccess = () => e(v.result), v.onabort = v.onerror = () => fe(v.error);
  });
}
function createStore(v, e) {
  const fe = indexedDB.open(v);
  fe.onupgradeneeded = () => fe.result.createObjectStore(e);
  const be = promisifyRequest(fe);
  return (ye, ve) => be.then((Ee) => ve(Ee.transaction(e, ye).objectStore(e)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  return defaultGetStoreFunc || (defaultGetStoreFunc = createStore("keyval-store", "keyval")), defaultGetStoreFunc;
}
function get(v, e = defaultGetStore()) {
  return e("readonly", (fe) => promisifyRequest(fe.get(v)));
}
function set(v, e, fe = defaultGetStore()) {
  return fe("readwrite", (be) => (be.put(e, v), promisifyRequest(be.transaction)));
}
function del(v, e = defaultGetStore()) {
  return e("readwrite", (fe) => (fe.delete(v), promisifyRequest(fe.transaction)));
}
function clear(v = defaultGetStore()) {
  return v("readwrite", (e) => (e.clear(), promisifyRequest(e.transaction)));
}
function eachCursor(v, e) {
  return v.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, promisifyRequest(v.transaction);
}
function keys(v = defaultGetStore()) {
  return v("readonly", (e) => {
    if (e.getAllKeys)
      return promisifyRequest(e.getAllKeys());
    const fe = [];
    return eachCursor(e, (be) => fe.push(be.key)).then(() => fe);
  });
}
const JSONStringify = (v) => JSON.stringify(v, (e, fe) => typeof fe == "bigint" ? fe.toString() + "n" : fe), JSONParse = (v) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, fe = v.replace(e, '$1"$2n"$3');
  return JSON.parse(fe, (be, ye) => typeof ye == "string" && ye.match(/^\d+n$/) ? BigInt(ye.substring(0, ye.length - 1)) : ye);
};
function safeJsonParse(v) {
  if (typeof v != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof v}`);
  try {
    return JSONParse(v);
  } catch {
    return v;
  }
}
function safeJsonStringify(v) {
  return typeof v == "string" ? v : JSONStringify(v) || "";
}
const x$4 = "idb-keyval";
var z$1 = (v = {}) => {
  const e = v.base && v.base.length > 0 ? `${v.base}:` : "", fe = (ye) => e + ye;
  let be;
  return v.dbName && v.storeName && (be = createStore(v.dbName, v.storeName)), { name: x$4, options: v, async hasItem(ye) {
    return !(typeof await get(fe(ye), be) > "u");
  }, async getItem(ye) {
    return await get(fe(ye), be) ?? null;
  }, setItem(ye, ve) {
    return set(fe(ye), ve, be);
  }, removeItem(ye) {
    return del(fe(ye), be);
  }, getKeys() {
    return keys(be);
  }, clear() {
    return clear(be);
  } };
};
const D$2 = "WALLET_CONNECT_V2_INDEXED_DB", E$2 = "keyvaluestorage";
let _$3 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z$1({ dbName: D$2, storeName: E$2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const fe = await this.indexedDb.getItem(e);
    if (fe !== null)
      return fe;
  }
  async setItem(e, fe) {
    await this.indexedDb.setItem(e, safeJsonStringify(fe));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var l$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c = { exports: {} };
(function() {
  let v;
  function e() {
  }
  v = e, v.prototype.getItem = function(fe) {
    return this.hasOwnProperty(fe) ? String(this[fe]) : null;
  }, v.prototype.setItem = function(fe, be) {
    this[fe] = String(be);
  }, v.prototype.removeItem = function(fe) {
    delete this[fe];
  }, v.prototype.clear = function() {
    const fe = this;
    Object.keys(fe).forEach(function(be) {
      fe[be] = void 0, delete fe[be];
    });
  }, v.prototype.key = function(fe) {
    return fe = fe || 0, Object.keys(this)[fe];
  }, v.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$1 < "u" && l$1.localStorage ? c.exports = l$1.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new e();
})();
function k(v) {
  var e;
  return [v[0], safeJsonParse((e = v[1]) != null ? e : "")];
}
let K$1 = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k);
  }
  async getItem(e) {
    const fe = this.localStorage.getItem(e);
    if (fe !== null)
      return safeJsonParse(fe);
  }
  async setItem(e, fe) {
    this.localStorage.setItem(e, safeJsonStringify(fe));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const N$3 = "wc_storage_version", y$2 = 1, O$1 = async (v, e, fe) => {
  const be = N$3, ye = await e.getItem(be);
  if (ye && ye >= y$2) {
    fe(e);
    return;
  }
  const ve = await v.getKeys();
  if (!ve.length) {
    fe(e);
    return;
  }
  const Ee = [];
  for (; ve.length; ) {
    const Se = ve.shift();
    if (!Se)
      continue;
    const Oe = Se.toLowerCase();
    if (Oe.includes("wc@") || Oe.includes("walletconnect") || Oe.includes("wc_") || Oe.includes("wallet_connect")) {
      const xe = await v.getItem(Se);
      await e.setItem(Se, xe), Ee.push(Se);
    }
  }
  await e.setItem(be, y$2), fe(e), j$3(v, Ee);
}, j$3 = async (v, e) => {
  e.length && e.forEach(async (fe) => {
    await v.removeItem(fe);
  });
};
let h$4 = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (fe) => {
      this.storage = fe, this.initialized = !0;
    };
    const e = new K$1();
    this.storage = e;
    try {
      const fe = new _$3();
      O$1(e, fe, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, fe) {
    return await this.initialize(), this.storage.setItem(e, fe);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const fe = setInterval(() => {
        this.initialized && (clearInterval(fe), e());
      }, 20);
    });
  }
};
var cjs$5 = {}, tslib = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(v) {
  var e, fe, be, ye, ve, Ee, Se, Oe, xe, me, we, ur, lr, Ar, Br, Xr, eo, jr, kr, $r, Vr, Mr, gr;
  (function(Fr) {
    var Zr = typeof commonjsGlobal == "object" ? commonjsGlobal : typeof self == "object" ? self : typeof this == "object" ? this : {};
    Fr(Wr(Zr, Wr(v.exports)));
    function Wr(qr, Qr) {
      return qr !== Zr && (typeof Object.create == "function" ? Object.defineProperty(qr, "__esModule", { value: !0 }) : qr.__esModule = !0), function(lo, Nr) {
        return qr[lo] = Qr ? Qr(lo, Nr) : Nr;
      };
    }
  })(function(Fr) {
    var Zr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Wr, qr) {
      Wr.__proto__ = qr;
    } || function(Wr, qr) {
      for (var Qr in qr)
        qr.hasOwnProperty(Qr) && (Wr[Qr] = qr[Qr]);
    };
    e = function(Wr, qr) {
      Zr(Wr, qr);
      function Qr() {
        this.constructor = Wr;
      }
      Wr.prototype = qr === null ? Object.create(qr) : (Qr.prototype = qr.prototype, new Qr());
    }, fe = Object.assign || function(Wr) {
      for (var qr, Qr = 1, lo = arguments.length; Qr < lo; Qr++) {
        qr = arguments[Qr];
        for (var Nr in qr)
          Object.prototype.hasOwnProperty.call(qr, Nr) && (Wr[Nr] = qr[Nr]);
      }
      return Wr;
    }, be = function(Wr, qr) {
      var Qr = {};
      for (var lo in Wr)
        Object.prototype.hasOwnProperty.call(Wr, lo) && qr.indexOf(lo) < 0 && (Qr[lo] = Wr[lo]);
      if (Wr != null && typeof Object.getOwnPropertySymbols == "function")
        for (var Nr = 0, lo = Object.getOwnPropertySymbols(Wr); Nr < lo.length; Nr++)
          qr.indexOf(lo[Nr]) < 0 && Object.prototype.propertyIsEnumerable.call(Wr, lo[Nr]) && (Qr[lo[Nr]] = Wr[lo[Nr]]);
      return Qr;
    }, ye = function(Wr, qr, Qr, lo) {
      var Nr = arguments.length, Lr = Nr < 3 ? qr : lo === null ? lo = Object.getOwnPropertyDescriptor(qr, Qr) : lo, so;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        Lr = Reflect.decorate(Wr, qr, Qr, lo);
      else
        for (var fo = Wr.length - 1; fo >= 0; fo--)
          (so = Wr[fo]) && (Lr = (Nr < 3 ? so(Lr) : Nr > 3 ? so(qr, Qr, Lr) : so(qr, Qr)) || Lr);
      return Nr > 3 && Lr && Object.defineProperty(qr, Qr, Lr), Lr;
    }, ve = function(Wr, qr) {
      return function(Qr, lo) {
        qr(Qr, lo, Wr);
      };
    }, Ee = function(Wr, qr) {
      if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(Wr, qr);
    }, Se = function(Wr, qr, Qr, lo) {
      function Nr(Lr) {
        return Lr instanceof Qr ? Lr : new Qr(function(so) {
          so(Lr);
        });
      }
      return new (Qr || (Qr = Promise))(function(Lr, so) {
        function fo(uo) {
          try {
            no(lo.next(uo));
          } catch (bo) {
            so(bo);
          }
        }
        function co(uo) {
          try {
            no(lo.throw(uo));
          } catch (bo) {
            so(bo);
          }
        }
        function no(uo) {
          uo.done ? Lr(uo.value) : Nr(uo.value).then(fo, co);
        }
        no((lo = lo.apply(Wr, qr || [])).next());
      });
    }, Oe = function(Wr, qr) {
      var Qr = { label: 0, sent: function() {
        if (Lr[0] & 1)
          throw Lr[1];
        return Lr[1];
      }, trys: [], ops: [] }, lo, Nr, Lr, so;
      return so = { next: fo(0), throw: fo(1), return: fo(2) }, typeof Symbol == "function" && (so[Symbol.iterator] = function() {
        return this;
      }), so;
      function fo(no) {
        return function(uo) {
          return co([no, uo]);
        };
      }
      function co(no) {
        if (lo)
          throw new TypeError("Generator is already executing.");
        for (; Qr; )
          try {
            if (lo = 1, Nr && (Lr = no[0] & 2 ? Nr.return : no[0] ? Nr.throw || ((Lr = Nr.return) && Lr.call(Nr), 0) : Nr.next) && !(Lr = Lr.call(Nr, no[1])).done)
              return Lr;
            switch (Nr = 0, Lr && (no = [no[0] & 2, Lr.value]), no[0]) {
              case 0:
              case 1:
                Lr = no;
                break;
              case 4:
                return Qr.label++, { value: no[1], done: !1 };
              case 5:
                Qr.label++, Nr = no[1], no = [0];
                continue;
              case 7:
                no = Qr.ops.pop(), Qr.trys.pop();
                continue;
              default:
                if (Lr = Qr.trys, !(Lr = Lr.length > 0 && Lr[Lr.length - 1]) && (no[0] === 6 || no[0] === 2)) {
                  Qr = 0;
                  continue;
                }
                if (no[0] === 3 && (!Lr || no[1] > Lr[0] && no[1] < Lr[3])) {
                  Qr.label = no[1];
                  break;
                }
                if (no[0] === 6 && Qr.label < Lr[1]) {
                  Qr.label = Lr[1], Lr = no;
                  break;
                }
                if (Lr && Qr.label < Lr[2]) {
                  Qr.label = Lr[2], Qr.ops.push(no);
                  break;
                }
                Lr[2] && Qr.ops.pop(), Qr.trys.pop();
                continue;
            }
            no = qr.call(Wr, Qr);
          } catch (uo) {
            no = [6, uo], Nr = 0;
          } finally {
            lo = Lr = 0;
          }
        if (no[0] & 5)
          throw no[1];
        return { value: no[0] ? no[1] : void 0, done: !0 };
      }
    }, gr = function(Wr, qr, Qr, lo) {
      lo === void 0 && (lo = Qr), Wr[lo] = qr[Qr];
    }, xe = function(Wr, qr) {
      for (var Qr in Wr)
        Qr !== "default" && !qr.hasOwnProperty(Qr) && (qr[Qr] = Wr[Qr]);
    }, me = function(Wr) {
      var qr = typeof Symbol == "function" && Symbol.iterator, Qr = qr && Wr[qr], lo = 0;
      if (Qr)
        return Qr.call(Wr);
      if (Wr && typeof Wr.length == "number")
        return {
          next: function() {
            return Wr && lo >= Wr.length && (Wr = void 0), { value: Wr && Wr[lo++], done: !Wr };
          }
        };
      throw new TypeError(qr ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, we = function(Wr, qr) {
      var Qr = typeof Symbol == "function" && Wr[Symbol.iterator];
      if (!Qr)
        return Wr;
      var lo = Qr.call(Wr), Nr, Lr = [], so;
      try {
        for (; (qr === void 0 || qr-- > 0) && !(Nr = lo.next()).done; )
          Lr.push(Nr.value);
      } catch (fo) {
        so = { error: fo };
      } finally {
        try {
          Nr && !Nr.done && (Qr = lo.return) && Qr.call(lo);
        } finally {
          if (so)
            throw so.error;
        }
      }
      return Lr;
    }, ur = function() {
      for (var Wr = [], qr = 0; qr < arguments.length; qr++)
        Wr = Wr.concat(we(arguments[qr]));
      return Wr;
    }, lr = function() {
      for (var Wr = 0, qr = 0, Qr = arguments.length; qr < Qr; qr++)
        Wr += arguments[qr].length;
      for (var lo = Array(Wr), Nr = 0, qr = 0; qr < Qr; qr++)
        for (var Lr = arguments[qr], so = 0, fo = Lr.length; so < fo; so++, Nr++)
          lo[Nr] = Lr[so];
      return lo;
    }, Ar = function(Wr) {
      return this instanceof Ar ? (this.v = Wr, this) : new Ar(Wr);
    }, Br = function(Wr, qr, Qr) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var lo = Qr.apply(Wr, qr || []), Nr, Lr = [];
      return Nr = {}, so("next"), so("throw"), so("return"), Nr[Symbol.asyncIterator] = function() {
        return this;
      }, Nr;
      function so(So) {
        lo[So] && (Nr[So] = function(io) {
          return new Promise(function(To, Oo) {
            Lr.push([So, io, To, Oo]) > 1 || fo(So, io);
          });
        });
      }
      function fo(So, io) {
        try {
          co(lo[So](io));
        } catch (To) {
          bo(Lr[0][3], To);
        }
      }
      function co(So) {
        So.value instanceof Ar ? Promise.resolve(So.value.v).then(no, uo) : bo(Lr[0][2], So);
      }
      function no(So) {
        fo("next", So);
      }
      function uo(So) {
        fo("throw", So);
      }
      function bo(So, io) {
        So(io), Lr.shift(), Lr.length && fo(Lr[0][0], Lr[0][1]);
      }
    }, Xr = function(Wr) {
      var qr, Qr;
      return qr = {}, lo("next"), lo("throw", function(Nr) {
        throw Nr;
      }), lo("return"), qr[Symbol.iterator] = function() {
        return this;
      }, qr;
      function lo(Nr, Lr) {
        qr[Nr] = Wr[Nr] ? function(so) {
          return (Qr = !Qr) ? { value: Ar(Wr[Nr](so)), done: Nr === "return" } : Lr ? Lr(so) : so;
        } : Lr;
      }
    }, eo = function(Wr) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var qr = Wr[Symbol.asyncIterator], Qr;
      return qr ? qr.call(Wr) : (Wr = typeof me == "function" ? me(Wr) : Wr[Symbol.iterator](), Qr = {}, lo("next"), lo("throw"), lo("return"), Qr[Symbol.asyncIterator] = function() {
        return this;
      }, Qr);
      function lo(Lr) {
        Qr[Lr] = Wr[Lr] && function(so) {
          return new Promise(function(fo, co) {
            so = Wr[Lr](so), Nr(fo, co, so.done, so.value);
          });
        };
      }
      function Nr(Lr, so, fo, co) {
        Promise.resolve(co).then(function(no) {
          Lr({ value: no, done: fo });
        }, so);
      }
    }, jr = function(Wr, qr) {
      return Object.defineProperty ? Object.defineProperty(Wr, "raw", { value: qr }) : Wr.raw = qr, Wr;
    }, kr = function(Wr) {
      if (Wr && Wr.__esModule)
        return Wr;
      var qr = {};
      if (Wr != null)
        for (var Qr in Wr)
          Object.hasOwnProperty.call(Wr, Qr) && (qr[Qr] = Wr[Qr]);
      return qr.default = Wr, qr;
    }, $r = function(Wr) {
      return Wr && Wr.__esModule ? Wr : { default: Wr };
    }, Vr = function(Wr, qr) {
      if (!qr.has(Wr))
        throw new TypeError("attempted to get private field on non-instance");
      return qr.get(Wr);
    }, Mr = function(Wr, qr, Qr) {
      if (!qr.has(Wr))
        throw new TypeError("attempted to set private field on non-instance");
      return qr.set(Wr, Qr), Qr;
    }, Fr("__extends", e), Fr("__assign", fe), Fr("__rest", be), Fr("__decorate", ye), Fr("__param", ve), Fr("__metadata", Ee), Fr("__awaiter", Se), Fr("__generator", Oe), Fr("__exportStar", xe), Fr("__createBinding", gr), Fr("__values", me), Fr("__read", we), Fr("__spread", ur), Fr("__spreadArrays", lr), Fr("__await", Ar), Fr("__asyncGenerator", Br), Fr("__asyncDelegator", Xr), Fr("__asyncValues", eo), Fr("__makeTemplateObject", jr), Fr("__importStar", kr), Fr("__importDefault", $r), Fr("__classPrivateFieldGet", Vr), Fr("__classPrivateFieldSet", Mr);
  });
})(tslib);
var tslibExports = tslib.exports, heartbeat$2 = {}, cjs$4 = {}, utils$3 = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function v(e) {
    return new Promise((fe) => {
      setTimeout(() => {
        fe(!0);
      }, e);
    });
  }
  return delay.delay = v, delay;
}
var convert$1 = {}, constants$3 = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: !0 }), v.ONE_YEAR = v.FOUR_WEEKS = v.THREE_WEEKS = v.TWO_WEEKS = v.ONE_WEEK = v.THIRTY_DAYS = v.SEVEN_DAYS = v.FIVE_DAYS = v.THREE_DAYS = v.ONE_DAY = v.TWENTY_FOUR_HOURS = v.TWELVE_HOURS = v.SIX_HOURS = v.THREE_HOURS = v.ONE_HOUR = v.SIXTY_MINUTES = v.THIRTY_MINUTES = v.TEN_MINUTES = v.FIVE_MINUTES = v.ONE_MINUTE = v.SIXTY_SECONDS = v.THIRTY_SECONDS = v.TEN_SECONDS = v.FIVE_SECONDS = v.ONE_SECOND = void 0, v.ONE_SECOND = 1, v.FIVE_SECONDS = 5, v.TEN_SECONDS = 10, v.THIRTY_SECONDS = 30, v.SIXTY_SECONDS = 60, v.ONE_MINUTE = v.SIXTY_SECONDS, v.FIVE_MINUTES = v.ONE_MINUTE * 5, v.TEN_MINUTES = v.ONE_MINUTE * 10, v.THIRTY_MINUTES = v.ONE_MINUTE * 30, v.SIXTY_MINUTES = v.ONE_MINUTE * 60, v.ONE_HOUR = v.SIXTY_MINUTES, v.THREE_HOURS = v.ONE_HOUR * 3, v.SIX_HOURS = v.ONE_HOUR * 6, v.TWELVE_HOURS = v.ONE_HOUR * 12, v.TWENTY_FOUR_HOURS = v.ONE_HOUR * 24, v.ONE_DAY = v.TWENTY_FOUR_HOURS, v.THREE_DAYS = v.ONE_DAY * 3, v.FIVE_DAYS = v.ONE_DAY * 5, v.SEVEN_DAYS = v.ONE_DAY * 7, v.THIRTY_DAYS = v.ONE_DAY * 30, v.ONE_WEEK = v.SEVEN_DAYS, v.TWO_WEEKS = v.ONE_WEEK * 2, v.THREE_WEEKS = v.ONE_WEEK * 3, v.FOUR_WEEKS = v.ONE_WEEK * 4, v.ONE_YEAR = v.ONE_DAY * 365;
  }(time)), time;
}
var hasRequiredConstants$2;
function requireConstants$2() {
  return hasRequiredConstants$2 || (hasRequiredConstants$2 = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: !0 });
    const e = tslibExports;
    e.__exportStar(requireMisc(), v), e.__exportStar(requireTime(), v);
  }(constants$3)), constants$3;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert$1;
  hasRequiredConvert = 1, Object.defineProperty(convert$1, "__esModule", { value: !0 }), convert$1.fromMiliseconds = convert$1.toMiliseconds = void 0;
  const v = requireConstants$2();
  function e(be) {
    return be * v.ONE_THOUSAND;
  }
  convert$1.toMiliseconds = e;
  function fe(be) {
    return Math.floor(be / v.ONE_THOUSAND);
  }
  return convert$1.fromMiliseconds = fe, convert$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: !0 });
    const e = tslibExports;
    e.__exportStar(requireDelay(), v), e.__exportStar(requireConvert(), v);
  }(utils$3)), utils$3;
}
var watch$1 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.Watch = void 0;
  class v {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(fe) {
      if (this.timestamps.has(fe))
        throw new Error(`Watch already started for label: ${fe}`);
      this.timestamps.set(fe, { started: Date.now() });
    }
    stop(fe) {
      const be = this.get(fe);
      if (typeof be.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${fe}`);
      const ye = Date.now() - be.started;
      this.timestamps.set(fe, { started: be.started, elapsed: ye });
    }
    get(fe) {
      const be = this.timestamps.get(fe);
      if (typeof be > "u")
        throw new Error(`No timestamp found for label: ${fe}`);
      return be;
    }
    elapsed(fe) {
      const be = this.get(fe);
      return be.elapsed || Date.now() - be.started;
    }
  }
  return watch$1.Watch = v, watch$1.default = v, watch$1;
}
var types$3 = {}, watch = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1, Object.defineProperty(watch, "__esModule", { value: !0 }), watch.IWatch = void 0;
  class v {
  }
  return watch.IWatch = v, watch;
}
var hasRequiredTypes$2;
function requireTypes$2() {
  return hasRequiredTypes$2 || (hasRequiredTypes$2 = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: !0 }), tslibExports.__exportStar(requireWatch(), v);
  }(types$3)), types$3;
}
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  const e = tslibExports;
  e.__exportStar(requireUtils$1(), v), e.__exportStar(requireWatch$1(), v), e.__exportStar(requireTypes$2(), v), e.__exportStar(requireConstants$2(), v);
})(cjs$4);
var types$2 = {}, heartbeat$1 = {};
let IEvents$1 = class {
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: IEvents$1
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(esm);
var hasRequiredHeartbeat$2;
function requireHeartbeat$2() {
  if (hasRequiredHeartbeat$2)
    return heartbeat$1;
  hasRequiredHeartbeat$2 = 1, Object.defineProperty(heartbeat$1, "__esModule", { value: !0 }), heartbeat$1.IHeartBeat = void 0;
  const v = require$$0$1;
  class e extends v.IEvents {
    constructor(be) {
      super();
    }
  }
  return heartbeat$1.IHeartBeat = e, heartbeat$1;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: !0 }), tslibExports.__exportStar(requireHeartbeat$2(), v);
  }(types$2)), types$2;
}
var constants$2 = {}, heartbeat = {}, hasRequiredHeartbeat$1;
function requireHeartbeat$1() {
  if (hasRequiredHeartbeat$1)
    return heartbeat;
  hasRequiredHeartbeat$1 = 1, Object.defineProperty(heartbeat, "__esModule", { value: !0 }), heartbeat.HEARTBEAT_EVENTS = heartbeat.HEARTBEAT_INTERVAL = void 0;
  const v = cjs$4;
  return heartbeat.HEARTBEAT_INTERVAL = v.FIVE_SECONDS, heartbeat.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, heartbeat;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: !0 }), tslibExports.__exportStar(requireHeartbeat$1(), v);
  }(constants$2)), constants$2;
}
var hasRequiredHeartbeat;
function requireHeartbeat() {
  if (hasRequiredHeartbeat)
    return heartbeat$2;
  hasRequiredHeartbeat = 1, Object.defineProperty(heartbeat$2, "__esModule", { value: !0 }), heartbeat$2.HeartBeat = void 0;
  const v = tslibExports, e = eventsExports, fe = cjs$4, be = requireTypes$1(), ye = requireConstants$1();
  class ve extends be.IHeartBeat {
    constructor(Se) {
      super(Se), this.events = new e.EventEmitter(), this.interval = ye.HEARTBEAT_INTERVAL, this.interval = (Se == null ? void 0 : Se.interval) || ye.HEARTBEAT_INTERVAL;
    }
    static init(Se) {
      return v.__awaiter(this, void 0, void 0, function* () {
        const Oe = new ve(Se);
        return yield Oe.init(), Oe;
      });
    }
    init() {
      return v.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(Se, Oe) {
      this.events.on(Se, Oe);
    }
    once(Se, Oe) {
      this.events.once(Se, Oe);
    }
    off(Se, Oe) {
      this.events.off(Se, Oe);
    }
    removeListener(Se, Oe) {
      this.events.removeListener(Se, Oe);
    }
    initialize() {
      return v.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), fe.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(ye.HEARTBEAT_EVENTS.pulse);
    }
  }
  return heartbeat$2.HeartBeat = ve, heartbeat$2;
}
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  const e = tslibExports;
  e.__exportStar(requireHeartbeat(), v), e.__exportStar(requireTypes$1(), v), e.__exportStar(requireConstants$1(), v);
})(cjs$5);
var cjs$3 = {}, quickFormatUnescaped, hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped)
    return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function v(fe) {
    try {
      return JSON.stringify(fe);
    } catch {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = e;
  function e(fe, be, ye) {
    var ve = ye && ye.stringify || v, Ee = 1;
    if (typeof fe == "object" && fe !== null) {
      var Se = be.length + Ee;
      if (Se === 1)
        return fe;
      var Oe = new Array(Se);
      Oe[0] = ve(fe);
      for (var xe = 1; xe < Se; xe++)
        Oe[xe] = ve(be[xe]);
      return Oe.join(" ");
    }
    if (typeof fe != "string")
      return fe;
    var me = be.length;
    if (me === 0)
      return fe;
    for (var we = "", ur = 1 - Ee, lr = -1, Ar = fe && fe.length || 0, Br = 0; Br < Ar; ) {
      if (fe.charCodeAt(Br) === 37 && Br + 1 < Ar) {
        switch (lr = lr > -1 ? lr : 0, fe.charCodeAt(Br + 1)) {
          case 100:
          case 102:
            if (ur >= me || be[ur] == null)
              break;
            lr < Br && (we += fe.slice(lr, Br)), we += Number(be[ur]), lr = Br + 2, Br++;
            break;
          case 105:
            if (ur >= me || be[ur] == null)
              break;
            lr < Br && (we += fe.slice(lr, Br)), we += Math.floor(Number(be[ur])), lr = Br + 2, Br++;
            break;
          case 79:
          case 111:
          case 106:
            if (ur >= me || be[ur] === void 0)
              break;
            lr < Br && (we += fe.slice(lr, Br));
            var Xr = typeof be[ur];
            if (Xr === "string") {
              we += "'" + be[ur] + "'", lr = Br + 2, Br++;
              break;
            }
            if (Xr === "function") {
              we += be[ur].name || "<anonymous>", lr = Br + 2, Br++;
              break;
            }
            we += ve(be[ur]), lr = Br + 2, Br++;
            break;
          case 115:
            if (ur >= me)
              break;
            lr < Br && (we += fe.slice(lr, Br)), we += String(be[ur]), lr = Br + 2, Br++;
            break;
          case 37:
            lr < Br && (we += fe.slice(lr, Br)), we += "%", lr = Br + 2, Br++, ur--;
            break;
        }
        ++ur;
      }
      ++Br;
    }
    return lr === -1 ? fe : (lr < Ar && (we += fe.slice(lr)), we);
  }
  return quickFormatUnescaped;
}
var browser$1, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$1;
  hasRequiredBrowser = 1;
  const v = requireQuickFormatUnescaped();
  browser$1 = ye;
  const e = Vr().console || {}, fe = {
    mapHttpRequest: Ar,
    mapHttpResponse: Ar,
    wrapRequestSerializer: Br,
    wrapResponseSerializer: Br,
    wrapErrorSerializer: Br,
    req: Ar,
    res: Ar,
    err: ur
  };
  function be(Mr, gr) {
    return Array.isArray(Mr) ? Mr.filter(function(Zr) {
      return Zr !== "!stdSerializers.err";
    }) : Mr === !0 ? Object.keys(gr) : !1;
  }
  function ye(Mr) {
    Mr = Mr || {}, Mr.browser = Mr.browser || {};
    const gr = Mr.browser.transmit;
    if (gr && typeof gr.send != "function")
      throw Error("pino: transmit option must have a send function");
    const Fr = Mr.browser.write || e;
    Mr.browser.write && (Mr.browser.asObject = !0);
    const Zr = Mr.serializers || {}, Wr = be(Mr.browser.serialize, Zr);
    let qr = Mr.browser.serialize;
    Array.isArray(Mr.browser.serialize) && Mr.browser.serialize.indexOf("!stdSerializers.err") > -1 && (qr = !1);
    const Qr = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof Fr == "function" && (Fr.error = Fr.fatal = Fr.warn = Fr.info = Fr.debug = Fr.trace = Fr), Mr.enabled === !1 && (Mr.level = "silent");
    const lo = Mr.level || "info", Nr = Object.create(Fr);
    Nr.log || (Nr.log = Xr), Object.defineProperty(Nr, "levelVal", {
      get: so
    }), Object.defineProperty(Nr, "level", {
      get: fo,
      set: co
    });
    const Lr = {
      transmit: gr,
      serialize: Wr,
      asObject: Mr.browser.asObject,
      levels: Qr,
      timestamp: lr(Mr)
    };
    Nr.levels = ye.levels, Nr.level = lo, Nr.setMaxListeners = Nr.getMaxListeners = Nr.emit = Nr.addListener = Nr.on = Nr.prependListener = Nr.once = Nr.prependOnceListener = Nr.removeListener = Nr.removeAllListeners = Nr.listeners = Nr.listenerCount = Nr.eventNames = Nr.write = Nr.flush = Xr, Nr.serializers = Zr, Nr._serialize = Wr, Nr._stdErrSerialize = qr, Nr.child = no, gr && (Nr._logEvent = we());
    function so() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function fo() {
      return this._level;
    }
    function co(uo) {
      if (uo !== "silent" && !this.levels.values[uo])
        throw Error("unknown level " + uo);
      this._level = uo, ve(Lr, Nr, "error", "log"), ve(Lr, Nr, "fatal", "error"), ve(Lr, Nr, "warn", "error"), ve(Lr, Nr, "info", "log"), ve(Lr, Nr, "debug", "log"), ve(Lr, Nr, "trace", "log");
    }
    function no(uo, bo) {
      if (!uo)
        throw new Error("missing bindings for child Pino");
      bo = bo || {}, Wr && uo.serializers && (bo.serializers = uo.serializers);
      const So = bo.serializers;
      if (Wr && So) {
        var io = Object.assign({}, Zr, So), To = Mr.browser.serialize === !0 ? Object.keys(io) : Wr;
        delete uo.serializers, Oe([uo], To, io, this._stdErrSerialize);
      }
      function Oo(Mo) {
        this._childLevel = (Mo._childLevel | 0) + 1, this.error = xe(Mo, uo, "error"), this.fatal = xe(Mo, uo, "fatal"), this.warn = xe(Mo, uo, "warn"), this.info = xe(Mo, uo, "info"), this.debug = xe(Mo, uo, "debug"), this.trace = xe(Mo, uo, "trace"), io && (this.serializers = io, this._serialize = To), gr && (this._logEvent = we(
          [].concat(Mo._logEvent.bindings, uo)
        ));
      }
      return Oo.prototype = this, new Oo(this);
    }
    return Nr;
  }
  ye.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, ye.stdSerializers = fe, ye.stdTimeFunctions = Object.assign({}, { nullTime: eo, epochTime: jr, unixTime: kr, isoTime: $r });
  function ve(Mr, gr, Fr, Zr) {
    const Wr = Object.getPrototypeOf(gr);
    gr[Fr] = gr.levelVal > gr.levels.values[Fr] ? Xr : Wr[Fr] ? Wr[Fr] : e[Fr] || e[Zr] || Xr, Ee(Mr, gr, Fr);
  }
  function Ee(Mr, gr, Fr) {
    !Mr.transmit && gr[Fr] === Xr || (gr[Fr] = function(Zr) {
      return function() {
        const qr = Mr.timestamp(), Qr = new Array(arguments.length), lo = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var Nr = 0; Nr < Qr.length; Nr++)
          Qr[Nr] = arguments[Nr];
        if (Mr.serialize && !Mr.asObject && Oe(Qr, this._serialize, this.serializers, this._stdErrSerialize), Mr.asObject ? Zr.call(lo, Se(this, Fr, Qr, qr)) : Zr.apply(lo, Qr), Mr.transmit) {
          const Lr = Mr.transmit.level || gr.level, so = ye.levels.values[Lr], fo = ye.levels.values[Fr];
          if (fo < so)
            return;
          me(this, {
            ts: qr,
            methodLevel: Fr,
            methodValue: fo,
            transmitLevel: Lr,
            transmitValue: ye.levels.values[Mr.transmit.level || gr.level],
            send: Mr.transmit.send,
            val: gr.levelVal
          }, Qr);
        }
      };
    }(gr[Fr]));
  }
  function Se(Mr, gr, Fr, Zr) {
    Mr._serialize && Oe(Fr, Mr._serialize, Mr.serializers, Mr._stdErrSerialize);
    const Wr = Fr.slice();
    let qr = Wr[0];
    const Qr = {};
    Zr && (Qr.time = Zr), Qr.level = ye.levels.values[gr];
    let lo = (Mr._childLevel | 0) + 1;
    if (lo < 1 && (lo = 1), qr !== null && typeof qr == "object") {
      for (; lo-- && typeof Wr[0] == "object"; )
        Object.assign(Qr, Wr.shift());
      qr = Wr.length ? v(Wr.shift(), Wr) : void 0;
    } else
      typeof qr == "string" && (qr = v(Wr.shift(), Wr));
    return qr !== void 0 && (Qr.msg = qr), Qr;
  }
  function Oe(Mr, gr, Fr, Zr) {
    for (const Wr in Mr)
      if (Zr && Mr[Wr] instanceof Error)
        Mr[Wr] = ye.stdSerializers.err(Mr[Wr]);
      else if (typeof Mr[Wr] == "object" && !Array.isArray(Mr[Wr]))
        for (const qr in Mr[Wr])
          gr && gr.indexOf(qr) > -1 && qr in Fr && (Mr[Wr][qr] = Fr[qr](Mr[Wr][qr]));
  }
  function xe(Mr, gr, Fr) {
    return function() {
      const Zr = new Array(1 + arguments.length);
      Zr[0] = gr;
      for (var Wr = 1; Wr < Zr.length; Wr++)
        Zr[Wr] = arguments[Wr - 1];
      return Mr[Fr].apply(this, Zr);
    };
  }
  function me(Mr, gr, Fr) {
    const Zr = gr.send, Wr = gr.ts, qr = gr.methodLevel, Qr = gr.methodValue, lo = gr.val, Nr = Mr._logEvent.bindings;
    Oe(
      Fr,
      Mr._serialize || Object.keys(Mr.serializers),
      Mr.serializers,
      Mr._stdErrSerialize === void 0 ? !0 : Mr._stdErrSerialize
    ), Mr._logEvent.ts = Wr, Mr._logEvent.messages = Fr.filter(function(Lr) {
      return Nr.indexOf(Lr) === -1;
    }), Mr._logEvent.level.label = qr, Mr._logEvent.level.value = Qr, Zr(qr, Mr._logEvent, lo), Mr._logEvent = we(Nr);
  }
  function we(Mr) {
    return {
      ts: 0,
      messages: [],
      bindings: Mr || [],
      level: { label: "", value: 0 }
    };
  }
  function ur(Mr) {
    const gr = {
      type: Mr.constructor.name,
      msg: Mr.message,
      stack: Mr.stack
    };
    for (const Fr in Mr)
      gr[Fr] === void 0 && (gr[Fr] = Mr[Fr]);
    return gr;
  }
  function lr(Mr) {
    return typeof Mr.timestamp == "function" ? Mr.timestamp : Mr.timestamp === !1 ? eo : jr;
  }
  function Ar() {
    return {};
  }
  function Br(Mr) {
    return Mr;
  }
  function Xr() {
  }
  function eo() {
    return !1;
  }
  function jr() {
    return Date.now();
  }
  function kr() {
    return Math.round(Date.now() / 1e3);
  }
  function $r() {
    return new Date(Date.now()).toISOString();
  }
  function Vr() {
    function Mr(gr) {
      return typeof gr < "u" && gr;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return Mr(self) || Mr(window) || Mr(this) || {};
    }
  }
  return browser$1;
}
var constants$1 = {}, hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, Object.defineProperty(constants$1, "__esModule", { value: !0 }), constants$1.PINO_CUSTOM_CONTEXT_KEY = constants$1.PINO_LOGGER_DEFAULTS = void 0, constants$1.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, constants$1.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), constants$1;
}
var utils$2 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$2;
  hasRequiredUtils = 1, Object.defineProperty(utils$2, "__esModule", { value: !0 }), utils$2.generateChildLogger = utils$2.formatChildLoggerContext = utils$2.getLoggerContext = utils$2.setBrowserLoggerContext = utils$2.getBrowserLoggerContext = utils$2.getDefaultLoggerOptions = void 0;
  const v = requireConstants();
  function e(Se) {
    return Object.assign(Object.assign({}, Se), { level: (Se == null ? void 0 : Se.level) || v.PINO_LOGGER_DEFAULTS.level });
  }
  utils$2.getDefaultLoggerOptions = e;
  function fe(Se, Oe = v.PINO_CUSTOM_CONTEXT_KEY) {
    return Se[Oe] || "";
  }
  utils$2.getBrowserLoggerContext = fe;
  function be(Se, Oe, xe = v.PINO_CUSTOM_CONTEXT_KEY) {
    return Se[xe] = Oe, Se;
  }
  utils$2.setBrowserLoggerContext = be;
  function ye(Se, Oe = v.PINO_CUSTOM_CONTEXT_KEY) {
    let xe = "";
    return typeof Se.bindings > "u" ? xe = fe(Se, Oe) : xe = Se.bindings().context || "", xe;
  }
  utils$2.getLoggerContext = ye;
  function ve(Se, Oe, xe = v.PINO_CUSTOM_CONTEXT_KEY) {
    const me = ye(Se, xe);
    return me.trim() ? `${me}/${Oe}` : Oe;
  }
  utils$2.formatChildLoggerContext = ve;
  function Ee(Se, Oe, xe = v.PINO_CUSTOM_CONTEXT_KEY) {
    const me = ve(Se, Oe, xe), we = Se.child({ context: me });
    return be(we, me, xe);
  }
  return utils$2.generateChildLogger = Ee, utils$2;
}
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 }), v.pino = void 0;
  const e = tslibExports, fe = e.__importDefault(requireBrowser());
  Object.defineProperty(v, "pino", { enumerable: !0, get: function() {
    return fe.default;
  } }), e.__exportStar(requireConstants(), v), e.__exportStar(requireUtils(), v);
})(cjs$3);
let n$1 = class extends IEvents$1 {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, h$3 = class extends IEvents$1 {
  constructor(e, fe) {
    super(), this.core = e, this.logger = fe, this.records = /* @__PURE__ */ new Map();
  }
}, a$1 = class {
  constructor(e, fe) {
    this.logger = e, this.core = fe;
  }
}, u$1 = class extends IEvents$1 {
  constructor(e, fe) {
    super(), this.relayer = e, this.logger = fe;
  }
}, g$3 = class extends IEvents$1 {
  constructor(e) {
    super();
  }
}, p$3 = class {
  constructor(e, fe, be, ye) {
    this.core = e, this.logger = fe, this.name = be;
  }
};
class d extends IEvents$1 {
  constructor(e, fe) {
    super(), this.relayer = e, this.logger = fe;
  }
}
let E$1 = class extends IEvents$1 {
  constructor(e, fe) {
    super(), this.core = e, this.logger = fe;
  }
}, y$1 = class {
  constructor(e, fe) {
    this.projectId = e, this.logger = fe;
  }
}, b$1 = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, S$1 = class {
  constructor(e) {
    this.client = e;
  }
};
var ed25519 = {}, random = {}, system = {}, browser = {};
Object.defineProperty(browser, "__esModule", { value: !0 });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const fe = new Uint8Array(e);
    for (let be = 0; be < fe.length; be += QUOTA)
      this._crypto.getRandomValues(fe.subarray(be, be + Math.min(fe.length - be, QUOTA)));
    return fe;
  }
}
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(v) {
  throw new Error('Could not dynamically require "' + v + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {}, wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(v) {
  for (var e = 0; e < v.length; e++)
    v[e] = 0;
  return v;
}
wipe$1.wipe = wipe;
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node, "__esModule", { value: !0 });
node.NodeRandomSource = void 0;
const wipe_1$3 = wipe$1;
class NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire < "u") {
      const e = require$$0;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let fe = this._crypto.randomBytes(e);
    if (fe.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const be = new Uint8Array(e);
    for (let ye = 0; ye < be.length; ye++)
      be[ye] = fe[ye];
    return (0, wipe_1$3.wipe)(fe), be;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser, node_1 = node;
class SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {}, int = {};
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  function e(Se, Oe) {
    var xe = Se >>> 16 & 65535, me = Se & 65535, we = Oe >>> 16 & 65535, ur = Oe & 65535;
    return me * ur + (xe * ur + me * we << 16 >>> 0) | 0;
  }
  v.mul = Math.imul || e;
  function fe(Se, Oe) {
    return Se + Oe | 0;
  }
  v.add = fe;
  function be(Se, Oe) {
    return Se - Oe | 0;
  }
  v.sub = be;
  function ye(Se, Oe) {
    return Se << Oe | Se >>> 32 - Oe;
  }
  v.rotl = ye;
  function ve(Se, Oe) {
    return Se << 32 - Oe | Se >>> Oe;
  }
  v.rotr = ve;
  function Ee(Se) {
    return typeof Se == "number" && isFinite(Se) && Math.floor(Se) === Se;
  }
  v.isInteger = Number.isInteger || Ee, v.MAX_SAFE_INTEGER = 9007199254740991, v.isSafeInteger = function(Se) {
    return v.isInteger(Se) && Se >= -v.MAX_SAFE_INTEGER && Se <= v.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(v, e) {
  return e === void 0 && (e = 0), (v[e + 0] << 8 | v[e + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(v, e) {
  return e === void 0 && (e = 0), (v[e + 0] << 8 | v[e + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(v, e) {
  return e === void 0 && (e = 0), (v[e + 1] << 8 | v[e]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(v, e) {
  return e === void 0 && (e = 0), (v[e + 1] << 8 | v[e]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(v, e, fe) {
  return e === void 0 && (e = new Uint8Array(2)), fe === void 0 && (fe = 0), e[fe + 0] = v >>> 8, e[fe + 1] = v >>> 0, e;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(v, e, fe) {
  return e === void 0 && (e = new Uint8Array(2)), fe === void 0 && (fe = 0), e[fe + 0] = v >>> 0, e[fe + 1] = v >>> 8, e;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(v, e) {
  return e === void 0 && (e = 0), v[e] << 24 | v[e + 1] << 16 | v[e + 2] << 8 | v[e + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(v, e) {
  return e === void 0 && (e = 0), (v[e] << 24 | v[e + 1] << 16 | v[e + 2] << 8 | v[e + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(v, e) {
  return e === void 0 && (e = 0), v[e + 3] << 24 | v[e + 2] << 16 | v[e + 1] << 8 | v[e];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(v, e) {
  return e === void 0 && (e = 0), (v[e + 3] << 24 | v[e + 2] << 16 | v[e + 1] << 8 | v[e]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(v, e, fe) {
  return e === void 0 && (e = new Uint8Array(4)), fe === void 0 && (fe = 0), e[fe + 0] = v >>> 24, e[fe + 1] = v >>> 16, e[fe + 2] = v >>> 8, e[fe + 3] = v >>> 0, e;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(v, e, fe) {
  return e === void 0 && (e = new Uint8Array(4)), fe === void 0 && (fe = 0), e[fe + 0] = v >>> 0, e[fe + 1] = v >>> 8, e[fe + 2] = v >>> 16, e[fe + 3] = v >>> 24, e;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(v, e) {
  e === void 0 && (e = 0);
  var fe = readInt32BE(v, e), be = readInt32BE(v, e + 4);
  return fe * 4294967296 + be - (be >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(v, e) {
  e === void 0 && (e = 0);
  var fe = readUint32BE(v, e), be = readUint32BE(v, e + 4);
  return fe * 4294967296 + be;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(v, e) {
  e === void 0 && (e = 0);
  var fe = readInt32LE(v, e), be = readInt32LE(v, e + 4);
  return be * 4294967296 + fe - (fe >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(v, e) {
  e === void 0 && (e = 0);
  var fe = readUint32LE(v, e), be = readUint32LE(v, e + 4);
  return be * 4294967296 + fe;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(v, e, fe) {
  return e === void 0 && (e = new Uint8Array(8)), fe === void 0 && (fe = 0), writeUint32BE(v / 4294967296 >>> 0, e, fe), writeUint32BE(v >>> 0, e, fe + 4), e;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(v, e, fe) {
  return e === void 0 && (e = new Uint8Array(8)), fe === void 0 && (fe = 0), writeUint32LE(v >>> 0, e, fe), writeUint32LE(v / 4294967296 >>> 0, e, fe + 4), e;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE$1(v, e, fe) {
  if (fe === void 0 && (fe = 0), v % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (v / 8 > e.length - fe)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var be = 0, ye = 1, ve = v / 8 + fe - 1; ve >= fe; ve--)
    be += e[ve] * ye, ye *= 256;
  return be;
}
binary.readUintBE = readUintBE$1;
function readUintLE$1(v, e, fe) {
  if (fe === void 0 && (fe = 0), v % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (v / 8 > e.length - fe)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var be = 0, ye = 1, ve = fe; ve < fe + v / 8; ve++)
    be += e[ve] * ye, ye *= 256;
  return be;
}
binary.readUintLE = readUintLE$1;
function writeUintBE$1(v, e, fe, be) {
  if (fe === void 0 && (fe = new Uint8Array(v / 8)), be === void 0 && (be = 0), v % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var ye = 1, ve = v / 8 + be - 1; ve >= be; ve--)
    fe[ve] = e / ye & 255, ye *= 256;
  return fe;
}
binary.writeUintBE = writeUintBE$1;
function writeUintLE$1(v, e, fe, be) {
  if (fe === void 0 && (fe = new Uint8Array(v / 8)), be === void 0 && (be = 0), v % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var ye = 1, ve = be; ve < be + v / 8; ve++)
    fe[ve] = e / ye & 255, ye *= 256;
  return fe;
}
binary.writeUintLE = writeUintLE$1;
function readFloat32BE(v, e) {
  e === void 0 && (e = 0);
  var fe = new DataView(v.buffer, v.byteOffset, v.byteLength);
  return fe.getFloat32(e);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(v, e) {
  e === void 0 && (e = 0);
  var fe = new DataView(v.buffer, v.byteOffset, v.byteLength);
  return fe.getFloat32(e, !0);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(v, e) {
  e === void 0 && (e = 0);
  var fe = new DataView(v.buffer, v.byteOffset, v.byteLength);
  return fe.getFloat64(e);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(v, e) {
  e === void 0 && (e = 0);
  var fe = new DataView(v.buffer, v.byteOffset, v.byteLength);
  return fe.getFloat64(e, !0);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(v, e, fe) {
  e === void 0 && (e = new Uint8Array(4)), fe === void 0 && (fe = 0);
  var be = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return be.setFloat32(fe, v), e;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(v, e, fe) {
  e === void 0 && (e = new Uint8Array(4)), fe === void 0 && (fe = 0);
  var be = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return be.setFloat32(fe, v, !0), e;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(v, e, fe) {
  e === void 0 && (e = new Uint8Array(8)), fe === void 0 && (fe = 0);
  var be = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return be.setFloat64(fe, v), e;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(v, e, fe) {
  e === void 0 && (e = new Uint8Array(8)), fe === void 0 && (fe = 0);
  var be = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return be.setFloat64(fe, v, !0), e;
}
binary.writeFloat64LE = writeFloat64LE;
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 }), v.randomStringForEntropy = v.randomString = v.randomUint32 = v.randomBytes = v.defaultRandomSource = void 0;
  const e = system, fe = binary, be = wipe$1;
  v.defaultRandomSource = new e.SystemRandomSource();
  function ye(xe, me = v.defaultRandomSource) {
    return me.randomBytes(xe);
  }
  v.randomBytes = ye;
  function ve(xe = v.defaultRandomSource) {
    const me = ye(4, xe), we = (0, fe.readUint32LE)(me);
    return (0, be.wipe)(me), we;
  }
  v.randomUint32 = ve;
  const Ee = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function Se(xe, me = Ee, we = v.defaultRandomSource) {
    if (me.length < 2)
      throw new Error("randomString charset is too short");
    if (me.length > 256)
      throw new Error("randomString charset is too long");
    let ur = "";
    const lr = me.length, Ar = 256 - 256 % lr;
    for (; xe > 0; ) {
      const Br = ye(Math.ceil(xe * 256 / Ar), we);
      for (let Xr = 0; Xr < Br.length && xe > 0; Xr++) {
        const eo = Br[Xr];
        eo < Ar && (ur += me.charAt(eo % lr), xe--);
      }
      (0, be.wipe)(Br);
    }
    return ur;
  }
  v.randomString = Se;
  function Oe(xe, me = Ee, we = v.defaultRandomSource) {
    const ur = Math.ceil(xe / (Math.log(me.length) / Math.LN2));
    return Se(ur, me, we);
  }
  v.randomStringForEntropy = Oe;
})(random);
var sha512 = {};
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  var e = binary, fe = wipe$1;
  v.DIGEST_LENGTH = 64, v.BLOCK_SIZE = 128;
  var be = (
    /** @class */
    function() {
      function Se() {
        this.digestLength = v.DIGEST_LENGTH, this.blockSize = v.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return Se.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, Se.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, Se.prototype.clean = function() {
        fe.wipe(this._buffer), fe.wipe(this._tempHi), fe.wipe(this._tempLo), this.reset();
      }, Se.prototype.update = function(Oe, xe) {
        if (xe === void 0 && (xe = Oe.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var me = 0;
        if (this._bytesHashed += xe, this._bufferLength > 0) {
          for (; this._bufferLength < v.BLOCK_SIZE && xe > 0; )
            this._buffer[this._bufferLength++] = Oe[me++], xe--;
          this._bufferLength === this.blockSize && (ve(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (xe >= this.blockSize && (me = ve(this._tempHi, this._tempLo, this._stateHi, this._stateLo, Oe, me, xe), xe %= this.blockSize); xe > 0; )
          this._buffer[this._bufferLength++] = Oe[me++], xe--;
        return this;
      }, Se.prototype.finish = function(Oe) {
        if (!this._finished) {
          var xe = this._bytesHashed, me = this._bufferLength, we = xe / 536870912 | 0, ur = xe << 3, lr = xe % 128 < 112 ? 128 : 256;
          this._buffer[me] = 128;
          for (var Ar = me + 1; Ar < lr - 8; Ar++)
            this._buffer[Ar] = 0;
          e.writeUint32BE(we, this._buffer, lr - 8), e.writeUint32BE(ur, this._buffer, lr - 4), ve(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, lr), this._finished = !0;
        }
        for (var Ar = 0; Ar < this.digestLength / 8; Ar++)
          e.writeUint32BE(this._stateHi[Ar], Oe, Ar * 8), e.writeUint32BE(this._stateLo[Ar], Oe, Ar * 8 + 4);
        return this;
      }, Se.prototype.digest = function() {
        var Oe = new Uint8Array(this.digestLength);
        return this.finish(Oe), Oe;
      }, Se.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, Se.prototype.restoreState = function(Oe) {
        return this._stateHi.set(Oe.stateHi), this._stateLo.set(Oe.stateLo), this._bufferLength = Oe.bufferLength, Oe.buffer && this._buffer.set(Oe.buffer), this._bytesHashed = Oe.bytesHashed, this._finished = !1, this;
      }, Se.prototype.cleanSavedState = function(Oe) {
        fe.wipe(Oe.stateHi), fe.wipe(Oe.stateLo), Oe.buffer && fe.wipe(Oe.buffer), Oe.bufferLength = 0, Oe.bytesHashed = 0;
      }, Se;
    }()
  );
  v.SHA512 = be;
  var ye = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function ve(Se, Oe, xe, me, we, ur, lr) {
    for (var Ar = xe[0], Br = xe[1], Xr = xe[2], eo = xe[3], jr = xe[4], kr = xe[5], $r = xe[6], Vr = xe[7], Mr = me[0], gr = me[1], Fr = me[2], Zr = me[3], Wr = me[4], qr = me[5], Qr = me[6], lo = me[7], Nr, Lr, so, fo, co, no, uo, bo; lr >= 128; ) {
      for (var So = 0; So < 16; So++) {
        var io = 8 * So + ur;
        Se[So] = e.readUint32BE(we, io), Oe[So] = e.readUint32BE(we, io + 4);
      }
      for (var So = 0; So < 80; So++) {
        var To = Ar, Oo = Br, Mo = Xr, ao = eo, oo = jr, zr = kr, dr = $r, Hr = Vr, go = Mr, ho = gr, Eo = Fr, Fo = Zr, Po = Wr, jo = qr, Qo = Qr, bn = lo;
        if (Nr = Vr, Lr = lo, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = (jr >>> 14 | Wr << 32 - 14) ^ (jr >>> 18 | Wr << 32 - 18) ^ (Wr >>> 41 - 32 | jr << 32 - (41 - 32)), Lr = (Wr >>> 14 | jr << 32 - 14) ^ (Wr >>> 18 | jr << 32 - 18) ^ (jr >>> 41 - 32 | Wr << 32 - (41 - 32)), co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, Nr = jr & kr ^ ~jr & $r, Lr = Wr & qr ^ ~Wr & Qr, co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, Nr = ye[So * 2], Lr = ye[So * 2 + 1], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, Nr = Se[So % 16], Lr = Oe[So % 16], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, so = uo & 65535 | bo << 16, fo = co & 65535 | no << 16, Nr = so, Lr = fo, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = (Ar >>> 28 | Mr << 32 - 28) ^ (Mr >>> 34 - 32 | Ar << 32 - (34 - 32)) ^ (Mr >>> 39 - 32 | Ar << 32 - (39 - 32)), Lr = (Mr >>> 28 | Ar << 32 - 28) ^ (Ar >>> 34 - 32 | Mr << 32 - (34 - 32)) ^ (Ar >>> 39 - 32 | Mr << 32 - (39 - 32)), co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, Nr = Ar & Br ^ Ar & Xr ^ Br & Xr, Lr = Mr & gr ^ Mr & Fr ^ gr & Fr, co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, Hr = uo & 65535 | bo << 16, bn = co & 65535 | no << 16, Nr = ao, Lr = Fo, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = so, Lr = fo, co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, ao = uo & 65535 | bo << 16, Fo = co & 65535 | no << 16, Br = To, Xr = Oo, eo = Mo, jr = ao, kr = oo, $r = zr, Vr = dr, Ar = Hr, gr = go, Fr = ho, Zr = Eo, Wr = Fo, qr = Po, Qr = jo, lo = Qo, Mr = bn, So % 16 === 15)
          for (var io = 0; io < 16; io++)
            Nr = Se[io], Lr = Oe[io], co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = Se[(io + 9) % 16], Lr = Oe[(io + 9) % 16], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, so = Se[(io + 1) % 16], fo = Oe[(io + 1) % 16], Nr = (so >>> 1 | fo << 32 - 1) ^ (so >>> 8 | fo << 32 - 8) ^ so >>> 7, Lr = (fo >>> 1 | so << 32 - 1) ^ (fo >>> 8 | so << 32 - 8) ^ (fo >>> 7 | so << 32 - 7), co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, so = Se[(io + 14) % 16], fo = Oe[(io + 14) % 16], Nr = (so >>> 19 | fo << 32 - 19) ^ (fo >>> 61 - 32 | so << 32 - (61 - 32)) ^ so >>> 6, Lr = (fo >>> 19 | so << 32 - 19) ^ (so >>> 61 - 32 | fo << 32 - (61 - 32)) ^ (fo >>> 6 | so << 32 - 6), co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, Se[io] = uo & 65535 | bo << 16, Oe[io] = co & 65535 | no << 16;
      }
      Nr = Ar, Lr = Mr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[0], Lr = me[0], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[0] = Ar = uo & 65535 | bo << 16, me[0] = Mr = co & 65535 | no << 16, Nr = Br, Lr = gr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[1], Lr = me[1], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[1] = Br = uo & 65535 | bo << 16, me[1] = gr = co & 65535 | no << 16, Nr = Xr, Lr = Fr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[2], Lr = me[2], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[2] = Xr = uo & 65535 | bo << 16, me[2] = Fr = co & 65535 | no << 16, Nr = eo, Lr = Zr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[3], Lr = me[3], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[3] = eo = uo & 65535 | bo << 16, me[3] = Zr = co & 65535 | no << 16, Nr = jr, Lr = Wr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[4], Lr = me[4], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[4] = jr = uo & 65535 | bo << 16, me[4] = Wr = co & 65535 | no << 16, Nr = kr, Lr = qr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[5], Lr = me[5], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[5] = kr = uo & 65535 | bo << 16, me[5] = qr = co & 65535 | no << 16, Nr = $r, Lr = Qr, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[6], Lr = me[6], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[6] = $r = uo & 65535 | bo << 16, me[6] = Qr = co & 65535 | no << 16, Nr = Vr, Lr = lo, co = Lr & 65535, no = Lr >>> 16, uo = Nr & 65535, bo = Nr >>> 16, Nr = xe[7], Lr = me[7], co += Lr & 65535, no += Lr >>> 16, uo += Nr & 65535, bo += Nr >>> 16, no += co >>> 16, uo += no >>> 16, bo += uo >>> 16, xe[7] = Vr = uo & 65535 | bo << 16, me[7] = lo = co & 65535 | no << 16, ur += 128, lr -= 128;
    }
    return ur;
  }
  function Ee(Se) {
    var Oe = new be();
    Oe.update(Se);
    var xe = Oe.digest();
    return Oe.clean(), xe;
  }
  v.hash = Ee;
})(sha512);
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 }), v.convertSecretKeyToX25519 = v.convertPublicKeyToX25519 = v.verify = v.sign = v.extractPublicKeyFromSecretKey = v.generateKeyPair = v.generateKeyPairFromSeed = v.SEED_LENGTH = v.SECRET_KEY_LENGTH = v.PUBLIC_KEY_LENGTH = v.SIGNATURE_LENGTH = void 0;
  const e = random, fe = sha512, be = wipe$1;
  v.SIGNATURE_LENGTH = 64, v.PUBLIC_KEY_LENGTH = 32, v.SECRET_KEY_LENGTH = 64, v.SEED_LENGTH = 32;
  function ye(ao) {
    const oo = new Float64Array(16);
    if (ao)
      for (let zr = 0; zr < ao.length; zr++)
        oo[zr] = ao[zr];
    return oo;
  }
  const ve = new Uint8Array(32);
  ve[0] = 9;
  const Ee = ye(), Se = ye([1]), Oe = ye([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), xe = ye([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), me = ye([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), we = ye([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), ur = ye([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function lr(ao, oo) {
    for (let zr = 0; zr < 16; zr++)
      ao[zr] = oo[zr] | 0;
  }
  function Ar(ao) {
    let oo = 1;
    for (let zr = 0; zr < 16; zr++) {
      let dr = ao[zr] + oo + 65535;
      oo = Math.floor(dr / 65536), ao[zr] = dr - oo * 65536;
    }
    ao[0] += oo - 1 + 37 * (oo - 1);
  }
  function Br(ao, oo, zr) {
    const dr = ~(zr - 1);
    for (let Hr = 0; Hr < 16; Hr++) {
      const go = dr & (ao[Hr] ^ oo[Hr]);
      ao[Hr] ^= go, oo[Hr] ^= go;
    }
  }
  function Xr(ao, oo) {
    const zr = ye(), dr = ye();
    for (let Hr = 0; Hr < 16; Hr++)
      dr[Hr] = oo[Hr];
    Ar(dr), Ar(dr), Ar(dr);
    for (let Hr = 0; Hr < 2; Hr++) {
      zr[0] = dr[0] - 65517;
      for (let ho = 1; ho < 15; ho++)
        zr[ho] = dr[ho] - 65535 - (zr[ho - 1] >> 16 & 1), zr[ho - 1] &= 65535;
      zr[15] = dr[15] - 32767 - (zr[14] >> 16 & 1);
      const go = zr[15] >> 16 & 1;
      zr[14] &= 65535, Br(dr, zr, 1 - go);
    }
    for (let Hr = 0; Hr < 16; Hr++)
      ao[2 * Hr] = dr[Hr] & 255, ao[2 * Hr + 1] = dr[Hr] >> 8;
  }
  function eo(ao, oo) {
    let zr = 0;
    for (let dr = 0; dr < 32; dr++)
      zr |= ao[dr] ^ oo[dr];
    return (1 & zr - 1 >>> 8) - 1;
  }
  function jr(ao, oo) {
    const zr = new Uint8Array(32), dr = new Uint8Array(32);
    return Xr(zr, ao), Xr(dr, oo), eo(zr, dr);
  }
  function kr(ao) {
    const oo = new Uint8Array(32);
    return Xr(oo, ao), oo[0] & 1;
  }
  function $r(ao, oo) {
    for (let zr = 0; zr < 16; zr++)
      ao[zr] = oo[2 * zr] + (oo[2 * zr + 1] << 8);
    ao[15] &= 32767;
  }
  function Vr(ao, oo, zr) {
    for (let dr = 0; dr < 16; dr++)
      ao[dr] = oo[dr] + zr[dr];
  }
  function Mr(ao, oo, zr) {
    for (let dr = 0; dr < 16; dr++)
      ao[dr] = oo[dr] - zr[dr];
  }
  function gr(ao, oo, zr) {
    let dr, Hr, go = 0, ho = 0, Eo = 0, Fo = 0, Po = 0, jo = 0, Qo = 0, bn = 0, Lo = 0, Vo = 0, zo = 0, ko = 0, Wo = 0, Co = 0, $o = 0, xo = 0, Ho = 0, qo = 0, Bo = 0, Yo = 0, Ko = 0, Jo = 0, Zo = 0, Xo = 0, Pn = 0, Un = 0, Yn = 0, An = 0, Zn = 0, ei = 0, Sn = 0, gn = zr[0], hn = zr[1], Yr = zr[2], Ur = zr[3], Jr = zr[4], to = zr[5], po = zr[6], yo = zr[7], mo = zr[8], vo = zr[9], Ao = zr[10], wo = zr[11], Do = zr[12], Io = zr[13], No = zr[14], Go = zr[15];
    dr = oo[0], go += dr * gn, ho += dr * hn, Eo += dr * Yr, Fo += dr * Ur, Po += dr * Jr, jo += dr * to, Qo += dr * po, bn += dr * yo, Lo += dr * mo, Vo += dr * vo, zo += dr * Ao, ko += dr * wo, Wo += dr * Do, Co += dr * Io, $o += dr * No, xo += dr * Go, dr = oo[1], ho += dr * gn, Eo += dr * hn, Fo += dr * Yr, Po += dr * Ur, jo += dr * Jr, Qo += dr * to, bn += dr * po, Lo += dr * yo, Vo += dr * mo, zo += dr * vo, ko += dr * Ao, Wo += dr * wo, Co += dr * Do, $o += dr * Io, xo += dr * No, Ho += dr * Go, dr = oo[2], Eo += dr * gn, Fo += dr * hn, Po += dr * Yr, jo += dr * Ur, Qo += dr * Jr, bn += dr * to, Lo += dr * po, Vo += dr * yo, zo += dr * mo, ko += dr * vo, Wo += dr * Ao, Co += dr * wo, $o += dr * Do, xo += dr * Io, Ho += dr * No, qo += dr * Go, dr = oo[3], Fo += dr * gn, Po += dr * hn, jo += dr * Yr, Qo += dr * Ur, bn += dr * Jr, Lo += dr * to, Vo += dr * po, zo += dr * yo, ko += dr * mo, Wo += dr * vo, Co += dr * Ao, $o += dr * wo, xo += dr * Do, Ho += dr * Io, qo += dr * No, Bo += dr * Go, dr = oo[4], Po += dr * gn, jo += dr * hn, Qo += dr * Yr, bn += dr * Ur, Lo += dr * Jr, Vo += dr * to, zo += dr * po, ko += dr * yo, Wo += dr * mo, Co += dr * vo, $o += dr * Ao, xo += dr * wo, Ho += dr * Do, qo += dr * Io, Bo += dr * No, Yo += dr * Go, dr = oo[5], jo += dr * gn, Qo += dr * hn, bn += dr * Yr, Lo += dr * Ur, Vo += dr * Jr, zo += dr * to, ko += dr * po, Wo += dr * yo, Co += dr * mo, $o += dr * vo, xo += dr * Ao, Ho += dr * wo, qo += dr * Do, Bo += dr * Io, Yo += dr * No, Ko += dr * Go, dr = oo[6], Qo += dr * gn, bn += dr * hn, Lo += dr * Yr, Vo += dr * Ur, zo += dr * Jr, ko += dr * to, Wo += dr * po, Co += dr * yo, $o += dr * mo, xo += dr * vo, Ho += dr * Ao, qo += dr * wo, Bo += dr * Do, Yo += dr * Io, Ko += dr * No, Jo += dr * Go, dr = oo[7], bn += dr * gn, Lo += dr * hn, Vo += dr * Yr, zo += dr * Ur, ko += dr * Jr, Wo += dr * to, Co += dr * po, $o += dr * yo, xo += dr * mo, Ho += dr * vo, qo += dr * Ao, Bo += dr * wo, Yo += dr * Do, Ko += dr * Io, Jo += dr * No, Zo += dr * Go, dr = oo[8], Lo += dr * gn, Vo += dr * hn, zo += dr * Yr, ko += dr * Ur, Wo += dr * Jr, Co += dr * to, $o += dr * po, xo += dr * yo, Ho += dr * mo, qo += dr * vo, Bo += dr * Ao, Yo += dr * wo, Ko += dr * Do, Jo += dr * Io, Zo += dr * No, Xo += dr * Go, dr = oo[9], Vo += dr * gn, zo += dr * hn, ko += dr * Yr, Wo += dr * Ur, Co += dr * Jr, $o += dr * to, xo += dr * po, Ho += dr * yo, qo += dr * mo, Bo += dr * vo, Yo += dr * Ao, Ko += dr * wo, Jo += dr * Do, Zo += dr * Io, Xo += dr * No, Pn += dr * Go, dr = oo[10], zo += dr * gn, ko += dr * hn, Wo += dr * Yr, Co += dr * Ur, $o += dr * Jr, xo += dr * to, Ho += dr * po, qo += dr * yo, Bo += dr * mo, Yo += dr * vo, Ko += dr * Ao, Jo += dr * wo, Zo += dr * Do, Xo += dr * Io, Pn += dr * No, Un += dr * Go, dr = oo[11], ko += dr * gn, Wo += dr * hn, Co += dr * Yr, $o += dr * Ur, xo += dr * Jr, Ho += dr * to, qo += dr * po, Bo += dr * yo, Yo += dr * mo, Ko += dr * vo, Jo += dr * Ao, Zo += dr * wo, Xo += dr * Do, Pn += dr * Io, Un += dr * No, Yn += dr * Go, dr = oo[12], Wo += dr * gn, Co += dr * hn, $o += dr * Yr, xo += dr * Ur, Ho += dr * Jr, qo += dr * to, Bo += dr * po, Yo += dr * yo, Ko += dr * mo, Jo += dr * vo, Zo += dr * Ao, Xo += dr * wo, Pn += dr * Do, Un += dr * Io, Yn += dr * No, An += dr * Go, dr = oo[13], Co += dr * gn, $o += dr * hn, xo += dr * Yr, Ho += dr * Ur, qo += dr * Jr, Bo += dr * to, Yo += dr * po, Ko += dr * yo, Jo += dr * mo, Zo += dr * vo, Xo += dr * Ao, Pn += dr * wo, Un += dr * Do, Yn += dr * Io, An += dr * No, Zn += dr * Go, dr = oo[14], $o += dr * gn, xo += dr * hn, Ho += dr * Yr, qo += dr * Ur, Bo += dr * Jr, Yo += dr * to, Ko += dr * po, Jo += dr * yo, Zo += dr * mo, Xo += dr * vo, Pn += dr * Ao, Un += dr * wo, Yn += dr * Do, An += dr * Io, Zn += dr * No, ei += dr * Go, dr = oo[15], xo += dr * gn, Ho += dr * hn, qo += dr * Yr, Bo += dr * Ur, Yo += dr * Jr, Ko += dr * to, Jo += dr * po, Zo += dr * yo, Xo += dr * mo, Pn += dr * vo, Un += dr * Ao, Yn += dr * wo, An += dr * Do, Zn += dr * Io, ei += dr * No, Sn += dr * Go, go += 38 * Ho, ho += 38 * qo, Eo += 38 * Bo, Fo += 38 * Yo, Po += 38 * Ko, jo += 38 * Jo, Qo += 38 * Zo, bn += 38 * Xo, Lo += 38 * Pn, Vo += 38 * Un, zo += 38 * Yn, ko += 38 * An, Wo += 38 * Zn, Co += 38 * ei, $o += 38 * Sn, Hr = 1, dr = go + Hr + 65535, Hr = Math.floor(dr / 65536), go = dr - Hr * 65536, dr = ho + Hr + 65535, Hr = Math.floor(dr / 65536), ho = dr - Hr * 65536, dr = Eo + Hr + 65535, Hr = Math.floor(dr / 65536), Eo = dr - Hr * 65536, dr = Fo + Hr + 65535, Hr = Math.floor(dr / 65536), Fo = dr - Hr * 65536, dr = Po + Hr + 65535, Hr = Math.floor(dr / 65536), Po = dr - Hr * 65536, dr = jo + Hr + 65535, Hr = Math.floor(dr / 65536), jo = dr - Hr * 65536, dr = Qo + Hr + 65535, Hr = Math.floor(dr / 65536), Qo = dr - Hr * 65536, dr = bn + Hr + 65535, Hr = Math.floor(dr / 65536), bn = dr - Hr * 65536, dr = Lo + Hr + 65535, Hr = Math.floor(dr / 65536), Lo = dr - Hr * 65536, dr = Vo + Hr + 65535, Hr = Math.floor(dr / 65536), Vo = dr - Hr * 65536, dr = zo + Hr + 65535, Hr = Math.floor(dr / 65536), zo = dr - Hr * 65536, dr = ko + Hr + 65535, Hr = Math.floor(dr / 65536), ko = dr - Hr * 65536, dr = Wo + Hr + 65535, Hr = Math.floor(dr / 65536), Wo = dr - Hr * 65536, dr = Co + Hr + 65535, Hr = Math.floor(dr / 65536), Co = dr - Hr * 65536, dr = $o + Hr + 65535, Hr = Math.floor(dr / 65536), $o = dr - Hr * 65536, dr = xo + Hr + 65535, Hr = Math.floor(dr / 65536), xo = dr - Hr * 65536, go += Hr - 1 + 37 * (Hr - 1), Hr = 1, dr = go + Hr + 65535, Hr = Math.floor(dr / 65536), go = dr - Hr * 65536, dr = ho + Hr + 65535, Hr = Math.floor(dr / 65536), ho = dr - Hr * 65536, dr = Eo + Hr + 65535, Hr = Math.floor(dr / 65536), Eo = dr - Hr * 65536, dr = Fo + Hr + 65535, Hr = Math.floor(dr / 65536), Fo = dr - Hr * 65536, dr = Po + Hr + 65535, Hr = Math.floor(dr / 65536), Po = dr - Hr * 65536, dr = jo + Hr + 65535, Hr = Math.floor(dr / 65536), jo = dr - Hr * 65536, dr = Qo + Hr + 65535, Hr = Math.floor(dr / 65536), Qo = dr - Hr * 65536, dr = bn + Hr + 65535, Hr = Math.floor(dr / 65536), bn = dr - Hr * 65536, dr = Lo + Hr + 65535, Hr = Math.floor(dr / 65536), Lo = dr - Hr * 65536, dr = Vo + Hr + 65535, Hr = Math.floor(dr / 65536), Vo = dr - Hr * 65536, dr = zo + Hr + 65535, Hr = Math.floor(dr / 65536), zo = dr - Hr * 65536, dr = ko + Hr + 65535, Hr = Math.floor(dr / 65536), ko = dr - Hr * 65536, dr = Wo + Hr + 65535, Hr = Math.floor(dr / 65536), Wo = dr - Hr * 65536, dr = Co + Hr + 65535, Hr = Math.floor(dr / 65536), Co = dr - Hr * 65536, dr = $o + Hr + 65535, Hr = Math.floor(dr / 65536), $o = dr - Hr * 65536, dr = xo + Hr + 65535, Hr = Math.floor(dr / 65536), xo = dr - Hr * 65536, go += Hr - 1 + 37 * (Hr - 1), ao[0] = go, ao[1] = ho, ao[2] = Eo, ao[3] = Fo, ao[4] = Po, ao[5] = jo, ao[6] = Qo, ao[7] = bn, ao[8] = Lo, ao[9] = Vo, ao[10] = zo, ao[11] = ko, ao[12] = Wo, ao[13] = Co, ao[14] = $o, ao[15] = xo;
  }
  function Fr(ao, oo) {
    gr(ao, oo, oo);
  }
  function Zr(ao, oo) {
    const zr = ye();
    let dr;
    for (dr = 0; dr < 16; dr++)
      zr[dr] = oo[dr];
    for (dr = 253; dr >= 0; dr--)
      Fr(zr, zr), dr !== 2 && dr !== 4 && gr(zr, zr, oo);
    for (dr = 0; dr < 16; dr++)
      ao[dr] = zr[dr];
  }
  function Wr(ao, oo) {
    const zr = ye();
    let dr;
    for (dr = 0; dr < 16; dr++)
      zr[dr] = oo[dr];
    for (dr = 250; dr >= 0; dr--)
      Fr(zr, zr), dr !== 1 && gr(zr, zr, oo);
    for (dr = 0; dr < 16; dr++)
      ao[dr] = zr[dr];
  }
  function qr(ao, oo) {
    const zr = ye(), dr = ye(), Hr = ye(), go = ye(), ho = ye(), Eo = ye(), Fo = ye(), Po = ye(), jo = ye();
    Mr(zr, ao[1], ao[0]), Mr(jo, oo[1], oo[0]), gr(zr, zr, jo), Vr(dr, ao[0], ao[1]), Vr(jo, oo[0], oo[1]), gr(dr, dr, jo), gr(Hr, ao[3], oo[3]), gr(Hr, Hr, xe), gr(go, ao[2], oo[2]), Vr(go, go, go), Mr(ho, dr, zr), Mr(Eo, go, Hr), Vr(Fo, go, Hr), Vr(Po, dr, zr), gr(ao[0], ho, Eo), gr(ao[1], Po, Fo), gr(ao[2], Fo, Eo), gr(ao[3], ho, Po);
  }
  function Qr(ao, oo, zr) {
    for (let dr = 0; dr < 4; dr++)
      Br(ao[dr], oo[dr], zr);
  }
  function lo(ao, oo) {
    const zr = ye(), dr = ye(), Hr = ye();
    Zr(Hr, oo[2]), gr(zr, oo[0], Hr), gr(dr, oo[1], Hr), Xr(ao, dr), ao[31] ^= kr(zr) << 7;
  }
  function Nr(ao, oo, zr) {
    lr(ao[0], Ee), lr(ao[1], Se), lr(ao[2], Se), lr(ao[3], Ee);
    for (let dr = 255; dr >= 0; --dr) {
      const Hr = zr[dr / 8 | 0] >> (dr & 7) & 1;
      Qr(ao, oo, Hr), qr(oo, ao), qr(ao, ao), Qr(ao, oo, Hr);
    }
  }
  function Lr(ao, oo) {
    const zr = [ye(), ye(), ye(), ye()];
    lr(zr[0], me), lr(zr[1], we), lr(zr[2], Se), gr(zr[3], me, we), Nr(ao, zr, oo);
  }
  function so(ao) {
    if (ao.length !== v.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${v.SEED_LENGTH} bytes`);
    const oo = (0, fe.hash)(ao);
    oo[0] &= 248, oo[31] &= 127, oo[31] |= 64;
    const zr = new Uint8Array(32), dr = [ye(), ye(), ye(), ye()];
    Lr(dr, oo), lo(zr, dr);
    const Hr = new Uint8Array(64);
    return Hr.set(ao), Hr.set(zr, 32), {
      publicKey: zr,
      secretKey: Hr
    };
  }
  v.generateKeyPairFromSeed = so;
  function fo(ao) {
    const oo = (0, e.randomBytes)(32, ao), zr = so(oo);
    return (0, be.wipe)(oo), zr;
  }
  v.generateKeyPair = fo;
  function co(ao) {
    if (ao.length !== v.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${v.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(ao.subarray(32));
  }
  v.extractPublicKeyFromSecretKey = co;
  const no = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function uo(ao, oo) {
    let zr, dr, Hr, go;
    for (dr = 63; dr >= 32; --dr) {
      for (zr = 0, Hr = dr - 32, go = dr - 12; Hr < go; ++Hr)
        oo[Hr] += zr - 16 * oo[dr] * no[Hr - (dr - 32)], zr = Math.floor((oo[Hr] + 128) / 256), oo[Hr] -= zr * 256;
      oo[Hr] += zr, oo[dr] = 0;
    }
    for (zr = 0, Hr = 0; Hr < 32; Hr++)
      oo[Hr] += zr - (oo[31] >> 4) * no[Hr], zr = oo[Hr] >> 8, oo[Hr] &= 255;
    for (Hr = 0; Hr < 32; Hr++)
      oo[Hr] -= zr * no[Hr];
    for (dr = 0; dr < 32; dr++)
      oo[dr + 1] += oo[dr] >> 8, ao[dr] = oo[dr] & 255;
  }
  function bo(ao) {
    const oo = new Float64Array(64);
    for (let zr = 0; zr < 64; zr++)
      oo[zr] = ao[zr];
    for (let zr = 0; zr < 64; zr++)
      ao[zr] = 0;
    uo(ao, oo);
  }
  function So(ao, oo) {
    const zr = new Float64Array(64), dr = [ye(), ye(), ye(), ye()], Hr = (0, fe.hash)(ao.subarray(0, 32));
    Hr[0] &= 248, Hr[31] &= 127, Hr[31] |= 64;
    const go = new Uint8Array(64);
    go.set(Hr.subarray(32), 32);
    const ho = new fe.SHA512();
    ho.update(go.subarray(32)), ho.update(oo);
    const Eo = ho.digest();
    ho.clean(), bo(Eo), Lr(dr, Eo), lo(go, dr), ho.reset(), ho.update(go.subarray(0, 32)), ho.update(ao.subarray(32)), ho.update(oo);
    const Fo = ho.digest();
    bo(Fo);
    for (let Po = 0; Po < 32; Po++)
      zr[Po] = Eo[Po];
    for (let Po = 0; Po < 32; Po++)
      for (let jo = 0; jo < 32; jo++)
        zr[Po + jo] += Fo[Po] * Hr[jo];
    return uo(go.subarray(32), zr), go;
  }
  v.sign = So;
  function io(ao, oo) {
    const zr = ye(), dr = ye(), Hr = ye(), go = ye(), ho = ye(), Eo = ye(), Fo = ye();
    return lr(ao[2], Se), $r(ao[1], oo), Fr(Hr, ao[1]), gr(go, Hr, Oe), Mr(Hr, Hr, ao[2]), Vr(go, ao[2], go), Fr(ho, go), Fr(Eo, ho), gr(Fo, Eo, ho), gr(zr, Fo, Hr), gr(zr, zr, go), Wr(zr, zr), gr(zr, zr, Hr), gr(zr, zr, go), gr(zr, zr, go), gr(ao[0], zr, go), Fr(dr, ao[0]), gr(dr, dr, go), jr(dr, Hr) && gr(ao[0], ao[0], ur), Fr(dr, ao[0]), gr(dr, dr, go), jr(dr, Hr) ? -1 : (kr(ao[0]) === oo[31] >> 7 && Mr(ao[0], Ee, ao[0]), gr(ao[3], ao[0], ao[1]), 0);
  }
  function To(ao, oo, zr) {
    const dr = new Uint8Array(32), Hr = [ye(), ye(), ye(), ye()], go = [ye(), ye(), ye(), ye()];
    if (zr.length !== v.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${v.SIGNATURE_LENGTH} bytes`);
    if (io(go, ao))
      return !1;
    const ho = new fe.SHA512();
    ho.update(zr.subarray(0, 32)), ho.update(ao), ho.update(oo);
    const Eo = ho.digest();
    return bo(Eo), Nr(Hr, go, Eo), Lr(go, zr.subarray(32)), qr(Hr, go), lo(dr, Hr), !eo(zr, dr);
  }
  v.verify = To;
  function Oo(ao) {
    let oo = [ye(), ye(), ye(), ye()];
    if (io(oo, ao))
      throw new Error("Ed25519: invalid public key");
    let zr = ye(), dr = ye(), Hr = oo[1];
    Vr(zr, Se, Hr), Mr(dr, Se, Hr), Zr(dr, dr), gr(zr, zr, dr);
    let go = new Uint8Array(32);
    return Xr(go, zr), go;
  }
  v.convertPublicKeyToX25519 = Oo;
  function Mo(ao) {
    const oo = (0, fe.hash)(ao.subarray(0, 32));
    oo[0] &= 248, oo[31] &= 127, oo[31] |= 64;
    const zr = new Uint8Array(oo.subarray(0, 32));
    return (0, be.wipe)(oo), zr;
  }
  v.convertSecretKeyToX25519 = Mo;
})(ed25519);
const JWT_IRIDIUM_ALG = "EdDSA", JWT_IRIDIUM_TYP = "JWT", JWT_DELIMITER = ".", JWT_ENCODING = "base64url", JSON_ENCODING = "utf8", DATA_ENCODING = "utf8", DID_DELIMITER = ":", DID_PREFIX = "did", DID_METHOD = "key", MULTICODEC_ED25519_ENCODING = "base58btc", MULTICODEC_ED25519_BASE = "z", MULTICODEC_ED25519_HEADER = "K36", KEY_PAIR_SEED_LENGTH = 32;
function asUint8Array(v) {
  return globalThis.Buffer != null ? new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : v;
}
function allocUnsafe(v = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array(globalThis.Buffer.allocUnsafe(v)) : new Uint8Array(v);
}
function concat$1(v, e) {
  e || (e = v.reduce((ye, ve) => ye + ve.length, 0));
  const fe = allocUnsafe(e);
  let be = 0;
  for (const ye of v)
    fe.set(ye, be), be += ye.length;
  return asUint8Array(fe);
}
function base$2(v, e) {
  if (v.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var fe = new Uint8Array(256), be = 0; be < fe.length; be++)
    fe[be] = 255;
  for (var ye = 0; ye < v.length; ye++) {
    var ve = v.charAt(ye), Ee = ve.charCodeAt(0);
    if (fe[Ee] !== 255)
      throw new TypeError(ve + " is ambiguous");
    fe[Ee] = ye;
  }
  var Se = v.length, Oe = v.charAt(0), xe = Math.log(Se) / Math.log(256), me = Math.log(256) / Math.log(Se);
  function we(Ar) {
    if (Ar instanceof Uint8Array || (ArrayBuffer.isView(Ar) ? Ar = new Uint8Array(Ar.buffer, Ar.byteOffset, Ar.byteLength) : Array.isArray(Ar) && (Ar = Uint8Array.from(Ar))), !(Ar instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ar.length === 0)
      return "";
    for (var Br = 0, Xr = 0, eo = 0, jr = Ar.length; eo !== jr && Ar[eo] === 0; )
      eo++, Br++;
    for (var kr = (jr - eo) * me + 1 >>> 0, $r = new Uint8Array(kr); eo !== jr; ) {
      for (var Vr = Ar[eo], Mr = 0, gr = kr - 1; (Vr !== 0 || Mr < Xr) && gr !== -1; gr--, Mr++)
        Vr += 256 * $r[gr] >>> 0, $r[gr] = Vr % Se >>> 0, Vr = Vr / Se >>> 0;
      if (Vr !== 0)
        throw new Error("Non-zero carry");
      Xr = Mr, eo++;
    }
    for (var Fr = kr - Xr; Fr !== kr && $r[Fr] === 0; )
      Fr++;
    for (var Zr = Oe.repeat(Br); Fr < kr; ++Fr)
      Zr += v.charAt($r[Fr]);
    return Zr;
  }
  function ur(Ar) {
    if (typeof Ar != "string")
      throw new TypeError("Expected String");
    if (Ar.length === 0)
      return new Uint8Array();
    var Br = 0;
    if (Ar[Br] !== " ") {
      for (var Xr = 0, eo = 0; Ar[Br] === Oe; )
        Xr++, Br++;
      for (var jr = (Ar.length - Br) * xe + 1 >>> 0, kr = new Uint8Array(jr); Ar[Br]; ) {
        var $r = fe[Ar.charCodeAt(Br)];
        if ($r === 255)
          return;
        for (var Vr = 0, Mr = jr - 1; ($r !== 0 || Vr < eo) && Mr !== -1; Mr--, Vr++)
          $r += Se * kr[Mr] >>> 0, kr[Mr] = $r % 256 >>> 0, $r = $r / 256 >>> 0;
        if ($r !== 0)
          throw new Error("Non-zero carry");
        eo = Vr, Br++;
      }
      if (Ar[Br] !== " ") {
        for (var gr = jr - eo; gr !== jr && kr[gr] === 0; )
          gr++;
        for (var Fr = new Uint8Array(Xr + (jr - gr)), Zr = Xr; gr !== jr; )
          Fr[Zr++] = kr[gr++];
        return Fr;
      }
    }
  }
  function lr(Ar) {
    var Br = ur(Ar);
    if (Br)
      return Br;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: we,
    decodeUnsafe: ur,
    decode: lr
  };
}
var src$3 = base$2, _brrp__multiformats_scope_baseX = src$3;
const coerce = (v) => {
  if (v instanceof Uint8Array && v.constructor.name === "Uint8Array")
    return v;
  if (v instanceof ArrayBuffer)
    return new Uint8Array(v);
  if (ArrayBuffer.isView(v))
    return new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$1 = (v) => new TextEncoder().encode(v), toString$1 = (v) => new TextDecoder().decode(v);
class Encoder {
  constructor(e, fe, be) {
    this.name = e, this.prefix = fe, this.baseEncode = be;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder {
  constructor(e, fe, be) {
    if (this.name = e, this.prefix = fe, fe.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = fe.codePointAt(0), this.baseDecode = be;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return or$1(this, e);
  }
}
class ComposedDecoder {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return or$1(this, e);
  }
  decode(e) {
    const fe = e[0], be = this.decoders[fe];
    if (be)
      return be.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$1 = (v, e) => new ComposedDecoder({
  ...v.decoders || { [v.prefix]: v },
  ...e.decoders || { [e.prefix]: e }
});
class Codec {
  constructor(e, fe, be, ye) {
    this.name = e, this.prefix = fe, this.baseEncode = be, this.baseDecode = ye, this.encoder = new Encoder(e, fe, be), this.decoder = new Decoder(e, fe, ye);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const from = ({ name: v, prefix: e, encode: fe, decode: be }) => new Codec(v, e, fe, be), baseX$1 = ({ prefix: v, name: e, alphabet: fe }) => {
  const { encode: be, decode: ye } = _brrp__multiformats_scope_baseX(fe, e);
  return from({
    prefix: v,
    name: e,
    encode: be,
    decode: (ve) => coerce(ye(ve))
  });
}, decode$3 = (v, e, fe, be) => {
  const ye = {};
  for (let me = 0; me < e.length; ++me)
    ye[e[me]] = me;
  let ve = v.length;
  for (; v[ve - 1] === "="; )
    --ve;
  const Ee = new Uint8Array(ve * fe / 8 | 0);
  let Se = 0, Oe = 0, xe = 0;
  for (let me = 0; me < ve; ++me) {
    const we = ye[v[me]];
    if (we === void 0)
      throw new SyntaxError(`Non-${be} character`);
    Oe = Oe << fe | we, Se += fe, Se >= 8 && (Se -= 8, Ee[xe++] = 255 & Oe >> Se);
  }
  if (Se >= fe || 255 & Oe << 8 - Se)
    throw new SyntaxError("Unexpected end of data");
  return Ee;
}, encode$2 = (v, e, fe) => {
  const be = e[e.length - 1] === "=", ye = (1 << fe) - 1;
  let ve = "", Ee = 0, Se = 0;
  for (let Oe = 0; Oe < v.length; ++Oe)
    for (Se = Se << 8 | v[Oe], Ee += 8; Ee > fe; )
      Ee -= fe, ve += e[ye & Se >> Ee];
  if (Ee && (ve += e[ye & Se << fe - Ee]), be)
    for (; ve.length * fe & 7; )
      ve += "=";
  return ve;
}, rfc4648$2 = ({ name: v, prefix: e, bitsPerChar: fe, alphabet: be }) => from({
  prefix: e,
  name: v,
  encode(ye) {
    return encode$2(ye, be, fe);
  },
  decode(ye) {
    return decode$3(ye, be, fe, v);
  }
}), identity$1 = from({
  prefix: "\0",
  name: "identity",
  encode: (v) => toString$1(v),
  decode: (v) => fromString$1(v)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$1
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648$2({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648$2({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX$1({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648$2({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648$2({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648$2({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648$2({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648$2({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648$2({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648$2({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648$2({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648$2({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648$2({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648$2({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX$1({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX$1({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX$1({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX$1({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64$2 = rfc4648$2({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648$2({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648$2({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648$2({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$2,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from(""), alphabetBytesToChars = alphabet.reduce((v, e, fe) => (v[fe] = e, v), []), alphabetCharsToBytes = alphabet.reduce((v, e, fe) => (v[e.codePointAt(0)] = fe, v), []);
function encode$1(v) {
  return v.reduce((e, fe) => (e += alphabetBytesToChars[fe], e), "");
}
function decode$2(v) {
  const e = [];
  for (const fe of v) {
    const be = alphabetCharsToBytes[fe.codePointAt(0)];
    if (be === void 0)
      throw new Error(`Non-base256emoji character: ${fe}`);
    e.push(be);
  }
  return new Uint8Array(e);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode: encode$1,
  decode: decode$2
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$3,
  ...base256emoji$1
};
function createCodec(v, e, fe, be) {
  return {
    name: v,
    prefix: e,
    encoder: {
      name: v,
      prefix: e,
      encode: fe
    },
    decoder: { decode: be }
  };
}
const string = createCodec("utf8", "u", (v) => "u" + new TextDecoder("utf8").decode(v), (v) => new TextEncoder().encode(v.substring(1))), ascii = createCodec("ascii", "a", (v) => {
  let e = "a";
  for (let fe = 0; fe < v.length; fe++)
    e += String.fromCharCode(v[fe]);
  return e;
}, (v) => {
  v = v.substring(1);
  const e = allocUnsafe(v.length);
  for (let fe = 0; fe < v.length; fe++)
    e[fe] = v.charCodeAt(fe);
  return e;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString(v, e = "utf8") {
  const fe = BASES[e];
  if (!fe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(v.buffer, v.byteOffset, v.byteLength).toString("utf8") : fe.encoder.encode(v).substring(1);
}
function fromString(v, e = "utf8") {
  const fe = BASES[e];
  if (!fe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? asUint8Array(globalThis.Buffer.from(v, "utf-8")) : fe.decoder.decode(`${fe.prefix}${v}`);
}
function encodeJSON(v) {
  return toString(fromString(safeJsonStringify(v), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(v) {
  const e = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING), fe = MULTICODEC_ED25519_BASE + toString(concat$1([e, v]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, fe].join(DID_DELIMITER);
}
function encodeSig(v) {
  return toString(v, JWT_ENCODING);
}
function encodeData(v) {
  return fromString([encodeJSON(v.header), encodeJSON(v.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(v) {
  return [
    encodeJSON(v.header),
    encodeJSON(v.payload),
    encodeSig(v.signature)
  ].join(JWT_DELIMITER);
}
function generateKeyPair(v = random.randomBytes(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(v);
}
async function signJWT(v, e, fe, be, ye = cjs$4.fromMiliseconds(Date.now())) {
  const ve = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP }, Ee = encodeIss(be.publicKey), Se = ye + fe, Oe = { iss: Ee, sub: v, aud: e, iat: ye, exp: Se }, xe = encodeData({ header: ve, payload: Oe }), me = ed25519.sign(be.secretKey, xe);
  return encodeJWT({ header: ve, payload: Oe, signature: me });
}
var chacha20poly1305 = {}, chacha = {};
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$2 = wipe$1, ROUNDS = 20;
function core(v, e, fe) {
  for (var be = 1634760805, ye = 857760878, ve = 2036477234, Ee = 1797285236, Se = fe[3] << 24 | fe[2] << 16 | fe[1] << 8 | fe[0], Oe = fe[7] << 24 | fe[6] << 16 | fe[5] << 8 | fe[4], xe = fe[11] << 24 | fe[10] << 16 | fe[9] << 8 | fe[8], me = fe[15] << 24 | fe[14] << 16 | fe[13] << 8 | fe[12], we = fe[19] << 24 | fe[18] << 16 | fe[17] << 8 | fe[16], ur = fe[23] << 24 | fe[22] << 16 | fe[21] << 8 | fe[20], lr = fe[27] << 24 | fe[26] << 16 | fe[25] << 8 | fe[24], Ar = fe[31] << 24 | fe[30] << 16 | fe[29] << 8 | fe[28], Br = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], Xr = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], eo = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], jr = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], kr = be, $r = ye, Vr = ve, Mr = Ee, gr = Se, Fr = Oe, Zr = xe, Wr = me, qr = we, Qr = ur, lo = lr, Nr = Ar, Lr = Br, so = Xr, fo = eo, co = jr, no = 0; no < ROUNDS; no += 2)
    kr = kr + gr | 0, Lr ^= kr, Lr = Lr >>> 32 - 16 | Lr << 16, qr = qr + Lr | 0, gr ^= qr, gr = gr >>> 32 - 12 | gr << 12, $r = $r + Fr | 0, so ^= $r, so = so >>> 32 - 16 | so << 16, Qr = Qr + so | 0, Fr ^= Qr, Fr = Fr >>> 32 - 12 | Fr << 12, Vr = Vr + Zr | 0, fo ^= Vr, fo = fo >>> 32 - 16 | fo << 16, lo = lo + fo | 0, Zr ^= lo, Zr = Zr >>> 32 - 12 | Zr << 12, Mr = Mr + Wr | 0, co ^= Mr, co = co >>> 32 - 16 | co << 16, Nr = Nr + co | 0, Wr ^= Nr, Wr = Wr >>> 32 - 12 | Wr << 12, Vr = Vr + Zr | 0, fo ^= Vr, fo = fo >>> 32 - 8 | fo << 8, lo = lo + fo | 0, Zr ^= lo, Zr = Zr >>> 32 - 7 | Zr << 7, Mr = Mr + Wr | 0, co ^= Mr, co = co >>> 32 - 8 | co << 8, Nr = Nr + co | 0, Wr ^= Nr, Wr = Wr >>> 32 - 7 | Wr << 7, $r = $r + Fr | 0, so ^= $r, so = so >>> 32 - 8 | so << 8, Qr = Qr + so | 0, Fr ^= Qr, Fr = Fr >>> 32 - 7 | Fr << 7, kr = kr + gr | 0, Lr ^= kr, Lr = Lr >>> 32 - 8 | Lr << 8, qr = qr + Lr | 0, gr ^= qr, gr = gr >>> 32 - 7 | gr << 7, kr = kr + Fr | 0, co ^= kr, co = co >>> 32 - 16 | co << 16, lo = lo + co | 0, Fr ^= lo, Fr = Fr >>> 32 - 12 | Fr << 12, $r = $r + Zr | 0, Lr ^= $r, Lr = Lr >>> 32 - 16 | Lr << 16, Nr = Nr + Lr | 0, Zr ^= Nr, Zr = Zr >>> 32 - 12 | Zr << 12, Vr = Vr + Wr | 0, so ^= Vr, so = so >>> 32 - 16 | so << 16, qr = qr + so | 0, Wr ^= qr, Wr = Wr >>> 32 - 12 | Wr << 12, Mr = Mr + gr | 0, fo ^= Mr, fo = fo >>> 32 - 16 | fo << 16, Qr = Qr + fo | 0, gr ^= Qr, gr = gr >>> 32 - 12 | gr << 12, Vr = Vr + Wr | 0, so ^= Vr, so = so >>> 32 - 8 | so << 8, qr = qr + so | 0, Wr ^= qr, Wr = Wr >>> 32 - 7 | Wr << 7, Mr = Mr + gr | 0, fo ^= Mr, fo = fo >>> 32 - 8 | fo << 8, Qr = Qr + fo | 0, gr ^= Qr, gr = gr >>> 32 - 7 | gr << 7, $r = $r + Zr | 0, Lr ^= $r, Lr = Lr >>> 32 - 8 | Lr << 8, Nr = Nr + Lr | 0, Zr ^= Nr, Zr = Zr >>> 32 - 7 | Zr << 7, kr = kr + Fr | 0, co ^= kr, co = co >>> 32 - 8 | co << 8, lo = lo + co | 0, Fr ^= lo, Fr = Fr >>> 32 - 7 | Fr << 7;
  binary_1.writeUint32LE(kr + be | 0, v, 0), binary_1.writeUint32LE($r + ye | 0, v, 4), binary_1.writeUint32LE(Vr + ve | 0, v, 8), binary_1.writeUint32LE(Mr + Ee | 0, v, 12), binary_1.writeUint32LE(gr + Se | 0, v, 16), binary_1.writeUint32LE(Fr + Oe | 0, v, 20), binary_1.writeUint32LE(Zr + xe | 0, v, 24), binary_1.writeUint32LE(Wr + me | 0, v, 28), binary_1.writeUint32LE(qr + we | 0, v, 32), binary_1.writeUint32LE(Qr + ur | 0, v, 36), binary_1.writeUint32LE(lo + lr | 0, v, 40), binary_1.writeUint32LE(Nr + Ar | 0, v, 44), binary_1.writeUint32LE(Lr + Br | 0, v, 48), binary_1.writeUint32LE(so + Xr | 0, v, 52), binary_1.writeUint32LE(fo + eo | 0, v, 56), binary_1.writeUint32LE(co + jr | 0, v, 60);
}
function streamXOR(v, e, fe, be, ye) {
  if (ye === void 0 && (ye = 0), v.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (be.length < fe.length)
    throw new Error("ChaCha: destination is shorter than source");
  var ve, Ee;
  if (ye === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    ve = new Uint8Array(16), Ee = ve.length - e.length, ve.set(e, Ee);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    ve = e, Ee = ye;
  }
  for (var Se = new Uint8Array(64), Oe = 0; Oe < fe.length; Oe += 64) {
    core(Se, ve, v);
    for (var xe = Oe; xe < Oe + 64 && xe < fe.length; xe++)
      be[xe] = fe[xe] ^ Se[xe - Oe];
    incrementCounter(ve, 0, Ee);
  }
  return wipe_1$2.wipe(Se), ye === 0 && wipe_1$2.wipe(ve), be;
}
chacha.streamXOR = streamXOR;
function stream(v, e, fe, be) {
  return be === void 0 && (be = 0), wipe_1$2.wipe(fe), streamXOR(v, e, fe, fe, be);
}
chacha.stream = stream;
function incrementCounter(v, e, fe) {
  for (var be = 1; fe--; )
    be = be + (v[e] & 255) | 0, v[e] = be & 255, be >>>= 8, e++;
  if (be > 0)
    throw new Error("ChaCha: counter overflow");
}
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(v, e, fe) {
  return ~(v - 1) & e | v - 1 & fe;
}
constantTime.select = select;
function lessOrEqual(v, e) {
  return (v | 0) - (e | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(v, e) {
  if (v.length !== e.length)
    return 0;
  for (var fe = 0, be = 0; be < v.length; be++)
    fe |= v[be] ^ e[be];
  return 1 & fe - 1 >>> 8;
}
constantTime.compare = compare;
function equal(v, e) {
  return v.length === 0 || e.length === 0 ? !1 : compare(v, e) !== 0;
}
constantTime.equal = equal;
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  var e = constantTime, fe = wipe$1;
  v.DIGEST_LENGTH = 16;
  var be = (
    /** @class */
    function() {
      function Ee(Se) {
        this.digestLength = v.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var Oe = Se[0] | Se[1] << 8;
        this._r[0] = Oe & 8191;
        var xe = Se[2] | Se[3] << 8;
        this._r[1] = (Oe >>> 13 | xe << 3) & 8191;
        var me = Se[4] | Se[5] << 8;
        this._r[2] = (xe >>> 10 | me << 6) & 7939;
        var we = Se[6] | Se[7] << 8;
        this._r[3] = (me >>> 7 | we << 9) & 8191;
        var ur = Se[8] | Se[9] << 8;
        this._r[4] = (we >>> 4 | ur << 12) & 255, this._r[5] = ur >>> 1 & 8190;
        var lr = Se[10] | Se[11] << 8;
        this._r[6] = (ur >>> 14 | lr << 2) & 8191;
        var Ar = Se[12] | Se[13] << 8;
        this._r[7] = (lr >>> 11 | Ar << 5) & 8065;
        var Br = Se[14] | Se[15] << 8;
        this._r[8] = (Ar >>> 8 | Br << 8) & 8191, this._r[9] = Br >>> 5 & 127, this._pad[0] = Se[16] | Se[17] << 8, this._pad[1] = Se[18] | Se[19] << 8, this._pad[2] = Se[20] | Se[21] << 8, this._pad[3] = Se[22] | Se[23] << 8, this._pad[4] = Se[24] | Se[25] << 8, this._pad[5] = Se[26] | Se[27] << 8, this._pad[6] = Se[28] | Se[29] << 8, this._pad[7] = Se[30] | Se[31] << 8;
      }
      return Ee.prototype._blocks = function(Se, Oe, xe) {
        for (var me = this._fin ? 0 : 2048, we = this._h[0], ur = this._h[1], lr = this._h[2], Ar = this._h[3], Br = this._h[4], Xr = this._h[5], eo = this._h[6], jr = this._h[7], kr = this._h[8], $r = this._h[9], Vr = this._r[0], Mr = this._r[1], gr = this._r[2], Fr = this._r[3], Zr = this._r[4], Wr = this._r[5], qr = this._r[6], Qr = this._r[7], lo = this._r[8], Nr = this._r[9]; xe >= 16; ) {
          var Lr = Se[Oe + 0] | Se[Oe + 1] << 8;
          we += Lr & 8191;
          var so = Se[Oe + 2] | Se[Oe + 3] << 8;
          ur += (Lr >>> 13 | so << 3) & 8191;
          var fo = Se[Oe + 4] | Se[Oe + 5] << 8;
          lr += (so >>> 10 | fo << 6) & 8191;
          var co = Se[Oe + 6] | Se[Oe + 7] << 8;
          Ar += (fo >>> 7 | co << 9) & 8191;
          var no = Se[Oe + 8] | Se[Oe + 9] << 8;
          Br += (co >>> 4 | no << 12) & 8191, Xr += no >>> 1 & 8191;
          var uo = Se[Oe + 10] | Se[Oe + 11] << 8;
          eo += (no >>> 14 | uo << 2) & 8191;
          var bo = Se[Oe + 12] | Se[Oe + 13] << 8;
          jr += (uo >>> 11 | bo << 5) & 8191;
          var So = Se[Oe + 14] | Se[Oe + 15] << 8;
          kr += (bo >>> 8 | So << 8) & 8191, $r += So >>> 5 | me;
          var io = 0, To = io;
          To += we * Vr, To += ur * (5 * Nr), To += lr * (5 * lo), To += Ar * (5 * Qr), To += Br * (5 * qr), io = To >>> 13, To &= 8191, To += Xr * (5 * Wr), To += eo * (5 * Zr), To += jr * (5 * Fr), To += kr * (5 * gr), To += $r * (5 * Mr), io += To >>> 13, To &= 8191;
          var Oo = io;
          Oo += we * Mr, Oo += ur * Vr, Oo += lr * (5 * Nr), Oo += Ar * (5 * lo), Oo += Br * (5 * Qr), io = Oo >>> 13, Oo &= 8191, Oo += Xr * (5 * qr), Oo += eo * (5 * Wr), Oo += jr * (5 * Zr), Oo += kr * (5 * Fr), Oo += $r * (5 * gr), io += Oo >>> 13, Oo &= 8191;
          var Mo = io;
          Mo += we * gr, Mo += ur * Mr, Mo += lr * Vr, Mo += Ar * (5 * Nr), Mo += Br * (5 * lo), io = Mo >>> 13, Mo &= 8191, Mo += Xr * (5 * Qr), Mo += eo * (5 * qr), Mo += jr * (5 * Wr), Mo += kr * (5 * Zr), Mo += $r * (5 * Fr), io += Mo >>> 13, Mo &= 8191;
          var ao = io;
          ao += we * Fr, ao += ur * gr, ao += lr * Mr, ao += Ar * Vr, ao += Br * (5 * Nr), io = ao >>> 13, ao &= 8191, ao += Xr * (5 * lo), ao += eo * (5 * Qr), ao += jr * (5 * qr), ao += kr * (5 * Wr), ao += $r * (5 * Zr), io += ao >>> 13, ao &= 8191;
          var oo = io;
          oo += we * Zr, oo += ur * Fr, oo += lr * gr, oo += Ar * Mr, oo += Br * Vr, io = oo >>> 13, oo &= 8191, oo += Xr * (5 * Nr), oo += eo * (5 * lo), oo += jr * (5 * Qr), oo += kr * (5 * qr), oo += $r * (5 * Wr), io += oo >>> 13, oo &= 8191;
          var zr = io;
          zr += we * Wr, zr += ur * Zr, zr += lr * Fr, zr += Ar * gr, zr += Br * Mr, io = zr >>> 13, zr &= 8191, zr += Xr * Vr, zr += eo * (5 * Nr), zr += jr * (5 * lo), zr += kr * (5 * Qr), zr += $r * (5 * qr), io += zr >>> 13, zr &= 8191;
          var dr = io;
          dr += we * qr, dr += ur * Wr, dr += lr * Zr, dr += Ar * Fr, dr += Br * gr, io = dr >>> 13, dr &= 8191, dr += Xr * Mr, dr += eo * Vr, dr += jr * (5 * Nr), dr += kr * (5 * lo), dr += $r * (5 * Qr), io += dr >>> 13, dr &= 8191;
          var Hr = io;
          Hr += we * Qr, Hr += ur * qr, Hr += lr * Wr, Hr += Ar * Zr, Hr += Br * Fr, io = Hr >>> 13, Hr &= 8191, Hr += Xr * gr, Hr += eo * Mr, Hr += jr * Vr, Hr += kr * (5 * Nr), Hr += $r * (5 * lo), io += Hr >>> 13, Hr &= 8191;
          var go = io;
          go += we * lo, go += ur * Qr, go += lr * qr, go += Ar * Wr, go += Br * Zr, io = go >>> 13, go &= 8191, go += Xr * Fr, go += eo * gr, go += jr * Mr, go += kr * Vr, go += $r * (5 * Nr), io += go >>> 13, go &= 8191;
          var ho = io;
          ho += we * Nr, ho += ur * lo, ho += lr * Qr, ho += Ar * qr, ho += Br * Wr, io = ho >>> 13, ho &= 8191, ho += Xr * Zr, ho += eo * Fr, ho += jr * gr, ho += kr * Mr, ho += $r * Vr, io += ho >>> 13, ho &= 8191, io = (io << 2) + io | 0, io = io + To | 0, To = io & 8191, io = io >>> 13, Oo += io, we = To, ur = Oo, lr = Mo, Ar = ao, Br = oo, Xr = zr, eo = dr, jr = Hr, kr = go, $r = ho, Oe += 16, xe -= 16;
        }
        this._h[0] = we, this._h[1] = ur, this._h[2] = lr, this._h[3] = Ar, this._h[4] = Br, this._h[5] = Xr, this._h[6] = eo, this._h[7] = jr, this._h[8] = kr, this._h[9] = $r;
      }, Ee.prototype.finish = function(Se, Oe) {
        Oe === void 0 && (Oe = 0);
        var xe = new Uint16Array(10), me, we, ur, lr;
        if (this._leftover) {
          for (lr = this._leftover, this._buffer[lr++] = 1; lr < 16; lr++)
            this._buffer[lr] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (me = this._h[1] >>> 13, this._h[1] &= 8191, lr = 2; lr < 10; lr++)
          this._h[lr] += me, me = this._h[lr] >>> 13, this._h[lr] &= 8191;
        for (this._h[0] += me * 5, me = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += me, me = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += me, xe[0] = this._h[0] + 5, me = xe[0] >>> 13, xe[0] &= 8191, lr = 1; lr < 10; lr++)
          xe[lr] = this._h[lr] + me, me = xe[lr] >>> 13, xe[lr] &= 8191;
        for (xe[9] -= 8192, we = (me ^ 1) - 1, lr = 0; lr < 10; lr++)
          xe[lr] &= we;
        for (we = ~we, lr = 0; lr < 10; lr++)
          this._h[lr] = this._h[lr] & we | xe[lr];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, ur = this._h[0] + this._pad[0], this._h[0] = ur & 65535, lr = 1; lr < 8; lr++)
          ur = (this._h[lr] + this._pad[lr] | 0) + (ur >>> 16) | 0, this._h[lr] = ur & 65535;
        return Se[Oe + 0] = this._h[0] >>> 0, Se[Oe + 1] = this._h[0] >>> 8, Se[Oe + 2] = this._h[1] >>> 0, Se[Oe + 3] = this._h[1] >>> 8, Se[Oe + 4] = this._h[2] >>> 0, Se[Oe + 5] = this._h[2] >>> 8, Se[Oe + 6] = this._h[3] >>> 0, Se[Oe + 7] = this._h[3] >>> 8, Se[Oe + 8] = this._h[4] >>> 0, Se[Oe + 9] = this._h[4] >>> 8, Se[Oe + 10] = this._h[5] >>> 0, Se[Oe + 11] = this._h[5] >>> 8, Se[Oe + 12] = this._h[6] >>> 0, Se[Oe + 13] = this._h[6] >>> 8, Se[Oe + 14] = this._h[7] >>> 0, Se[Oe + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, Ee.prototype.update = function(Se) {
        var Oe = 0, xe = Se.length, me;
        if (this._leftover) {
          me = 16 - this._leftover, me > xe && (me = xe);
          for (var we = 0; we < me; we++)
            this._buffer[this._leftover + we] = Se[Oe + we];
          if (xe -= me, Oe += me, this._leftover += me, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (xe >= 16 && (me = xe - xe % 16, this._blocks(Se, Oe, me), Oe += me, xe -= me), xe) {
          for (var we = 0; we < xe; we++)
            this._buffer[this._leftover + we] = Se[Oe + we];
          this._leftover += xe;
        }
        return this;
      }, Ee.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var Se = new Uint8Array(16);
        return this.finish(Se), Se;
      }, Ee.prototype.clean = function() {
        return fe.wipe(this._buffer), fe.wipe(this._r), fe.wipe(this._h), fe.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, Ee;
    }()
  );
  v.Poly1305 = be;
  function ye(Ee, Se) {
    var Oe = new be(Ee);
    Oe.update(Se);
    var xe = Oe.digest();
    return Oe.clean(), xe;
  }
  v.oneTimeAuth = ye;
  function ve(Ee, Se) {
    return Ee.length !== v.DIGEST_LENGTH || Se.length !== v.DIGEST_LENGTH ? !1 : e.equal(Ee, Se);
  }
  v.equal = ve;
})(poly1305);
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  var e = chacha, fe = poly1305, be = wipe$1, ye = binary, ve = constantTime;
  v.KEY_LENGTH = 32, v.NONCE_LENGTH = 12, v.TAG_LENGTH = 16;
  var Ee = new Uint8Array(16), Se = (
    /** @class */
    function() {
      function Oe(xe) {
        if (this.nonceLength = v.NONCE_LENGTH, this.tagLength = v.TAG_LENGTH, xe.length !== v.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(xe);
      }
      return Oe.prototype.seal = function(xe, me, we, ur) {
        if (xe.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var lr = new Uint8Array(16);
        lr.set(xe, lr.length - xe.length);
        var Ar = new Uint8Array(32);
        e.stream(this._key, lr, Ar, 4);
        var Br = me.length + this.tagLength, Xr;
        if (ur) {
          if (ur.length !== Br)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Xr = ur;
        } else
          Xr = new Uint8Array(Br);
        return e.streamXOR(this._key, lr, me, Xr, 4), this._authenticate(Xr.subarray(Xr.length - this.tagLength, Xr.length), Ar, Xr.subarray(0, Xr.length - this.tagLength), we), be.wipe(lr), Xr;
      }, Oe.prototype.open = function(xe, me, we, ur) {
        if (xe.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (me.length < this.tagLength)
          return null;
        var lr = new Uint8Array(16);
        lr.set(xe, lr.length - xe.length);
        var Ar = new Uint8Array(32);
        e.stream(this._key, lr, Ar, 4);
        var Br = new Uint8Array(this.tagLength);
        if (this._authenticate(Br, Ar, me.subarray(0, me.length - this.tagLength), we), !ve.equal(Br, me.subarray(me.length - this.tagLength, me.length)))
          return null;
        var Xr = me.length - this.tagLength, eo;
        if (ur) {
          if (ur.length !== Xr)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          eo = ur;
        } else
          eo = new Uint8Array(Xr);
        return e.streamXOR(this._key, lr, me.subarray(0, me.length - this.tagLength), eo, 4), be.wipe(lr), eo;
      }, Oe.prototype.clean = function() {
        return be.wipe(this._key), this;
      }, Oe.prototype._authenticate = function(xe, me, we, ur) {
        var lr = new fe.Poly1305(me);
        ur && (lr.update(ur), ur.length % 16 > 0 && lr.update(Ee.subarray(ur.length % 16))), lr.update(we), we.length % 16 > 0 && lr.update(Ee.subarray(we.length % 16));
        var Ar = new Uint8Array(8);
        ur && ye.writeUint64LE(ur.length, Ar), lr.update(Ar), ye.writeUint64LE(we.length, Ar), lr.update(Ar);
        for (var Br = lr.digest(), Xr = 0; Xr < Br.length; Xr++)
          xe[Xr] = Br[Xr];
        lr.clean(), be.wipe(Br), be.wipe(Ar);
      }, Oe;
    }()
  );
  v.ChaCha20Poly1305 = Se;
})(chacha20poly1305);
var hkdf = {}, hmac$1 = {}, hash$1 = {};
Object.defineProperty(hash$1, "__esModule", { value: !0 });
function isSerializableHash(v) {
  return typeof v.saveState < "u" && typeof v.restoreState < "u" && typeof v.cleanSavedState < "u";
}
hash$1.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: !0 });
var hash_1 = hash$1, constant_time_1 = constantTime, wipe_1$1 = wipe$1, HMAC = (
  /** @class */
  function() {
    function v(e, fe) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var be = new Uint8Array(this.blockSize);
      fe.length > this.blockSize ? this._inner.update(fe).finish(be).clean() : be.set(fe);
      for (var ye = 0; ye < be.length; ye++)
        be[ye] ^= 54;
      this._inner.update(be);
      for (var ye = 0; ye < be.length; ye++)
        be[ye] ^= 106;
      this._outer.update(be), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$1.wipe(be);
    }
    return v.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, v.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, v.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, v.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, v.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, v.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, v.prototype.restoreState = function(e) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, v.prototype.cleanSavedState = function(e) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, v;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(v, e, fe) {
  var be = new HMAC(v, e);
  be.update(fe);
  var ye = be.digest();
  return be.clean(), ye;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$1, wipe_1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function v(e, fe, be, ye) {
      be === void 0 && (be = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = ye;
      var ve = hmac_1.hmac(this._hash, be, fe);
      this._hmac = new hmac_1.HMAC(e, ve), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return v.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, v.prototype.expand = function(e) {
      for (var fe = new Uint8Array(e), be = 0; be < fe.length; be++)
        this._bufpos === this._buffer.length && this._fillBuffer(), fe[be] = this._buffer[this._bufpos++];
      return fe;
    }, v.prototype.clean = function() {
      this._hmac.clean(), wipe_1.wipe(this._buffer), wipe_1.wipe(this._counter), this._bufpos = 0;
    }, v;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, sha256$1 = {};
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  var e = binary, fe = wipe$1;
  v.DIGEST_LENGTH = 32, v.BLOCK_SIZE = 64;
  var be = (
    /** @class */
    function() {
      function Se() {
        this.digestLength = v.DIGEST_LENGTH, this.blockSize = v.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return Se.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, Se.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, Se.prototype.clean = function() {
        fe.wipe(this._buffer), fe.wipe(this._temp), this.reset();
      }, Se.prototype.update = function(Oe, xe) {
        if (xe === void 0 && (xe = Oe.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var me = 0;
        if (this._bytesHashed += xe, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && xe > 0; )
            this._buffer[this._bufferLength++] = Oe[me++], xe--;
          this._bufferLength === this.blockSize && (ve(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (xe >= this.blockSize && (me = ve(this._temp, this._state, Oe, me, xe), xe %= this.blockSize); xe > 0; )
          this._buffer[this._bufferLength++] = Oe[me++], xe--;
        return this;
      }, Se.prototype.finish = function(Oe) {
        if (!this._finished) {
          var xe = this._bytesHashed, me = this._bufferLength, we = xe / 536870912 | 0, ur = xe << 3, lr = xe % 64 < 56 ? 64 : 128;
          this._buffer[me] = 128;
          for (var Ar = me + 1; Ar < lr - 8; Ar++)
            this._buffer[Ar] = 0;
          e.writeUint32BE(we, this._buffer, lr - 8), e.writeUint32BE(ur, this._buffer, lr - 4), ve(this._temp, this._state, this._buffer, 0, lr), this._finished = !0;
        }
        for (var Ar = 0; Ar < this.digestLength / 4; Ar++)
          e.writeUint32BE(this._state[Ar], Oe, Ar * 4);
        return this;
      }, Se.prototype.digest = function() {
        var Oe = new Uint8Array(this.digestLength);
        return this.finish(Oe), Oe;
      }, Se.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, Se.prototype.restoreState = function(Oe) {
        return this._state.set(Oe.state), this._bufferLength = Oe.bufferLength, Oe.buffer && this._buffer.set(Oe.buffer), this._bytesHashed = Oe.bytesHashed, this._finished = !1, this;
      }, Se.prototype.cleanSavedState = function(Oe) {
        fe.wipe(Oe.state), Oe.buffer && fe.wipe(Oe.buffer), Oe.bufferLength = 0, Oe.bytesHashed = 0;
      }, Se;
    }()
  );
  v.SHA256 = be;
  var ye = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function ve(Se, Oe, xe, me, we) {
    for (; we >= 64; ) {
      for (var ur = Oe[0], lr = Oe[1], Ar = Oe[2], Br = Oe[3], Xr = Oe[4], eo = Oe[5], jr = Oe[6], kr = Oe[7], $r = 0; $r < 16; $r++) {
        var Vr = me + $r * 4;
        Se[$r] = e.readUint32BE(xe, Vr);
      }
      for (var $r = 16; $r < 64; $r++) {
        var Mr = Se[$r - 2], gr = (Mr >>> 17 | Mr << 32 - 17) ^ (Mr >>> 19 | Mr << 32 - 19) ^ Mr >>> 10;
        Mr = Se[$r - 15];
        var Fr = (Mr >>> 7 | Mr << 32 - 7) ^ (Mr >>> 18 | Mr << 32 - 18) ^ Mr >>> 3;
        Se[$r] = (gr + Se[$r - 7] | 0) + (Fr + Se[$r - 16] | 0);
      }
      for (var $r = 0; $r < 64; $r++) {
        var gr = (((Xr >>> 6 | Xr << 26) ^ (Xr >>> 11 | Xr << 21) ^ (Xr >>> 25 | Xr << 7)) + (Xr & eo ^ ~Xr & jr) | 0) + (kr + (ye[$r] + Se[$r] | 0) | 0) | 0, Fr = ((ur >>> 2 | ur << 32 - 2) ^ (ur >>> 13 | ur << 32 - 13) ^ (ur >>> 22 | ur << 32 - 22)) + (ur & lr ^ ur & Ar ^ lr & Ar) | 0;
        kr = jr, jr = eo, eo = Xr, Xr = Br + gr | 0, Br = Ar, Ar = lr, lr = ur, ur = gr + Fr | 0;
      }
      Oe[0] += ur, Oe[1] += lr, Oe[2] += Ar, Oe[3] += Br, Oe[4] += Xr, Oe[5] += eo, Oe[6] += jr, Oe[7] += kr, me += 64, we -= 64;
    }
    return me;
  }
  function Ee(Se) {
    var Oe = new be();
    Oe.update(Se);
    var xe = Oe.digest();
    return Oe.clean(), xe;
  }
  v.hash = Ee;
})(sha256$1);
var x25519 = {};
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 }), v.sharedKey = v.generateKeyPair = v.generateKeyPairFromSeed = v.scalarMultBase = v.scalarMult = v.SHARED_KEY_LENGTH = v.SECRET_KEY_LENGTH = v.PUBLIC_KEY_LENGTH = void 0;
  const e = random, fe = wipe$1;
  v.PUBLIC_KEY_LENGTH = 32, v.SECRET_KEY_LENGTH = 32, v.SHARED_KEY_LENGTH = 32;
  function be($r) {
    const Vr = new Float64Array(16);
    if ($r)
      for (let Mr = 0; Mr < $r.length; Mr++)
        Vr[Mr] = $r[Mr];
    return Vr;
  }
  const ye = new Uint8Array(32);
  ye[0] = 9;
  const ve = be([56129, 1]);
  function Ee($r) {
    let Vr = 1;
    for (let Mr = 0; Mr < 16; Mr++) {
      let gr = $r[Mr] + Vr + 65535;
      Vr = Math.floor(gr / 65536), $r[Mr] = gr - Vr * 65536;
    }
    $r[0] += Vr - 1 + 37 * (Vr - 1);
  }
  function Se($r, Vr, Mr) {
    const gr = ~(Mr - 1);
    for (let Fr = 0; Fr < 16; Fr++) {
      const Zr = gr & ($r[Fr] ^ Vr[Fr]);
      $r[Fr] ^= Zr, Vr[Fr] ^= Zr;
    }
  }
  function Oe($r, Vr) {
    const Mr = be(), gr = be();
    for (let Fr = 0; Fr < 16; Fr++)
      gr[Fr] = Vr[Fr];
    Ee(gr), Ee(gr), Ee(gr);
    for (let Fr = 0; Fr < 2; Fr++) {
      Mr[0] = gr[0] - 65517;
      for (let Wr = 1; Wr < 15; Wr++)
        Mr[Wr] = gr[Wr] - 65535 - (Mr[Wr - 1] >> 16 & 1), Mr[Wr - 1] &= 65535;
      Mr[15] = gr[15] - 32767 - (Mr[14] >> 16 & 1);
      const Zr = Mr[15] >> 16 & 1;
      Mr[14] &= 65535, Se(gr, Mr, 1 - Zr);
    }
    for (let Fr = 0; Fr < 16; Fr++)
      $r[2 * Fr] = gr[Fr] & 255, $r[2 * Fr + 1] = gr[Fr] >> 8;
  }
  function xe($r, Vr) {
    for (let Mr = 0; Mr < 16; Mr++)
      $r[Mr] = Vr[2 * Mr] + (Vr[2 * Mr + 1] << 8);
    $r[15] &= 32767;
  }
  function me($r, Vr, Mr) {
    for (let gr = 0; gr < 16; gr++)
      $r[gr] = Vr[gr] + Mr[gr];
  }
  function we($r, Vr, Mr) {
    for (let gr = 0; gr < 16; gr++)
      $r[gr] = Vr[gr] - Mr[gr];
  }
  function ur($r, Vr, Mr) {
    let gr, Fr, Zr = 0, Wr = 0, qr = 0, Qr = 0, lo = 0, Nr = 0, Lr = 0, so = 0, fo = 0, co = 0, no = 0, uo = 0, bo = 0, So = 0, io = 0, To = 0, Oo = 0, Mo = 0, ao = 0, oo = 0, zr = 0, dr = 0, Hr = 0, go = 0, ho = 0, Eo = 0, Fo = 0, Po = 0, jo = 0, Qo = 0, bn = 0, Lo = Mr[0], Vo = Mr[1], zo = Mr[2], ko = Mr[3], Wo = Mr[4], Co = Mr[5], $o = Mr[6], xo = Mr[7], Ho = Mr[8], qo = Mr[9], Bo = Mr[10], Yo = Mr[11], Ko = Mr[12], Jo = Mr[13], Zo = Mr[14], Xo = Mr[15];
    gr = Vr[0], Zr += gr * Lo, Wr += gr * Vo, qr += gr * zo, Qr += gr * ko, lo += gr * Wo, Nr += gr * Co, Lr += gr * $o, so += gr * xo, fo += gr * Ho, co += gr * qo, no += gr * Bo, uo += gr * Yo, bo += gr * Ko, So += gr * Jo, io += gr * Zo, To += gr * Xo, gr = Vr[1], Wr += gr * Lo, qr += gr * Vo, Qr += gr * zo, lo += gr * ko, Nr += gr * Wo, Lr += gr * Co, so += gr * $o, fo += gr * xo, co += gr * Ho, no += gr * qo, uo += gr * Bo, bo += gr * Yo, So += gr * Ko, io += gr * Jo, To += gr * Zo, Oo += gr * Xo, gr = Vr[2], qr += gr * Lo, Qr += gr * Vo, lo += gr * zo, Nr += gr * ko, Lr += gr * Wo, so += gr * Co, fo += gr * $o, co += gr * xo, no += gr * Ho, uo += gr * qo, bo += gr * Bo, So += gr * Yo, io += gr * Ko, To += gr * Jo, Oo += gr * Zo, Mo += gr * Xo, gr = Vr[3], Qr += gr * Lo, lo += gr * Vo, Nr += gr * zo, Lr += gr * ko, so += gr * Wo, fo += gr * Co, co += gr * $o, no += gr * xo, uo += gr * Ho, bo += gr * qo, So += gr * Bo, io += gr * Yo, To += gr * Ko, Oo += gr * Jo, Mo += gr * Zo, ao += gr * Xo, gr = Vr[4], lo += gr * Lo, Nr += gr * Vo, Lr += gr * zo, so += gr * ko, fo += gr * Wo, co += gr * Co, no += gr * $o, uo += gr * xo, bo += gr * Ho, So += gr * qo, io += gr * Bo, To += gr * Yo, Oo += gr * Ko, Mo += gr * Jo, ao += gr * Zo, oo += gr * Xo, gr = Vr[5], Nr += gr * Lo, Lr += gr * Vo, so += gr * zo, fo += gr * ko, co += gr * Wo, no += gr * Co, uo += gr * $o, bo += gr * xo, So += gr * Ho, io += gr * qo, To += gr * Bo, Oo += gr * Yo, Mo += gr * Ko, ao += gr * Jo, oo += gr * Zo, zr += gr * Xo, gr = Vr[6], Lr += gr * Lo, so += gr * Vo, fo += gr * zo, co += gr * ko, no += gr * Wo, uo += gr * Co, bo += gr * $o, So += gr * xo, io += gr * Ho, To += gr * qo, Oo += gr * Bo, Mo += gr * Yo, ao += gr * Ko, oo += gr * Jo, zr += gr * Zo, dr += gr * Xo, gr = Vr[7], so += gr * Lo, fo += gr * Vo, co += gr * zo, no += gr * ko, uo += gr * Wo, bo += gr * Co, So += gr * $o, io += gr * xo, To += gr * Ho, Oo += gr * qo, Mo += gr * Bo, ao += gr * Yo, oo += gr * Ko, zr += gr * Jo, dr += gr * Zo, Hr += gr * Xo, gr = Vr[8], fo += gr * Lo, co += gr * Vo, no += gr * zo, uo += gr * ko, bo += gr * Wo, So += gr * Co, io += gr * $o, To += gr * xo, Oo += gr * Ho, Mo += gr * qo, ao += gr * Bo, oo += gr * Yo, zr += gr * Ko, dr += gr * Jo, Hr += gr * Zo, go += gr * Xo, gr = Vr[9], co += gr * Lo, no += gr * Vo, uo += gr * zo, bo += gr * ko, So += gr * Wo, io += gr * Co, To += gr * $o, Oo += gr * xo, Mo += gr * Ho, ao += gr * qo, oo += gr * Bo, zr += gr * Yo, dr += gr * Ko, Hr += gr * Jo, go += gr * Zo, ho += gr * Xo, gr = Vr[10], no += gr * Lo, uo += gr * Vo, bo += gr * zo, So += gr * ko, io += gr * Wo, To += gr * Co, Oo += gr * $o, Mo += gr * xo, ao += gr * Ho, oo += gr * qo, zr += gr * Bo, dr += gr * Yo, Hr += gr * Ko, go += gr * Jo, ho += gr * Zo, Eo += gr * Xo, gr = Vr[11], uo += gr * Lo, bo += gr * Vo, So += gr * zo, io += gr * ko, To += gr * Wo, Oo += gr * Co, Mo += gr * $o, ao += gr * xo, oo += gr * Ho, zr += gr * qo, dr += gr * Bo, Hr += gr * Yo, go += gr * Ko, ho += gr * Jo, Eo += gr * Zo, Fo += gr * Xo, gr = Vr[12], bo += gr * Lo, So += gr * Vo, io += gr * zo, To += gr * ko, Oo += gr * Wo, Mo += gr * Co, ao += gr * $o, oo += gr * xo, zr += gr * Ho, dr += gr * qo, Hr += gr * Bo, go += gr * Yo, ho += gr * Ko, Eo += gr * Jo, Fo += gr * Zo, Po += gr * Xo, gr = Vr[13], So += gr * Lo, io += gr * Vo, To += gr * zo, Oo += gr * ko, Mo += gr * Wo, ao += gr * Co, oo += gr * $o, zr += gr * xo, dr += gr * Ho, Hr += gr * qo, go += gr * Bo, ho += gr * Yo, Eo += gr * Ko, Fo += gr * Jo, Po += gr * Zo, jo += gr * Xo, gr = Vr[14], io += gr * Lo, To += gr * Vo, Oo += gr * zo, Mo += gr * ko, ao += gr * Wo, oo += gr * Co, zr += gr * $o, dr += gr * xo, Hr += gr * Ho, go += gr * qo, ho += gr * Bo, Eo += gr * Yo, Fo += gr * Ko, Po += gr * Jo, jo += gr * Zo, Qo += gr * Xo, gr = Vr[15], To += gr * Lo, Oo += gr * Vo, Mo += gr * zo, ao += gr * ko, oo += gr * Wo, zr += gr * Co, dr += gr * $o, Hr += gr * xo, go += gr * Ho, ho += gr * qo, Eo += gr * Bo, Fo += gr * Yo, Po += gr * Ko, jo += gr * Jo, Qo += gr * Zo, bn += gr * Xo, Zr += 38 * Oo, Wr += 38 * Mo, qr += 38 * ao, Qr += 38 * oo, lo += 38 * zr, Nr += 38 * dr, Lr += 38 * Hr, so += 38 * go, fo += 38 * ho, co += 38 * Eo, no += 38 * Fo, uo += 38 * Po, bo += 38 * jo, So += 38 * Qo, io += 38 * bn, Fr = 1, gr = Zr + Fr + 65535, Fr = Math.floor(gr / 65536), Zr = gr - Fr * 65536, gr = Wr + Fr + 65535, Fr = Math.floor(gr / 65536), Wr = gr - Fr * 65536, gr = qr + Fr + 65535, Fr = Math.floor(gr / 65536), qr = gr - Fr * 65536, gr = Qr + Fr + 65535, Fr = Math.floor(gr / 65536), Qr = gr - Fr * 65536, gr = lo + Fr + 65535, Fr = Math.floor(gr / 65536), lo = gr - Fr * 65536, gr = Nr + Fr + 65535, Fr = Math.floor(gr / 65536), Nr = gr - Fr * 65536, gr = Lr + Fr + 65535, Fr = Math.floor(gr / 65536), Lr = gr - Fr * 65536, gr = so + Fr + 65535, Fr = Math.floor(gr / 65536), so = gr - Fr * 65536, gr = fo + Fr + 65535, Fr = Math.floor(gr / 65536), fo = gr - Fr * 65536, gr = co + Fr + 65535, Fr = Math.floor(gr / 65536), co = gr - Fr * 65536, gr = no + Fr + 65535, Fr = Math.floor(gr / 65536), no = gr - Fr * 65536, gr = uo + Fr + 65535, Fr = Math.floor(gr / 65536), uo = gr - Fr * 65536, gr = bo + Fr + 65535, Fr = Math.floor(gr / 65536), bo = gr - Fr * 65536, gr = So + Fr + 65535, Fr = Math.floor(gr / 65536), So = gr - Fr * 65536, gr = io + Fr + 65535, Fr = Math.floor(gr / 65536), io = gr - Fr * 65536, gr = To + Fr + 65535, Fr = Math.floor(gr / 65536), To = gr - Fr * 65536, Zr += Fr - 1 + 37 * (Fr - 1), Fr = 1, gr = Zr + Fr + 65535, Fr = Math.floor(gr / 65536), Zr = gr - Fr * 65536, gr = Wr + Fr + 65535, Fr = Math.floor(gr / 65536), Wr = gr - Fr * 65536, gr = qr + Fr + 65535, Fr = Math.floor(gr / 65536), qr = gr - Fr * 65536, gr = Qr + Fr + 65535, Fr = Math.floor(gr / 65536), Qr = gr - Fr * 65536, gr = lo + Fr + 65535, Fr = Math.floor(gr / 65536), lo = gr - Fr * 65536, gr = Nr + Fr + 65535, Fr = Math.floor(gr / 65536), Nr = gr - Fr * 65536, gr = Lr + Fr + 65535, Fr = Math.floor(gr / 65536), Lr = gr - Fr * 65536, gr = so + Fr + 65535, Fr = Math.floor(gr / 65536), so = gr - Fr * 65536, gr = fo + Fr + 65535, Fr = Math.floor(gr / 65536), fo = gr - Fr * 65536, gr = co + Fr + 65535, Fr = Math.floor(gr / 65536), co = gr - Fr * 65536, gr = no + Fr + 65535, Fr = Math.floor(gr / 65536), no = gr - Fr * 65536, gr = uo + Fr + 65535, Fr = Math.floor(gr / 65536), uo = gr - Fr * 65536, gr = bo + Fr + 65535, Fr = Math.floor(gr / 65536), bo = gr - Fr * 65536, gr = So + Fr + 65535, Fr = Math.floor(gr / 65536), So = gr - Fr * 65536, gr = io + Fr + 65535, Fr = Math.floor(gr / 65536), io = gr - Fr * 65536, gr = To + Fr + 65535, Fr = Math.floor(gr / 65536), To = gr - Fr * 65536, Zr += Fr - 1 + 37 * (Fr - 1), $r[0] = Zr, $r[1] = Wr, $r[2] = qr, $r[3] = Qr, $r[4] = lo, $r[5] = Nr, $r[6] = Lr, $r[7] = so, $r[8] = fo, $r[9] = co, $r[10] = no, $r[11] = uo, $r[12] = bo, $r[13] = So, $r[14] = io, $r[15] = To;
  }
  function lr($r, Vr) {
    ur($r, Vr, Vr);
  }
  function Ar($r, Vr) {
    const Mr = be();
    for (let gr = 0; gr < 16; gr++)
      Mr[gr] = Vr[gr];
    for (let gr = 253; gr >= 0; gr--)
      lr(Mr, Mr), gr !== 2 && gr !== 4 && ur(Mr, Mr, Vr);
    for (let gr = 0; gr < 16; gr++)
      $r[gr] = Mr[gr];
  }
  function Br($r, Vr) {
    const Mr = new Uint8Array(32), gr = new Float64Array(80), Fr = be(), Zr = be(), Wr = be(), qr = be(), Qr = be(), lo = be();
    for (let fo = 0; fo < 31; fo++)
      Mr[fo] = $r[fo];
    Mr[31] = $r[31] & 127 | 64, Mr[0] &= 248, xe(gr, Vr);
    for (let fo = 0; fo < 16; fo++)
      Zr[fo] = gr[fo];
    Fr[0] = qr[0] = 1;
    for (let fo = 254; fo >= 0; --fo) {
      const co = Mr[fo >>> 3] >>> (fo & 7) & 1;
      Se(Fr, Zr, co), Se(Wr, qr, co), me(Qr, Fr, Wr), we(Fr, Fr, Wr), me(Wr, Zr, qr), we(Zr, Zr, qr), lr(qr, Qr), lr(lo, Fr), ur(Fr, Wr, Fr), ur(Wr, Zr, Qr), me(Qr, Fr, Wr), we(Fr, Fr, Wr), lr(Zr, Fr), we(Wr, qr, lo), ur(Fr, Wr, ve), me(Fr, Fr, qr), ur(Wr, Wr, Fr), ur(Fr, qr, lo), ur(qr, Zr, gr), lr(Zr, Qr), Se(Fr, Zr, co), Se(Wr, qr, co);
    }
    for (let fo = 0; fo < 16; fo++)
      gr[fo + 16] = Fr[fo], gr[fo + 32] = Wr[fo], gr[fo + 48] = Zr[fo], gr[fo + 64] = qr[fo];
    const Nr = gr.subarray(32), Lr = gr.subarray(16);
    Ar(Nr, Nr), ur(Lr, Lr, Nr);
    const so = new Uint8Array(32);
    return Oe(so, Lr), so;
  }
  v.scalarMult = Br;
  function Xr($r) {
    return Br($r, ye);
  }
  v.scalarMultBase = Xr;
  function eo($r) {
    if ($r.length !== v.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${v.SECRET_KEY_LENGTH} bytes`);
    const Vr = new Uint8Array($r);
    return {
      publicKey: Xr(Vr),
      secretKey: Vr
    };
  }
  v.generateKeyPairFromSeed = eo;
  function jr($r) {
    const Vr = (0, e.randomBytes)(32, $r), Mr = eo(Vr);
    return (0, fe.wipe)(Vr), Mr;
  }
  v.generateKeyPair = jr;
  function kr($r, Vr, Mr = !1) {
    if ($r.length !== v.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (Vr.length !== v.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const gr = Br($r, Vr);
    if (Mr) {
      let Fr = 0;
      for (let Zr = 0; Zr < gr.length; Zr++)
        Fr |= gr[Zr];
      if (Fr === 0)
        throw new Error("X25519: invalid shared key");
    }
    return gr;
  }
  v.sharedKey = kr;
})(x25519);
var __spreadArray = globalThis && globalThis.__spreadArray || function(v, e, fe) {
  if (fe || arguments.length === 2)
    for (var be = 0, ye = e.length, ve; be < ye; be++)
      (ve || !(be in e)) && (ve || (ve = Array.prototype.slice.call(e, 0, be)), ve[be] = e[be]);
  return v.concat(ve || Array.prototype.slice.call(e));
}, BrowserInfo = (
  /** @class */
  function() {
    function v(e, fe, be) {
      this.name = e, this.version = fe, this.os = be, this.type = "browser";
    }
    return v;
  }()
), NodeInfo = (
  /** @class */
  function() {
    function v(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return v;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  function() {
    function v(e, fe, be, ye) {
      this.name = e, this.version = fe, this.os = be, this.bot = ye, this.type = "bot-device";
    }
    return v;
  }()
), BotInfo = (
  /** @class */
  function() {
    function v() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return v;
  }()
), ReactNativeInfo = (
  /** @class */
  function() {
    function v() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return v;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(v) {
  return v ? parseUserAgent(v) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
function matchUserAgent(v) {
  return v !== "" && userAgentRules.reduce(function(e, fe) {
    var be = fe[0], ye = fe[1];
    if (e)
      return e;
    var ve = ye.exec(v);
    return !!ve && [be, ve];
  }, !1);
}
function parseUserAgent(v) {
  var e = matchUserAgent(v);
  if (!e)
    return null;
  var fe = e[0], be = e[1];
  if (fe === "searchbot")
    return new BotInfo();
  var ye = be[1] && be[1].split(".").join("_").split("_").slice(0, 3);
  ye ? ye.length < REQUIRED_VERSION_PARTS && (ye = __spreadArray(__spreadArray([], ye, !0), createVersionParts(REQUIRED_VERSION_PARTS - ye.length), !0)) : ye = [];
  var ve = ye.join("."), Ee = detectOS(v), Se = SEARCHBOT_OS_REGEX.exec(v);
  return Se && Se[1] ? new SearchBotDeviceInfo(fe, ve, Ee, Se[1]) : new BrowserInfo(fe, ve, Ee);
}
function detectOS(v) {
  for (var e = 0, fe = operatingSystemRules.length; e < fe; e++) {
    var be = operatingSystemRules[e], ye = be[0], ve = be[1], Ee = ve.exec(v);
    if (Ee)
      return ye;
  }
  return null;
}
function getNodeVersion() {
  var v = typeof process < "u" && process.version;
  return v ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(v) {
  for (var e = [], fe = 0; fe < v; fe++)
    e.push("0");
  return e;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: !0 });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
function getFromWindow(v) {
  let e;
  return typeof window < "u" && typeof window[v] < "u" && (e = window[v]), e;
}
cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(v) {
  const e = getFromWindow(v);
  if (!e)
    throw new Error(`${v} is not defined in Window`);
  return e;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage;
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let v, e;
  try {
    v = window_getters_1.getDocumentOrThrow(), e = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function fe() {
    const we = v.getElementsByTagName("link"), ur = [];
    for (let lr = 0; lr < we.length; lr++) {
      const Ar = we[lr], Br = Ar.getAttribute("rel");
      if (Br && Br.toLowerCase().indexOf("icon") > -1) {
        const Xr = Ar.getAttribute("href");
        if (Xr)
          if (Xr.toLowerCase().indexOf("https:") === -1 && Xr.toLowerCase().indexOf("http:") === -1 && Xr.indexOf("//") !== 0) {
            let eo = e.protocol + "//" + e.host;
            if (Xr.indexOf("/") === 0)
              eo += Xr;
            else {
              const jr = e.pathname.split("/");
              jr.pop();
              const kr = jr.join("/");
              eo += kr + "/" + Xr;
            }
            ur.push(eo);
          } else if (Xr.indexOf("//") === 0) {
            const eo = e.protocol + Xr;
            ur.push(eo);
          } else
            ur.push(Xr);
      }
    }
    return ur;
  }
  function be(...we) {
    const ur = v.getElementsByTagName("meta");
    for (let lr = 0; lr < ur.length; lr++) {
      const Ar = ur[lr], Br = ["itemprop", "property", "name"].map((Xr) => Ar.getAttribute(Xr)).filter((Xr) => Xr ? we.includes(Xr) : !1);
      if (Br.length && Br) {
        const Xr = Ar.getAttribute("content");
        if (Xr)
          return Xr;
      }
    }
    return "";
  }
  function ye() {
    let we = be("name", "og:site_name", "og:title", "twitter:title");
    return we || (we = v.title), we;
  }
  function ve() {
    return be("description", "og:description", "twitter:description", "keywords");
  }
  const Ee = ye(), Se = ve(), Oe = e.origin, xe = fe();
  return {
    description: Se,
    url: Oe,
    icons: xe,
    name: Ee
  };
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = (v) => encodeURIComponent(v).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(v, e) {
  try {
    return [decodeURIComponent(v.join(""))];
  } catch {
  }
  if (v.length === 1)
    return v;
  e = e || 1;
  var fe = v.slice(0, e), be = v.slice(e);
  return Array.prototype.concat.call([], decodeComponents(fe), decodeComponents(be));
}
function decode$1(v) {
  try {
    return decodeURIComponent(v);
  } catch {
    for (var e = v.match(singleMatcher) || [], fe = 1; fe < e.length; fe++)
      v = decodeComponents(e, fe).join(""), e = v.match(singleMatcher) || [];
    return v;
  }
}
function customDecodeURIComponent(v) {
  for (var e = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, fe = multiMatcher.exec(v); fe; ) {
    try {
      e[fe[0]] = decodeURIComponent(fe[0]);
    } catch {
      var be = decode$1(fe[0]);
      be !== fe[0] && (e[fe[0]] = be);
    }
    fe = multiMatcher.exec(v);
  }
  e["%C2"] = "";
  for (var ye = Object.keys(e), ve = 0; ve < ye.length; ve++) {
    var Ee = ye[ve];
    v = v.replace(new RegExp(Ee, "g"), e[Ee]);
  }
  return v;
}
var decodeUriComponent = function(v) {
  if (typeof v != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof v + "`");
  try {
    return v = v.replace(/\+/g, " "), decodeURIComponent(v);
  } catch {
    return customDecodeURIComponent(v);
  }
}, splitOnFirst = (v, e) => {
  if (!(typeof v == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [v];
  const fe = v.indexOf(e);
  return fe === -1 ? [v] : [
    v.slice(0, fe),
    v.slice(fe + e.length)
  ];
}, filterObj = function(v, e) {
  for (var fe = {}, be = Object.keys(v), ye = Array.isArray(e), ve = 0; ve < be.length; ve++) {
    var Ee = be[ve], Se = v[Ee];
    (ye ? e.indexOf(Ee) !== -1 : e(Ee, Se, v)) && (fe[Ee] = Se);
  }
  return fe;
};
(function(v) {
  const e = strictUriEncode, fe = decodeUriComponent, be = splitOnFirst, ye = filterObj, ve = (jr) => jr == null, Ee = Symbol("encodeFragmentIdentifier");
  function Se(jr) {
    switch (jr.arrayFormat) {
      case "index":
        return (kr) => ($r, Vr) => {
          const Mr = $r.length;
          return Vr === void 0 || jr.skipNull && Vr === null || jr.skipEmptyString && Vr === "" ? $r : Vr === null ? [...$r, [me(kr, jr), "[", Mr, "]"].join("")] : [
            ...$r,
            [me(kr, jr), "[", me(Mr, jr), "]=", me(Vr, jr)].join("")
          ];
        };
      case "bracket":
        return (kr) => ($r, Vr) => Vr === void 0 || jr.skipNull && Vr === null || jr.skipEmptyString && Vr === "" ? $r : Vr === null ? [...$r, [me(kr, jr), "[]"].join("")] : [...$r, [me(kr, jr), "[]=", me(Vr, jr)].join("")];
      case "colon-list-separator":
        return (kr) => ($r, Vr) => Vr === void 0 || jr.skipNull && Vr === null || jr.skipEmptyString && Vr === "" ? $r : Vr === null ? [...$r, [me(kr, jr), ":list="].join("")] : [...$r, [me(kr, jr), ":list=", me(Vr, jr)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const kr = jr.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return ($r) => (Vr, Mr) => Mr === void 0 || jr.skipNull && Mr === null || jr.skipEmptyString && Mr === "" ? Vr : (Mr = Mr === null ? "" : Mr, Vr.length === 0 ? [[me($r, jr), kr, me(Mr, jr)].join("")] : [[Vr, me(Mr, jr)].join(jr.arrayFormatSeparator)]);
      }
      default:
        return (kr) => ($r, Vr) => Vr === void 0 || jr.skipNull && Vr === null || jr.skipEmptyString && Vr === "" ? $r : Vr === null ? [...$r, me(kr, jr)] : [...$r, [me(kr, jr), "=", me(Vr, jr)].join("")];
    }
  }
  function Oe(jr) {
    let kr;
    switch (jr.arrayFormat) {
      case "index":
        return ($r, Vr, Mr) => {
          if (kr = /\[(\d*)\]$/.exec($r), $r = $r.replace(/\[\d*\]$/, ""), !kr) {
            Mr[$r] = Vr;
            return;
          }
          Mr[$r] === void 0 && (Mr[$r] = {}), Mr[$r][kr[1]] = Vr;
        };
      case "bracket":
        return ($r, Vr, Mr) => {
          if (kr = /(\[\])$/.exec($r), $r = $r.replace(/\[\]$/, ""), !kr) {
            Mr[$r] = Vr;
            return;
          }
          if (Mr[$r] === void 0) {
            Mr[$r] = [Vr];
            return;
          }
          Mr[$r] = [].concat(Mr[$r], Vr);
        };
      case "colon-list-separator":
        return ($r, Vr, Mr) => {
          if (kr = /(:list)$/.exec($r), $r = $r.replace(/:list$/, ""), !kr) {
            Mr[$r] = Vr;
            return;
          }
          if (Mr[$r] === void 0) {
            Mr[$r] = [Vr];
            return;
          }
          Mr[$r] = [].concat(Mr[$r], Vr);
        };
      case "comma":
      case "separator":
        return ($r, Vr, Mr) => {
          const gr = typeof Vr == "string" && Vr.includes(jr.arrayFormatSeparator), Fr = typeof Vr == "string" && !gr && we(Vr, jr).includes(jr.arrayFormatSeparator);
          Vr = Fr ? we(Vr, jr) : Vr;
          const Zr = gr || Fr ? Vr.split(jr.arrayFormatSeparator).map((Wr) => we(Wr, jr)) : Vr === null ? Vr : we(Vr, jr);
          Mr[$r] = Zr;
        };
      case "bracket-separator":
        return ($r, Vr, Mr) => {
          const gr = /(\[\])$/.test($r);
          if ($r = $r.replace(/\[\]$/, ""), !gr) {
            Mr[$r] = Vr && we(Vr, jr);
            return;
          }
          const Fr = Vr === null ? [] : Vr.split(jr.arrayFormatSeparator).map((Zr) => we(Zr, jr));
          if (Mr[$r] === void 0) {
            Mr[$r] = Fr;
            return;
          }
          Mr[$r] = [].concat(Mr[$r], Fr);
        };
      default:
        return ($r, Vr, Mr) => {
          if (Mr[$r] === void 0) {
            Mr[$r] = Vr;
            return;
          }
          Mr[$r] = [].concat(Mr[$r], Vr);
        };
    }
  }
  function xe(jr) {
    if (typeof jr != "string" || jr.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function me(jr, kr) {
    return kr.encode ? kr.strict ? e(jr) : encodeURIComponent(jr) : jr;
  }
  function we(jr, kr) {
    return kr.decode ? fe(jr) : jr;
  }
  function ur(jr) {
    return Array.isArray(jr) ? jr.sort() : typeof jr == "object" ? ur(Object.keys(jr)).sort((kr, $r) => Number(kr) - Number($r)).map((kr) => jr[kr]) : jr;
  }
  function lr(jr) {
    const kr = jr.indexOf("#");
    return kr !== -1 && (jr = jr.slice(0, kr)), jr;
  }
  function Ar(jr) {
    let kr = "";
    const $r = jr.indexOf("#");
    return $r !== -1 && (kr = jr.slice($r)), kr;
  }
  function Br(jr) {
    jr = lr(jr);
    const kr = jr.indexOf("?");
    return kr === -1 ? "" : jr.slice(kr + 1);
  }
  function Xr(jr, kr) {
    return kr.parseNumbers && !Number.isNaN(Number(jr)) && typeof jr == "string" && jr.trim() !== "" ? jr = Number(jr) : kr.parseBooleans && jr !== null && (jr.toLowerCase() === "true" || jr.toLowerCase() === "false") && (jr = jr.toLowerCase() === "true"), jr;
  }
  function eo(jr, kr) {
    kr = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, kr), xe(kr.arrayFormatSeparator);
    const $r = Oe(kr), Vr = /* @__PURE__ */ Object.create(null);
    if (typeof jr != "string" || (jr = jr.trim().replace(/^[?#&]/, ""), !jr))
      return Vr;
    for (const Mr of jr.split("&")) {
      if (Mr === "")
        continue;
      let [gr, Fr] = be(kr.decode ? Mr.replace(/\+/g, " ") : Mr, "=");
      Fr = Fr === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(kr.arrayFormat) ? Fr : we(Fr, kr), $r(we(gr, kr), Fr, Vr);
    }
    for (const Mr of Object.keys(Vr)) {
      const gr = Vr[Mr];
      if (typeof gr == "object" && gr !== null)
        for (const Fr of Object.keys(gr))
          gr[Fr] = Xr(gr[Fr], kr);
      else
        Vr[Mr] = Xr(gr, kr);
    }
    return kr.sort === !1 ? Vr : (kr.sort === !0 ? Object.keys(Vr).sort() : Object.keys(Vr).sort(kr.sort)).reduce((Mr, gr) => {
      const Fr = Vr[gr];
      return Fr && typeof Fr == "object" && !Array.isArray(Fr) ? Mr[gr] = ur(Fr) : Mr[gr] = Fr, Mr;
    }, /* @__PURE__ */ Object.create(null));
  }
  v.extract = Br, v.parse = eo, v.stringify = (jr, kr) => {
    if (!jr)
      return "";
    kr = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, kr), xe(kr.arrayFormatSeparator);
    const $r = (Fr) => kr.skipNull && ve(jr[Fr]) || kr.skipEmptyString && jr[Fr] === "", Vr = Se(kr), Mr = {};
    for (const Fr of Object.keys(jr))
      $r(Fr) || (Mr[Fr] = jr[Fr]);
    const gr = Object.keys(Mr);
    return kr.sort !== !1 && gr.sort(kr.sort), gr.map((Fr) => {
      const Zr = jr[Fr];
      return Zr === void 0 ? "" : Zr === null ? me(Fr, kr) : Array.isArray(Zr) ? Zr.length === 0 && kr.arrayFormat === "bracket-separator" ? me(Fr, kr) + "[]" : Zr.reduce(Vr(Fr), []).join("&") : me(Fr, kr) + "=" + me(Zr, kr);
    }).filter((Fr) => Fr.length > 0).join("&");
  }, v.parseUrl = (jr, kr) => {
    kr = Object.assign({
      decode: !0
    }, kr);
    const [$r, Vr] = be(jr, "#");
    return Object.assign(
      {
        url: $r.split("?")[0] || "",
        query: eo(Br(jr), kr)
      },
      kr && kr.parseFragmentIdentifier && Vr ? { fragmentIdentifier: we(Vr, kr) } : {}
    );
  }, v.stringifyUrl = (jr, kr) => {
    kr = Object.assign({
      encode: !0,
      strict: !0,
      [Ee]: !0
    }, kr);
    const $r = lr(jr.url).split("?")[0] || "", Vr = v.extract(jr.url), Mr = v.parse(Vr, { sort: !1 }), gr = Object.assign(Mr, jr.query);
    let Fr = v.stringify(gr, kr);
    Fr && (Fr = `?${Fr}`);
    let Zr = Ar(jr.url);
    return jr.fragmentIdentifier && (Zr = `#${kr[Ee] ? me(jr.fragmentIdentifier, kr) : jr.fragmentIdentifier}`), `${$r}${Fr}${Zr}`;
  }, v.pick = (jr, kr, $r) => {
    $r = Object.assign({
      parseFragmentIdentifier: !0,
      [Ee]: !1
    }, $r);
    const { url: Vr, query: Mr, fragmentIdentifier: gr } = v.parseUrl(jr, $r);
    return v.stringifyUrl({
      url: Vr,
      query: ye(Mr, kr),
      fragmentIdentifier: gr
    }, $r);
  }, v.exclude = (jr, kr, $r) => {
    const Vr = Array.isArray(kr) ? (Mr) => !kr.includes(Mr) : (Mr, gr) => !kr(Mr, gr);
    return v.pick(jr, Vr, $r);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
}, J$2 = "base10", p$2 = "base16", L = "base64pad", x$3 = "utf8", Q$2 = 0, _$2 = 1, $n = 0, Ie = 1, Z$1 = 12, X$2 = 32;
function jn() {
  const v = x25519.generateKeyPair();
  return { privateKey: toString(v.secretKey, p$2), publicKey: toString(v.publicKey, p$2) };
}
function Dn() {
  const v = random.randomBytes(X$2);
  return toString(v, p$2);
}
function kn(v, e) {
  const fe = x25519.sharedKey(fromString(v, p$2), fromString(e, p$2)), be = new HKDF_1(sha256$1.SHA256, fe).expand(X$2);
  return toString(be, p$2);
}
function Vn(v) {
  const e = sha256$1.hash(fromString(v, p$2));
  return toString(e, p$2);
}
function Mn$1(v) {
  const e = sha256$1.hash(fromString(v, x$3));
  return toString(e, p$2);
}
function Pe(v) {
  return fromString(`${v}`, J$2);
}
function $(v) {
  return Number(toString(v, J$2));
}
function Kn(v) {
  const e = Pe(typeof v.type < "u" ? v.type : Q$2);
  if ($(e) === _$2 && typeof v.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const fe = typeof v.senderPublicKey < "u" ? fromString(v.senderPublicKey, p$2) : void 0, be = typeof v.iv < "u" ? fromString(v.iv, p$2) : random.randomBytes(Z$1), ye = new chacha20poly1305.ChaCha20Poly1305(fromString(v.symKey, p$2)).seal(be, fromString(v.message, x$3));
  return Te({ type: e, sealed: ye, iv: be, senderPublicKey: fe });
}
function Ln(v) {
  const e = new chacha20poly1305.ChaCha20Poly1305(fromString(v.symKey, p$2)), { sealed: fe, iv: be } = ee(v.encoded), ye = e.open(be, fe);
  if (ye === null)
    throw new Error("Failed to decrypt");
  return toString(ye, x$3);
}
function Te(v) {
  if ($(v.type) === _$2) {
    if (typeof v.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat$1([v.type, v.senderPublicKey, v.iv, v.sealed]), L);
  }
  return toString(concat$1([v.type, v.iv, v.sealed]), L);
}
function ee(v) {
  const e = fromString(v, L), fe = e.slice($n, Ie), be = Ie;
  if ($(fe) === _$2) {
    const Se = be + X$2, Oe = Se + Z$1, xe = e.slice(be, Se), me = e.slice(Se, Oe), we = e.slice(Oe);
    return { type: fe, sealed: we, iv: me, senderPublicKey: xe };
  }
  const ye = be + Z$1, ve = e.slice(be, ye), Ee = e.slice(ye);
  return { type: fe, sealed: Ee, iv: ve };
}
function xn(v, e) {
  const fe = ee(v);
  return Re({ type: $(fe.type), senderPublicKey: typeof fe.senderPublicKey < "u" ? toString(fe.senderPublicKey, p$2) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function Re(v) {
  const e = (v == null ? void 0 : v.type) || Q$2;
  if (e === _$2) {
    if (typeof (v == null ? void 0 : v.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (v == null ? void 0 : v.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: v == null ? void 0 : v.senderPublicKey, receiverPublicKey: v == null ? void 0 : v.receiverPublicKey };
}
function Fn(v) {
  return v.type === _$2 && typeof v.senderPublicKey == "string" && typeof v.receiverPublicKey == "string";
}
var Hn = Object.defineProperty, Ae$1 = Object.getOwnPropertySymbols, qn = Object.prototype.hasOwnProperty, Bn = Object.prototype.propertyIsEnumerable, Ue$1 = (v, e, fe) => e in v ? Hn(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, _e = (v, e) => {
  for (var fe in e || (e = {}))
    qn.call(e, fe) && Ue$1(v, fe, e[fe]);
  if (Ae$1)
    for (var fe of Ae$1(e))
      Bn.call(e, fe) && Ue$1(v, fe, e[fe]);
  return v;
};
const Ce$1 = "ReactNative", m$2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, je$1 = "js";
function te$1() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function H$2() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce$1;
}
function q$2() {
  return !te$1() && !!getNavigator_1();
}
function R$2() {
  return H$2() ? m$2.reactNative : te$1() ? m$2.node : q$2() ? m$2.browser : m$2.unknown;
}
function De(v, e) {
  let fe = queryString.parse(v);
  return fe = _e(_e({}, fe), e), v = queryString.stringify(fe), v;
}
function ke$1() {
  if (R$2() === m$2.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: fe, Version: be } = global.Platform;
    return [fe, be].join("-");
  }
  const v = detect();
  if (v === null)
    return "unknown";
  const e = v.os ? v.os.replace(" ", "").toLowerCase() : "unknown";
  return v.type === "browser" ? [e, v.name, v.version].join("-") : [e, v.version].join("-");
}
function Ve$1() {
  var v;
  const e = R$2();
  return e === m$2.browser ? [e, ((v = getLocation_1()) == null ? void 0 : v.host) || "unknown"].join(":") : e;
}
function Me$1(v, e, fe) {
  const be = ke$1(), ye = Ve$1();
  return [[v, e].join("-"), [je$1, fe].join("-"), be, ye].join("/");
}
function Jn({ protocol: v, version: e, relayUrl: fe, sdkVersion: be, auth: ye, projectId: ve, useOnCloseEvent: Ee }) {
  const Se = fe.split("?"), Oe = Me$1(v, e, be), xe = { auth: ye, ua: Oe, projectId: ve, useOnCloseEvent: Ee || void 0 }, me = De(Se[1] || "", xe);
  return Se[0] + "?" + me;
}
function et$1(v) {
  return Object.fromEntries(v.entries());
}
function nt$1(v) {
  return new Map(Object.entries(v));
}
function st$2(v = cjs$4.FIVE_MINUTES, e) {
  const fe = cjs$4.toMiliseconds(v || cjs$4.FIVE_MINUTES);
  let be, ye, ve;
  return { resolve: (Ee) => {
    ve && be && (clearTimeout(ve), be(Ee));
  }, reject: (Ee) => {
    ve && ye && (clearTimeout(ve), ye(Ee));
  }, done: () => new Promise((Ee, Se) => {
    ve = setTimeout(() => {
      Se(new Error(e));
    }, fe), be = Ee, ye = Se;
  }) };
}
function it$1(v, e, fe) {
  return new Promise(async (be, ye) => {
    const ve = setTimeout(() => ye(new Error(fe)), e);
    try {
      const Ee = await v;
      be(Ee);
    } catch (Ee) {
      ye(Ee);
    }
    clearTimeout(ve);
  });
}
function re(v, e) {
  if (typeof e == "string" && e.startsWith(`${v}:`))
    return e;
  if (v.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (v.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${v}`);
}
function ct$1(v) {
  return re("topic", v);
}
function at$1(v) {
  return re("id", v);
}
function ut$2(v) {
  const [e, fe] = v.split(":"), be = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof fe == "string")
    be.topic = fe;
  else if (e === "id" && Number.isInteger(Number(fe)))
    be.id = Number(fe);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${fe}`);
  return be;
}
function lt$2(v, e) {
  return cjs$4.fromMiliseconds((e || Date.now()) + cjs$4.toMiliseconds(v));
}
function dt$2(v) {
  return Date.now() >= cjs$4.toMiliseconds(v);
}
function ft$2(v, e) {
  return `${v}${e ? `:${e}` : ""}`;
}
const Fe$1 = "irn";
function mt$1(v) {
  return (v == null ? void 0 : v.relay) || { protocol: Fe$1 };
}
function yt$1(v) {
  const e = RELAY_JSONRPC[v];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${v}`);
  return e;
}
var ht$1 = Object.defineProperty, He$1 = Object.getOwnPropertySymbols, vt$1 = Object.prototype.hasOwnProperty, gt$1 = Object.prototype.propertyIsEnumerable, qe$1 = (v, e, fe) => e in v ? ht$1(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, Et$1 = (v, e) => {
  for (var fe in e || (e = {}))
    vt$1.call(e, fe) && qe$1(v, fe, e[fe]);
  if (He$1)
    for (var fe of He$1(e))
      gt$1.call(e, fe) && qe$1(v, fe, e[fe]);
  return v;
};
function Be$1(v, e = "-") {
  const fe = {}, be = "relay" + e;
  return Object.keys(v).forEach((ye) => {
    if (ye.startsWith(be)) {
      const ve = ye.replace(be, ""), Ee = v[ye];
      fe[ve] = Ee;
    }
  }), fe;
}
function bt$1(v) {
  const e = v.indexOf(":"), fe = v.indexOf("?") !== -1 ? v.indexOf("?") : void 0, be = v.substring(0, e), ye = v.substring(e + 1, fe).split("@"), ve = typeof fe < "u" ? v.substring(fe) : "", Ee = queryString.parse(ve);
  return { protocol: be, topic: Ge$1(ye[0]), version: parseInt(ye[1], 10), symKey: Ee.symKey, relay: Be$1(Ee) };
}
function Ge$1(v) {
  return v.startsWith("//") ? v.substring(2) : v;
}
function We$1(v, e = "-") {
  const fe = "relay", be = {};
  return Object.keys(v).forEach((ye) => {
    const ve = fe + e + ye;
    v[ye] && (be[ve] = v[ye]);
  }), be;
}
function Nt$1(v) {
  return `${v.protocol}:${v.topic}@${v.version}?` + queryString.stringify(Et$1({ symKey: v.symKey }, We$1(v.relay)));
}
const _t$3 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Ct$2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N$2(v, e) {
  const { message: fe, code: be } = Ct$2[v];
  return { message: e ? `${fe} ${e}` : fe, code: be };
}
function U$4(v, e) {
  const { message: fe, code: be } = _t$3[v];
  return { message: e ? `${fe} ${e}` : fe, code: be };
}
function j$2(v, e) {
  return Array.isArray(v) ? typeof e < "u" && v.length ? v.every(e) : !0 : !1;
}
function w$3(v) {
  return typeof v > "u";
}
function h$2(v, e) {
  return e && w$3(v) ? !0 : typeof v == "string" && !!v.trim().length;
}
function jt(v) {
  if (h$2(v, !1))
    try {
      return typeof new URL(v) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function Dt$1(v) {
  var e;
  return (e = v == null ? void 0 : v.proposer) == null ? void 0 : e.publicKey;
}
function kt$1(v) {
  return v == null ? void 0 : v.topic;
}
function xt$2(v) {
  return typeof v < "u" && typeof v !== null;
}
function Zt() {
  const v = R$2();
  return new Promise((e) => {
    switch (v) {
      case m$2.browser:
        e(dn());
        break;
      case m$2.reactNative:
        e(fn());
        break;
      case m$2.node:
        e(pn());
        break;
      default:
        e(!0);
    }
  });
}
function dn() {
  return q$2() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (H$2() && typeof global < "u" && global != null && global.NetInfo) {
    const v = await (global == null ? void 0 : global.NetInfo.fetch());
    return v == null ? void 0 : v.isConnected;
  }
  return !0;
}
function pn() {
  return !0;
}
function Xt(v) {
  switch (R$2()) {
    case m$2.browser:
      mn(v);
      break;
    case m$2.reactNative:
      yn(v);
      break;
  }
}
function mn(v) {
  q$2() && (window.addEventListener("online", () => v(!0)), window.addEventListener("offline", () => v(!1)));
}
function yn(v) {
  H$2() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => v(e == null ? void 0 : e.isConnected)));
}
const PARSE_ERROR = "PARSE_ERROR", INVALID_REQUEST = "INVALID_REQUEST", METHOD_NOT_FOUND = "METHOD_NOT_FOUND", INVALID_PARAMS = "INVALID_PARAMS", INTERNAL_ERROR = "INTERNAL_ERROR", SERVER_ERROR = "SERVER_ERROR", RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603], STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
}, DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(v) {
  return RESERVED_ERROR_CODES.includes(v);
}
function getError(v) {
  return Object.keys(STANDARD_ERROR_MAP).includes(v) ? STANDARD_ERROR_MAP[v] : STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function getErrorByCode(v) {
  const e = Object.values(STANDARD_ERROR_MAP).find((fe) => fe.code === v);
  return e || STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function parseConnectionError(v, e, fe) {
  return v.message.includes("getaddrinfo ENOTFOUND") || v.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${fe} RPC url at ${e}`) : v;
}
var cjs = {}, crypto$2 = {}, hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto)
    return crypto$2;
  hasRequiredCrypto = 1, Object.defineProperty(crypto$2, "__esModule", { value: !0 }), crypto$2.isBrowserCryptoAvailable = crypto$2.getSubtleCrypto = crypto$2.getBrowerCrypto = void 0;
  function v() {
    return (commonjsGlobal == null ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal == null ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$2.getBrowerCrypto = v;
  function e() {
    const be = v();
    return be.subtle || be.webkitSubtle;
  }
  crypto$2.getSubtleCrypto = e;
  function fe() {
    return !!v() && !!e();
  }
  return crypto$2.isBrowserCryptoAvailable = fe, crypto$2;
}
var env = {}, hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv)
    return env;
  hasRequiredEnv = 1, Object.defineProperty(env, "__esModule", { value: !0 }), env.isBrowser = env.isNode = env.isReactNative = void 0;
  function v() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  env.isReactNative = v;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  env.isNode = e;
  function fe() {
    return !v() && !e();
  }
  return env.isBrowser = fe, env;
}
(function(v) {
  Object.defineProperty(v, "__esModule", { value: !0 });
  const e = tslibExports;
  e.__exportStar(requireCrypto(), v), e.__exportStar(requireEnv(), v);
})(cjs);
function payloadId(v = 3) {
  const e = Date.now() * Math.pow(10, v), fe = Math.floor(Math.random() * Math.pow(10, v));
  return e + fe;
}
function getBigIntRpcId(v = 6) {
  return BigInt(payloadId(v));
}
function formatJsonRpcRequest(v, e, fe) {
  return {
    id: fe || payloadId(),
    jsonrpc: "2.0",
    method: v,
    params: e
  };
}
function formatJsonRpcResult(v, e) {
  return {
    id: v,
    jsonrpc: "2.0",
    result: e
  };
}
function formatJsonRpcError(v, e, fe) {
  return {
    id: v,
    jsonrpc: "2.0",
    error: formatErrorMessage(e, fe)
  };
}
function formatErrorMessage(v, e) {
  return typeof v > "u" ? getError(INTERNAL_ERROR) : (typeof v == "string" && (v = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: v })), typeof e < "u" && (v.data = e), isReservedErrorCode(v.code) && (v = getErrorByCode(v.code)), v);
}
class IEvents {
}
class IBaseJsonRpcProvider extends IEvents {
  constructor() {
    super();
  }
}
class IJsonRpcProvider extends IBaseJsonRpcProvider {
  constructor(e) {
    super();
  }
}
const WS_REGEX = "^wss?:";
function getUrlProtocol(v) {
  const e = v.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function matchRegexProtocol(v, e) {
  const fe = getUrlProtocol(v);
  return typeof fe > "u" ? !1 : new RegExp(e).test(fe);
}
function isWsUrl(v) {
  return matchRegexProtocol(v, WS_REGEX);
}
function isLocalhostUrl(v) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(v);
}
function isJsonRpcPayload(v) {
  return typeof v == "object" && "id" in v && "jsonrpc" in v && v.jsonrpc === "2.0";
}
function isJsonRpcRequest(v) {
  return isJsonRpcPayload(v) && "method" in v;
}
function isJsonRpcResponse(v) {
  return isJsonRpcPayload(v) && (isJsonRpcResult(v) || isJsonRpcError(v));
}
function isJsonRpcResult(v) {
  return "result" in v;
}
function isJsonRpcError(v) {
  return "error" in v;
}
class JsonRpcProvider extends IJsonRpcProvider {
  constructor(e) {
    super(e), this.events = new eventsExports.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, fe) {
    this.events.on(e, fe);
  }
  once(e, fe) {
    this.events.once(e, fe);
  }
  off(e, fe) {
    this.events.off(e, fe);
  }
  removeListener(e, fe) {
    this.events.removeListener(e, fe);
  }
  async request(e, fe) {
    return this.requestStrict(formatJsonRpcRequest(e.method, e.params || [], e.id || getBigIntRpcId().toString()), fe);
  }
  async requestStrict(e, fe) {
    return new Promise(async (be, ye) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (ve) {
          ye(ve);
        }
      this.events.on(`${e.id}`, (ve) => {
        isJsonRpcError(ve) ? ye(ve.error) : be(ve.result);
      });
      try {
        await this.connection.send(e, fe);
      } catch (ve) {
        ye(ve);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), isJsonRpcResponse(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const resolveWebSocketImplementation = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), hasBuiltInWebSocket = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", truncateQuery = (v) => v.split("?")[0], EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10, WS = resolveWebSocketImplementation();
class WsConnection {
  constructor(e) {
    if (this.url = e, this.events = new eventsExports.EventEmitter(), this.registering = !1, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, fe) {
    this.events.on(e, fe);
  }
  once(e, fe) {
    this.events.once(e, fe);
  }
  off(e, fe) {
    this.events.off(e, fe);
  }
  removeListener(e, fe) {
    this.events.removeListener(e, fe);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, fe) => {
      if (typeof this.socket > "u") {
        fe(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (be) => {
        this.onClose(be), e();
      }, this.socket.close();
    });
  }
  async send(e, fe) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (be) {
      this.onError(e.id, be);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const fe = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= fe || this.events.listenerCount("open") >= fe) && this.events.setMaxListeners(fe + 1), new Promise((be, ye) => {
        this.events.once("register_error", (ve) => {
          this.resetMaxListeners(), ye(ve);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return ye(new Error("WebSocket connection is missing or invalid"));
          be(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((fe, be) => {
      const ye = cjs.isReactNative() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, ve = new WS(e, [], ye);
      hasBuiltInWebSocket() ? ve.onerror = (Ee) => {
        const Se = Ee;
        be(this.emitError(Se.error));
      } : ve.on("error", (Ee) => {
        be(this.emitError(Ee));
      }), ve.onopen = () => {
        this.onOpen(ve), fe(ve);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (fe) => this.onPayload(fe), e.onclose = (fe) => this.onClose(fe), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const fe = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", fe);
  }
  onError(e, fe) {
    const be = this.parseError(fe), ye = be.message || be.toString(), ve = formatJsonRpcError(e, ye);
    this.events.emit("payload", ve);
  }
  parseError(e, fe = this.url) {
    return parseConnectionError(e, truncateQuery(fe), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT && this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
  }
  emitError(e) {
    const fe = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${truncateQuery(this.url)}`));
    return this.events.emit("register_error", fe), fe;
  }
}
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(v, e) {
  var fe = 200, be = "__lodash_hash_undefined__", ye = 1, ve = 2, Ee = 9007199254740991, Se = "[object Arguments]", Oe = "[object Array]", xe = "[object AsyncFunction]", me = "[object Boolean]", we = "[object Date]", ur = "[object Error]", lr = "[object Function]", Ar = "[object GeneratorFunction]", Br = "[object Map]", Xr = "[object Number]", eo = "[object Null]", jr = "[object Object]", kr = "[object Promise]", $r = "[object Proxy]", Vr = "[object RegExp]", Mr = "[object Set]", gr = "[object String]", Fr = "[object Symbol]", Zr = "[object Undefined]", Wr = "[object WeakMap]", qr = "[object ArrayBuffer]", Qr = "[object DataView]", lo = "[object Float32Array]", Nr = "[object Float64Array]", Lr = "[object Int8Array]", so = "[object Int16Array]", fo = "[object Int32Array]", co = "[object Uint8Array]", no = "[object Uint8ClampedArray]", uo = "[object Uint16Array]", bo = "[object Uint32Array]", So = /[\\^$.*+?()[\]{}|]/g, io = /^\[object .+?Constructor\]$/, To = /^(?:0|[1-9]\d*)$/, Oo = {};
  Oo[lo] = Oo[Nr] = Oo[Lr] = Oo[so] = Oo[fo] = Oo[co] = Oo[no] = Oo[uo] = Oo[bo] = !0, Oo[Se] = Oo[Oe] = Oo[qr] = Oo[me] = Oo[Qr] = Oo[we] = Oo[ur] = Oo[lr] = Oo[Br] = Oo[Xr] = Oo[jr] = Oo[Vr] = Oo[Mr] = Oo[gr] = Oo[Wr] = !1;
  var Mo = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, ao = typeof self == "object" && self && self.Object === Object && self, oo = Mo || ao || Function("return this")(), zr = e && !e.nodeType && e, dr = zr && !0 && v && !v.nodeType && v, Hr = dr && dr.exports === zr, go = Hr && Mo.process, ho = function() {
    try {
      return go && go.binding && go.binding("util");
    } catch {
    }
  }(), Eo = ho && ho.isTypedArray;
  function Fo(Gr, ro) {
    for (var _o = -1, Ro = Gr == null ? 0 : Gr.length, _n = 0, Uo = []; ++_o < Ro; ) {
      var wn = Gr[_o];
      ro(wn, _o, Gr) && (Uo[_n++] = wn);
    }
    return Uo;
  }
  function Po(Gr, ro) {
    for (var _o = -1, Ro = ro.length, _n = Gr.length; ++_o < Ro; )
      Gr[_n + _o] = ro[_o];
    return Gr;
  }
  function jo(Gr, ro) {
    for (var _o = -1, Ro = Gr == null ? 0 : Gr.length; ++_o < Ro; )
      if (ro(Gr[_o], _o, Gr))
        return !0;
    return !1;
  }
  function Qo(Gr, ro) {
    for (var _o = -1, Ro = Array(Gr); ++_o < Gr; )
      Ro[_o] = ro(_o);
    return Ro;
  }
  function bn(Gr) {
    return function(ro) {
      return Gr(ro);
    };
  }
  function Lo(Gr, ro) {
    return Gr.has(ro);
  }
  function Vo(Gr, ro) {
    return Gr == null ? void 0 : Gr[ro];
  }
  function zo(Gr) {
    var ro = -1, _o = Array(Gr.size);
    return Gr.forEach(function(Ro, _n) {
      _o[++ro] = [_n, Ro];
    }), _o;
  }
  function ko(Gr, ro) {
    return function(_o) {
      return Gr(ro(_o));
    };
  }
  function Wo(Gr) {
    var ro = -1, _o = Array(Gr.size);
    return Gr.forEach(function(Ro) {
      _o[++ro] = Ro;
    }), _o;
  }
  var Co = Array.prototype, $o = Function.prototype, xo = Object.prototype, Ho = oo["__core-js_shared__"], qo = $o.toString, Bo = xo.hasOwnProperty, Yo = function() {
    var Gr = /[^.]+$/.exec(Ho && Ho.keys && Ho.keys.IE_PROTO || "");
    return Gr ? "Symbol(src)_1." + Gr : "";
  }(), Ko = xo.toString, Jo = RegExp(
    "^" + qo.call(Bo).replace(So, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Zo = Hr ? oo.Buffer : void 0, Xo = oo.Symbol, Pn = oo.Uint8Array, Un = xo.propertyIsEnumerable, Yn = Co.splice, An = Xo ? Xo.toStringTag : void 0, Zn = Object.getOwnPropertySymbols, ei = Zo ? Zo.isBuffer : void 0, Sn = ko(Object.keys, Object), gn = ci(oo, "DataView"), hn = ci(oo, "Map"), Yr = ci(oo, "Promise"), Ur = ci(oo, "Set"), Jr = ci(oo, "WeakMap"), to = ci(Object, "create"), po = ui(gn), yo = ui(hn), mo = ui(Yr), vo = ui(Ur), Ao = ui(Jr), wo = Xo ? Xo.prototype : void 0, Do = wo ? wo.valueOf : void 0;
  function Io(Gr) {
    var ro = -1, _o = Gr == null ? 0 : Gr.length;
    for (this.clear(); ++ro < _o; ) {
      var Ro = Gr[ro];
      this.set(Ro[0], Ro[1]);
    }
  }
  function No() {
    this.__data__ = to ? to(null) : {}, this.size = 0;
  }
  function Go(Gr) {
    var ro = this.has(Gr) && delete this.__data__[Gr];
    return this.size -= ro ? 1 : 0, ro;
  }
  function En(Gr) {
    var ro = this.__data__;
    if (to) {
      var _o = ro[Gr];
      return _o === be ? void 0 : _o;
    }
    return Bo.call(ro, Gr) ? ro[Gr] : void 0;
  }
  function Nn(Gr) {
    var ro = this.__data__;
    return to ? ro[Gr] !== void 0 : Bo.call(ro, Gr);
  }
  function ti(Gr, ro) {
    var _o = this.__data__;
    return this.size += this.has(Gr) ? 0 : 1, _o[Gr] = to && ro === void 0 ? be : ro, this;
  }
  Io.prototype.clear = No, Io.prototype.delete = Go, Io.prototype.get = En, Io.prototype.has = Nn, Io.prototype.set = ti;
  function Rn(Gr) {
    var ro = -1, _o = Gr == null ? 0 : Gr.length;
    for (this.clear(); ++ro < _o; ) {
      var Ro = Gr[ro];
      this.set(Ro[0], Ro[1]);
    }
  }
  function ri() {
    this.__data__ = [], this.size = 0;
  }
  function pi(Gr) {
    var ro = this.__data__, _o = bi(ro, Gr);
    if (_o < 0)
      return !1;
    var Ro = ro.length - 1;
    return _o == Ro ? ro.pop() : Yn.call(ro, _o, 1), --this.size, !0;
  }
  function fi(Gr) {
    var ro = this.__data__, _o = bi(ro, Gr);
    return _o < 0 ? void 0 : ro[_o][1];
  }
  function si(Gr) {
    return bi(this.__data__, Gr) > -1;
  }
  function Si(Gr, ro) {
    var _o = this.__data__, Ro = bi(_o, Gr);
    return Ro < 0 ? (++this.size, _o.push([Gr, ro])) : _o[Ro][1] = ro, this;
  }
  Rn.prototype.clear = ri, Rn.prototype.delete = pi, Rn.prototype.get = fi, Rn.prototype.has = si, Rn.prototype.set = Si;
  function ai(Gr) {
    var ro = -1, _o = Gr == null ? 0 : Gr.length;
    for (this.clear(); ++ro < _o; ) {
      var Ro = Gr[ro];
      this.set(Ro[0], Ro[1]);
    }
  }
  function Ci() {
    this.size = 0, this.__data__ = {
      hash: new Io(),
      map: new (hn || Rn)(),
      string: new Io()
    };
  }
  function Ui(Gr) {
    var ro = _i(this, Gr).delete(Gr);
    return this.size -= ro ? 1 : 0, ro;
  }
  function Li(Gr) {
    return _i(this, Gr).get(Gr);
  }
  function zi(Gr) {
    return _i(this, Gr).has(Gr);
  }
  function ea(Gr, ro) {
    var _o = _i(this, Gr), Ro = _o.size;
    return _o.set(Gr, ro), this.size += _o.size == Ro ? 0 : 1, this;
  }
  ai.prototype.clear = Ci, ai.prototype.delete = Ui, ai.prototype.get = Li, ai.prototype.has = zi, ai.prototype.set = ea;
  function yi(Gr) {
    var ro = -1, _o = Gr == null ? 0 : Gr.length;
    for (this.__data__ = new ai(); ++ro < _o; )
      this.add(Gr[ro]);
  }
  function ta(Gr) {
    return this.__data__.set(Gr, be), this;
  }
  function ra(Gr) {
    return this.__data__.has(Gr);
  }
  yi.prototype.add = yi.prototype.push = ta, yi.prototype.has = ra;
  function oi(Gr) {
    var ro = this.__data__ = new Rn(Gr);
    this.size = ro.size;
  }
  function oa() {
    this.__data__ = new Rn(), this.size = 0;
  }
  function na(Gr) {
    var ro = this.__data__, _o = ro.delete(Gr);
    return this.size = ro.size, _o;
  }
  function ia(Gr) {
    return this.__data__.get(Gr);
  }
  function sa(Gr) {
    return this.__data__.has(Gr);
  }
  function aa(Gr, ro) {
    var _o = this.__data__;
    if (_o instanceof Rn) {
      var Ro = _o.__data__;
      if (!hn || Ro.length < fe - 1)
        return Ro.push([Gr, ro]), this.size = ++_o.size, this;
      _o = this.__data__ = new ai(Ro);
    }
    return _o.set(Gr, ro), this.size = _o.size, this;
  }
  oi.prototype.clear = oa, oi.prototype.delete = na, oi.prototype.get = ia, oi.prototype.has = sa, oi.prototype.set = aa;
  function ua(Gr, ro) {
    var _o = mi(Gr), Ro = !_o && Sa(Gr), _n = !_o && !Ro && wi(Gr), Uo = !_o && !Ro && !_n && xi(Gr), wn = _o || Ro || _n || Uo, On = wn ? Qo(Gr.length, String) : [], Tn = On.length;
    for (var vn in Gr)
      (ro || Bo.call(Gr, vn)) && !(wn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (vn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      _n && (vn == "offset" || vn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Uo && (vn == "buffer" || vn == "byteLength" || vn == "byteOffset") || // Skip index properties.
      _a(vn, Tn))) && On.push(vn);
    return On;
  }
  function bi(Gr, ro) {
    for (var _o = Gr.length; _o--; )
      if (Di(Gr[_o][0], ro))
        return _o;
    return -1;
  }
  function la(Gr, ro, _o) {
    var Ro = ro(Gr);
    return mi(Gr) ? Ro : Po(Ro, _o(Gr));
  }
  function di(Gr) {
    return Gr == null ? Gr === void 0 ? Zr : eo : An && An in Object(Gr) ? ya(Gr) : wa(Gr);
  }
  function Oi(Gr) {
    return hi(Gr) && di(Gr) == Se;
  }
  function Ti(Gr, ro, _o, Ro, _n) {
    return Gr === ro ? !0 : Gr == null || ro == null || !hi(Gr) && !hi(ro) ? Gr !== Gr && ro !== ro : pa(Gr, ro, _o, Ro, Ti, _n);
  }
  function pa(Gr, ro, _o, Ro, _n, Uo) {
    var wn = mi(Gr), On = mi(ro), Tn = wn ? Oe : ni(Gr), vn = On ? Oe : ni(ro);
    Tn = Tn == Se ? jr : Tn, vn = vn == Se ? jr : vn;
    var Cn = Tn == jr, Xn = vn == jr, In = Tn == vn;
    if (In && wi(Gr)) {
      if (!wi(ro))
        return !1;
      wn = !0, Cn = !1;
    }
    if (In && !Cn)
      return Uo || (Uo = new oi()), wn || xi(Gr) ? Ai(Gr, ro, _o, Ro, _n, Uo) : da(Gr, ro, Tn, _o, Ro, _n, Uo);
    if (!(_o & ye)) {
      var Wn = Cn && Bo.call(Gr, "__wrapped__"), Gn = Xn && Bo.call(ro, "__wrapped__");
      if (Wn || Gn) {
        var ii = Wn ? Gr.value() : Gr, Qn = Gn ? ro.value() : ro;
        return Uo || (Uo = new oi()), _n(ii, Qn, _o, Ro, Uo);
      }
    }
    return In ? (Uo || (Uo = new oi()), ha(Gr, ro, _o, Ro, _n, Uo)) : !1;
  }
  function ca(Gr) {
    if (!Ni(Gr) || va(Gr))
      return !1;
    var ro = Ii(Gr) ? Jo : io;
    return ro.test(ui(Gr));
  }
  function ga(Gr) {
    return hi(Gr) && Fi(Gr.length) && !!Oo[di(Gr)];
  }
  function fa(Gr) {
    if (!Ea(Gr))
      return Sn(Gr);
    var ro = [];
    for (var _o in Object(Gr))
      Bo.call(Gr, _o) && _o != "constructor" && ro.push(_o);
    return ro;
  }
  function Ai(Gr, ro, _o, Ro, _n, Uo) {
    var wn = _o & ye, On = Gr.length, Tn = ro.length;
    if (On != Tn && !(wn && Tn > On))
      return !1;
    var vn = Uo.get(Gr);
    if (vn && Uo.get(ro))
      return vn == ro;
    var Cn = -1, Xn = !0, In = _o & ve ? new yi() : void 0;
    for (Uo.set(Gr, ro), Uo.set(ro, Gr); ++Cn < On; ) {
      var Wn = Gr[Cn], Gn = ro[Cn];
      if (Ro)
        var ii = wn ? Ro(Gn, Wn, Cn, ro, Gr, Uo) : Ro(Wn, Gn, Cn, Gr, ro, Uo);
      if (ii !== void 0) {
        if (ii)
          continue;
        Xn = !1;
        break;
      }
      if (In) {
        if (!jo(ro, function(Qn, li) {
          if (!Lo(In, li) && (Wn === Qn || _n(Wn, Qn, _o, Ro, Uo)))
            return In.push(li);
        })) {
          Xn = !1;
          break;
        }
      } else if (!(Wn === Gn || _n(Wn, Gn, _o, Ro, Uo))) {
        Xn = !1;
        break;
      }
    }
    return Uo.delete(Gr), Uo.delete(ro), Xn;
  }
  function da(Gr, ro, _o, Ro, _n, Uo, wn) {
    switch (_o) {
      case Qr:
        if (Gr.byteLength != ro.byteLength || Gr.byteOffset != ro.byteOffset)
          return !1;
        Gr = Gr.buffer, ro = ro.buffer;
      case qr:
        return !(Gr.byteLength != ro.byteLength || !Uo(new Pn(Gr), new Pn(ro)));
      case me:
      case we:
      case Xr:
        return Di(+Gr, +ro);
      case ur:
        return Gr.name == ro.name && Gr.message == ro.message;
      case Vr:
      case gr:
        return Gr == ro + "";
      case Br:
        var On = zo;
      case Mr:
        var Tn = Ro & ye;
        if (On || (On = Wo), Gr.size != ro.size && !Tn)
          return !1;
        var vn = wn.get(Gr);
        if (vn)
          return vn == ro;
        Ro |= ve, wn.set(Gr, ro);
        var Cn = Ai(On(Gr), On(ro), Ro, _n, Uo, wn);
        return wn.delete(Gr), Cn;
      case Fr:
        if (Do)
          return Do.call(Gr) == Do.call(ro);
    }
    return !1;
  }
  function ha(Gr, ro, _o, Ro, _n, Uo) {
    var wn = _o & ye, On = Ri(Gr), Tn = On.length, vn = Ri(ro), Cn = vn.length;
    if (Tn != Cn && !wn)
      return !1;
    for (var Xn = Tn; Xn--; ) {
      var In = On[Xn];
      if (!(wn ? In in ro : Bo.call(ro, In)))
        return !1;
    }
    var Wn = Uo.get(Gr);
    if (Wn && Uo.get(ro))
      return Wn == ro;
    var Gn = !0;
    Uo.set(Gr, ro), Uo.set(ro, Gr);
    for (var ii = wn; ++Xn < Tn; ) {
      In = On[Xn];
      var Qn = Gr[In], li = ro[In];
      if (Ro)
        var $i = wn ? Ro(li, Qn, In, ro, Gr, Uo) : Ro(Qn, li, In, Gr, ro, Uo);
      if (!($i === void 0 ? Qn === li || _n(Qn, li, _o, Ro, Uo) : $i)) {
        Gn = !1;
        break;
      }
      ii || (ii = In == "constructor");
    }
    if (Gn && !ii) {
      var vi = Gr.constructor, Ei = ro.constructor;
      vi != Ei && "constructor" in Gr && "constructor" in ro && !(typeof vi == "function" && vi instanceof vi && typeof Ei == "function" && Ei instanceof Ei) && (Gn = !1);
    }
    return Uo.delete(Gr), Uo.delete(ro), Gn;
  }
  function Ri(Gr) {
    return la(Gr, Aa, ba);
  }
  function _i(Gr, ro) {
    var _o = Gr.__data__;
    return ma(ro) ? _o[typeof ro == "string" ? "string" : "hash"] : _o.map;
  }
  function ci(Gr, ro) {
    var _o = Vo(Gr, ro);
    return ca(_o) ? _o : void 0;
  }
  function ya(Gr) {
    var ro = Bo.call(Gr, An), _o = Gr[An];
    try {
      Gr[An] = void 0;
      var Ro = !0;
    } catch {
    }
    var _n = Ko.call(Gr);
    return Ro && (ro ? Gr[An] = _o : delete Gr[An]), _n;
  }
  var ba = Zn ? function(Gr) {
    return Gr == null ? [] : (Gr = Object(Gr), Fo(Zn(Gr), function(ro) {
      return Un.call(Gr, ro);
    }));
  } : Ra, ni = di;
  (gn && ni(new gn(new ArrayBuffer(1))) != Qr || hn && ni(new hn()) != Br || Yr && ni(Yr.resolve()) != kr || Ur && ni(new Ur()) != Mr || Jr && ni(new Jr()) != Wr) && (ni = function(Gr) {
    var ro = di(Gr), _o = ro == jr ? Gr.constructor : void 0, Ro = _o ? ui(_o) : "";
    if (Ro)
      switch (Ro) {
        case po:
          return Qr;
        case yo:
          return Br;
        case mo:
          return kr;
        case vo:
          return Mr;
        case Ao:
          return Wr;
      }
    return ro;
  });
  function _a(Gr, ro) {
    return ro = ro ?? Ee, !!ro && (typeof Gr == "number" || To.test(Gr)) && Gr > -1 && Gr % 1 == 0 && Gr < ro;
  }
  function ma(Gr) {
    var ro = typeof Gr;
    return ro == "string" || ro == "number" || ro == "symbol" || ro == "boolean" ? Gr !== "__proto__" : Gr === null;
  }
  function va(Gr) {
    return !!Yo && Yo in Gr;
  }
  function Ea(Gr) {
    var ro = Gr && Gr.constructor, _o = typeof ro == "function" && ro.prototype || xo;
    return Gr === _o;
  }
  function wa(Gr) {
    return Ko.call(Gr);
  }
  function ui(Gr) {
    if (Gr != null) {
      try {
        return qo.call(Gr);
      } catch {
      }
      try {
        return Gr + "";
      } catch {
      }
    }
    return "";
  }
  function Di(Gr, ro) {
    return Gr === ro || Gr !== Gr && ro !== ro;
  }
  var Sa = Oi(function() {
    return arguments;
  }()) ? Oi : function(Gr) {
    return hi(Gr) && Bo.call(Gr, "callee") && !Un.call(Gr, "callee");
  }, mi = Array.isArray;
  function Oa(Gr) {
    return Gr != null && Fi(Gr.length) && !Ii(Gr);
  }
  var wi = ei || Da;
  function Ta(Gr, ro) {
    return Ti(Gr, ro);
  }
  function Ii(Gr) {
    if (!Ni(Gr))
      return !1;
    var ro = di(Gr);
    return ro == lr || ro == Ar || ro == xe || ro == $r;
  }
  function Fi(Gr) {
    return typeof Gr == "number" && Gr > -1 && Gr % 1 == 0 && Gr <= Ee;
  }
  function Ni(Gr) {
    var ro = typeof Gr;
    return Gr != null && (ro == "object" || ro == "function");
  }
  function hi(Gr) {
    return Gr != null && typeof Gr == "object";
  }
  var xi = Eo ? bn(Eo) : ga;
  function Aa(Gr) {
    return Oa(Gr) ? ua(Gr) : fa(Gr);
  }
  function Ra() {
    return [];
  }
  function Da() {
    return !1;
  }
  v.exports = Ta;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const Mi = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports);
function ki(v, e) {
  if (v.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var fe = new Uint8Array(256), be = 0; be < fe.length; be++)
    fe[be] = 255;
  for (var ye = 0; ye < v.length; ye++) {
    var ve = v.charAt(ye), Ee = ve.charCodeAt(0);
    if (fe[Ee] !== 255)
      throw new TypeError(ve + " is ambiguous");
    fe[Ee] = ye;
  }
  var Se = v.length, Oe = v.charAt(0), xe = Math.log(Se) / Math.log(256), me = Math.log(256) / Math.log(Se);
  function we(Ar) {
    if (Ar instanceof Uint8Array || (ArrayBuffer.isView(Ar) ? Ar = new Uint8Array(Ar.buffer, Ar.byteOffset, Ar.byteLength) : Array.isArray(Ar) && (Ar = Uint8Array.from(Ar))), !(Ar instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ar.length === 0)
      return "";
    for (var Br = 0, Xr = 0, eo = 0, jr = Ar.length; eo !== jr && Ar[eo] === 0; )
      eo++, Br++;
    for (var kr = (jr - eo) * me + 1 >>> 0, $r = new Uint8Array(kr); eo !== jr; ) {
      for (var Vr = Ar[eo], Mr = 0, gr = kr - 1; (Vr !== 0 || Mr < Xr) && gr !== -1; gr--, Mr++)
        Vr += 256 * $r[gr] >>> 0, $r[gr] = Vr % Se >>> 0, Vr = Vr / Se >>> 0;
      if (Vr !== 0)
        throw new Error("Non-zero carry");
      Xr = Mr, eo++;
    }
    for (var Fr = kr - Xr; Fr !== kr && $r[Fr] === 0; )
      Fr++;
    for (var Zr = Oe.repeat(Br); Fr < kr; ++Fr)
      Zr += v.charAt($r[Fr]);
    return Zr;
  }
  function ur(Ar) {
    if (typeof Ar != "string")
      throw new TypeError("Expected String");
    if (Ar.length === 0)
      return new Uint8Array();
    var Br = 0;
    if (Ar[Br] !== " ") {
      for (var Xr = 0, eo = 0; Ar[Br] === Oe; )
        Xr++, Br++;
      for (var jr = (Ar.length - Br) * xe + 1 >>> 0, kr = new Uint8Array(jr); Ar[Br]; ) {
        var $r = fe[Ar.charCodeAt(Br)];
        if ($r === 255)
          return;
        for (var Vr = 0, Mr = jr - 1; ($r !== 0 || Vr < eo) && Mr !== -1; Mr--, Vr++)
          $r += Se * kr[Mr] >>> 0, kr[Mr] = $r % 256 >>> 0, $r = $r / 256 >>> 0;
        if ($r !== 0)
          throw new Error("Non-zero carry");
        eo = Vr, Br++;
      }
      if (Ar[Br] !== " ") {
        for (var gr = jr - eo; gr !== jr && kr[gr] === 0; )
          gr++;
        for (var Fr = new Uint8Array(Xr + (jr - gr)), Zr = Xr; gr !== jr; )
          Fr[Zr++] = kr[gr++];
        return Fr;
      }
    }
  }
  function lr(Ar) {
    var Br = ur(Ar);
    if (Br)
      return Br;
    throw new Error(`Non-${e} character`);
  }
  return { encode: we, decodeUnsafe: ur, decode: lr };
}
var Ki = ki, Bi = Ki;
const Ae = (v) => {
  if (v instanceof Uint8Array && v.constructor.name === "Uint8Array")
    return v;
  if (v instanceof ArrayBuffer)
    return new Uint8Array(v);
  if (ArrayBuffer.isView(v))
    return new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Vi = (v) => new TextEncoder().encode(v), qi = (v) => new TextDecoder().decode(v);
class ji {
  constructor(e, fe, be) {
    this.name = e, this.prefix = fe, this.baseEncode = be;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Yi {
  constructor(e, fe, be) {
    if (this.name = e, this.prefix = fe, fe.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = fe.codePointAt(0), this.baseDecode = be;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ze(this, e);
  }
}
class Gi {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ze(this, e);
  }
  decode(e) {
    const fe = e[0], be = this.decoders[fe];
    if (be)
      return be.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const ze = (v, e) => new Gi({ ...v.decoders || { [v.prefix]: v }, ...e.decoders || { [e.prefix]: e } });
class Hi {
  constructor(e, fe, be, ye) {
    this.name = e, this.prefix = fe, this.baseEncode = be, this.baseDecode = ye, this.encoder = new ji(e, fe, be), this.decoder = new Yi(e, fe, ye);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const J$1 = ({ name: v, prefix: e, encode: fe, decode: be }) => new Hi(v, e, fe, be), K = ({ prefix: v, name: e, alphabet: fe }) => {
  const { encode: be, decode: ye } = Bi(fe, e);
  return J$1({ prefix: v, name: e, encode: be, decode: (ve) => Ae(ye(ve)) });
}, Ji = (v, e, fe, be) => {
  const ye = {};
  for (let me = 0; me < e.length; ++me)
    ye[e[me]] = me;
  let ve = v.length;
  for (; v[ve - 1] === "="; )
    --ve;
  const Ee = new Uint8Array(ve * fe / 8 | 0);
  let Se = 0, Oe = 0, xe = 0;
  for (let me = 0; me < ve; ++me) {
    const we = ye[v[me]];
    if (we === void 0)
      throw new SyntaxError(`Non-${be} character`);
    Oe = Oe << fe | we, Se += fe, Se >= 8 && (Se -= 8, Ee[xe++] = 255 & Oe >> Se);
  }
  if (Se >= fe || 255 & Oe << 8 - Se)
    throw new SyntaxError("Unexpected end of data");
  return Ee;
}, Wi = (v, e, fe) => {
  const be = e[e.length - 1] === "=", ye = (1 << fe) - 1;
  let ve = "", Ee = 0, Se = 0;
  for (let Oe = 0; Oe < v.length; ++Oe)
    for (Se = Se << 8 | v[Oe], Ee += 8; Ee > fe; )
      Ee -= fe, ve += e[ye & Se >> Ee];
  if (Ee && (ve += e[ye & Se << fe - Ee]), be)
    for (; ve.length * fe & 7; )
      ve += "=";
  return ve;
}, g$2 = ({ name: v, prefix: e, bitsPerChar: fe, alphabet: be }) => J$1({ prefix: e, name: v, encode(ye) {
  return Wi(ye, be, fe);
}, decode(ye) {
  return Ji(ye, be, fe, v);
} }), Xi = J$1({ prefix: "\0", name: "identity", encode: (v) => qi(v), decode: (v) => Vi(v) });
var Qi = Object.freeze({ __proto__: null, identity: Xi });
const Zi = g$2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var es = Object.freeze({ __proto__: null, base2: Zi });
const ts = g$2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var is = Object.freeze({ __proto__: null, base8: ts });
const ss = K({ prefix: "9", name: "base10", alphabet: "0123456789" });
var rs$1 = Object.freeze({ __proto__: null, base10: ss });
const ns$1 = g$2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), as$1 = g$2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var os$1 = Object.freeze({ __proto__: null, base16: ns$1, base16upper: as$1 });
const hs$1 = g$2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), cs$1 = g$2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), us = g$2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), ls$1 = g$2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), ds$1 = g$2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), gs = g$2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ps$1 = g$2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Ds = g$2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), ys = g$2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var bs = Object.freeze({ __proto__: null, base32: hs$1, base32upper: cs$1, base32pad: us, base32padupper: ls$1, base32hex: ds$1, base32hexupper: gs, base32hexpad: ps$1, base32hexpadupper: Ds, base32z: ys });
const ms = K({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), fs$1 = K({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Es = Object.freeze({ __proto__: null, base36: ms, base36upper: fs$1 });
const ws = K({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), vs = K({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Is = Object.freeze({ __proto__: null, base58btc: ws, base58flickr: vs });
const Cs = g$2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Rs = g$2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), _s = g$2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), Ts = g$2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ss = Object.freeze({ __proto__: null, base64: Cs, base64pad: Rs, base64url: _s, base64urlpad: Ts });
const Ne = Array.from(""), Ps = Ne.reduce((v, e, fe) => (v[fe] = e, v), []), Os = Ne.reduce((v, e, fe) => (v[e.codePointAt(0)] = fe, v), []);
function xs(v) {
  return v.reduce((e, fe) => (e += Ps[fe], e), "");
}
function As(v) {
  const e = [];
  for (const fe of v) {
    const be = Os[fe.codePointAt(0)];
    if (be === void 0)
      throw new Error(`Non-base256emoji character: ${fe}`);
    e.push(be);
  }
  return new Uint8Array(e);
}
const zs = J$1({ prefix: "", name: "base256emoji", encode: xs, decode: As });
var Ns = Object.freeze({ __proto__: null, base256emoji: zs }), Ls = Ue, Le = 128, Us = 127, Fs = ~Us, $s = Math.pow(2, 31);
function Ue(v, e, fe) {
  e = e || [], fe = fe || 0;
  for (var be = fe; v >= $s; )
    e[fe++] = v & 255 | Le, v /= 128;
  for (; v & Fs; )
    e[fe++] = v & 255 | Le, v >>>= 7;
  return e[fe] = v | 0, Ue.bytes = fe - be + 1, e;
}
var Ms = ae$2, ks = 128, Fe = 127;
function ae$2(v, be) {
  var fe = 0, be = be || 0, ye = 0, ve = be, Ee, Se = v.length;
  do {
    if (ve >= Se)
      throw ae$2.bytes = 0, new RangeError("Could not decode varint");
    Ee = v[ve++], fe += ye < 28 ? (Ee & Fe) << ye : (Ee & Fe) * Math.pow(2, ye), ye += 7;
  } while (Ee >= ks);
  return ae$2.bytes = ve - be, fe;
}
var Ks = Math.pow(2, 7), Bs = Math.pow(2, 14), Vs = Math.pow(2, 21), qs = Math.pow(2, 28), js = Math.pow(2, 35), Ys = Math.pow(2, 42), Gs = Math.pow(2, 49), Hs = Math.pow(2, 56), Js = Math.pow(2, 63), Ws = function(v) {
  return v < Ks ? 1 : v < Bs ? 2 : v < Vs ? 3 : v < qs ? 4 : v < js ? 5 : v < Ys ? 6 : v < Gs ? 7 : v < Hs ? 8 : v < Js ? 9 : 10;
}, Xs = { encode: Ls, decode: Ms, encodingLength: Ws }, $e = Xs;
const Me = (v, e, fe = 0) => ($e.encode(v, e, fe), e), ke = (v) => $e.encodingLength(v), oe$1 = (v, e) => {
  const fe = e.byteLength, be = ke(v), ye = be + ke(fe), ve = new Uint8Array(ye + fe);
  return Me(v, ve, 0), Me(fe, ve, be), ve.set(e, ye), new Qs(v, fe, e, ve);
};
class Qs {
  constructor(e, fe, be, ye) {
    this.code = e, this.size = fe, this.digest = be, this.bytes = ye;
  }
}
const Ke = ({ name: v, code: e, encode: fe }) => new Zs(v, e, fe);
class Zs {
  constructor(e, fe, be) {
    this.name = e, this.code = fe, this.encode = be;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const fe = this.encode(e);
      return fe instanceof Uint8Array ? oe$1(this.code, fe) : fe.then((be) => oe$1(this.code, be));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const Be = (v) => async (e) => new Uint8Array(await crypto.subtle.digest(v, e)), er$1 = Ke({ name: "sha2-256", code: 18, encode: Be("SHA-256") }), tr = Ke({ name: "sha2-512", code: 19, encode: Be("SHA-512") });
var ir = Object.freeze({ __proto__: null, sha256: er$1, sha512: tr });
const Ve = 0, sr = "identity", qe = Ae, rr = (v) => oe$1(Ve, qe(v)), nr = { code: Ve, name: sr, encode: qe, digest: rr };
var ar = Object.freeze({ __proto__: null, identity: nr });
new TextEncoder(), new TextDecoder();
const je = { ...Qi, ...es, ...is, ...rs$1, ...os$1, ...bs, ...Es, ...Is, ...Ss, ...Ns };
({ ...ir, ...ar });
function Ye(v) {
  return globalThis.Buffer != null ? new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : v;
}
function or(v = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ye(globalThis.Buffer.allocUnsafe(v)) : new Uint8Array(v);
}
function Ge(v, e, fe, be) {
  return { name: v, prefix: e, encoder: { name: v, prefix: e, encode: fe }, decoder: { decode: be } };
}
const He = Ge("utf8", "u", (v) => "u" + new TextDecoder("utf8").decode(v), (v) => new TextEncoder().encode(v.substring(1))), he$1 = Ge("ascii", "a", (v) => {
  let e = "a";
  for (let fe = 0; fe < v.length; fe++)
    e += String.fromCharCode(v[fe]);
  return e;
}, (v) => {
  v = v.substring(1);
  const e = or(v.length);
  for (let fe = 0; fe < v.length; fe++)
    e[fe] = v.charCodeAt(fe);
  return e;
}), hr = { utf8: He, "utf-8": He, hex: je.base16, latin1: he$1, ascii: he$1, binary: he$1, ...je };
function cr(v, e = "utf8") {
  const fe = hr[e];
  if (!fe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ye(globalThis.Buffer.from(v, "utf-8")) : fe.decoder.decode(`${fe.prefix}${v}`);
}
const ce$2 = "wc", Je$1 = 2, W$1 = "core", x$2 = `${ce$2}@2:${W$1}:`, We = { name: W$1, logger: "error" }, Xe = { database: ":memory:" }, Qe$1 = "crypto", ue = "client_ed25519_seed", Ze$1 = cjs$4.ONE_DAY, et = "keychain", tt = "0.3", it = "messages", st$1 = "0.3", rt = cjs$4.SIX_HOURS, nt = "publisher", at = "irn", ot = "error", le$1 = "wss://relay.walletconnect.com", de$1 = "wss://relay.walletconnect.org", ht = "relayer", D$1 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, ct = "_subscription", P$1 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, ut$1 = cjs$4.ONE_SECOND, lt$1 = "2.10.0", dt$1 = 1e4, gt = "0.3", pt$1 = "WALLETCONNECT_CLIENT_ID", C$1 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, Dt = "subscription", yt = "0.3", bt = cjs$4.FIVE_SECONDS * 1e3, mt = "pairing", ft$1 = "0.3", F$1 = { wc_pairingDelete: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 0 } } }, R$1 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Et = "history", wt = "0.3", vt = "expirer", w$2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, It = "0.3", X$1 = "verify-api", Q$1 = "https://verify.walletconnect.com", ge = "https://verify.walletconnect.org";
let Ct$1 = class {
  constructor(e, fe) {
    this.core = e, this.logger = fe, this.keychain = /* @__PURE__ */ new Map(), this.name = et, this.version = tt, this.initialized = !1, this.storagePrefix = x$2, this.init = async () => {
      if (!this.initialized) {
        const be = await this.getKeyChain();
        typeof be < "u" && (this.keychain = be), this.initialized = !0;
      }
    }, this.has = (be) => (this.isInitialized(), this.keychain.has(be)), this.set = async (be, ye) => {
      this.isInitialized(), this.keychain.set(be, ye), await this.persist();
    }, this.get = (be) => {
      this.isInitialized();
      const ye = this.keychain.get(be);
      if (typeof ye > "u") {
        const { message: ve } = N$2("NO_MATCHING_KEY", `${this.name}: ${be}`);
        throw new Error(ve);
      }
      return ye;
    }, this.del = async (be) => {
      this.isInitialized(), this.keychain.delete(be), await this.persist();
    }, this.core = e, this.logger = cjs$3.generateChildLogger(fe, this.name);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, et$1(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt$1(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class Rt {
  constructor(e, fe, be) {
    this.core = e, this.logger = fe, this.name = Qe$1, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (ye) => (this.isInitialized(), this.keychain.has(ye)), this.getClientId = async () => {
      this.isInitialized();
      const ye = await this.getClientSeed(), ve = generateKeyPair(ye);
      return encodeIss(ve.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const ye = jn();
      return this.setPrivateKey(ye.publicKey, ye.privateKey);
    }, this.signJWT = async (ye) => {
      this.isInitialized();
      const ve = await this.getClientSeed(), Ee = generateKeyPair(ve), Se = Dn();
      return await signJWT(Se, ye, Ze$1, Ee);
    }, this.generateSharedKey = (ye, ve, Ee) => {
      this.isInitialized();
      const Se = this.getPrivateKey(ye), Oe = kn(Se, ve);
      return this.setSymKey(Oe, Ee);
    }, this.setSymKey = async (ye, ve) => {
      this.isInitialized();
      const Ee = ve || Vn(ye);
      return await this.keychain.set(Ee, ye), Ee;
    }, this.deleteKeyPair = async (ye) => {
      this.isInitialized(), await this.keychain.del(ye);
    }, this.deleteSymKey = async (ye) => {
      this.isInitialized(), await this.keychain.del(ye);
    }, this.encode = async (ye, ve, Ee) => {
      this.isInitialized();
      const Se = Re(Ee), Oe = safeJsonStringify(ve);
      if (Fn(Se)) {
        const ur = Se.senderPublicKey, lr = Se.receiverPublicKey;
        ye = await this.generateSharedKey(ur, lr);
      }
      const xe = this.getSymKey(ye), { type: me, senderPublicKey: we } = Se;
      return Kn({ type: me, symKey: xe, message: Oe, senderPublicKey: we });
    }, this.decode = async (ye, ve, Ee) => {
      this.isInitialized();
      const Se = xn(ve, Ee);
      if (Fn(Se)) {
        const Oe = Se.receiverPublicKey, xe = Se.senderPublicKey;
        ye = await this.generateSharedKey(Oe, xe);
      }
      try {
        const Oe = this.getSymKey(ye), xe = Ln({ symKey: Oe, encoded: ve });
        return safeJsonParse(xe);
      } catch (Oe) {
        this.logger.error(`Failed to decode message from topic: '${ye}', clientId: '${await this.getClientId()}'`), this.logger.error(Oe);
      }
    }, this.getPayloadType = (ye) => {
      const ve = ee(ye);
      return $(ve.type);
    }, this.getPayloadSenderPublicKey = (ye) => {
      const ve = ee(ye);
      return ve.senderPublicKey ? toString(ve.senderPublicKey, p$2) : void 0;
    }, this.core = e, this.logger = cjs$3.generateChildLogger(fe, this.name), this.keychain = be || new Ct$1(this.core, this.logger);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, fe) {
    return await this.keychain.set(e, fe), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ue);
    } catch {
      e = Dn(), await this.keychain.set(ue, e);
    }
    return cr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
let _t$2 = class extends a$1 {
  constructor(e, fe) {
    super(e, fe), this.logger = e, this.core = fe, this.messages = /* @__PURE__ */ new Map(), this.name = it, this.version = st$1, this.initialized = !1, this.storagePrefix = x$2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const be = await this.getRelayerMessages();
          typeof be < "u" && (this.messages = be), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (be) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(be);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (be, ye) => {
      this.isInitialized();
      const ve = Mn$1(ye);
      let Ee = this.messages.get(be);
      return typeof Ee > "u" && (Ee = {}), typeof Ee[ve] < "u" || (Ee[ve] = ye, this.messages.set(be, Ee), await this.persist()), ve;
    }, this.get = (be) => {
      this.isInitialized();
      let ye = this.messages.get(be);
      return typeof ye > "u" && (ye = {}), ye;
    }, this.has = (be, ye) => {
      this.isInitialized();
      const ve = this.get(be), Ee = Mn$1(ye);
      return typeof ve[Ee] < "u";
    }, this.del = async (be) => {
      this.isInitialized(), this.messages.delete(be), await this.persist();
    }, this.logger = cjs$3.generateChildLogger(e, this.name), this.core = fe;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, et$1(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt$1(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class pr extends u$1 {
  constructor(e, fe) {
    super(e, fe), this.relayer = e, this.logger = fe, this.events = new eventsExports.EventEmitter(), this.name = nt, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$4.toMiliseconds(cjs$4.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (be, ye, ve) => {
      var Ee;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: be, message: ye, opts: ve } });
      try {
        const Se = (ve == null ? void 0 : ve.ttl) || rt, Oe = mt$1(ve), xe = (ve == null ? void 0 : ve.prompt) || !1, me = (ve == null ? void 0 : ve.tag) || 0, we = (ve == null ? void 0 : ve.id) || getBigIntRpcId().toString(), ur = { topic: be, message: ye, opts: { ttl: Se, relay: Oe, prompt: xe, tag: me, id: we } }, lr = setTimeout(() => this.queue.set(we, ur), this.publishTimeout);
        try {
          await await it$1(this.rpcPublish(be, ye, Se, Oe, xe, me, we), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(we), this.relayer.events.emit(D$1.publish, ur);
        } catch (Ar) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (Ee = ve == null ? void 0 : ve.internal) != null && Ee.throwOnFailedPublish)
            throw this.removeRequestFromQueue(we), Ar;
          return;
        } finally {
          clearTimeout(lr);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: be, message: ye, opts: ve } });
      } catch (Se) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(Se), Se;
      }
    }, this.on = (be, ye) => {
      this.events.on(be, ye);
    }, this.once = (be, ye) => {
      this.events.once(be, ye);
    }, this.off = (be, ye) => {
      this.events.off(be, ye);
    }, this.removeListener = (be, ye) => {
      this.events.removeListener(be, ye);
    }, this.relayer = e, this.logger = cjs$3.generateChildLogger(fe, this.name), this.registerEventListeners();
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  rpcPublish(e, fe, be, ye, ve, Ee, Se) {
    var Oe, xe, me, we;
    const ur = { method: yt$1(ye.protocol).publish, params: { topic: e, message: fe, ttl: be, prompt: ve, tag: Ee }, id: Se };
    return w$3((Oe = ur.params) == null ? void 0 : Oe.prompt) && ((xe = ur.params) == null || delete xe.prompt), w$3((me = ur.params) == null ? void 0 : me.tag) && ((we = ur.params) == null || delete we.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: ur }), this.relayer.request(ur);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: fe, message: be, opts: ye } = e;
      await this.publish(fe, be, ye);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(D$1.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D$1.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class Dr {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, fe) => {
      const be = this.get(e);
      this.exists(e, fe) || this.map.set(e, [...be, fe]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, fe) => this.get(e).includes(fe), this.delete = (e, fe) => {
      if (typeof fe > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const be = this.get(e);
      if (!this.exists(e, fe))
        return;
      const ye = be.filter((ve) => ve !== fe);
      if (!ye.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, ye);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var yr = Object.defineProperty, br = Object.defineProperties, mr = Object.getOwnPropertyDescriptors, Tt = Object.getOwnPropertySymbols, fr = Object.prototype.hasOwnProperty, Er = Object.prototype.propertyIsEnumerable, St = (v, e, fe) => e in v ? yr(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, B$1 = (v, e) => {
  for (var fe in e || (e = {}))
    fr.call(e, fe) && St(v, fe, e[fe]);
  if (Tt)
    for (var fe of Tt(e))
      Er.call(e, fe) && St(v, fe, e[fe]);
  return v;
}, pe$1 = (v, e) => br(v, mr(e));
class Pt extends d {
  constructor(e, fe) {
    super(e, fe), this.relayer = e, this.logger = fe, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Dr(), this.events = new eventsExports.EventEmitter(), this.name = Dt, this.version = yt, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x$2, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (be, ye) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: be, opts: ye } });
      try {
        const ve = mt$1(ye), Ee = { topic: be, relay: ve };
        this.pending.set(be, Ee);
        const Se = await this.rpcSubscribe(be, ve);
        return this.onSubscribe(Se, Ee), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: be, opts: ye } }), Se;
      } catch (ve) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(ve), ve;
      }
    }, this.unsubscribe = async (be, ye) => {
      await this.restartToComplete(), this.isInitialized(), typeof (ye == null ? void 0 : ye.id) < "u" ? await this.unsubscribeById(be, ye.id, ye) : await this.unsubscribeByTopic(be, ye);
    }, this.isSubscribed = async (be) => this.topics.includes(be) ? !0 : await new Promise((ye, ve) => {
      const Ee = new cjs$4.Watch();
      Ee.start(this.pendingSubscriptionWatchLabel);
      const Se = setInterval(() => {
        !this.pending.has(be) && this.topics.includes(be) && (clearInterval(Se), Ee.stop(this.pendingSubscriptionWatchLabel), ye(!0)), Ee.elapsed(this.pendingSubscriptionWatchLabel) >= bt && (clearInterval(Se), Ee.stop(this.pendingSubscriptionWatchLabel), ve(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => !1), this.on = (be, ye) => {
      this.events.on(be, ye);
    }, this.once = (be, ye) => {
      this.events.once(be, ye);
    }, this.off = (be, ye) => {
      this.events.off(be, ye);
    }, this.removeListener = (be, ye) => {
      this.events.removeListener(be, ye);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = cjs$3.generateChildLogger(fe, this.name), this.clientId = "";
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, fe) {
    let be = !1;
    try {
      be = this.getSubscription(e).topic === fe;
    } catch {
    }
    return be;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, fe) {
    const be = this.topicMap.get(e);
    await Promise.all(be.map(async (ye) => await this.unsubscribeById(e, ye, fe)));
  }
  async unsubscribeById(e, fe, be) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: fe, opts: be } });
    try {
      const ye = mt$1(be);
      await this.rpcUnsubscribe(e, fe, ye);
      const ve = U$4("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, fe, ve), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: fe, opts: be } });
    } catch (ye) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(ye), ye;
    }
  }
  async rpcSubscribe(e, fe) {
    const be = { method: yt$1(fe.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: be });
    try {
      await await it$1(this.relayer.request(be), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D$1.connection_stalled);
    }
    return Mn$1(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const fe = e[0].relay, be = { method: yt$1(fe.protocol).batchSubscribe, params: { topics: e.map((ye) => ye.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: be });
    try {
      return await await it$1(this.relayer.request(be), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D$1.connection_stalled);
    }
  }
  rpcUnsubscribe(e, fe, be) {
    const ye = { method: yt$1(be.protocol).unsubscribe, params: { topic: e, id: fe } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: ye }), this.relayer.request(ye);
  }
  onSubscribe(e, fe) {
    this.setSubscription(e, pe$1(B$1({}, fe), { id: e })), this.pending.delete(fe.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((fe) => {
      this.setSubscription(fe.id, B$1({}, fe)), this.pending.delete(fe.topic);
    });
  }
  async onUnsubscribe(e, fe, be) {
    this.events.removeAllListeners(fe), this.hasSubscription(fe, e) && this.deleteSubscription(fe, be), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, fe) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: fe }), this.addSubscription(e, fe));
  }
  addSubscription(e, fe) {
    this.subscriptions.set(e, B$1({}, fe)), this.topicMap.set(fe.topic, e), this.events.emit(C$1.created, fe);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const fe = this.subscriptions.get(e);
    if (!fe) {
      const { message: be } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(be);
    }
    return fe;
  }
  deleteSubscription(e, fe) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: fe });
    const be = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(be.topic, e), this.events.emit(C$1.deleted, pe$1(B$1({}, be), { reason: fe }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(C$1.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let fe = 0; fe < e; fe++) {
        const be = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(be);
      }
    }
    this.events.emit(C$1.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: fe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(fe), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(fe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const fe = await this.rpcBatchSubscribe(e);
    j$2(fe) && this.onBatchSubscribe(fe.map((be, ye) => pe$1(B$1({}, e[ye]), { id: be })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((fe) => {
      e.push(fe);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D$1.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D$1.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(C$1.created, async (e) => {
      const fe = C$1.created;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, data: e }), await this.persist();
    }), this.events.on(C$1.deleted, async (e) => {
      const fe = C$1.deleted;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const fe = setInterval(() => {
        this.restartInProgress || (clearInterval(fe), e());
      }, this.pollingInterval);
    });
  }
}
var wr = Object.defineProperty, Ot = Object.getOwnPropertySymbols, vr = Object.prototype.hasOwnProperty, Ir = Object.prototype.propertyIsEnumerable, xt$1 = (v, e, fe) => e in v ? wr(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, Cr = (v, e) => {
  for (var fe in e || (e = {}))
    vr.call(e, fe) && xt$1(v, fe, e[fe]);
  if (Ot)
    for (var fe of Ot(e))
      Ir.call(e, fe) && xt$1(v, fe, e[fe]);
  return v;
};
let At$1 = class extends g$3 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new eventsExports.EventEmitter(), this.name = ht, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async (fe) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(fe);
      } catch (be) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(be), be;
      }
    }, this.onPayloadHandler = (fe) => {
      this.onProviderPayload(fe);
    }, this.onConnectHandler = () => {
      this.events.emit(D$1.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (fe) => {
      this.logger.error(fe), this.events.emit(D$1.error, fe);
    }, this.registerProviderListeners = () => {
      this.provider.on(P$1.payload, this.onPayloadHandler), this.provider.on(P$1.connect, this.onConnectHandler), this.provider.on(P$1.disconnect, this.onDisconnectHandler), this.provider.on(P$1.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? cjs$3.generateChildLogger(e.logger, this.name) : cjs$3.pino(cjs$3.getDefaultLoggerOptions({ level: e.logger || ot })), this.messages = new _t$2(this.logger, e.core), this.subscriber = new Pt(this, this.logger), this.publisher = new pr(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || le$1, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de$1}...`), await this.restartTransport(de$1);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, dt$1);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, fe, be) {
    this.isInitialized(), await this.publisher.publish(e, fe, be), await this.recordMessageEvent({ topic: e, message: fe, publishedAt: Date.now() });
  }
  async subscribe(e, fe) {
    var be;
    this.isInitialized();
    let ye = ((be = this.subscriber.topicMap.get(e)) == null ? void 0 : be[0]) || "";
    return ye || (await Promise.all([new Promise((ve) => {
      this.subscriber.once(C$1.created, (Ee) => {
        Ee.topic === e && ve();
      });
    }), new Promise(async (ve) => {
      ye = await this.subscriber.subscribe(e, fe), ve();
    })]), ye);
  }
  async unsubscribe(e, fe) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, fe);
  }
  on(e, fe) {
    this.events.on(e, fe);
  }
  once(e, fe) {
    this.events.once(e, fe);
  }
  off(e, fe) {
    this.events.off(e, fe);
  }
  removeListener(e, fe) {
    this.events.removeListener(e, fe);
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await it$1(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((fe) => {
          if (!this.initialized)
            return fe();
          this.subscriber.once(C$1.resubscribed, () => {
            fe();
          });
        }), new Promise(async (fe, be) => {
          try {
            await it$1(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (ye) {
            be(ye);
            return;
          }
          fe();
        })]);
      } catch (fe) {
        this.logger.error(fe);
        const be = fe;
        if (!this.isConnectionStalled(be.message))
          throw fe;
        this.provider.events.emit(P$1.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((fe) => e.includes(fe));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new WsConnection(Jn({ sdkVersion: lt$1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: fe, message: be } = e;
    await this.messages.set(fe, be);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: fe, message: be } = e;
    if (!be || be.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${be}`), !0;
    if (!await this.subscriber.isSubscribed(fe))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${fe}`), !0;
    const ye = this.messages.has(fe, be);
    return ye && this.logger.debug(`Ignoring duplicate message: ${be}`), ye;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ct))
        return;
      const fe = e.params, { topic: be, message: ye, publishedAt: ve } = fe.data, Ee = { topic: be, message: ye, publishedAt: ve };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Cr({ type: "event", event: fe.id }, Ee)), this.events.emit(fe.id, Ee), await this.acknowledgePayload(e), await this.onMessageEvent(Ee);
    } else
      isJsonRpcResponse(e) && this.events.emit(D$1.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D$1.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const fe = formatJsonRpcResult(e.id, !0);
    await this.provider.connection.send(fe);
  }
  unregisterProviderListeners() {
    this.provider.off(P$1.payload, this.onPayloadHandler), this.provider.off(P$1.connect, this.onConnectHandler), this.provider.off(P$1.disconnect, this.onDisconnectHandler), this.provider.off(P$1.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D$1.connection_stalled, () => {
      this.restartTransport().catch((fe) => this.logger.error(fe));
    });
    let e = await Zt();
    Xt(async (fe) => {
      this.initialized && e !== fe && (e = fe, fe ? await this.restartTransport().catch((be) => this.logger.error(be)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((be) => this.logger.error(be))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D$1.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, cjs$4.toMiliseconds(ut$1)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const fe = setInterval(() => {
            this.connected && (clearInterval(fe), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Rr = Object.defineProperty, zt$1 = Object.getOwnPropertySymbols, _r = Object.prototype.hasOwnProperty, Tr = Object.prototype.propertyIsEnumerable, Nt = (v, e, fe) => e in v ? Rr(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, Lt$1 = (v, e) => {
  for (var fe in e || (e = {}))
    _r.call(e, fe) && Nt(v, fe, e[fe]);
  if (zt$1)
    for (var fe of zt$1(e))
      Tr.call(e, fe) && Nt(v, fe, e[fe]);
  return v;
};
class Ut extends p$3 {
  constructor(e, fe, be, ye = x$2, ve = void 0) {
    super(e, fe, be, ye), this.core = e, this.logger = fe, this.name = be, this.map = /* @__PURE__ */ new Map(), this.version = gt, this.cached = [], this.initialized = !1, this.storagePrefix = x$2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Ee) => {
        this.getKey && Ee !== null && !w$3(Ee) ? this.map.set(this.getKey(Ee), Ee) : Dt$1(Ee) ? this.map.set(Ee.id, Ee) : kt$1(Ee) && this.map.set(Ee.topic, Ee);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (Ee, Se) => {
      this.isInitialized(), this.map.has(Ee) ? await this.update(Ee, Se) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: Ee, value: Se }), this.map.set(Ee, Se), await this.persist());
    }, this.get = (Ee) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: Ee }), this.getData(Ee)), this.getAll = (Ee) => (this.isInitialized(), Ee ? this.values.filter((Se) => Object.keys(Ee).every((Oe) => Mi(Se[Oe], Ee[Oe]))) : this.values), this.update = async (Ee, Se) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: Ee, update: Se });
      const Oe = Lt$1(Lt$1({}, this.getData(Ee)), Se);
      this.map.set(Ee, Oe), await this.persist();
    }, this.delete = async (Ee, Se) => {
      this.isInitialized(), this.map.has(Ee) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: Ee, reason: Se }), this.map.delete(Ee), await this.persist());
    }, this.logger = cjs$3.generateChildLogger(fe, this.name), this.storagePrefix = ye, this.getKey = ve;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const fe = this.map.get(e);
    if (!fe) {
      const { message: be } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(be), new Error(be);
    }
    return fe;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: fe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(fe), new Error(fe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
let Ft$1 = class {
  constructor(e, fe) {
    this.core = e, this.logger = fe, this.name = mt, this.version = ft$1, this.events = new ke$2(), this.initialized = !1, this.storagePrefix = x$2, this.ignoredPayloadTypes = [_$2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: be }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...be])];
    }, this.create = async () => {
      this.isInitialized();
      const be = Dn(), ye = await this.core.crypto.setSymKey(be), ve = lt$2(cjs$4.FIVE_MINUTES), Ee = { protocol: at }, Se = { topic: ye, expiry: ve, relay: Ee, active: !1 }, Oe = Nt$1({ protocol: this.core.protocol, version: this.core.version, topic: ye, symKey: be, relay: Ee });
      return await this.pairings.set(ye, Se), await this.core.relayer.subscribe(ye), this.core.expirer.set(ye, ve), { topic: ye, uri: Oe };
    }, this.pair = async (be) => {
      this.isInitialized(), this.isValidPair(be);
      const { topic: ye, symKey: ve, relay: Ee } = bt$1(be.uri);
      if (this.pairings.keys.includes(ye))
        throw new Error(`Pairing already exists: ${ye}`);
      if (this.core.crypto.hasKeys(ye))
        throw new Error(`Keychain already exists: ${ye}`);
      const Se = lt$2(cjs$4.FIVE_MINUTES), Oe = { topic: ye, relay: Ee, expiry: Se, active: !1 };
      return await this.pairings.set(ye, Oe), await this.core.crypto.setSymKey(ve, ye), await this.core.relayer.subscribe(ye, { relay: Ee }), this.core.expirer.set(ye, Se), be.activatePairing && await this.activate({ topic: ye }), Oe;
    }, this.activate = async ({ topic: be }) => {
      this.isInitialized();
      const ye = lt$2(cjs$4.THIRTY_DAYS);
      await this.pairings.update(be, { active: !0, expiry: ye }), this.core.expirer.set(be, ye);
    }, this.ping = async (be) => {
      this.isInitialized(), await this.isValidPing(be);
      const { topic: ye } = be;
      if (this.pairings.keys.includes(ye)) {
        const ve = await this.sendRequest(ye, "wc_pairingPing", {}), { done: Ee, resolve: Se, reject: Oe } = st$2();
        this.events.once(ft$2("pairing_ping", ve), ({ error: xe }) => {
          xe ? Oe(xe) : Se();
        }), await Ee();
      }
    }, this.updateExpiry = async ({ topic: be, expiry: ye }) => {
      this.isInitialized(), await this.pairings.update(be, { expiry: ye });
    }, this.updateMetadata = async ({ topic: be, metadata: ye }) => {
      this.isInitialized(), await this.pairings.update(be, { peerMetadata: ye });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (be) => {
      this.isInitialized(), await this.isValidDisconnect(be);
      const { topic: ye } = be;
      this.pairings.keys.includes(ye) && (await this.sendRequest(ye, "wc_pairingDelete", U$4("USER_DISCONNECTED")), await this.deletePairing(ye));
    }, this.sendRequest = async (be, ye, ve) => {
      const Ee = formatJsonRpcRequest(ye, ve), Se = await this.core.crypto.encode(be, Ee), Oe = F$1[ye].req;
      return this.core.history.set(be, Ee), this.core.relayer.publish(be, Se, Oe), Ee.id;
    }, this.sendResult = async (be, ye, ve) => {
      const Ee = formatJsonRpcResult(be, ve), Se = await this.core.crypto.encode(ye, Ee), Oe = await this.core.history.get(ye, be), xe = F$1[Oe.request.method].res;
      await this.core.relayer.publish(ye, Se, xe), await this.core.history.resolve(Ee);
    }, this.sendError = async (be, ye, ve) => {
      const Ee = formatJsonRpcError(be, ve), Se = await this.core.crypto.encode(ye, Ee), Oe = await this.core.history.get(ye, be), xe = F$1[Oe.request.method] ? F$1[Oe.request.method].res : F$1.unregistered_method.res;
      await this.core.relayer.publish(ye, Se, xe), await this.core.history.resolve(Ee);
    }, this.deletePairing = async (be, ye) => {
      await this.core.relayer.unsubscribe(be), await Promise.all([this.pairings.delete(be, U$4("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(be), ye ? Promise.resolve() : this.core.expirer.del(be)]);
    }, this.cleanup = async () => {
      const be = this.pairings.getAll().filter((ye) => dt$2(ye.expiry));
      await Promise.all(be.map((ye) => this.deletePairing(ye.topic)));
    }, this.onRelayEventRequest = (be) => {
      const { topic: ye, payload: ve } = be;
      switch (ve.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(ye, ve);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(ye, ve);
        default:
          return this.onUnknownRpcMethodRequest(ye, ve);
      }
    }, this.onRelayEventResponse = async (be) => {
      const { topic: ye, payload: ve } = be, Ee = (await this.core.history.get(ye, ve.id)).request.method;
      switch (Ee) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(ye, ve);
        default:
          return this.onUnknownRpcMethodResponse(Ee);
      }
    }, this.onPairingPingRequest = async (be, ye) => {
      const { id: ve } = ye;
      try {
        this.isValidPing({ topic: be }), await this.sendResult(ve, be, !0), this.events.emit("pairing_ping", { id: ve, topic: be });
      } catch (Ee) {
        await this.sendError(ve, be, Ee), this.logger.error(Ee);
      }
    }, this.onPairingPingResponse = (be, ye) => {
      const { id: ve } = ye;
      setTimeout(() => {
        isJsonRpcResult(ye) ? this.events.emit(ft$2("pairing_ping", ve), {}) : isJsonRpcError(ye) && this.events.emit(ft$2("pairing_ping", ve), { error: ye.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (be, ye) => {
      const { id: ve } = ye;
      try {
        this.isValidDisconnect({ topic: be }), await this.deletePairing(be), this.events.emit("pairing_delete", { id: ve, topic: be });
      } catch (Ee) {
        await this.sendError(ve, be, Ee), this.logger.error(Ee);
      }
    }, this.onUnknownRpcMethodRequest = async (be, ye) => {
      const { id: ve, method: Ee } = ye;
      try {
        if (this.registeredMethods.includes(Ee))
          return;
        const Se = U$4("WC_METHOD_UNSUPPORTED", Ee);
        await this.sendError(ve, be, Se), this.logger.error(Se);
      } catch (Se) {
        await this.sendError(ve, be, Se), this.logger.error(Se);
      }
    }, this.onUnknownRpcMethodResponse = (be) => {
      this.registeredMethods.includes(be) || this.logger.error(U$4("WC_METHOD_UNSUPPORTED", be));
    }, this.isValidPair = (be) => {
      if (!xt$2(be)) {
        const { message: ye } = N$2("MISSING_OR_INVALID", `pair() params: ${be}`);
        throw new Error(ye);
      }
      if (!jt(be.uri)) {
        const { message: ye } = N$2("MISSING_OR_INVALID", `pair() uri: ${be.uri}`);
        throw new Error(ye);
      }
    }, this.isValidPing = async (be) => {
      if (!xt$2(be)) {
        const { message: ve } = N$2("MISSING_OR_INVALID", `ping() params: ${be}`);
        throw new Error(ve);
      }
      const { topic: ye } = be;
      await this.isValidPairingTopic(ye);
    }, this.isValidDisconnect = async (be) => {
      if (!xt$2(be)) {
        const { message: ve } = N$2("MISSING_OR_INVALID", `disconnect() params: ${be}`);
        throw new Error(ve);
      }
      const { topic: ye } = be;
      await this.isValidPairingTopic(ye);
    }, this.isValidPairingTopic = async (be) => {
      if (!h$2(be, !1)) {
        const { message: ye } = N$2("MISSING_OR_INVALID", `pairing topic should be a string: ${be}`);
        throw new Error(ye);
      }
      if (!this.pairings.keys.includes(be)) {
        const { message: ye } = N$2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${be}`);
        throw new Error(ye);
      }
      if (dt$2(this.pairings.get(be).expiry)) {
        await this.deletePairing(be);
        const { message: ye } = N$2("EXPIRED", `pairing topic: ${be}`);
        throw new Error(ye);
      }
    }, this.core = e, this.logger = cjs$3.generateChildLogger(fe, this.name), this.pairings = new Ut(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D$1.message, async (e) => {
      const { topic: fe, message: be } = e;
      if (!this.pairings.keys.includes(fe) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(be)))
        return;
      const ye = await this.core.crypto.decode(fe, be);
      try {
        isJsonRpcRequest(ye) ? (this.core.history.set(fe, ye), this.onRelayEventRequest({ topic: fe, payload: ye })) : isJsonRpcResponse(ye) && (await this.core.history.resolve(ye), await this.onRelayEventResponse({ topic: fe, payload: ye }), this.core.history.delete(fe, ye.id));
      } catch (ve) {
        this.logger.error(ve);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(w$2.expired, async (e) => {
      const { topic: fe } = ut$2(e.target);
      fe && this.pairings.keys.includes(fe) && (await this.deletePairing(fe, !0), this.events.emit("pairing_expire", { topic: fe }));
    });
  }
}, $t$1 = class extends h$3 {
  constructor(e, fe) {
    super(e, fe), this.core = e, this.logger = fe, this.records = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = Et, this.version = wt, this.cached = [], this.initialized = !1, this.storagePrefix = x$2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((be) => this.records.set(be.id, be)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (be, ye, ve) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: be, request: ye, chainId: ve }), this.records.has(ye.id))
        return;
      const Ee = { id: ye.id, topic: be, request: { method: ye.method, params: ye.params || null }, chainId: ve, expiry: lt$2(cjs$4.THIRTY_DAYS) };
      this.records.set(Ee.id, Ee), this.events.emit(R$1.created, Ee);
    }, this.resolve = async (be) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: be }), !this.records.has(be.id))
        return;
      const ye = await this.getRecord(be.id);
      typeof ye.response > "u" && (ye.response = isJsonRpcError(be) ? { error: be.error } : { result: be.result }, this.records.set(ye.id, ye), this.events.emit(R$1.updated, ye));
    }, this.get = async (be, ye) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: be, id: ye }), await this.getRecord(ye)), this.delete = (be, ye) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: ye }), this.values.forEach((ve) => {
        if (ve.topic === be) {
          if (typeof ye < "u" && ve.id !== ye)
            return;
          this.records.delete(ve.id), this.events.emit(R$1.deleted, ve);
        }
      });
    }, this.exists = async (be, ye) => (this.isInitialized(), this.records.has(ye) ? (await this.getRecord(ye)).topic === be : !1), this.on = (be, ye) => {
      this.events.on(be, ye);
    }, this.once = (be, ye) => {
      this.events.once(be, ye);
    }, this.off = (be, ye) => {
      this.events.off(be, ye);
    }, this.removeListener = (be, ye) => {
      this.events.removeListener(be, ye);
    }, this.logger = cjs$3.generateChildLogger(fe, this.name);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((fe) => {
      if (typeof fe.response < "u")
        return;
      const be = { topic: fe.topic, request: formatJsonRpcRequest(fe.request.method, fe.request.params, fe.id), chainId: fe.chainId };
      return e.push(be);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const fe = this.records.get(e);
    if (!fe) {
      const { message: be } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(be);
    }
    return fe;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R$1.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: fe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(fe), new Error(fe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R$1.created, (e) => {
      const fe = R$1.created;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, record: e }), this.persist();
    }), this.events.on(R$1.updated, (e) => {
      const fe = R$1.updated;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, record: e }), this.persist();
    }), this.events.on(R$1.deleted, (e) => {
      const fe = R$1.deleted;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, record: e }), this.persist();
    }), this.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        cjs$4.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, Mt$1 = class extends E$1 {
  constructor(e, fe) {
    super(e, fe), this.core = e, this.logger = fe, this.expirations = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = vt, this.version = It, this.cached = [], this.initialized = !1, this.storagePrefix = x$2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((be) => this.expirations.set(be.target, be)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (be) => {
      try {
        const ye = this.formatTarget(be);
        return typeof this.getExpiration(ye) < "u";
      } catch {
        return !1;
      }
    }, this.set = (be, ye) => {
      this.isInitialized();
      const ve = this.formatTarget(be), Ee = { target: ve, expiry: ye };
      this.expirations.set(ve, Ee), this.checkExpiry(ve, Ee), this.events.emit(w$2.created, { target: ve, expiration: Ee });
    }, this.get = (be) => {
      this.isInitialized();
      const ye = this.formatTarget(be);
      return this.getExpiration(ye);
    }, this.del = (be) => {
      if (this.isInitialized(), this.has(be)) {
        const ye = this.formatTarget(be), ve = this.getExpiration(ye);
        this.expirations.delete(ye), this.events.emit(w$2.deleted, { target: ye, expiration: ve });
      }
    }, this.on = (be, ye) => {
      this.events.on(be, ye);
    }, this.once = (be, ye) => {
      this.events.once(be, ye);
    }, this.off = (be, ye) => {
      this.events.off(be, ye);
    }, this.removeListener = (be, ye) => {
      this.events.removeListener(be, ye);
    }, this.logger = cjs$3.generateChildLogger(fe, this.name);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return ct$1(e);
    if (typeof e == "number")
      return at$1(e);
    const { message: fe } = N$2("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(fe);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(w$2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: fe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(fe), new Error(fe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const fe = this.expirations.get(e);
    if (!fe) {
      const { message: be } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(be), new Error(be);
    }
    return fe;
  }
  checkExpiry(e, fe) {
    const { expiry: be } = fe;
    cjs$4.toMiliseconds(be) - Date.now() <= 0 && this.expire(e, fe);
  }
  expire(e, fe) {
    this.expirations.delete(e), this.events.emit(w$2.expired, { target: e, expiration: fe });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, fe) => this.checkExpiry(fe, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(w$2.created, (e) => {
      const fe = w$2.created;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, data: e }), this.persist();
    }), this.events.on(w$2.expired, (e) => {
      const fe = w$2.expired;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, data: e }), this.persist();
    }), this.events.on(w$2.deleted, (e) => {
      const fe = w$2.deleted;
      this.logger.info(`Emitting ${fe}`), this.logger.debug({ type: "event", event: fe, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class kt extends y$1 {
  constructor(e, fe) {
    super(e, fe), this.projectId = e, this.logger = fe, this.name = X$1, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (be) => {
      if (this.verifyDisabled || H$2() || !q$2())
        return;
      const ye = (be == null ? void 0 : be.verifyUrl) || Q$1;
      this.verifyUrl !== ye && this.removeIframe(), this.verifyUrl = ye;
      try {
        await this.createIframe();
      } catch (ve) {
        this.logger.warn(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.warn(ve);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ge;
        try {
          await this.createIframe();
        } catch (ve) {
          this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(ve), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (be) => {
      this.initialized ? this.sendPost(be.attestationId) : (this.addToQueue(be.attestationId), await this.init());
    }, this.resolve = async (be) => {
      if (this.isDevEnv)
        return "";
      const ye = (be == null ? void 0 : be.verifyUrl) || Q$1;
      let ve = "";
      try {
        ve = await this.fetchAttestation(be.attestationId, ye);
      } catch (Ee) {
        this.logger.warn(`failed to resolve attestation: ${be.attestationId} from url: ${ye}`), this.logger.warn(Ee), ve = await this.fetchAttestation(be.attestationId, ge);
      }
      return ve;
    }, this.fetchAttestation = async (be, ye) => {
      var ve;
      this.logger.info(`resolving attestation: ${be} from url: ${ye}`);
      const Ee = this.startAbortTimer(cjs$4.ONE_SECOND * 2), Se = await fetch(`${ye}/attestation/${be}`, { signal: this.abortController.signal });
      return clearTimeout(Ee), Se.status === 200 ? (ve = await Se.json()) == null ? void 0 : ve.origin : "";
    }, this.addToQueue = (be) => {
      this.queue.push(be);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((be) => this.sendPost(be)), this.queue = []);
    }, this.sendPost = (be) => {
      var ye;
      try {
        if (!this.iframe)
          return;
        (ye = this.iframe.contentWindow) == null || ye.postMessage(be, "*"), this.logger.info(`postMessage sent: ${be} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let be;
      const ye = (ve) => {
        ve.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", ye), be());
      };
      await Promise.race([new Promise((ve) => {
        if (document.getElementById(X$1))
          return ve();
        window.addEventListener("message", ye);
        const Ee = document.createElement("iframe");
        Ee.id = X$1, Ee.src = `${this.verifyUrl}/${this.projectId}`, Ee.style.display = "none", document.body.append(Ee), this.iframe = Ee, be = ve;
      }), new Promise((ve, Ee) => setTimeout(() => {
        window.removeEventListener("message", ye), Ee("verify iframe load timeout");
      }, cjs$4.toMiliseconds(cjs$4.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.logger = cjs$3.generateChildLogger(fe, this.name), this.verifyUrl = Q$1, this.abortController = new AbortController(), this.isDevEnv = te$1() && process.env.IS_VITEST;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$4.toMiliseconds(e));
  }
}
var Sr = Object.defineProperty, Kt$1 = Object.getOwnPropertySymbols, Pr = Object.prototype.hasOwnProperty, Or = Object.prototype.propertyIsEnumerable, Bt$1 = (v, e, fe) => e in v ? Sr(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, Vt$1 = (v, e) => {
  for (var fe in e || (e = {}))
    Pr.call(e, fe) && Bt$1(v, fe, e[fe]);
  if (Kt$1)
    for (var fe of Kt$1(e))
      Or.call(e, fe) && Bt$1(v, fe, e[fe]);
  return v;
};
class Z extends n$1 {
  constructor(e) {
    super(e), this.protocol = ce$2, this.version = Je$1, this.name = W$1, this.events = new eventsExports.EventEmitter(), this.initialized = !1, this.on = (be, ye) => this.events.on(be, ye), this.once = (be, ye) => this.events.once(be, ye), this.off = (be, ye) => this.events.off(be, ye), this.removeListener = (be, ye) => this.events.removeListener(be, ye), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || le$1;
    const fe = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : cjs$3.pino(cjs$3.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || We.logger }));
    this.logger = cjs$3.generateChildLogger(fe, this.name), this.heartbeat = new cjs$5.HeartBeat(), this.crypto = new Rt(this, this.logger, e == null ? void 0 : e.keychain), this.history = new $t$1(this, this.logger), this.expirer = new Mt$1(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h$4(Vt$1(Vt$1({}, Xe), e == null ? void 0 : e.storageOptions)), this.relayer = new At$1({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Ft$1(this, this.logger), this.verify = new kt(this.projectId || "", this.logger);
  }
  static async init(e) {
    const fe = new Z(e);
    await fe.initialize();
    const be = await fe.crypto.getClientId();
    return await fe.storage.setItem(pt$1, be), fe;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const xr = Z;
function M$1(v, e) {
  return v.includes(":") ? [v] : e.chains || [];
}
const p$1 = "base16", x$1 = "utf8", _$1 = 1;
function Mn(v) {
  const e = sha256$1.hash(fromString(v, x$1));
  return toString(e, p$1);
}
const Ce = "ReactNative", m$1 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function H$1() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce;
}
function q$1() {
  return !te() && !!getNavigator_1();
}
function R() {
  return H$1() ? m$1.reactNative : te() ? m$1.node : q$1() ? m$1.browser : m$1.unknown;
}
function zn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function O(v, e) {
  return v.filter((fe) => e.includes(fe)).length === v.length;
}
function st(v = cjs$4.FIVE_MINUTES, e) {
  const fe = cjs$4.toMiliseconds(v || cjs$4.FIVE_MINUTES);
  let be, ye, ve;
  return { resolve: (Ee) => {
    ve && be && (clearTimeout(ve), be(Ee));
  }, reject: (Ee) => {
    ve && ye && (clearTimeout(ve), ye(Ee));
  }, done: () => new Promise((Ee, Se) => {
    ve = setTimeout(() => {
      Se(new Error(e));
    }, fe), be = Ee, ye = Se;
  }) };
}
function ut(v) {
  const [e, fe] = v.split(":"), be = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof fe == "string")
    be.topic = fe;
  else if (e === "id" && Number.isInteger(Number(fe)))
    be.id = Number(fe);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${fe}`);
  return be;
}
function lt(v, e) {
  return cjs$4.fromMiliseconds((e || Date.now()) + cjs$4.toMiliseconds(v));
}
function dt(v) {
  return Date.now() >= cjs$4.toMiliseconds(v);
}
function ft(v, e) {
  return `${v}${e ? `:${e}` : ""}`;
}
async function pt({ id: v, topic: e, wcDeepLink: fe }) {
  try {
    if (!fe)
      return;
    const be = typeof fe == "string" ? JSON.parse(fe) : fe;
    let ye = be == null ? void 0 : be.href;
    if (typeof ye != "string")
      return;
    ye.endsWith("/") && (ye = ye.slice(0, -1));
    const ve = `${ye}/wc?requestId=${v}&sessionTopic=${e}`, Ee = R();
    Ee === m$1.browser ? ve.startsWith("https://") ? window.open(ve, "_blank", "noreferrer noopener") : window.open(ve, "_self", "noreferrer noopener") : Ee === m$1.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(ve);
  } catch (be) {
    console.error(be);
  }
}
function A$1(v) {
  const e = [];
  return v.forEach((fe) => {
    const [be, ye] = fe.split(":");
    e.push(`${be}:${ye}`);
  }), e;
}
function Je(v) {
  const e = [];
  return Object.values(v).forEach((fe) => {
    e.push(...A$1(fe.accounts));
  }), e;
}
function Qe(v, e) {
  const fe = [];
  return Object.values(v).forEach((be) => {
    A$1(be.accounts).includes(e) && fe.push(...be.methods);
  }), fe;
}
function Ze(v, e) {
  const fe = [];
  return Object.values(v).forEach((be) => {
    A$1(be.accounts).includes(e) && fe.push(...be.events);
  }), fe;
}
function At(v, e) {
  const fe = cn(v, e);
  if (fe)
    throw new Error(fe.message);
  const be = {};
  for (const [ye, ve] of Object.entries(v))
    be[ye] = { methods: ve.methods, events: ve.events, chains: ve.accounts.map((Ee) => `${Ee.split(":")[0]}:${Ee.split(":")[1]}`) };
  return be;
}
const _t$1 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Ct = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N$1(v, e) {
  const { message: fe, code: be } = Ct[v];
  return { message: e ? `${fe} ${e}` : fe, code: be };
}
function U$3(v, e) {
  const { message: fe, code: be } = _t$1[v];
  return { message: e ? `${fe} ${e}` : fe, code: be };
}
function j$1(v, e) {
  return Array.isArray(v) ? typeof e < "u" && v.length ? v.every(e) : !0 : !1;
}
function B(v) {
  return Object.getPrototypeOf(v) === Object.prototype && Object.keys(v).length;
}
function w$1(v) {
  return typeof v > "u";
}
function h$1(v, e) {
  return e && w$1(v) ? !0 : typeof v == "string" && !!v.trim().length;
}
function G$1(v, e) {
  return e && w$1(v) ? !0 : typeof v == "number" && !isNaN(v);
}
function $t(v, e) {
  const { requiredNamespaces: fe } = e, be = Object.keys(v.namespaces), ye = Object.keys(fe);
  let ve = !0;
  return O(ye, be) ? (be.forEach((Ee) => {
    const { accounts: Se, methods: Oe, events: xe } = v.namespaces[Ee], me = A$1(Se), we = fe[Ee];
    (!O(M$1(Ee, we), me) || !O(we.methods, Oe) || !O(we.events, xe)) && (ve = !1);
  }), ve) : !1;
}
function D(v) {
  return h$1(v, !1) && v.includes(":") ? v.split(":").length === 2 : !1;
}
function en(v) {
  if (h$1(v, !1) && v.includes(":")) {
    const e = v.split(":");
    if (e.length === 3) {
      const fe = e[0] + ":" + e[1];
      return !!e[2] && D(fe);
    }
  }
  return !1;
}
function Vt(v, e) {
  let fe = null;
  return h$1(v == null ? void 0 : v.publicKey, !1) || (fe = N$1("MISSING_OR_INVALID", `${e} controller public key should be a string`)), fe;
}
function ie(v) {
  let e = !0;
  return j$1(v) ? v.length && (e = v.every((fe) => h$1(fe, !1))) : e = !1, e;
}
function nn(v, e, fe) {
  let be = null;
  return j$1(e) && e.length ? e.forEach((ye) => {
    be || D(ye) || (be = U$3("UNSUPPORTED_CHAINS", `${fe}, chain ${ye} should be a string and conform to "namespace:chainId" format`));
  }) : D(v) || (be = U$3("UNSUPPORTED_CHAINS", `${fe}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), be;
}
function tn(v, e, fe) {
  let be = null;
  return Object.entries(v).forEach(([ye, ve]) => {
    if (be)
      return;
    const Ee = nn(ye, M$1(ye, ve), `${e} ${fe}`);
    Ee && (be = Ee);
  }), be;
}
function rn(v, e) {
  let fe = null;
  return j$1(v) ? v.forEach((be) => {
    fe || en(be) || (fe = U$3("UNSUPPORTED_ACCOUNTS", `${e}, account ${be} should be a string and conform to "namespace:chainId:address" format`));
  }) : fe = U$3("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), fe;
}
function on(v, e) {
  let fe = null;
  return Object.values(v).forEach((be) => {
    if (fe)
      return;
    const ye = rn(be == null ? void 0 : be.accounts, `${e} namespace`);
    ye && (fe = ye);
  }), fe;
}
function sn(v, e) {
  let fe = null;
  return ie(v == null ? void 0 : v.methods) ? ie(v == null ? void 0 : v.events) || (fe = U$3("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : fe = U$3("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), fe;
}
function ce$1(v, e) {
  let fe = null;
  return Object.values(v).forEach((be) => {
    if (fe)
      return;
    const ye = sn(be, `${e}, namespace`);
    ye && (fe = ye);
  }), fe;
}
function Mt(v, e, fe) {
  let be = null;
  if (v && B(v)) {
    const ye = ce$1(v, e);
    ye && (be = ye);
    const ve = tn(v, e, fe);
    ve && (be = ve);
  } else
    be = N$1("MISSING_OR_INVALID", `${e}, ${fe} should be an object with data`);
  return be;
}
function cn(v, e) {
  let fe = null;
  if (v && B(v)) {
    const be = ce$1(v, e);
    be && (fe = be);
    const ye = on(v, e);
    ye && (fe = ye);
  } else
    fe = N$1("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return fe;
}
function an(v) {
  return h$1(v.protocol, !0);
}
function Kt(v, e) {
  let fe = !1;
  return e && !v ? fe = !0 : v && j$1(v) && v.length && v.forEach((be) => {
    fe = an(be);
  }), fe;
}
function Lt(v) {
  return typeof v == "number";
}
function xt(v) {
  return typeof v < "u" && typeof v !== null;
}
function Ft(v) {
  return !(!v || typeof v != "object" || !v.code || !G$1(v.code, !1) || !v.message || !h$1(v.message, !1));
}
function Ht(v) {
  return !(w$1(v) || !h$1(v.method, !1));
}
function qt(v) {
  return !(w$1(v) || w$1(v.result) && w$1(v.error) || !G$1(v.id, !1) || !h$1(v.jsonrpc, !1));
}
function Bt(v) {
  return !(w$1(v) || !h$1(v.name, !1));
}
function Gt(v, e) {
  return !(!D(e) || !Je(v).includes(e));
}
function Wt(v, e, fe) {
  return h$1(fe, !1) ? Qe(v, e).includes(fe) : !1;
}
function zt(v, e, fe) {
  return h$1(fe, !1) ? Ze(v, e).includes(fe) : !1;
}
function un(v, e, fe) {
  let be = null;
  const ye = Yt(v), ve = Jt(e), Ee = Object.keys(ye), Se = Object.keys(ve), Oe = ln(Object.keys(v)), xe = ln(Object.keys(e)), me = Oe.filter((we) => !xe.includes(we));
  return me.length && (be = N$1("NON_CONFORMING_NAMESPACES", `${fe} namespaces keys don't satisfy requiredNamespaces.
      Required: ${me.toString()}
      Received: ${Object.keys(e).toString()}`)), O(Ee, Se) || (be = N$1("NON_CONFORMING_NAMESPACES", `${fe} namespaces chains don't satisfy required namespaces.
      Required: ${Ee.toString()}
      Approved: ${Se.toString()}`)), Object.keys(e).forEach((we) => {
    if (!we.includes(":") || be)
      return;
    const ur = A$1(e[we].accounts);
    ur.includes(we) || (be = N$1("NON_CONFORMING_NAMESPACES", `${fe} namespaces accounts don't satisfy namespace accounts for ${we}
        Required: ${we}
        Approved: ${ur.toString()}`));
  }), Ee.forEach((we) => {
    be || (O(ye[we].methods, ve[we].methods) ? O(ye[we].events, ve[we].events) || (be = N$1("NON_CONFORMING_NAMESPACES", `${fe} namespaces events don't satisfy namespace events for ${we}`)) : be = N$1("NON_CONFORMING_NAMESPACES", `${fe} namespaces methods don't satisfy namespace methods for ${we}`));
  }), be;
}
function Yt(v) {
  const e = {};
  return Object.keys(v).forEach((fe) => {
    var be;
    fe.includes(":") ? e[fe] = v[fe] : (be = v[fe].chains) == null || be.forEach((ye) => {
      e[ye] = { methods: v[fe].methods, events: v[fe].events };
    });
  }), e;
}
function ln(v) {
  return [...new Set(v.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Jt(v) {
  const e = {};
  return Object.keys(v).forEach((fe) => {
    if (fe.includes(":"))
      e[fe] = v[fe];
    else {
      const be = A$1(v[fe].accounts);
      be == null || be.forEach((ye) => {
        e[ye] = { accounts: v[fe].accounts.filter((ve) => ve.includes(`${ye}:`)), methods: v[fe].methods, events: v[fe].events };
      });
    }
  }), e;
}
function Qt(v, e) {
  return G$1(v, !1) && v <= e.max && v >= e.min;
}
const ae$1 = {};
class er {
  static get(e) {
    return ae$1[e];
  }
  static set(e, fe) {
    ae$1[e] = fe;
  }
  static delete(e) {
    delete ae$1[e];
  }
}
const J = "wc", X = 2, F = "client", G = `${J}@${X}:${F}:`, M = { name: F, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, H = "WALLETCONNECT_DEEPLINK_CHOICE", ne = "proposal", oe = "Proposal expired", ae = "session", C = cjs$4.SEVEN_DAYS, ce = "engine", V = { wc_sessionPropose: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, U$2 = { min: cjs$4.FIVE_MINUTES, max: cjs$4.SEVEN_DAYS }, E = { idle: "IDLE", active: "ACTIVE" }, le = "request", pe = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var rs = Object.defineProperty, ns = Object.defineProperties, os = Object.getOwnPropertyDescriptors, he = Object.getOwnPropertySymbols, as = Object.prototype.hasOwnProperty, cs = Object.prototype.propertyIsEnumerable, de = (v, e, fe) => e in v ? rs(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, g$1 = (v, e) => {
  for (var fe in e || (e = {}))
    as.call(e, fe) && de(v, fe, e[fe]);
  if (he)
    for (var fe of he(e))
      cs.call(e, fe) && de(v, fe, e[fe]);
  return v;
}, b = (v, e) => ns(v, os(e));
class ls extends S$1 {
  constructor(e) {
    super(e), this.name = ce, this.events = new ke$2(), this.initialized = !1, this.ignoredPayloadTypes = [_$1], this.requestQueue = { state: E.idle, queue: [] }, this.sessionRequestQueue = { state: E.idle, queue: [] }, this.requestQueueDelay = cjs$4.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(V) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$4.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (fe) => {
      await this.isInitialized();
      const be = b(g$1({}, fe), { requiredNamespaces: fe.requiredNamespaces || {}, optionalNamespaces: fe.optionalNamespaces || {} });
      await this.isValidConnect(be);
      const { pairingTopic: ye, requiredNamespaces: ve, optionalNamespaces: Ee, sessionProperties: Se, relays: Oe } = be;
      let xe = ye, me, we = !1;
      if (xe && (we = this.client.core.pairing.pairings.get(xe).active), !xe || !we) {
        const { topic: kr, uri: $r } = await this.client.core.pairing.create();
        xe = kr, me = $r;
      }
      const ur = await this.client.core.crypto.generateKeyPair(), lr = g$1({ requiredNamespaces: ve, optionalNamespaces: Ee, relays: Oe ?? [{ protocol: at }], proposer: { publicKey: ur, metadata: this.client.metadata } }, Se && { sessionProperties: Se }), { reject: Ar, resolve: Br, done: Xr } = st(cjs$4.FIVE_MINUTES, oe);
      if (this.events.once(ft("session_connect"), async ({ error: kr, session: $r }) => {
        if (kr)
          Ar(kr);
        else if ($r) {
          $r.self.publicKey = ur;
          const Vr = b(g$1({}, $r), { requiredNamespaces: $r.requiredNamespaces, optionalNamespaces: $r.optionalNamespaces });
          await this.client.session.set($r.topic, Vr), await this.setExpiry($r.topic, $r.expiry), xe && await this.client.core.pairing.updateMetadata({ topic: xe, metadata: $r.peer.metadata }), Br(Vr);
        }
      }), !xe) {
        const { message: kr } = N$1("NO_MATCHING_KEY", `connect() pairing topic: ${xe}`);
        throw new Error(kr);
      }
      const eo = await this.sendRequest({ topic: xe, method: "wc_sessionPropose", params: lr }), jr = lt(cjs$4.FIVE_MINUTES);
      return await this.setProposal(eo, g$1({ id: eo, expiry: jr }, lr)), { uri: me, approval: Xr };
    }, this.pair = async (fe) => (await this.isInitialized(), await this.client.core.pairing.pair(fe)), this.approve = async (fe) => {
      await this.isInitialized(), await this.isValidApprove(fe);
      const { id: be, relayProtocol: ye, namespaces: ve, sessionProperties: Ee } = fe, Se = this.client.proposal.get(be);
      let { pairingTopic: Oe, proposer: xe, requiredNamespaces: me, optionalNamespaces: we } = Se;
      Oe = Oe || "", B(me) || (me = At(ve, "approve()"));
      const ur = await this.client.core.crypto.generateKeyPair(), lr = xe.publicKey, Ar = await this.client.core.crypto.generateSharedKey(ur, lr);
      Oe && be && (await this.client.core.pairing.updateMetadata({ topic: Oe, metadata: xe.metadata }), await this.sendResult({ id: be, topic: Oe, result: { relay: { protocol: ye ?? "irn" }, responderPublicKey: ur } }), await this.client.proposal.delete(be, U$3("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: Oe }));
      const Br = g$1({ relay: { protocol: ye ?? "irn" }, namespaces: ve, requiredNamespaces: me, optionalNamespaces: we, pairingTopic: Oe, controller: { publicKey: ur, metadata: this.client.metadata }, expiry: lt(C) }, Ee && { sessionProperties: Ee });
      await this.client.core.relayer.subscribe(Ar), await this.sendRequest({ topic: Ar, method: "wc_sessionSettle", params: Br, throwOnFailedPublish: !0 });
      const Xr = b(g$1({}, Br), { topic: Ar, pairingTopic: Oe, acknowledged: !1, self: Br.controller, peer: { publicKey: xe.publicKey, metadata: xe.metadata }, controller: ur });
      return await this.client.session.set(Ar, Xr), await this.setExpiry(Ar, lt(C)), { topic: Ar, acknowledged: () => new Promise((eo) => setTimeout(() => eo(this.client.session.get(Ar)), 500)) };
    }, this.reject = async (fe) => {
      await this.isInitialized(), await this.isValidReject(fe);
      const { id: be, reason: ye } = fe, { pairingTopic: ve } = this.client.proposal.get(be);
      ve && (await this.sendError(be, ve, ye), await this.client.proposal.delete(be, U$3("USER_DISCONNECTED")));
    }, this.update = async (fe) => {
      await this.isInitialized(), await this.isValidUpdate(fe);
      const { topic: be, namespaces: ye } = fe, ve = await this.sendRequest({ topic: be, method: "wc_sessionUpdate", params: { namespaces: ye } }), { done: Ee, resolve: Se, reject: Oe } = st();
      return this.events.once(ft("session_update", ve), ({ error: xe }) => {
        xe ? Oe(xe) : Se();
      }), await this.client.session.update(be, { namespaces: ye }), { acknowledged: Ee };
    }, this.extend = async (fe) => {
      await this.isInitialized(), await this.isValidExtend(fe);
      const { topic: be } = fe, ye = await this.sendRequest({ topic: be, method: "wc_sessionExtend", params: {} }), { done: ve, resolve: Ee, reject: Se } = st();
      return this.events.once(ft("session_extend", ye), ({ error: Oe }) => {
        Oe ? Se(Oe) : Ee();
      }), await this.setExpiry(be, lt(C)), { acknowledged: ve };
    }, this.request = async (fe) => {
      await this.isInitialized(), await this.isValidRequest(fe);
      const { chainId: be, request: ye, topic: ve, expiry: Ee } = fe, Se = payloadId(), { done: Oe, resolve: xe, reject: me } = st(Ee);
      return this.events.once(ft("session_request", Se), ({ error: we, result: ur }) => {
        we ? me(we) : xe(ur);
      }), await Promise.all([new Promise(async (we) => {
        await this.sendRequest({ clientRpcId: Se, topic: ve, method: "wc_sessionRequest", params: { request: ye, chainId: be }, expiry: Ee, throwOnFailedPublish: !0 }).catch((ur) => me(ur)), this.client.events.emit("session_request_sent", { topic: ve, request: ye, chainId: be, id: Se }), we();
      }), new Promise(async (we) => {
        const ur = await this.client.core.storage.getItem(H);
        pt({ id: Se, topic: ve, wcDeepLink: ur }), we();
      }), Oe()]).then((we) => we[2]);
    }, this.respond = async (fe) => {
      await this.isInitialized(), await this.isValidRespond(fe);
      const { topic: be, response: ye } = fe, { id: ve } = ye;
      isJsonRpcResult(ye) ? await this.sendResult({ id: ve, topic: be, result: ye.result, throwOnFailedPublish: !0 }) : isJsonRpcError(ye) && await this.sendError(ve, be, ye.error), this.cleanupAfterResponse(fe);
    }, this.ping = async (fe) => {
      await this.isInitialized(), await this.isValidPing(fe);
      const { topic: be } = fe;
      if (this.client.session.keys.includes(be)) {
        const ye = await this.sendRequest({ topic: be, method: "wc_sessionPing", params: {} }), { done: ve, resolve: Ee, reject: Se } = st();
        this.events.once(ft("session_ping", ye), ({ error: Oe }) => {
          Oe ? Se(Oe) : Ee();
        }), await ve();
      } else
        this.client.core.pairing.pairings.keys.includes(be) && await this.client.core.pairing.ping({ topic: be });
    }, this.emit = async (fe) => {
      await this.isInitialized(), await this.isValidEmit(fe);
      const { topic: be, event: ye, chainId: ve } = fe;
      await this.sendRequest({ topic: be, method: "wc_sessionEvent", params: { event: ye, chainId: ve } });
    }, this.disconnect = async (fe) => {
      await this.isInitialized(), await this.isValidDisconnect(fe);
      const { topic: be } = fe;
      this.client.session.keys.includes(be) ? (await this.sendRequest({ topic: be, method: "wc_sessionDelete", params: U$3("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession(be)) : await this.client.core.pairing.disconnect({ topic: be });
    }, this.find = (fe) => (this.isInitialized(), this.client.session.getAll().filter((be) => $t(be, fe))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (fe) => {
      if (fe.pairingTopic)
        try {
          const be = this.client.core.pairing.pairings.get(fe.pairingTopic), ye = this.client.core.pairing.pairings.getAll().filter((ve) => {
            var Ee, Se;
            return ((Ee = ve.peerMetadata) == null ? void 0 : Ee.url) && ((Se = ve.peerMetadata) == null ? void 0 : Se.url) === fe.peer.metadata.url && ve.topic && ve.topic !== be.topic;
          });
          if (ye.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${ye.length} duplicate pairing(s)`), await Promise.all(ye.map((ve) => this.client.core.pairing.disconnect({ topic: ve.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (be) {
          this.client.logger.error(be);
        }
    }, this.deleteSession = async (fe, be) => {
      const { self: ye } = this.client.session.get(fe);
      await this.client.core.relayer.unsubscribe(fe), this.client.session.delete(fe, U$3("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(ye.publicKey) && await this.client.core.crypto.deleteKeyPair(ye.publicKey), this.client.core.crypto.keychain.has(fe) && await this.client.core.crypto.deleteSymKey(fe), be || this.client.core.expirer.del(fe), this.client.core.storage.removeItem(H).catch((ve) => this.client.logger.warn(ve));
    }, this.deleteProposal = async (fe, be) => {
      await Promise.all([this.client.proposal.delete(fe, U$3("USER_DISCONNECTED")), be ? Promise.resolve() : this.client.core.expirer.del(fe)]);
    }, this.deletePendingSessionRequest = async (fe, be, ye = !1) => {
      await Promise.all([this.client.pendingRequest.delete(fe, be), ye ? Promise.resolve() : this.client.core.expirer.del(fe)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((ve) => ve.id !== fe), ye && (this.sessionRequestQueue.state = E.idle);
    }, this.setExpiry = async (fe, be) => {
      this.client.session.keys.includes(fe) && await this.client.session.update(fe, { expiry: be }), this.client.core.expirer.set(fe, be);
    }, this.setProposal = async (fe, be) => {
      await this.client.proposal.set(fe, be), this.client.core.expirer.set(fe, be.expiry);
    }, this.setPendingSessionRequest = async (fe) => {
      const be = V.wc_sessionRequest.req.ttl, { id: ye, topic: ve, params: Ee } = fe;
      await this.client.pendingRequest.set(ye, { id: ye, topic: ve, params: Ee }), be && this.client.core.expirer.set(ye, lt(be));
    }, this.sendRequest = async (fe) => {
      const { topic: be, method: ye, params: ve, expiry: Ee, relayRpcId: Se, clientRpcId: Oe, throwOnFailedPublish: xe } = fe, me = formatJsonRpcRequest(ye, ve, Oe);
      if (q$1() && pe.includes(ye)) {
        const lr = Mn(JSON.stringify(me));
        this.client.core.verify.register({ attestationId: lr });
      }
      const we = await this.client.core.crypto.encode(be, me), ur = V[ye].req;
      return Ee && (ur.ttl = Ee), Se && (ur.id = Se), this.client.core.history.set(be, me), xe ? (ur.internal = b(g$1({}, ur.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(be, we, ur)) : this.client.core.relayer.publish(be, we, ur).catch((lr) => this.client.logger.error(lr)), me.id;
    }, this.sendResult = async (fe) => {
      const { id: be, topic: ye, result: ve, throwOnFailedPublish: Ee } = fe, Se = formatJsonRpcResult(be, ve), Oe = await this.client.core.crypto.encode(ye, Se), xe = await this.client.core.history.get(ye, be), me = V[xe.request.method].res;
      Ee ? (me.internal = b(g$1({}, me.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(ye, Oe, me)) : this.client.core.relayer.publish(ye, Oe, me).catch((we) => this.client.logger.error(we)), await this.client.core.history.resolve(Se);
    }, this.sendError = async (fe, be, ye) => {
      const ve = formatJsonRpcError(fe, ye), Ee = await this.client.core.crypto.encode(be, ve), Se = await this.client.core.history.get(be, fe), Oe = V[Se.request.method].res;
      this.client.core.relayer.publish(be, Ee, Oe), await this.client.core.history.resolve(ve);
    }, this.cleanup = async () => {
      const fe = [], be = [];
      this.client.session.getAll().forEach((ye) => {
        dt(ye.expiry) && fe.push(ye.topic);
      }), this.client.proposal.getAll().forEach((ye) => {
        dt(ye.expiry) && be.push(ye.id);
      }), await Promise.all([...fe.map((ye) => this.deleteSession(ye)), ...be.map((ye) => this.deleteProposal(ye))]);
    }, this.onRelayEventRequest = async (fe) => {
      this.requestQueue.queue.push(fe), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === E.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = E.active;
        const fe = this.requestQueue.queue.shift();
        if (fe)
          try {
            this.processRequest(fe), await new Promise((be) => setTimeout(be, 300));
          } catch (be) {
            this.client.logger.warn(be);
          }
      }
      this.requestQueue.state = E.idle;
    }, this.processRequest = (fe) => {
      const { topic: be, payload: ye } = fe, ve = ye.method;
      switch (ve) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(be, ye);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(be, ye);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(be, ye);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(be, ye);
        case "wc_sessionPing":
          return this.onSessionPingRequest(be, ye);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(be, ye);
        case "wc_sessionRequest":
          return this.onSessionRequest(be, ye);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(be, ye);
        default:
          return this.client.logger.info(`Unsupported request method ${ve}`);
      }
    }, this.onRelayEventResponse = async (fe) => {
      const { topic: be, payload: ye } = fe, ve = (await this.client.core.history.get(be, ye.id)).request.method;
      switch (ve) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(be, ye);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(be, ye);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(be, ye);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(be, ye);
        case "wc_sessionPing":
          return this.onSessionPingResponse(be, ye);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(be, ye);
        default:
          return this.client.logger.info(`Unsupported response method ${ve}`);
      }
    }, this.onRelayEventUnknownPayload = (fe) => {
      const { topic: be } = fe, { message: ye } = N$1("MISSING_OR_INVALID", `Decoded payload on topic ${be} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(ye);
    }, this.onSessionProposeRequest = async (fe, be) => {
      const { params: ye, id: ve } = be;
      try {
        this.isValidConnect(g$1({}, be.params));
        const Ee = lt(cjs$4.FIVE_MINUTES), Se = g$1({ id: ve, pairingTopic: fe, expiry: Ee }, ye);
        await this.setProposal(ve, Se);
        const Oe = Mn(JSON.stringify(be)), xe = await this.getVerifyContext(Oe, Se.proposer.metadata);
        this.client.events.emit("session_proposal", { id: ve, params: Se, verifyContext: xe });
      } catch (Ee) {
        await this.sendError(ve, fe, Ee), this.client.logger.error(Ee);
      }
    }, this.onSessionProposeResponse = async (fe, be) => {
      const { id: ye } = be;
      if (isJsonRpcResult(be)) {
        const { result: ve } = be;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: ve });
        const Ee = this.client.proposal.get(ye);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: Ee });
        const Se = Ee.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: Se });
        const Oe = ve.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: Oe });
        const xe = await this.client.core.crypto.generateSharedKey(Se, Oe);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: xe });
        const me = await this.client.core.relayer.subscribe(xe);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: me }), await this.client.core.pairing.activate({ topic: fe });
      } else
        isJsonRpcError(be) && (await this.client.proposal.delete(ye, U$3("USER_DISCONNECTED")), this.events.emit(ft("session_connect"), { error: be.error }));
    }, this.onSessionSettleRequest = async (fe, be) => {
      const { id: ye, params: ve } = be;
      try {
        this.isValidSessionSettleRequest(ve);
        const { relay: Ee, controller: Se, expiry: Oe, namespaces: xe, requiredNamespaces: me, optionalNamespaces: we, sessionProperties: ur, pairingTopic: lr } = be.params, Ar = g$1({ topic: fe, relay: Ee, expiry: Oe, namespaces: xe, acknowledged: !0, pairingTopic: lr, requiredNamespaces: me, optionalNamespaces: we, controller: Se.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: Se.publicKey, metadata: Se.metadata } }, ur && { sessionProperties: ur });
        await this.sendResult({ id: be.id, topic: fe, result: !0 }), this.events.emit(ft("session_connect"), { session: Ar }), this.cleanupDuplicatePairings(Ar);
      } catch (Ee) {
        await this.sendError(ye, fe, Ee), this.client.logger.error(Ee);
      }
    }, this.onSessionSettleResponse = async (fe, be) => {
      const { id: ye } = be;
      isJsonRpcResult(be) ? (await this.client.session.update(fe, { acknowledged: !0 }), this.events.emit(ft("session_approve", ye), {})) : isJsonRpcError(be) && (await this.client.session.delete(fe, U$3("USER_DISCONNECTED")), this.events.emit(ft("session_approve", ye), { error: be.error }));
    }, this.onSessionUpdateRequest = async (fe, be) => {
      const { params: ye, id: ve } = be;
      try {
        const Ee = `${fe}_session_update`, Se = er.get(Ee);
        if (Se && this.isRequestOutOfSync(Se, ve)) {
          this.client.logger.info(`Discarding out of sync request - ${ve}`);
          return;
        }
        this.isValidUpdate(g$1({ topic: fe }, ye)), await this.client.session.update(fe, { namespaces: ye.namespaces }), await this.sendResult({ id: ve, topic: fe, result: !0 }), this.client.events.emit("session_update", { id: ve, topic: fe, params: ye }), er.set(Ee, ve);
      } catch (Ee) {
        await this.sendError(ve, fe, Ee), this.client.logger.error(Ee);
      }
    }, this.isRequestOutOfSync = (fe, be) => parseInt(be.toString().slice(0, -3)) <= parseInt(fe.toString().slice(0, -3)), this.onSessionUpdateResponse = (fe, be) => {
      const { id: ye } = be;
      isJsonRpcResult(be) ? this.events.emit(ft("session_update", ye), {}) : isJsonRpcError(be) && this.events.emit(ft("session_update", ye), { error: be.error });
    }, this.onSessionExtendRequest = async (fe, be) => {
      const { id: ye } = be;
      try {
        this.isValidExtend({ topic: fe }), await this.setExpiry(fe, lt(C)), await this.sendResult({ id: ye, topic: fe, result: !0 }), this.client.events.emit("session_extend", { id: ye, topic: fe });
      } catch (ve) {
        await this.sendError(ye, fe, ve), this.client.logger.error(ve);
      }
    }, this.onSessionExtendResponse = (fe, be) => {
      const { id: ye } = be;
      isJsonRpcResult(be) ? this.events.emit(ft("session_extend", ye), {}) : isJsonRpcError(be) && this.events.emit(ft("session_extend", ye), { error: be.error });
    }, this.onSessionPingRequest = async (fe, be) => {
      const { id: ye } = be;
      try {
        this.isValidPing({ topic: fe }), await this.sendResult({ id: ye, topic: fe, result: !0 }), this.client.events.emit("session_ping", { id: ye, topic: fe });
      } catch (ve) {
        await this.sendError(ye, fe, ve), this.client.logger.error(ve);
      }
    }, this.onSessionPingResponse = (fe, be) => {
      const { id: ye } = be;
      setTimeout(() => {
        isJsonRpcResult(be) ? this.events.emit(ft("session_ping", ye), {}) : isJsonRpcError(be) && this.events.emit(ft("session_ping", ye), { error: be.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (fe, be) => {
      const { id: ye } = be;
      try {
        this.isValidDisconnect({ topic: fe, reason: be.params }), await Promise.all([new Promise((ve) => {
          this.client.core.relayer.once(D$1.publish, async () => {
            ve(await this.deleteSession(fe));
          });
        }), this.sendResult({ id: ye, topic: fe, result: !0 })]), this.client.events.emit("session_delete", { id: ye, topic: fe });
      } catch (ve) {
        this.client.logger.error(ve);
      }
    }, this.onSessionRequest = async (fe, be) => {
      const { id: ye, params: ve } = be;
      try {
        this.isValidRequest(g$1({ topic: fe }, ve)), await this.setPendingSessionRequest({ id: ye, topic: fe, params: ve }), this.addSessionRequestToSessionRequestQueue({ id: ye, topic: fe, params: ve }), await this.processSessionRequestQueue();
      } catch (Ee) {
        await this.sendError(ye, fe, Ee), this.client.logger.error(Ee);
      }
    }, this.onSessionRequestResponse = (fe, be) => {
      const { id: ye } = be;
      isJsonRpcResult(be) ? this.events.emit(ft("session_request", ye), { result: be.result }) : isJsonRpcError(be) && this.events.emit(ft("session_request", ye), { error: be.error });
    }, this.onSessionEventRequest = async (fe, be) => {
      const { id: ye, params: ve } = be;
      try {
        const Ee = `${fe}_session_event_${ve.event.name}`, Se = er.get(Ee);
        if (Se && this.isRequestOutOfSync(Se, ye)) {
          this.client.logger.info(`Discarding out of sync request - ${ye}`);
          return;
        }
        this.isValidEmit(g$1({ topic: fe }, ve)), this.client.events.emit("session_event", { id: ye, topic: fe, params: ve }), er.set(Ee, ye);
      } catch (Ee) {
        await this.sendError(ye, fe, Ee), this.client.logger.error(Ee);
      }
    }, this.addSessionRequestToSessionRequestQueue = (fe) => {
      this.sessionRequestQueue.queue.push(fe);
    }, this.cleanupAfterResponse = (fe) => {
      this.deletePendingSessionRequest(fe.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = E.idle, this.processSessionRequestQueue();
      }, cjs$4.toMiliseconds(this.requestQueueDelay));
    }, this.processSessionRequestQueue = async () => {
      if (this.sessionRequestQueue.state === E.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const fe = this.sessionRequestQueue.queue[0];
      if (!fe) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        const { id: be, topic: ye, params: ve } = fe, Ee = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", ve, be))), Se = this.client.session.get(ye), Oe = await this.getVerifyContext(Ee, Se.peer.metadata);
        this.sessionRequestQueue.state = E.active, this.client.events.emit("session_request", { id: be, topic: ye, params: ve, verifyContext: Oe });
      } catch (be) {
        this.client.logger.error(be);
      }
    }, this.isValidConnect = async (fe) => {
      if (!xt(fe)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(fe)}`);
        throw new Error(Oe);
      }
      const { pairingTopic: be, requiredNamespaces: ye, optionalNamespaces: ve, sessionProperties: Ee, relays: Se } = fe;
      if (w$1(be) || await this.isValidPairingTopic(be), !Kt(Se, !0)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `connect() relays: ${Se}`);
        throw new Error(Oe);
      }
      !w$1(ye) && B(ye) !== 0 && this.validateNamespaces(ye, "requiredNamespaces"), !w$1(ve) && B(ve) !== 0 && this.validateNamespaces(ve, "optionalNamespaces"), w$1(Ee) || this.validateSessionProps(Ee, "sessionProperties");
    }, this.validateNamespaces = (fe, be) => {
      const ye = Mt(fe, "connect()", be);
      if (ye)
        throw new Error(ye.message);
    }, this.isValidApprove = async (fe) => {
      if (!xt(fe))
        throw new Error(N$1("MISSING_OR_INVALID", `approve() params: ${fe}`).message);
      const { id: be, namespaces: ye, relayProtocol: ve, sessionProperties: Ee } = fe;
      await this.isValidProposalId(be);
      const Se = this.client.proposal.get(be), Oe = cn(ye, "approve()");
      if (Oe)
        throw new Error(Oe.message);
      const xe = un(Se.requiredNamespaces, ye, "approve()");
      if (xe)
        throw new Error(xe.message);
      if (!h$1(ve, !0)) {
        const { message: me } = N$1("MISSING_OR_INVALID", `approve() relayProtocol: ${ve}`);
        throw new Error(me);
      }
      w$1(Ee) || this.validateSessionProps(Ee, "sessionProperties");
    }, this.isValidReject = async (fe) => {
      if (!xt(fe)) {
        const { message: ve } = N$1("MISSING_OR_INVALID", `reject() params: ${fe}`);
        throw new Error(ve);
      }
      const { id: be, reason: ye } = fe;
      if (await this.isValidProposalId(be), !Ft(ye)) {
        const { message: ve } = N$1("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(ye)}`);
        throw new Error(ve);
      }
    }, this.isValidSessionSettleRequest = (fe) => {
      if (!xt(fe)) {
        const { message: xe } = N$1("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${fe}`);
        throw new Error(xe);
      }
      const { relay: be, controller: ye, namespaces: ve, expiry: Ee } = fe;
      if (!an(be)) {
        const { message: xe } = N$1("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(xe);
      }
      const Se = Vt(ye, "onSessionSettleRequest()");
      if (Se)
        throw new Error(Se.message);
      const Oe = cn(ve, "onSessionSettleRequest()");
      if (Oe)
        throw new Error(Oe.message);
      if (dt(Ee)) {
        const { message: xe } = N$1("EXPIRED", "onSessionSettleRequest()");
        throw new Error(xe);
      }
    }, this.isValidUpdate = async (fe) => {
      if (!xt(fe)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `update() params: ${fe}`);
        throw new Error(Oe);
      }
      const { topic: be, namespaces: ye } = fe;
      await this.isValidSessionTopic(be);
      const ve = this.client.session.get(be), Ee = cn(ye, "update()");
      if (Ee)
        throw new Error(Ee.message);
      const Se = un(ve.requiredNamespaces, ye, "update()");
      if (Se)
        throw new Error(Se.message);
    }, this.isValidExtend = async (fe) => {
      if (!xt(fe)) {
        const { message: ye } = N$1("MISSING_OR_INVALID", `extend() params: ${fe}`);
        throw new Error(ye);
      }
      const { topic: be } = fe;
      await this.isValidSessionTopic(be);
    }, this.isValidRequest = async (fe) => {
      if (!xt(fe)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `request() params: ${fe}`);
        throw new Error(Oe);
      }
      const { topic: be, request: ye, chainId: ve, expiry: Ee } = fe;
      await this.isValidSessionTopic(be);
      const { namespaces: Se } = this.client.session.get(be);
      if (!Gt(Se, ve)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `request() chainId: ${ve}`);
        throw new Error(Oe);
      }
      if (!Ht(ye)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `request() ${JSON.stringify(ye)}`);
        throw new Error(Oe);
      }
      if (!Wt(Se, ve, ye.method)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `request() method: ${ye.method}`);
        throw new Error(Oe);
      }
      if (Ee && !Qt(Ee, U$2)) {
        const { message: Oe } = N$1("MISSING_OR_INVALID", `request() expiry: ${Ee}. Expiry must be a number (in seconds) between ${U$2.min} and ${U$2.max}`);
        throw new Error(Oe);
      }
    }, this.isValidRespond = async (fe) => {
      if (!xt(fe)) {
        const { message: ve } = N$1("MISSING_OR_INVALID", `respond() params: ${fe}`);
        throw new Error(ve);
      }
      const { topic: be, response: ye } = fe;
      if (await this.isValidSessionTopic(be), !qt(ye)) {
        const { message: ve } = N$1("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(ye)}`);
        throw new Error(ve);
      }
    }, this.isValidPing = async (fe) => {
      if (!xt(fe)) {
        const { message: ye } = N$1("MISSING_OR_INVALID", `ping() params: ${fe}`);
        throw new Error(ye);
      }
      const { topic: be } = fe;
      await this.isValidSessionOrPairingTopic(be);
    }, this.isValidEmit = async (fe) => {
      if (!xt(fe)) {
        const { message: Se } = N$1("MISSING_OR_INVALID", `emit() params: ${fe}`);
        throw new Error(Se);
      }
      const { topic: be, event: ye, chainId: ve } = fe;
      await this.isValidSessionTopic(be);
      const { namespaces: Ee } = this.client.session.get(be);
      if (!Gt(Ee, ve)) {
        const { message: Se } = N$1("MISSING_OR_INVALID", `emit() chainId: ${ve}`);
        throw new Error(Se);
      }
      if (!Bt(ye)) {
        const { message: Se } = N$1("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(ye)}`);
        throw new Error(Se);
      }
      if (!zt(Ee, ve, ye.name)) {
        const { message: Se } = N$1("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(ye)}`);
        throw new Error(Se);
      }
    }, this.isValidDisconnect = async (fe) => {
      if (!xt(fe)) {
        const { message: ye } = N$1("MISSING_OR_INVALID", `disconnect() params: ${fe}`);
        throw new Error(ye);
      }
      const { topic: be } = fe;
      await this.isValidSessionOrPairingTopic(be);
    }, this.getVerifyContext = async (fe, be) => {
      const ye = { verified: { verifyUrl: be.verifyUrl || Q$1, validation: "UNKNOWN", origin: be.url || "" } };
      try {
        const ve = await this.client.core.verify.resolve({ attestationId: fe, verifyUrl: be.verifyUrl });
        ve && (ye.verified.origin = ve, ye.verified.validation = ve === new URL(be.url).origin ? "VALID" : "INVALID");
      } catch (ve) {
        this.client.logger.error(ve);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(ye)}`), ye;
    }, this.validateSessionProps = (fe, be) => {
      Object.values(fe).forEach((ye) => {
        if (!h$1(ye, !1)) {
          const { message: ve } = N$1("MISSING_OR_INVALID", `${be} must be in Record<string, string> format. Received: ${JSON.stringify(ye)}`);
          throw new Error(ve);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$1("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D$1.message, async (e) => {
      const { topic: fe, message: be } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(be)))
        return;
      const ye = await this.client.core.crypto.decode(fe, be);
      try {
        isJsonRpcRequest(ye) ? (this.client.core.history.set(fe, ye), this.onRelayEventRequest({ topic: fe, payload: ye })) : isJsonRpcResponse(ye) ? (await this.client.core.history.resolve(ye), await this.onRelayEventResponse({ topic: fe, payload: ye }), this.client.core.history.delete(fe, ye.id)) : this.onRelayEventUnknownPayload({ topic: fe, payload: ye });
      } catch (ve) {
        this.client.logger.error(ve);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(w$2.expired, async (e) => {
      const { topic: fe, id: be } = ut(e.target);
      if (be && this.client.pendingRequest.keys.includes(be))
        return await this.deletePendingSessionRequest(be, N$1("EXPIRED"), !0);
      fe ? this.client.session.keys.includes(fe) && (await this.deleteSession(fe, !0), this.client.events.emit("session_expire", { topic: fe })) : be && (await this.deleteProposal(be, !0), this.client.events.emit("proposal_expire", { id: be }));
    });
  }
  isValidPairingTopic(e) {
    if (!h$1(e, !1)) {
      const { message: fe } = N$1("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(fe);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: fe } = N$1("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(fe);
    }
    if (dt(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: fe } = N$1("EXPIRED", `pairing topic: ${e}`);
      throw new Error(fe);
    }
  }
  async isValidSessionTopic(e) {
    if (!h$1(e, !1)) {
      const { message: fe } = N$1("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(fe);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: fe } = N$1("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(fe);
    }
    if (dt(this.client.session.get(e).expiry)) {
      await this.deleteSession(e);
      const { message: fe } = N$1("EXPIRED", `session topic: ${e}`);
      throw new Error(fe);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (h$1(e, !1)) {
      const { message: fe } = N$1("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(fe);
    } else {
      const { message: fe } = N$1("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(fe);
    }
  }
  async isValidProposalId(e) {
    if (!Lt(e)) {
      const { message: fe } = N$1("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(fe);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: fe } = N$1("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(fe);
    }
    if (dt(this.client.proposal.get(e).expiry)) {
      await this.deleteProposal(e);
      const { message: fe } = N$1("EXPIRED", `proposal id: ${e}`);
      throw new Error(fe);
    }
  }
}
class ps extends Ut {
  constructor(e, fe) {
    super(e, fe, ne, G), this.core = e, this.logger = fe;
  }
}
class hs extends Ut {
  constructor(e, fe) {
    super(e, fe, ae, G), this.core = e, this.logger = fe;
  }
}
class ds extends Ut {
  constructor(e, fe) {
    super(e, fe, le, G, (be) => be.id), this.core = e, this.logger = fe;
  }
}
class Q extends b$1 {
  constructor(e) {
    super(e), this.protocol = J, this.version = X, this.name = M.name, this.events = new eventsExports.EventEmitter(), this.on = (be, ye) => this.events.on(be, ye), this.once = (be, ye) => this.events.once(be, ye), this.off = (be, ye) => this.events.off(be, ye), this.removeListener = (be, ye) => this.events.removeListener(be, ye), this.removeAllListeners = (be) => this.events.removeAllListeners(be), this.connect = async (be) => {
      try {
        return await this.engine.connect(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.pair = async (be) => {
      try {
        return await this.engine.pair(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.approve = async (be) => {
      try {
        return await this.engine.approve(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.reject = async (be) => {
      try {
        return await this.engine.reject(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.update = async (be) => {
      try {
        return await this.engine.update(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.extend = async (be) => {
      try {
        return await this.engine.extend(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.request = async (be) => {
      try {
        return await this.engine.request(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.respond = async (be) => {
      try {
        return await this.engine.respond(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.ping = async (be) => {
      try {
        return await this.engine.ping(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.emit = async (be) => {
      try {
        return await this.engine.emit(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.disconnect = async (be) => {
      try {
        return await this.engine.disconnect(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.find = (be) => {
      try {
        return this.engine.find(be);
      } catch (ye) {
        throw this.logger.error(ye.message), ye;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (be) {
        throw this.logger.error(be.message), be;
      }
    }, this.name = (e == null ? void 0 : e.name) || M.name, this.metadata = (e == null ? void 0 : e.metadata) || zn();
    const fe = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : cjs$3.pino(cjs$3.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || M.logger }));
    this.core = (e == null ? void 0 : e.core) || new xr(e), this.logger = cjs$3.generateChildLogger(fe, this.name), this.session = new hs(this.core, this.logger), this.proposal = new ps(this.core, this.logger), this.pendingRequest = new ds(this.core, this.logger), this.engine = new ls(this);
  }
  static async init(e) {
    const fe = new Q(e);
    return await fe.initialize(), fe;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var P = Object.defineProperty, x = Object.defineProperties, N = Object.getOwnPropertyDescriptors, j = Object.getOwnPropertySymbols, U$1 = Object.prototype.hasOwnProperty, T = Object.prototype.propertyIsEnumerable, W = (v, e, fe) => e in v ? P(v, e, { enumerable: !0, configurable: !0, writable: !0, value: fe }) : v[e] = fe, q = (v, e) => {
  for (var fe in e || (e = {}))
    U$1.call(e, fe) && W(v, fe, e[fe]);
  if (j)
    for (var fe of j(e))
      T.call(e, fe) && W(v, fe, e[fe]);
  return v;
}, A = (v, e) => x(v, N(e)), S = (v, e, fe) => {
  if (!e.has(v))
    throw TypeError("Cannot " + fe);
}, a = (v, e, fe) => (S(v, e, "read from private field"), fe ? fe.call(v) : e.get(v)), l = (v, e, fe) => {
  if (e.has(v))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(v) : e.set(v, fe);
}, y = (v, e, fe, be) => (S(v, e, "write to private field"), be ? be.call(v, fe) : e.set(v, fe), fe), o = (v, e, fe) => (S(v, e, "access private method"), fe), h, p, w, i, u, _, n, r, m, g;
class z {
  constructor(e) {
    l(this, u), l(this, n), l(this, m), l(this, h, void 0), l(this, p, void 0), l(this, w, void 0), l(this, i, void 0), y(this, h, e), y(this, p, o(this, u, _).call(this)), o(this, n, r).call(this);
  }
  async connect(e) {
    const { requiredNamespaces: fe, optionalNamespaces: be } = e;
    return new Promise(async (ye, ve) => {
      await o(this, n, r).call(this);
      const Ee = a(this, p).subscribeModal((xe) => {
        xe.open || (Ee(), ve(new Error("Modal closed")));
      }), { uri: Se, approval: Oe } = await a(this, i).connect(e);
      if (Se) {
        const xe = /* @__PURE__ */ new Set();
        fe && Object.values(fe).forEach(({ chains: me }) => {
          me && me.forEach((we) => xe.add(we));
        }), be && Object.values(be).forEach(({ chains: me }) => {
          me && me.forEach((we) => xe.add(we));
        }), await a(this, p).openModal({ uri: Se, chains: Array.from(xe) });
      }
      try {
        const xe = await Oe();
        ye(xe);
      } catch (xe) {
        ve(xe);
      } finally {
        Ee(), a(this, p).closeModal();
      }
    });
  }
  async disconnect(e) {
    await o(this, n, r).call(this), await a(this, i).disconnect(e);
  }
  async request(e) {
    return await o(this, n, r).call(this), await a(this, i).request(e);
  }
  async getSessions() {
    return await o(this, n, r).call(this), a(this, i).session.getAll();
  }
  async getSession() {
    return await o(this, n, r).call(this), a(this, i).session.getAll().at(-1);
  }
  async onSessionEvent(e) {
    await o(this, n, r).call(this), a(this, i).on("session_event", e);
  }
  async offSessionEvent(e) {
    await o(this, n, r).call(this), a(this, i).off("session_event", e);
  }
  async onSessionUpdate(e) {
    await o(this, n, r).call(this), a(this, i).on("session_update", e);
  }
  async offSessionUpdate(e) {
    await o(this, n, r).call(this), a(this, i).off("session_update", e);
  }
  async onSessionDelete(e) {
    await o(this, n, r).call(this), a(this, i).on("session_delete", e);
  }
  async offSessionDelete(e) {
    await o(this, n, r).call(this), a(this, i).off("session_delete", e);
  }
  async onSessionExpire(e) {
    await o(this, n, r).call(this), a(this, i).on("session_expire", e);
  }
  async offSessionExpire(e) {
    await o(this, n, r).call(this), a(this, i).off("session_expire", e);
  }
}
h = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakSet(), _ = function() {
  const { modalOptions: v, projectId: e } = a(this, h);
  return new d$1(A(q({}, v), { projectId: e }));
}, n = /* @__PURE__ */ new WeakSet(), r = async function() {
  return a(this, i) ? !0 : (!a(this, w) && typeof window < "u" && y(this, w, o(this, m, g).call(this)), a(this, w));
}, m = /* @__PURE__ */ new WeakSet(), g = async function() {
  y(this, i, await Q.init({ metadata: a(this, h).metadata, projectId: a(this, h).projectId, relayUrl: a(this, h).relayUrl }));
  const v = await a(this, i).core.crypto.getClientId();
  try {
    localStorage.setItem("WCM_WALLETCONNECT_CLIENT_ID", v);
  } catch {
    console.info("Unable to set client id");
  }
};
const _t = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
function U(v, e) {
  const { message: fe, code: be } = _t[v];
  return { message: e ? `${fe} ${e}` : fe, code: be };
}
var lib$2 = {}, indexUtils = {}, utils$1 = {}, src$2 = { exports: {} };
function base$1(v) {
  if (v.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), fe = 0; fe < e.length; fe++)
    e[fe] = 255;
  for (var be = 0; be < v.length; be++) {
    var ye = v.charAt(be), ve = ye.charCodeAt(0);
    if (e[ve] !== 255)
      throw new TypeError(ye + " is ambiguous");
    e[ve] = be;
  }
  var Ee = v.length, Se = v.charAt(0), Oe = Math.log(Ee) / Math.log(256), xe = Math.log(256) / Math.log(Ee);
  function me(lr) {
    if (lr instanceof Uint8Array || (ArrayBuffer.isView(lr) ? lr = new Uint8Array(lr.buffer, lr.byteOffset, lr.byteLength) : Array.isArray(lr) && (lr = Uint8Array.from(lr))), !(lr instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (lr.length === 0)
      return "";
    for (var Ar = 0, Br = 0, Xr = 0, eo = lr.length; Xr !== eo && lr[Xr] === 0; )
      Xr++, Ar++;
    for (var jr = (eo - Xr) * xe + 1 >>> 0, kr = new Uint8Array(jr); Xr !== eo; ) {
      for (var $r = lr[Xr], Vr = 0, Mr = jr - 1; ($r !== 0 || Vr < Br) && Mr !== -1; Mr--, Vr++)
        $r += 256 * kr[Mr] >>> 0, kr[Mr] = $r % Ee >>> 0, $r = $r / Ee >>> 0;
      if ($r !== 0)
        throw new Error("Non-zero carry");
      Br = Vr, Xr++;
    }
    for (var gr = jr - Br; gr !== jr && kr[gr] === 0; )
      gr++;
    for (var Fr = Se.repeat(Ar); gr < jr; ++gr)
      Fr += v.charAt(kr[gr]);
    return Fr;
  }
  function we(lr) {
    if (typeof lr != "string")
      throw new TypeError("Expected String");
    if (lr.length === 0)
      return new Uint8Array();
    var Ar = 0;
    if (lr[Ar] !== " ") {
      for (var Br = 0, Xr = 0; lr[Ar] === Se; )
        Br++, Ar++;
      for (var eo = (lr.length - Ar) * Oe + 1 >>> 0, jr = new Uint8Array(eo); lr[Ar]; ) {
        var kr = e[lr.charCodeAt(Ar)];
        if (kr === 255)
          return;
        for (var $r = 0, Vr = eo - 1; (kr !== 0 || $r < Xr) && Vr !== -1; Vr--, $r++)
          kr += Ee * jr[Vr] >>> 0, jr[Vr] = kr % 256 >>> 0, kr = kr / 256 >>> 0;
        if (kr !== 0)
          throw new Error("Non-zero carry");
        Xr = $r, Ar++;
      }
      if (lr[Ar] !== " ") {
        for (var Mr = eo - Xr; Mr !== eo && jr[Mr] === 0; )
          Mr++;
        for (var gr = new Uint8Array(Br + (eo - Mr)), Fr = Br; Mr !== eo; )
          gr[Fr++] = jr[Mr++];
        return gr;
      }
    }
  }
  function ur(lr) {
    var Ar = we(lr);
    if (Ar)
      return Ar;
    throw new Error("Non-base" + Ee + " character");
  }
  return {
    encode: me,
    decodeUnsafe: we,
    decode: ur
  };
}
var src$1 = base$1;
const textDecoder = new TextDecoder(), decodeText$1 = (v) => textDecoder.decode(v), textEncoder = new TextEncoder(), encodeText$2 = (v) => textEncoder.encode(v);
function concat(v, e) {
  const fe = new Uint8Array(e);
  let be = 0;
  for (const ye of v)
    fe.set(ye, be), be += ye.length;
  return fe;
}
var util$9 = { decodeText: decodeText$1, encodeText: encodeText$2, concat };
const { encodeText: encodeText$1 } = util$9;
let Base$1 = class {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor(e, fe, be, ye) {
    this.name = e, this.code = fe, this.codeBuf = encodeText$1(this.code), this.alphabet = ye, this.codec = be(ye);
  }
  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode(e) {
    return this.codec.encode(e);
  }
  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode(e) {
    for (const fe of e)
      if (this.alphabet && this.alphabet.indexOf(fe) < 0)
        throw new Error(`invalid character '${fe}' in '${e}'`);
    return this.codec.decode(e);
  }
};
var base = Base$1;
const decode = (v, e, fe) => {
  const be = {};
  for (let xe = 0; xe < e.length; ++xe)
    be[e[xe]] = xe;
  let ye = v.length;
  for (; v[ye - 1] === "="; )
    --ye;
  const ve = new Uint8Array(ye * fe / 8 | 0);
  let Ee = 0, Se = 0, Oe = 0;
  for (let xe = 0; xe < ye; ++xe) {
    const me = be[v[xe]];
    if (me === void 0)
      throw new SyntaxError("Invalid character " + v[xe]);
    Se = Se << fe | me, Ee += fe, Ee >= 8 && (Ee -= 8, ve[Oe++] = 255 & Se >> Ee);
  }
  if (Ee >= fe || 255 & Se << 8 - Ee)
    throw new SyntaxError("Unexpected end of data");
  return ve;
}, encode = (v, e, fe) => {
  const be = e[e.length - 1] === "=", ye = (1 << fe) - 1;
  let ve = "", Ee = 0, Se = 0;
  for (let Oe = 0; Oe < v.length; ++Oe)
    for (Se = Se << 8 | v[Oe], Ee += 8; Ee > fe; )
      Ee -= fe, ve += e[ye & Se >> Ee];
  if (Ee && (ve += e[ye & Se << fe - Ee]), be)
    for (; ve.length * fe & 7; )
      ve += "=";
  return ve;
}, rfc4648$1 = (v) => (e) => ({
  /**
   * @param {Uint8Array} input
   * @returns {string}
   */
  encode(fe) {
    return encode(fe, e, v);
  },
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(fe) {
    return decode(fe, e, v);
  }
});
var rfc4648_1 = { rfc4648: rfc4648$1 };
const baseX = src$1, Base = base, { rfc4648 } = rfc4648_1, { decodeText, encodeText } = util$9, identity = () => ({
  encode: decodeText,
  decode: encodeText
}), constants = [
  ["identity", "\0", identity, ""],
  ["base2", "0", rfc4648(1), "01"],
  ["base8", "7", rfc4648(3), "01234567"],
  ["base10", "9", baseX, "0123456789"],
  ["base16", "f", rfc4648(4), "0123456789abcdef"],
  ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
  ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
  ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
  ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
  ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
  ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
  ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
  ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
  ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
  ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
  ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
  ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
  ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
  ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
  ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
  ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
  ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
  ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
], names = constants.reduce(
  (v, e) => (v[e[0]] = new Base(e[0], e[1], e[2], e[3]), v),
  /** @type {Record<BaseName,Base>} */
  {}
), codes = constants.reduce(
  (v, e) => (v[e[1]] = names[e[0]], v),
  /** @type {Record<BaseCode,Base>} */
  {}
);
var constants_1 = {
  names,
  codes
};
(function(v, e) {
  const fe = constants_1, { encodeText: be, decodeText: ye, concat: ve } = util$9;
  function Ee(Br, Xr) {
    if (!Xr)
      throw new Error("requires an encoded Uint8Array");
    const { name: eo, codeBuf: jr } = we(Br);
    return me(eo, Xr), ve([jr, Xr], jr.length + Xr.length);
  }
  function Se(Br, Xr) {
    const eo = we(Br), jr = be(eo.encode(Xr));
    return ve([eo.codeBuf, jr], eo.codeBuf.length + jr.length);
  }
  function Oe(Br) {
    Br instanceof Uint8Array && (Br = ye(Br));
    const Xr = Br[0];
    return ["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(Xr) && (Br = Br.toLowerCase()), we(
      /** @type {BaseCode} */
      Br[0]
    ).decode(Br.substring(1));
  }
  function xe(Br) {
    if (Br instanceof Uint8Array && (Br = ye(Br)), Object.prototype.toString.call(Br) !== "[object String]")
      return !1;
    try {
      return we(
        /** @type {BaseCode} */
        Br[0]
      ).name;
    } catch {
      return !1;
    }
  }
  function me(Br, Xr) {
    we(Br).decode(ye(Xr));
  }
  function we(Br) {
    if (Object.prototype.hasOwnProperty.call(
      fe.names,
      /** @type {BaseName} */
      Br
    ))
      return fe.names[
        /** @type {BaseName} */
        Br
      ];
    if (Object.prototype.hasOwnProperty.call(
      fe.codes,
      /** @type {BaseCode} */
      Br
    ))
      return fe.codes[
        /** @type {BaseCode} */
        Br
      ];
    throw new Error(`Unsupported encoding: ${Br}`);
  }
  function ur(Br) {
    return Br instanceof Uint8Array && (Br = ye(Br)), we(
      /** @type {BaseCode} */
      Br[0]
    );
  }
  e = v.exports = Ee, e.encode = Se, e.decode = Oe, e.isEncoded = xe, e.encoding = we, e.encodingFromData = ur;
  const lr = Object.freeze(fe.names), Ar = Object.freeze(fe.codes);
  e.names = lr, e.codes = Ar;
})(src$2, src$2.exports);
var srcExports$1 = src$2.exports, sha256 = {}, _sha2 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number(v) {
  if (!Number.isSafeInteger(v) || v < 0)
    throw new Error(`Wrong positive integer: ${v}`);
}
_assert.number = number;
function bool(v) {
  if (typeof v != "boolean")
    throw new Error(`Expected boolean, not ${v}`);
}
_assert.bool = bool;
function bytes(v, ...e) {
  if (!(v instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(v.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${v.length}`);
}
_assert.bytes = bytes;
function hash(v) {
  if (typeof v != "function" || typeof v.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(v.outputLen), number(v.blockLen);
}
_assert.hash = hash;
function exists(v, e = !0) {
  if (v.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && v.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(v, e) {
  bytes(v);
  const fe = e.outputLen;
  if (v.length < fe)
    throw new Error(`digestInto() expects output buffer of length at least ${fe}`);
}
_assert.output = output;
const assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
_assert.default = assert;
var utils = {}, crypto$1 = {};
Object.defineProperty(crypto$1, "__esModule", { value: !0 });
crypto$1.crypto = void 0;
crypto$1.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(v) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(v, "__esModule", { value: !0 }), v.randomBytes = v.wrapXOFConstructorWithOpts = v.wrapConstructorWithOpts = v.wrapConstructor = v.checkOpts = v.Hash = v.concatBytes = v.toBytes = v.utf8ToBytes = v.asyncLoop = v.nextTick = v.hexToBytes = v.bytesToHex = v.isLE = v.rotr = v.createView = v.u32 = v.u8 = void 0;
  const e = crypto$1, fe = (Mr) => Mr instanceof Uint8Array, be = (Mr) => new Uint8Array(Mr.buffer, Mr.byteOffset, Mr.byteLength);
  v.u8 = be;
  const ye = (Mr) => new Uint32Array(Mr.buffer, Mr.byteOffset, Math.floor(Mr.byteLength / 4));
  v.u32 = ye;
  const ve = (Mr) => new DataView(Mr.buffer, Mr.byteOffset, Mr.byteLength);
  v.createView = ve;
  const Ee = (Mr, gr) => Mr << 32 - gr | Mr >>> gr;
  if (v.rotr = Ee, v.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !v.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const Se = Array.from({ length: 256 }, (Mr, gr) => gr.toString(16).padStart(2, "0"));
  function Oe(Mr) {
    if (!fe(Mr))
      throw new Error("Uint8Array expected");
    let gr = "";
    for (let Fr = 0; Fr < Mr.length; Fr++)
      gr += Se[Mr[Fr]];
    return gr;
  }
  v.bytesToHex = Oe;
  function xe(Mr) {
    if (typeof Mr != "string")
      throw new Error("hex string expected, got " + typeof Mr);
    const gr = Mr.length;
    if (gr % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + gr);
    const Fr = new Uint8Array(gr / 2);
    for (let Zr = 0; Zr < Fr.length; Zr++) {
      const Wr = Zr * 2, qr = Mr.slice(Wr, Wr + 2), Qr = Number.parseInt(qr, 16);
      if (Number.isNaN(Qr) || Qr < 0)
        throw new Error("Invalid byte sequence");
      Fr[Zr] = Qr;
    }
    return Fr;
  }
  v.hexToBytes = xe;
  const me = async () => {
  };
  v.nextTick = me;
  async function we(Mr, gr, Fr) {
    let Zr = Date.now();
    for (let Wr = 0; Wr < Mr; Wr++) {
      Fr(Wr);
      const qr = Date.now() - Zr;
      qr >= 0 && qr < gr || (await (0, v.nextTick)(), Zr += qr);
    }
  }
  v.asyncLoop = we;
  function ur(Mr) {
    if (typeof Mr != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof Mr}`);
    return new Uint8Array(new TextEncoder().encode(Mr));
  }
  v.utf8ToBytes = ur;
  function lr(Mr) {
    if (typeof Mr == "string" && (Mr = ur(Mr)), !fe(Mr))
      throw new Error(`expected Uint8Array, got ${typeof Mr}`);
    return Mr;
  }
  v.toBytes = lr;
  function Ar(...Mr) {
    const gr = new Uint8Array(Mr.reduce((Zr, Wr) => Zr + Wr.length, 0));
    let Fr = 0;
    return Mr.forEach((Zr) => {
      if (!fe(Zr))
        throw new Error("Uint8Array expected");
      gr.set(Zr, Fr), Fr += Zr.length;
    }), gr;
  }
  v.concatBytes = Ar;
  class Br {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  v.Hash = Br;
  const Xr = (Mr) => Object.prototype.toString.call(Mr) === "[object Object]" && Mr.constructor === Object;
  function eo(Mr, gr) {
    if (gr !== void 0 && (typeof gr != "object" || !Xr(gr)))
      throw new Error("Options should be object or undefined");
    return Object.assign(Mr, gr);
  }
  v.checkOpts = eo;
  function jr(Mr) {
    const gr = (Zr) => Mr().update(lr(Zr)).digest(), Fr = Mr();
    return gr.outputLen = Fr.outputLen, gr.blockLen = Fr.blockLen, gr.create = () => Mr(), gr;
  }
  v.wrapConstructor = jr;
  function kr(Mr) {
    const gr = (Zr, Wr) => Mr(Wr).update(lr(Zr)).digest(), Fr = Mr({});
    return gr.outputLen = Fr.outputLen, gr.blockLen = Fr.blockLen, gr.create = (Zr) => Mr(Zr), gr;
  }
  v.wrapConstructorWithOpts = kr;
  function $r(Mr) {
    const gr = (Zr, Wr) => Mr(Wr).update(lr(Zr)).digest(), Fr = Mr({});
    return gr.outputLen = Fr.outputLen, gr.blockLen = Fr.blockLen, gr.create = (Zr) => Mr(Zr), gr;
  }
  v.wrapXOFConstructorWithOpts = $r;
  function Vr(Mr = 32) {
    if (e.crypto && typeof e.crypto.getRandomValues == "function")
      return e.crypto.getRandomValues(new Uint8Array(Mr));
    throw new Error("crypto.getRandomValues must be defined");
  }
  v.randomBytes = Vr;
})(utils);
Object.defineProperty(_sha2, "__esModule", { value: !0 });
_sha2.SHA2 = void 0;
const _assert_js_1 = _assert, utils_js_1$2 = utils;
function setBigUint64(v, e, fe, be) {
  if (typeof v.setBigUint64 == "function")
    return v.setBigUint64(e, fe, be);
  const ye = BigInt(32), ve = BigInt(4294967295), Ee = Number(fe >> ye & ve), Se = Number(fe & ve), Oe = be ? 4 : 0, xe = be ? 0 : 4;
  v.setUint32(e + Oe, Ee, be), v.setUint32(e + xe, Se, be);
}
class SHA2 extends utils_js_1$2.Hash {
  constructor(e, fe, be, ye) {
    super(), this.blockLen = e, this.outputLen = fe, this.padOffset = be, this.isLE = ye, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, utils_js_1$2.createView)(this.buffer);
  }
  update(e) {
    _assert_js_1.default.exists(this);
    const { view: fe, buffer: be, blockLen: ye } = this;
    e = (0, utils_js_1$2.toBytes)(e);
    const ve = e.length;
    for (let Ee = 0; Ee < ve; ) {
      const Se = Math.min(ye - this.pos, ve - Ee);
      if (Se === ye) {
        const Oe = (0, utils_js_1$2.createView)(e);
        for (; ye <= ve - Ee; Ee += ye)
          this.process(Oe, Ee);
        continue;
      }
      be.set(e.subarray(Ee, Ee + Se), this.pos), this.pos += Se, Ee += Se, this.pos === ye && (this.process(fe, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    _assert_js_1.default.exists(this), _assert_js_1.default.output(e, this), this.finished = !0;
    const { buffer: fe, view: be, blockLen: ye, isLE: ve } = this;
    let { pos: Ee } = this;
    fe[Ee++] = 128, this.buffer.subarray(Ee).fill(0), this.padOffset > ye - Ee && (this.process(be, 0), Ee = 0);
    for (let we = Ee; we < ye; we++)
      fe[we] = 0;
    setBigUint64(be, ye - 8, BigInt(this.length * 8), ve), this.process(be, 0);
    const Se = (0, utils_js_1$2.createView)(e), Oe = this.outputLen;
    if (Oe % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const xe = Oe / 4, me = this.get();
    if (xe > me.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let we = 0; we < xe; we++)
      Se.setUint32(4 * we, me[we], ve);
  }
  digest() {
    const { buffer: e, outputLen: fe } = this;
    this.digestInto(e);
    const be = e.slice(0, fe);
    return this.destroy(), be;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: fe, buffer: be, length: ye, finished: ve, destroyed: Ee, pos: Se } = this;
    return e.length = ye, e.pos = Se, e.finished = ve, e.destroyed = Ee, ye % fe && e.buffer.set(be), e;
  }
}
_sha2.SHA2 = SHA2;
Object.defineProperty(sha256, "__esModule", { value: !0 });
sha256.sha224 = sha256.sha256 = void 0;
const _sha2_js_1$1 = _sha2, utils_js_1$1 = utils, Chi = (v, e, fe) => v & e ^ ~v & fe, Maj = (v, e, fe) => v & e ^ v & fe ^ e & fe, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1$1.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: e, B: fe, C: be, D: ye, E: ve, F: Ee, G: Se, H: Oe } = this;
    return [e, fe, be, ye, ve, Ee, Se, Oe];
  }
  // prettier-ignore
  set(e, fe, be, ye, ve, Ee, Se, Oe) {
    this.A = e | 0, this.B = fe | 0, this.C = be | 0, this.D = ye | 0, this.E = ve | 0, this.F = Ee | 0, this.G = Se | 0, this.H = Oe | 0;
  }
  process(e, fe) {
    for (let we = 0; we < 16; we++, fe += 4)
      SHA256_W[we] = e.getUint32(fe, !1);
    for (let we = 16; we < 64; we++) {
      const ur = SHA256_W[we - 15], lr = SHA256_W[we - 2], Ar = (0, utils_js_1$1.rotr)(ur, 7) ^ (0, utils_js_1$1.rotr)(ur, 18) ^ ur >>> 3, Br = (0, utils_js_1$1.rotr)(lr, 17) ^ (0, utils_js_1$1.rotr)(lr, 19) ^ lr >>> 10;
      SHA256_W[we] = Br + SHA256_W[we - 7] + Ar + SHA256_W[we - 16] | 0;
    }
    let { A: be, B: ye, C: ve, D: Ee, E: Se, F: Oe, G: xe, H: me } = this;
    for (let we = 0; we < 64; we++) {
      const ur = (0, utils_js_1$1.rotr)(Se, 6) ^ (0, utils_js_1$1.rotr)(Se, 11) ^ (0, utils_js_1$1.rotr)(Se, 25), lr = me + ur + Chi(Se, Oe, xe) + SHA256_K[we] + SHA256_W[we] | 0, Br = ((0, utils_js_1$1.rotr)(be, 2) ^ (0, utils_js_1$1.rotr)(be, 13) ^ (0, utils_js_1$1.rotr)(be, 22)) + Maj(be, ye, ve) | 0;
      me = xe, xe = Oe, Oe = Se, Se = Ee + lr | 0, Ee = ve, ve = ye, ye = be, be = lr + Br | 0;
    }
    be = be + this.A | 0, ye = ye + this.B | 0, ve = ve + this.C | 0, Ee = Ee + this.D | 0, Se = Se + this.E | 0, Oe = Oe + this.F | 0, xe = xe + this.G | 0, me = me + this.H | 0, this.set(be, ye, ve, Ee, Se, Oe, xe, me);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256());
sha256.sha224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA224());
var ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _sha2_js_1 = _sha2, utils_js_1 = utils, Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = Uint8Array.from({ length: 16 }, (v, e) => e), Pi = Id.map((v) => (9 * v + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let v = 0; v < 4; v++)
  for (let e of [idxL, idxR])
    e.push(e[v].map((fe) => Rho[fe]));
const shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((v) => new Uint8Array(v)), shiftsL = idxL.map((v, e) => v.map((fe) => shifts[e][fe])), shiftsR = idxR.map((v, e) => v.map((fe) => shifts[e][fe])), Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), rotl = (v, e) => v << e | v >>> 32 - e;
function f(v, e, fe, be) {
  return v === 0 ? e ^ fe ^ be : v === 1 ? e & fe | ~e & be : v === 2 ? (e | ~fe) ^ be : v === 3 ? e & be | fe & ~be : e ^ (fe | ~be);
}
const BUF = new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e, h1: fe, h2: be, h3: ye, h4: ve } = this;
    return [e, fe, be, ye, ve];
  }
  set(e, fe, be, ye, ve) {
    this.h0 = e | 0, this.h1 = fe | 0, this.h2 = be | 0, this.h3 = ye | 0, this.h4 = ve | 0;
  }
  process(e, fe) {
    for (let lr = 0; lr < 16; lr++, fe += 4)
      BUF[lr] = e.getUint32(fe, !0);
    let be = this.h0 | 0, ye = be, ve = this.h1 | 0, Ee = ve, Se = this.h2 | 0, Oe = Se, xe = this.h3 | 0, me = xe, we = this.h4 | 0, ur = we;
    for (let lr = 0; lr < 5; lr++) {
      const Ar = 4 - lr, Br = Kl[lr], Xr = Kr[lr], eo = idxL[lr], jr = idxR[lr], kr = shiftsL[lr], $r = shiftsR[lr];
      for (let Vr = 0; Vr < 16; Vr++) {
        const Mr = rotl(be + f(lr, ve, Se, xe) + BUF[eo[Vr]] + Br, kr[Vr]) + we | 0;
        be = we, we = xe, xe = rotl(Se, 10) | 0, Se = ve, ve = Mr;
      }
      for (let Vr = 0; Vr < 16; Vr++) {
        const Mr = rotl(ye + f(Ar, Ee, Oe, me) + BUF[jr[Vr]] + Xr, $r[Vr]) + ur | 0;
        ye = ur, ur = me, me = rotl(Oe, 10) | 0, Oe = Ee, Ee = Mr;
      }
    }
    this.set(this.h1 + Se + me | 0, this.h2 + xe + ur | 0, this.h3 + we + ye | 0, this.h4 + be + Ee | 0, this.h0 + ve + Oe | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
const nested$1 = {
  koinos: {
    nested: {
      contracts: {
        nested: {
          token: {
            options: {
              go_package: "github.com/koinos/koinos-proto-golang/koinos/contracts/token"
            },
            nested: {
              name_arguments: {
                fields: {}
              },
              name_result: {
                fields: {
                  value: {
                    type: "string",
                    id: 1
                  }
                }
              },
              symbol_arguments: {
                fields: {}
              },
              symbol_result: {
                fields: {
                  value: {
                    type: "string",
                    id: 1
                  }
                }
              },
              decimals_arguments: {
                fields: {}
              },
              decimals_result: {
                fields: {
                  value: {
                    type: "uint32",
                    id: 1
                  }
                }
              },
              total_supply_arguments: {
                fields: {}
              },
              total_supply_result: {
                fields: {
                  value: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              balance_of_arguments: {
                fields: {
                  owner: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  }
                }
              },
              balance_of_result: {
                fields: {
                  value: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              transfer_arguments: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  to: {
                    type: "bytes",
                    id: 2,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 3,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              transfer_result: {
                fields: {}
              },
              mint_arguments: {
                fields: {
                  to: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              mint_result: {
                fields: {}
              },
              burn_arguments: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              burn_result: {
                fields: {}
              },
              balance_object: {
                fields: {
                  value: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              mana_balance_object: {
                fields: {
                  balance: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  },
                  mana: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  },
                  last_mana_update: {
                    type: "uint64",
                    id: 3,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              burn_event: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              mint_event: {
                fields: {
                  to: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              transfer_event: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  to: {
                    type: "bytes",
                    id: 2,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 3,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, require$$3$1 = {
  nested: nested$1
};
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(v, e, fe, be) {
  be === void 0 && (be = fe);
  var ye = Object.getOwnPropertyDescriptor(e, fe);
  (!ye || ("get" in ye ? !e.__esModule : ye.writable || ye.configurable)) && (ye = { enumerable: !0, get: function() {
    return e[fe];
  } }), Object.defineProperty(v, be, ye);
} : function(v, e, fe, be) {
  be === void 0 && (be = fe), v[be] = e[fe];
}), __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(v, e) {
  Object.defineProperty(v, "default", { enumerable: !0, value: e });
} : function(v, e) {
  v.default = e;
}), __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(v) {
  if (v && v.__esModule)
    return v;
  var e = {};
  if (v != null)
    for (var fe in v)
      fe !== "default" && Object.prototype.hasOwnProperty.call(v, fe) && __createBinding$3(e, v, fe);
  return __setModuleDefault$3(e, v), e;
}, __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(v) {
  return v && v.__esModule ? v : { default: v };
};
Object.defineProperty(utils$1, "__esModule", { value: !0 });
utils$1.tokenAbi = utils$1.btypeEncode = utils$1.btypeDecode = utils$1.btypeEncodeValue = utils$1.btypeDecodeValue = utils$1.parseUnits = utils$1.formatUnits = utils$1.isChecksumWif = utils$1.isChecksumAddress = utils$1.isChecksum = utils$1.bitcoinAddress = utils$1.bitcoinDecode = utils$1.bitcoinEncode = utils$1.calculateMerkleRoot = utils$1.decodeBase64 = utils$1.multihash = utils$1.encodeBase64 = utils$1.decodeBase64url = utils$1.encodeBase64url = utils$1.decodeBase58 = utils$1.encodeBase58 = utils$1.toHexString = utils$1.toUint8Array = void 0;
const multibase = __importStar$3(srcExports$1), sha256_1$2 = sha256, ripemd160_1 = ripemd160, token_proto_json_1 = __importDefault$2(require$$3$1);
function toUint8Array(v) {
  const e = v.match(/[\dA-F]{2}/gi);
  if (!e)
    throw new Error("Invalid hex");
  return new Uint8Array(
    e.map((fe) => parseInt(fe, 16))
    // convert to integers
  );
}
utils$1.toUint8Array = toUint8Array;
function toHexString(v) {
  return Array.from(v).map((e) => `0${Number(e).toString(16)}`.slice(-2)).join("");
}
utils$1.toHexString = toHexString;
function encodeBase58(v) {
  return new TextDecoder().decode(multibase.encode("z", v)).slice(1);
}
utils$1.encodeBase58 = encodeBase58;
function decodeBase58(v) {
  return multibase.decode(`z${v}`);
}
utils$1.decodeBase58 = decodeBase58;
function encodeBase64url(v) {
  return new TextDecoder().decode(multibase.encode("U", v)).slice(1);
}
utils$1.encodeBase64url = encodeBase64url;
function decodeBase64url(v) {
  return multibase.decode(`U${v}`);
}
utils$1.decodeBase64url = decodeBase64url;
function encodeBase64(v) {
  return new TextDecoder().decode(multibase.encode("M", v)).slice(1);
}
utils$1.encodeBase64 = encodeBase64;
function multihash(v, e = "sha2-256") {
  switch (e) {
    case "sha2-256":
      return new Uint8Array([18, v.length, ...v]);
    default:
      throw new Error(`multihash code ${e} not supported`);
  }
}
utils$1.multihash = multihash;
function decodeBase64(v) {
  return multibase.decode(`M${v}`);
}
utils$1.decodeBase64 = decodeBase64;
function calculateMerkleRoot(v) {
  if (!v.length)
    return (0, sha256_1$2.sha256)(new Uint8Array());
  for (; v.length > 1; ) {
    for (let e = 0; e < v.length; e += 2)
      if (e + 1 < v.length) {
        const fe = v[e], be = v[e + 1], ye = (0, sha256_1$2.sha256)(new Uint8Array([...fe, ...be]));
        v[e / 2] = new Uint8Array(ye);
      } else
        v[e / 2] = v[e];
    v = v.slice(0, Math.ceil(v.length / 2));
  }
  return v[0];
}
utils$1.calculateMerkleRoot = calculateMerkleRoot;
function bitcoinEncode(v, e, fe = !1) {
  let be, ye, ve;
  e === "public" ? (be = new Uint8Array(25), ye = new Uint8Array(21), be[0] = 0, ye[0] = 0, ve = 21) : (fe ? (be = new Uint8Array(38), ye = new Uint8Array(34), ve = 34, be[33] = 1, ye[33] = 1) : (be = new Uint8Array(37), ye = new Uint8Array(33), ve = 33), be[0] = 128, ye[0] = 128), ye.set(v, 1);
  const Ee = (0, sha256_1$2.sha256)(ye), Se = (0, sha256_1$2.sha256)(Ee), Oe = new Uint8Array(4);
  return Oe.set(Se.slice(0, 4)), be.set(v, 1), be.set(Oe, ve), encodeBase58(be);
}
utils$1.bitcoinEncode = bitcoinEncode;
function bitcoinDecode(v) {
  const e = decodeBase58(v), fe = new Uint8Array(32), be = new Uint8Array(4);
  return fe.set(e.slice(1, 33)), v[0] !== "5" ? be.set(e.slice(34, 38)) : be.set(e.slice(33, 37)), fe;
}
utils$1.bitcoinDecode = bitcoinDecode;
function bitcoinAddress(v) {
  const e = (0, sha256_1$2.sha256)(v), fe = (0, ripemd160_1.ripemd160)(e);
  return bitcoinEncode(fe, "public");
}
utils$1.bitcoinAddress = bitcoinAddress;
function isChecksum(v) {
  const e = v.length - 4, fe = new Uint8Array(e);
  fe.set(v.slice(0, e));
  const be = new Uint8Array(4);
  be.set(v.slice(e));
  const ye = (0, sha256_1$2.sha256)((0, sha256_1$2.sha256)(fe));
  for (let ve = 0; ve < 4; ve += 1)
    if (be[ve] !== ye[ve])
      return !1;
  return !0;
}
utils$1.isChecksum = isChecksum;
function isChecksumAddress(v) {
  const e = typeof v == "string" ? decodeBase58(v) : v;
  return e.length !== 25 || e[0] !== 0 ? !1 : isChecksum(e);
}
utils$1.isChecksumAddress = isChecksumAddress;
function isChecksumWif(v) {
  const e = typeof v == "string" ? decodeBase58(v) : v;
  return e.length !== 37 && e.length !== 38 || e.length === 38 && e[33] !== 1 || e[0] !== 128 ? !1 : isChecksum(e);
}
utils$1.isChecksumWif = isChecksumWif;
function formatUnits(v, e) {
  let fe = typeof v == "string" ? v : BigInt(v).toString();
  const be = fe[0] === "-" ? "-" : "";
  fe = fe.replace("-", "").padStart(e + 1, "0");
  const ye = fe.substring(0, fe.length - e).replace(/^0+(?=\d)/, ""), ve = fe.substring(fe.length - e);
  return `${be}${ye}.${ve}`.replace(/(\.0+)?(0+)$/, "");
}
utils$1.formatUnits = formatUnits;
function parseUnits(v, e) {
  const fe = v[0] === "-" ? "-" : "";
  let [be, ye] = v.replace("-", "").replace(",", ".").split(".");
  if (ye || (ye = ""), ye = ye.padEnd(e, "0"), ye.length > e) {
    const ve = ye.substring(e);
    ye = ye.substring(0, e), ve.startsWith("5") && (ye = (BigInt(ye) + BigInt(1)).toString());
  }
  return `${fe}${`${be}${ye}`.replace(/^0+(?=\d)/, "")}`;
}
utils$1.parseUnits = parseUnits;
function copyValue(v) {
  return typeof v == "string" || typeof v == "number" ? v : JSON.parse(JSON.stringify(v));
}
function btypeDecodeValue(v, e, fe) {
  if (e.type !== "bytes")
    return copyValue(v);
  const be = v;
  if (!e.btype)
    return decodeBase64url(be);
  switch (e.btype) {
    case "BASE58":
      return decodeBase58(be);
    case "CONTRACT_ID":
    case "ADDRESS":
      const ye = decodeBase58(be);
      if (fe && !isChecksumAddress(ye))
        throw new Error(`${be} is an invalid address`);
      return ye;
    case "BASE64":
      return decodeBase64url(be);
    case "HEX":
    case "BLOCK_ID":
    case "TRANSACTION_ID":
      return toUint8Array(be.slice(2));
    default:
      throw new Error(`unknown btype ${e.btype}`);
  }
}
utils$1.btypeDecodeValue = btypeDecodeValue;
function btypeEncodeValue(v, e, fe) {
  if (e.type !== "bytes")
    return copyValue(v);
  const be = v;
  if (!e.btype)
    return encodeBase64url(be);
  switch (e.btype) {
    case "BASE58":
      return encodeBase58(be);
    case "CONTRACT_ID":
    case "ADDRESS":
      const ye = encodeBase58(be);
      if (fe && !isChecksumAddress(be))
        throw new Error(`${ye} is an invalid address`);
      return ye;
    case "BASE64":
      return encodeBase64url(be);
    case "HEX":
    case "BLOCK_ID":
    case "TRANSACTION_ID":
      return `0x${toHexString(be)}`;
    default:
      throw new Error(`unknown btype ${e.btype}`);
  }
}
utils$1.btypeEncodeValue = btypeEncodeValue;
function btypeDecode(v, e, fe) {
  if (typeof v != "object")
    return v;
  const be = {};
  return Object.keys(e).forEach((ye) => {
    v[ye] && (e[ye].rule === "repeated" ? be[ye] = v[ye].map((ve) => e[ye].subtypes ? btypeDecode(ve, e[ye].subtypes, fe) : btypeDecodeValue(ve, e[ye], fe)) : e[ye].subtypes ? be[ye] = btypeDecode(v[ye], e[ye].subtypes, fe) : be[ye] = btypeDecodeValue(v[ye], e[ye], fe));
  }), be;
}
utils$1.btypeDecode = btypeDecode;
function btypeEncode(v, e, fe) {
  if (typeof v != "object")
    return v;
  const be = {};
  return Object.keys(e).forEach((ye) => {
    v[ye] && (e[ye].rule === "repeated" ? be[ye] = v[ye].map((ve) => e[ye].subtypes ? btypeEncode(ve, e[ye].subtypes, fe) : btypeEncodeValue(ve, e[ye], fe)) : e[ye].subtypes ? be[ye] = btypeEncode(v[ye], e[ye].subtypes, fe) : be[ye] = btypeEncodeValue(v[ye], e[ye], fe));
  }), be;
}
utils$1.btypeEncode = btypeEncode;
utils$1.tokenAbi = {
  methods: {
    name: {
      entry_point: 2191741823,
      argument: "name_arguments",
      return: "name_result",
      read_only: !0
    },
    symbol: {
      entry_point: 3077209249,
      argument: "symbol_arguments",
      return: "symbol_result",
      read_only: !0
    },
    decimals: {
      entry_point: 4001430831,
      argument: "decimals_arguments",
      return: "decimals_result",
      read_only: !0
    },
    totalSupply: {
      entry_point: 2967091508,
      argument: "total_supply_arguments",
      return: "total_supply_result",
      read_only: !0
    },
    balanceOf: {
      entry_point: 1550980247,
      argument: "balance_of_arguments",
      return: "balance_of_result",
      read_only: !0,
      default_output: { value: "0" }
    },
    transfer: {
      entry_point: 670398154,
      argument: "transfer_arguments",
      return: "transfer_result"
    },
    mint: {
      entry_point: 3698268091,
      argument: "mint_arguments",
      return: "mint_result"
    },
    burn: {
      entry_point: 2241834181,
      argument: "burn_arguments",
      return: "burn_result"
    }
  },
  koilib_types: token_proto_json_1.default
};
var utilsNode = {}, Serializer$1 = {}, src = { exports: {} }, indexLight = { exports: {} }, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise$1;
function asPromise$1(v, e) {
  for (var fe = new Array(arguments.length - 1), be = 0, ye = 2, ve = !0; ye < arguments.length; )
    fe[be++] = arguments[ye++];
  return new Promise(function(Se, Oe) {
    fe[be] = function(me) {
      if (ve)
        if (ve = !1, me)
          Oe(me);
        else {
          for (var we = new Array(arguments.length - 1), ur = 0; ur < we.length; )
            we[ur++] = arguments[ur];
          Se.apply(null, we);
        }
    };
    try {
      v.apply(e || null, fe);
    } catch (xe) {
      ve && (ve = !1, Oe(xe));
    }
  });
}
var base64$1 = {};
(function(v) {
  var e = v;
  e.length = function(Se) {
    var Oe = Se.length;
    if (!Oe)
      return 0;
    for (var xe = 0; --Oe % 4 > 1 && Se.charAt(Oe) === "="; )
      ++xe;
    return Math.ceil(Se.length * 3) / 4 - xe;
  };
  for (var fe = new Array(64), be = new Array(123), ye = 0; ye < 64; )
    be[fe[ye] = ye < 26 ? ye + 65 : ye < 52 ? ye + 71 : ye < 62 ? ye - 4 : ye - 59 | 43] = ye++;
  e.encode = function(Se, Oe, xe) {
    for (var me = null, we = [], ur = 0, lr = 0, Ar; Oe < xe; ) {
      var Br = Se[Oe++];
      switch (lr) {
        case 0:
          we[ur++] = fe[Br >> 2], Ar = (Br & 3) << 4, lr = 1;
          break;
        case 1:
          we[ur++] = fe[Ar | Br >> 4], Ar = (Br & 15) << 2, lr = 2;
          break;
        case 2:
          we[ur++] = fe[Ar | Br >> 6], we[ur++] = fe[Br & 63], lr = 0;
          break;
      }
      ur > 8191 && ((me || (me = [])).push(String.fromCharCode.apply(String, we)), ur = 0);
    }
    return lr && (we[ur++] = fe[Ar], we[ur++] = 61, lr === 1 && (we[ur++] = 61)), me ? (ur && me.push(String.fromCharCode.apply(String, we.slice(0, ur))), me.join("")) : String.fromCharCode.apply(String, we.slice(0, ur));
  };
  var ve = "invalid encoding";
  e.decode = function(Se, Oe, xe) {
    for (var me = xe, we = 0, ur, lr = 0; lr < Se.length; ) {
      var Ar = Se.charCodeAt(lr++);
      if (Ar === 61 && we > 1)
        break;
      if ((Ar = be[Ar]) === void 0)
        throw Error(ve);
      switch (we) {
        case 0:
          ur = Ar, we = 1;
          break;
        case 1:
          Oe[xe++] = ur << 2 | (Ar & 48) >> 4, ur = Ar, we = 2;
          break;
        case 2:
          Oe[xe++] = (ur & 15) << 4 | (Ar & 60) >> 2, ur = Ar, we = 3;
          break;
        case 3:
          Oe[xe++] = (ur & 3) << 6 | Ar, we = 0;
          break;
      }
    }
    if (we === 1)
      throw Error(ve);
    return xe - me;
  }, e.test = function(Se) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(Se);
  };
})(base64$1);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function(e, fe, be) {
  return (this._listeners[e] || (this._listeners[e] = [])).push({
    fn: fe,
    ctx: be || this
  }), this;
};
EventEmitter.prototype.off = function(e, fe) {
  if (e === void 0)
    this._listeners = {};
  else if (fe === void 0)
    this._listeners[e] = [];
  else
    for (var be = this._listeners[e], ye = 0; ye < be.length; )
      be[ye].fn === fe ? be.splice(ye, 1) : ++ye;
  return this;
};
EventEmitter.prototype.emit = function(e) {
  var fe = this._listeners[e];
  if (fe) {
    for (var be = [], ye = 1; ye < arguments.length; )
      be.push(arguments[ye++]);
    for (ye = 0; ye < fe.length; )
      fe[ye].fn.apply(fe[ye++].ctx, be);
  }
  return this;
};
var float = factory(factory);
function factory(v) {
  return typeof Float32Array < "u" ? function() {
    var e = new Float32Array([-0]), fe = new Uint8Array(e.buffer), be = fe[3] === 128;
    function ye(Oe, xe, me) {
      e[0] = Oe, xe[me] = fe[0], xe[me + 1] = fe[1], xe[me + 2] = fe[2], xe[me + 3] = fe[3];
    }
    function ve(Oe, xe, me) {
      e[0] = Oe, xe[me] = fe[3], xe[me + 1] = fe[2], xe[me + 2] = fe[1], xe[me + 3] = fe[0];
    }
    v.writeFloatLE = be ? ye : ve, v.writeFloatBE = be ? ve : ye;
    function Ee(Oe, xe) {
      return fe[0] = Oe[xe], fe[1] = Oe[xe + 1], fe[2] = Oe[xe + 2], fe[3] = Oe[xe + 3], e[0];
    }
    function Se(Oe, xe) {
      return fe[3] = Oe[xe], fe[2] = Oe[xe + 1], fe[1] = Oe[xe + 2], fe[0] = Oe[xe + 3], e[0];
    }
    v.readFloatLE = be ? Ee : Se, v.readFloatBE = be ? Se : Ee;
  }() : function() {
    function e(be, ye, ve, Ee) {
      var Se = ye < 0 ? 1 : 0;
      if (Se && (ye = -ye), ye === 0)
        be(1 / ye > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), ve, Ee);
      else if (isNaN(ye))
        be(2143289344, ve, Ee);
      else if (ye > 34028234663852886e22)
        be((Se << 31 | 2139095040) >>> 0, ve, Ee);
      else if (ye < 11754943508222875e-54)
        be((Se << 31 | Math.round(ye / 1401298464324817e-60)) >>> 0, ve, Ee);
      else {
        var Oe = Math.floor(Math.log(ye) / Math.LN2), xe = Math.round(ye * Math.pow(2, -Oe) * 8388608) & 8388607;
        be((Se << 31 | Oe + 127 << 23 | xe) >>> 0, ve, Ee);
      }
    }
    v.writeFloatLE = e.bind(null, writeUintLE), v.writeFloatBE = e.bind(null, writeUintBE);
    function fe(be, ye, ve) {
      var Ee = be(ye, ve), Se = (Ee >> 31) * 2 + 1, Oe = Ee >>> 23 & 255, xe = Ee & 8388607;
      return Oe === 255 ? xe ? NaN : Se * (1 / 0) : Oe === 0 ? Se * 1401298464324817e-60 * xe : Se * Math.pow(2, Oe - 150) * (xe + 8388608);
    }
    v.readFloatLE = fe.bind(null, readUintLE), v.readFloatBE = fe.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var e = new Float64Array([-0]), fe = new Uint8Array(e.buffer), be = fe[7] === 128;
    function ye(Oe, xe, me) {
      e[0] = Oe, xe[me] = fe[0], xe[me + 1] = fe[1], xe[me + 2] = fe[2], xe[me + 3] = fe[3], xe[me + 4] = fe[4], xe[me + 5] = fe[5], xe[me + 6] = fe[6], xe[me + 7] = fe[7];
    }
    function ve(Oe, xe, me) {
      e[0] = Oe, xe[me] = fe[7], xe[me + 1] = fe[6], xe[me + 2] = fe[5], xe[me + 3] = fe[4], xe[me + 4] = fe[3], xe[me + 5] = fe[2], xe[me + 6] = fe[1], xe[me + 7] = fe[0];
    }
    v.writeDoubleLE = be ? ye : ve, v.writeDoubleBE = be ? ve : ye;
    function Ee(Oe, xe) {
      return fe[0] = Oe[xe], fe[1] = Oe[xe + 1], fe[2] = Oe[xe + 2], fe[3] = Oe[xe + 3], fe[4] = Oe[xe + 4], fe[5] = Oe[xe + 5], fe[6] = Oe[xe + 6], fe[7] = Oe[xe + 7], e[0];
    }
    function Se(Oe, xe) {
      return fe[7] = Oe[xe], fe[6] = Oe[xe + 1], fe[5] = Oe[xe + 2], fe[4] = Oe[xe + 3], fe[3] = Oe[xe + 4], fe[2] = Oe[xe + 5], fe[1] = Oe[xe + 6], fe[0] = Oe[xe + 7], e[0];
    }
    v.readDoubleLE = be ? Ee : Se, v.readDoubleBE = be ? Se : Ee;
  }() : function() {
    function e(be, ye, ve, Ee, Se, Oe) {
      var xe = Ee < 0 ? 1 : 0;
      if (xe && (Ee = -Ee), Ee === 0)
        be(0, Se, Oe + ye), be(1 / Ee > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), Se, Oe + ve);
      else if (isNaN(Ee))
        be(0, Se, Oe + ye), be(2146959360, Se, Oe + ve);
      else if (Ee > 17976931348623157e292)
        be(0, Se, Oe + ye), be((xe << 31 | 2146435072) >>> 0, Se, Oe + ve);
      else {
        var me;
        if (Ee < 22250738585072014e-324)
          me = Ee / 5e-324, be(me >>> 0, Se, Oe + ye), be((xe << 31 | me / 4294967296) >>> 0, Se, Oe + ve);
        else {
          var we = Math.floor(Math.log(Ee) / Math.LN2);
          we === 1024 && (we = 1023), me = Ee * Math.pow(2, -we), be(me * 4503599627370496 >>> 0, Se, Oe + ye), be((xe << 31 | we + 1023 << 20 | me * 1048576 & 1048575) >>> 0, Se, Oe + ve);
        }
      }
    }
    v.writeDoubleLE = e.bind(null, writeUintLE, 0, 4), v.writeDoubleBE = e.bind(null, writeUintBE, 4, 0);
    function fe(be, ye, ve, Ee, Se) {
      var Oe = be(Ee, Se + ye), xe = be(Ee, Se + ve), me = (xe >> 31) * 2 + 1, we = xe >>> 20 & 2047, ur = 4294967296 * (xe & 1048575) + Oe;
      return we === 2047 ? ur ? NaN : me * (1 / 0) : we === 0 ? me * 5e-324 * ur : me * Math.pow(2, we - 1075) * (ur + 4503599627370496);
    }
    v.readDoubleLE = fe.bind(null, readUintLE, 0, 4), v.readDoubleBE = fe.bind(null, readUintBE, 4, 0);
  }(), v;
}
function writeUintLE(v, e, fe) {
  e[fe] = v & 255, e[fe + 1] = v >>> 8 & 255, e[fe + 2] = v >>> 16 & 255, e[fe + 3] = v >>> 24;
}
function writeUintBE(v, e, fe) {
  e[fe] = v >>> 24, e[fe + 1] = v >>> 16 & 255, e[fe + 2] = v >>> 8 & 255, e[fe + 3] = v & 255;
}
function readUintLE(v, e) {
  return (v[e] | v[e + 1] << 8 | v[e + 2] << 16 | v[e + 3] << 24) >>> 0;
}
function readUintBE(v, e) {
  return (v[e] << 24 | v[e + 1] << 16 | v[e + 2] << 8 | v[e + 3]) >>> 0;
}
var inquire_1 = inquire$1;
function inquire$1(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (v) {
  }
  return null;
}
var utf8$2 = {};
(function(v) {
  var e = v;
  e.length = function(be) {
    for (var ye = 0, ve = 0, Ee = 0; Ee < be.length; ++Ee)
      ve = be.charCodeAt(Ee), ve < 128 ? ye += 1 : ve < 2048 ? ye += 2 : (ve & 64512) === 55296 && (be.charCodeAt(Ee + 1) & 64512) === 56320 ? (++Ee, ye += 4) : ye += 3;
    return ye;
  }, e.read = function(be, ye, ve) {
    var Ee = ve - ye;
    if (Ee < 1)
      return "";
    for (var Se = null, Oe = [], xe = 0, me; ye < ve; )
      me = be[ye++], me < 128 ? Oe[xe++] = me : me > 191 && me < 224 ? Oe[xe++] = (me & 31) << 6 | be[ye++] & 63 : me > 239 && me < 365 ? (me = ((me & 7) << 18 | (be[ye++] & 63) << 12 | (be[ye++] & 63) << 6 | be[ye++] & 63) - 65536, Oe[xe++] = 55296 + (me >> 10), Oe[xe++] = 56320 + (me & 1023)) : Oe[xe++] = (me & 15) << 12 | (be[ye++] & 63) << 6 | be[ye++] & 63, xe > 8191 && ((Se || (Se = [])).push(String.fromCharCode.apply(String, Oe)), xe = 0);
    return Se ? (xe && Se.push(String.fromCharCode.apply(String, Oe.slice(0, xe))), Se.join("")) : String.fromCharCode.apply(String, Oe.slice(0, xe));
  }, e.write = function(be, ye, ve) {
    for (var Ee = ve, Se, Oe, xe = 0; xe < be.length; ++xe)
      Se = be.charCodeAt(xe), Se < 128 ? ye[ve++] = Se : Se < 2048 ? (ye[ve++] = Se >> 6 | 192, ye[ve++] = Se & 63 | 128) : (Se & 64512) === 55296 && ((Oe = be.charCodeAt(xe + 1)) & 64512) === 56320 ? (Se = 65536 + ((Se & 1023) << 10) + (Oe & 1023), ++xe, ye[ve++] = Se >> 18 | 240, ye[ve++] = Se >> 12 & 63 | 128, ye[ve++] = Se >> 6 & 63 | 128, ye[ve++] = Se & 63 | 128) : (ye[ve++] = Se >> 12 | 224, ye[ve++] = Se >> 6 & 63 | 128, ye[ve++] = Se & 63 | 128);
    return ve - Ee;
  };
})(utf8$2);
var pool_1 = pool;
function pool(v, e, fe) {
  var be = fe || 8192, ye = be >>> 1, ve = null, Ee = be;
  return function(Oe) {
    if (Oe < 1 || Oe > ye)
      return v(Oe);
    Ee + Oe > be && (ve = v(be), Ee = 0);
    var xe = e.call(ve, Ee, Ee += Oe);
    return Ee & 7 && (Ee = (Ee | 7) + 1), xe;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = e;
  var v = requireMinimal$1();
  function e(ve, Ee) {
    this.lo = ve >>> 0, this.hi = Ee >>> 0;
  }
  var fe = e.zero = new e(0, 0);
  fe.toNumber = function() {
    return 0;
  }, fe.zzEncode = fe.zzDecode = function() {
    return this;
  }, fe.length = function() {
    return 1;
  };
  var be = e.zeroHash = "\0\0\0\0\0\0\0\0";
  e.fromNumber = function(Ee) {
    if (Ee === 0)
      return fe;
    var Se = Ee < 0;
    Se && (Ee = -Ee);
    var Oe = Ee >>> 0, xe = (Ee - Oe) / 4294967296 >>> 0;
    return Se && (xe = ~xe >>> 0, Oe = ~Oe >>> 0, ++Oe > 4294967295 && (Oe = 0, ++xe > 4294967295 && (xe = 0))), new e(Oe, xe);
  }, e.from = function(Ee) {
    if (typeof Ee == "number")
      return e.fromNumber(Ee);
    if (v.isString(Ee))
      if (v.Long)
        Ee = v.Long.fromString(Ee);
      else
        return e.fromNumber(parseInt(Ee, 10));
    return Ee.low || Ee.high ? new e(Ee.low >>> 0, Ee.high >>> 0) : fe;
  }, e.prototype.toNumber = function(Ee) {
    if (!Ee && this.hi >>> 31) {
      var Se = ~this.lo + 1 >>> 0, Oe = ~this.hi >>> 0;
      return Se || (Oe = Oe + 1 >>> 0), -(Se + Oe * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, e.prototype.toLong = function(Ee) {
    return v.Long ? new v.Long(this.lo | 0, this.hi | 0, !!Ee) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!Ee };
  };
  var ye = String.prototype.charCodeAt;
  return e.fromHash = function(Ee) {
    return Ee === be ? fe : new e(
      (ye.call(Ee, 0) | ye.call(Ee, 1) << 8 | ye.call(Ee, 2) << 16 | ye.call(Ee, 3) << 24) >>> 0,
      (ye.call(Ee, 4) | ye.call(Ee, 5) << 8 | ye.call(Ee, 6) << 16 | ye.call(Ee, 7) << 24) >>> 0
    );
  }, e.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, e.prototype.zzEncode = function() {
    var Ee = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ Ee) >>> 0, this.lo = (this.lo << 1 ^ Ee) >>> 0, this;
  }, e.prototype.zzDecode = function() {
    var Ee = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ Ee) >>> 0, this.hi = (this.hi >>> 1 ^ Ee) >>> 0, this;
  }, e.prototype.length = function() {
    var Ee = this.lo, Se = (this.lo >>> 28 | this.hi << 4) >>> 0, Oe = this.hi >>> 24;
    return Oe === 0 ? Se === 0 ? Ee < 16384 ? Ee < 128 ? 1 : 2 : Ee < 2097152 ? 3 : 4 : Se < 16384 ? Se < 128 ? 5 : 6 : Se < 2097152 ? 7 : 8 : Oe < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  return hasRequiredMinimal$1 || (hasRequiredMinimal$1 = 1, function(v) {
    var e = v;
    e.asPromise = aspromise, e.base64 = base64$1, e.EventEmitter = eventemitter, e.float = float, e.inquire = inquire_1, e.utf8 = utf8$2, e.pool = pool_1, e.LongBits = requireLongbits(), e.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), e.global = e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, e.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), e.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), e.isInteger = Number.isInteger || /* istanbul ignore next */
    function(ve) {
      return typeof ve == "number" && isFinite(ve) && Math.floor(ve) === ve;
    }, e.isString = function(ve) {
      return typeof ve == "string" || ve instanceof String;
    }, e.isObject = function(ve) {
      return ve && typeof ve == "object";
    }, e.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    e.isSet = function(ve, Ee) {
      var Se = ve[Ee];
      return Se != null && ve.hasOwnProperty(Ee) ? typeof Se != "object" || (Array.isArray(Se) ? Se.length : Object.keys(Se).length) > 0 : !1;
    }, e.Buffer = function() {
      try {
        var ye = e.inquire("buffer").Buffer;
        return ye.prototype.utf8Write ? ye : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), e._Buffer_from = null, e._Buffer_allocUnsafe = null, e.newBuffer = function(ve) {
      return typeof ve == "number" ? e.Buffer ? e._Buffer_allocUnsafe(ve) : new e.Array(ve) : e.Buffer ? e._Buffer_from(ve) : typeof Uint8Array > "u" ? ve : new Uint8Array(ve);
    }, e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, e.Long = /* istanbul ignore next */
    e.global.dcodeIO && /* istanbul ignore next */
    e.global.dcodeIO.Long || /* istanbul ignore next */
    e.global.Long || e.inquire("long"), e.key2Re = /^true|false|0|1$/, e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, e.longToHash = function(ve) {
      return ve ? e.LongBits.from(ve).toHash() : e.LongBits.zeroHash;
    }, e.longFromHash = function(ve, Ee) {
      var Se = e.LongBits.fromHash(ve);
      return e.Long ? e.Long.fromBits(Se.lo, Se.hi, Ee) : Se.toNumber(!!Ee);
    };
    function fe(ye, ve, Ee) {
      for (var Se = Object.keys(ve), Oe = 0; Oe < Se.length; ++Oe)
        (ye[Se[Oe]] === void 0 || !Ee) && (ye[Se[Oe]] = ve[Se[Oe]]);
      return ye;
    }
    e.merge = fe, e.lcFirst = function(ve) {
      return ve.charAt(0).toLowerCase() + ve.substring(1);
    };
    function be(ye) {
      function ve(Ee, Se) {
        if (!(this instanceof ve))
          return new ve(Ee, Se);
        Object.defineProperty(this, "message", { get: function() {
          return Ee;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, ve) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), Se && fe(this, Se);
      }
      return ve.prototype = Object.create(Error.prototype, {
        constructor: {
          value: ve,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return ye;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), ve;
    }
    e.newError = be, e.ProtocolError = be("ProtocolError"), e.oneOfGetter = function(ve) {
      for (var Ee = {}, Se = 0; Se < ve.length; ++Se)
        Ee[ve[Se]] = 1;
      return function() {
        for (var Oe = Object.keys(this), xe = Oe.length - 1; xe > -1; --xe)
          if (Ee[Oe[xe]] === 1 && this[Oe[xe]] !== void 0 && this[Oe[xe]] !== null)
            return Oe[xe];
      };
    }, e.oneOfSetter = function(ve) {
      return function(Ee) {
        for (var Se = 0; Se < ve.length; ++Se)
          ve[Se] !== Ee && delete this[ve[Se]];
      };
    }, e.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, e._configure = function() {
      var ye = e.Buffer;
      if (!ye) {
        e._Buffer_from = e._Buffer_allocUnsafe = null;
        return;
      }
      e._Buffer_from = ye.from !== Uint8Array.from && ye.from || /* istanbul ignore next */
      function(Ee, Se) {
        return new ye(Ee, Se);
      }, e._Buffer_allocUnsafe = ye.allocUnsafe || /* istanbul ignore next */
      function(Ee) {
        return new ye(Ee);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer = Writer$1, util$8 = requireMinimal$1(), BufferWriter$1, LongBits$1 = util$8.LongBits, base64 = util$8.base64, utf8$1 = util$8.utf8;
function Op(v, e, fe) {
  this.fn = v, this.len = e, this.next = void 0, this.val = fe;
}
function noop() {
}
function State(v) {
  this.head = v.head, this.tail = v.tail, this.len = v.len, this.next = v.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;
}
var create$1 = function v() {
  return util$8.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$1();
Writer$1.alloc = function v(e) {
  return new util$8.Array(e);
};
util$8.Array !== Array && (Writer$1.alloc = util$8.pool(Writer$1.alloc, util$8.Array.prototype.subarray));
Writer$1.prototype._push = function v(e, fe, be) {
  return this.tail = this.tail.next = new Op(e, fe, be), this.len += fe, this;
};
function writeByte(v, e, fe) {
  e[fe] = v & 255;
}
function writeVarint32(v, e, fe) {
  for (; v > 127; )
    e[fe++] = v & 127 | 128, v >>>= 7;
  e[fe] = v;
}
function VarintOp(v, e) {
  this.len = v, this.next = void 0, this.val = e;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function v(e) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5,
    e
  )).len, this;
};
Writer$1.prototype.int32 = function v(e) {
  return e < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(e)) : this.uint32(e);
};
Writer$1.prototype.sint32 = function v(e) {
  return this.uint32((e << 1 ^ e >> 31) >>> 0);
};
function writeVarint64(v, e, fe) {
  for (; v.hi; )
    e[fe++] = v.lo & 127 | 128, v.lo = (v.lo >>> 7 | v.hi << 25) >>> 0, v.hi >>>= 7;
  for (; v.lo > 127; )
    e[fe++] = v.lo & 127 | 128, v.lo = v.lo >>> 7;
  e[fe++] = v.lo;
}
Writer$1.prototype.uint64 = function v(e) {
  var fe = LongBits$1.from(e);
  return this._push(writeVarint64, fe.length(), fe);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function v(e) {
  var fe = LongBits$1.from(e).zzEncode();
  return this._push(writeVarint64, fe.length(), fe);
};
Writer$1.prototype.bool = function v(e) {
  return this._push(writeByte, 1, e ? 1 : 0);
};
function writeFixed32(v, e, fe) {
  e[fe] = v & 255, e[fe + 1] = v >>> 8 & 255, e[fe + 2] = v >>> 16 & 255, e[fe + 3] = v >>> 24;
}
Writer$1.prototype.fixed32 = function v(e) {
  return this._push(writeFixed32, 4, e >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function v(e) {
  var fe = LongBits$1.from(e);
  return this._push(writeFixed32, 4, fe.lo)._push(writeFixed32, 4, fe.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function v(e) {
  return this._push(util$8.float.writeFloatLE, 4, e);
};
Writer$1.prototype.double = function v(e) {
  return this._push(util$8.float.writeDoubleLE, 8, e);
};
var writeBytes = util$8.Array.prototype.set ? function v(e, fe, be) {
  fe.set(e, be);
} : function v(e, fe, be) {
  for (var ye = 0; ye < e.length; ++ye)
    fe[be + ye] = e[ye];
};
Writer$1.prototype.bytes = function v(e) {
  var fe = e.length >>> 0;
  if (!fe)
    return this._push(writeByte, 1, 0);
  if (util$8.isString(e)) {
    var be = Writer$1.alloc(fe = base64.length(e));
    base64.decode(e, be, 0), e = be;
  }
  return this.uint32(fe)._push(writeBytes, fe, e);
};
Writer$1.prototype.string = function v(e) {
  var fe = utf8$1.length(e);
  return fe ? this.uint32(fe)._push(utf8$1.write, fe, e) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function v() {
  return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function v() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function v() {
  var e = this.head, fe = this.tail, be = this.len;
  return this.reset().uint32(be), be && (this.tail.next = e.next, this.tail = fe, this.len += be), this;
};
Writer$1.prototype.finish = function v() {
  for (var e = this.head.next, fe = this.constructor.alloc(this.len), be = 0; e; )
    e.fn(e.val, fe, be), be += e.len, e = e.next;
  return fe;
};
Writer$1._configure = function(v) {
  BufferWriter$1 = v, Writer$1.create = create$1(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$7 = requireMinimal$1();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$7._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$7.Buffer && util$7.Buffer.prototype instanceof Uint8Array && util$7.Buffer.prototype.set.name === "set" ? function(e, fe, be) {
    fe.set(e, be);
  } : function(e, fe, be) {
    if (e.copy)
      e.copy(fe, be, 0, e.length);
    else
      for (var ye = 0; ye < e.length; )
        fe[be++] = e[ye++];
  };
};
BufferWriter.prototype.bytes = function v(e) {
  util$7.isString(e) && (e = util$7._Buffer_from(e, "base64"));
  var fe = e.length >>> 0;
  return this.uint32(fe), fe && this._push(BufferWriter.writeBytesBuffer, fe, e), this;
};
function writeStringBuffer(v, e, fe) {
  v.length < 40 ? util$7.utf8.write(v, e, fe) : e.utf8Write ? e.utf8Write(v, fe) : e.write(v, fe);
}
BufferWriter.prototype.string = function v(e) {
  var fe = util$7.Buffer.byteLength(e);
  return this.uint32(fe), fe && this._push(writeStringBuffer, fe, e), this;
};
BufferWriter._configure();
var reader = Reader$1, util$6 = requireMinimal$1(), BufferReader$1, LongBits = util$6.LongBits, utf8 = util$6.utf8;
function indexOutOfRange(v, e) {
  return RangeError("index out of range: " + v.pos + " + " + (e || 1) + " > " + v.len);
}
function Reader$1(v) {
  this.buf = v, this.pos = 0, this.len = v.length;
}
var create_array = typeof Uint8Array < "u" ? function v(e) {
  if (e instanceof Uint8Array || Array.isArray(e))
    return new Reader$1(e);
  throw Error("illegal buffer");
} : function v(e) {
  if (Array.isArray(e))
    return new Reader$1(e);
  throw Error("illegal buffer");
}, create = function v() {
  return util$6.Buffer ? function(fe) {
    return (Reader$1.create = function(ye) {
      return util$6.Buffer.isBuffer(ye) ? new BufferReader$1(ye) : create_array(ye);
    })(fe);
  } : create_array;
};
Reader$1.create = create();
Reader$1.prototype._slice = util$6.Array.prototype.subarray || /* istanbul ignore next */
util$6.Array.prototype.slice;
Reader$1.prototype.uint32 = function v() {
  var e = 4294967295;
  return function() {
    if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return e;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return e;
  };
}();
Reader$1.prototype.int32 = function v() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function v() {
  var e = this.uint32();
  return e >>> 1 ^ -(e & 1) | 0;
};
function readLongVarint() {
  var v = new LongBits(0, 0), e = 0;
  if (this.len - this.pos > 4) {
    for (; e < 4; ++e)
      if (v.lo = (v.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
        return v;
    if (v.lo = (v.lo | (this.buf[this.pos] & 127) << 28) >>> 0, v.hi = (v.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return v;
    e = 0;
  } else {
    for (; e < 3; ++e) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (v.lo = (v.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
        return v;
    }
    return v.lo = (v.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, v;
  }
  if (this.len - this.pos > 4) {
    for (; e < 5; ++e)
      if (v.hi = (v.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return v;
  } else
    for (; e < 5; ++e) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (v.hi = (v.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return v;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function v() {
  return this.uint32() !== 0;
};
function readFixed32_end(v, e) {
  return (v[e - 4] | v[e - 3] << 8 | v[e - 2] << 16 | v[e - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function v() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function v() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function v() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var e = util$6.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, e;
};
Reader$1.prototype.double = function v() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var e = util$6.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, e;
};
Reader$1.prototype.bytes = function v() {
  var e = this.uint32(), fe = this.pos, be = this.pos + e;
  if (be > this.len)
    throw indexOutOfRange(this, e);
  return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(fe, be) : fe === be ? new this.buf.constructor(0) : this._slice.call(this.buf, fe, be);
};
Reader$1.prototype.string = function v() {
  var e = this.bytes();
  return utf8.read(e, 0, e.length);
};
Reader$1.prototype.skip = function v(e) {
  if (typeof e == "number") {
    if (this.pos + e > this.len)
      throw indexOutOfRange(this, e);
    this.pos += e;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(v) {
  switch (v) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (v = this.uint32() & 7) !== 4; )
        this.skipType(v);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + v + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(v) {
  BufferReader$1 = v, Reader$1.create = create(), BufferReader$1._configure();
  var e = util$6.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$6.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[e](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[e](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[e](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[e](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[e](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$5 = requireMinimal$1();
function BufferReader(v) {
  Reader.call(this, v);
}
BufferReader._configure = function() {
  util$5.Buffer && (BufferReader.prototype._slice = util$5.Buffer.prototype.slice);
};
BufferReader.prototype.string = function v() {
  var e = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len));
};
BufferReader._configure();
var rpc = {}, service$1 = Service$1, util$4 = requireMinimal$1();
(Service$1.prototype = Object.create(util$4.EventEmitter.prototype)).constructor = Service$1;
function Service$1(v, e, fe) {
  if (typeof v != "function")
    throw TypeError("rpcImpl must be a function");
  util$4.EventEmitter.call(this), this.rpcImpl = v, this.requestDelimited = !!e, this.responseDelimited = !!fe;
}
Service$1.prototype.rpcCall = function v(e, fe, be, ye, ve) {
  if (!ye)
    throw TypeError("request must be specified");
  var Ee = this;
  if (!ve)
    return util$4.asPromise(v, Ee, e, fe, be, ye);
  if (!Ee.rpcImpl) {
    setTimeout(function() {
      ve(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return Ee.rpcImpl(
      e,
      fe[Ee.requestDelimited ? "encodeDelimited" : "encode"](ye).finish(),
      function(Oe, xe) {
        if (Oe)
          return Ee.emit("error", Oe, e), ve(Oe);
        if (xe === null) {
          Ee.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(xe instanceof be))
          try {
            xe = be[Ee.responseDelimited ? "decodeDelimited" : "decode"](xe);
          } catch (me) {
            return Ee.emit("error", me, e), ve(me);
          }
        return Ee.emit("data", xe, e), ve(null, xe);
      }
    );
  } catch (Se) {
    Ee.emit("error", Se, e), setTimeout(function() {
      ve(Se);
    }, 0);
    return;
  }
};
Service$1.prototype.end = function v(e) {
  return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(v) {
  var e = v;
  e.Service = service$1;
})(rpc);
var roots = {};
(function(v) {
  var e = v;
  e.build = "minimal", e.Writer = writer, e.BufferWriter = writer_buffer, e.Reader = reader, e.BufferReader = reader_buffer, e.util = requireMinimal$1(), e.rpc = rpc, e.roots = roots, e.configure = fe;
  function fe() {
    e.util._configure(), e.Writer._configure(e.BufferWriter), e.Reader._configure(e.BufferReader);
  }
  fe();
})(indexMinimal);
var util$3 = { exports: {} }, codegen_1 = codegen;
function codegen(v, e) {
  typeof v == "string" && (e = v, v = void 0);
  var fe = [];
  function be(ve) {
    if (typeof ve != "string") {
      var Ee = ye();
      if (codegen.verbose && console.log("codegen: " + Ee), Ee = "return " + Ee, ve) {
        for (var Se = Object.keys(ve), Oe = new Array(Se.length + 1), xe = new Array(Se.length), me = 0; me < Se.length; )
          Oe[me] = Se[me], xe[me] = ve[Se[me++]];
        return Oe[me] = Ee, Function.apply(null, Oe).apply(null, xe);
      }
      return Function(Ee)();
    }
    for (var we = new Array(arguments.length - 1), ur = 0; ur < we.length; )
      we[ur] = arguments[++ur];
    if (ur = 0, ve = ve.replace(/%([%dfijs])/g, function(Ar, Br) {
      var Xr = we[ur++];
      switch (Br) {
        case "d":
        case "f":
          return String(Number(Xr));
        case "i":
          return String(Math.floor(Xr));
        case "j":
          return JSON.stringify(Xr);
        case "s":
          return String(Xr);
      }
      return "%";
    }), ur !== we.length)
      throw Error("parameter count mismatch");
    return fe.push(ve), be;
  }
  function ye(ve) {
    return "function " + (ve || e || "") + "(" + (v && v.join(",") || "") + `){
  ` + fe.join(`
  `) + `
}`;
  }
  return be.toString = ye, be;
}
codegen.verbose = !1;
var fetch_1 = fetch$1, asPromise = aspromise, inquire = inquire_1, fs = inquire("fs");
function fetch$1(v, e, fe) {
  return typeof e == "function" ? (fe = e, e = {}) : e || (e = {}), fe ? !e.xhr && fs && fs.readFile ? fs.readFile(v, function(ye, ve) {
    return ye && typeof XMLHttpRequest < "u" ? fetch$1.xhr(v, e, fe) : ye ? fe(ye) : fe(null, e.binary ? ve : ve.toString("utf8"));
  }) : fetch$1.xhr(v, e, fe) : asPromise(fetch$1, this, v, e);
}
fetch$1.xhr = function v(e, fe, be) {
  var ye = new XMLHttpRequest();
  ye.onreadystatechange = function() {
    if (ye.readyState === 4) {
      if (ye.status !== 0 && ye.status !== 200)
        return be(Error("status " + ye.status));
      if (fe.binary) {
        var Ee = ye.response;
        if (!Ee) {
          Ee = [];
          for (var Se = 0; Se < ye.responseText.length; ++Se)
            Ee.push(ye.responseText.charCodeAt(Se) & 255);
        }
        return be(null, typeof Uint8Array < "u" ? new Uint8Array(Ee) : Ee);
      }
      return be(null, ye.responseText);
    }
  }, fe.binary && ("overrideMimeType" in ye && ye.overrideMimeType("text/plain; charset=x-user-defined"), ye.responseType = "arraybuffer"), ye.open("GET", e), ye.send();
};
var path = {};
(function(v) {
  var e = v, fe = (
    /**
     * Tests if the specified path is absolute.
     * @param {string} path Path to test
     * @returns {boolean} `true` if path is absolute
     */
    e.isAbsolute = function(ve) {
      return /^(?:\/|\w+:)/.test(ve);
    }
  ), be = (
    /**
     * Normalizes the specified path.
     * @param {string} path Path to normalize
     * @returns {string} Normalized path
     */
    e.normalize = function(ve) {
      ve = ve.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var Ee = ve.split("/"), Se = fe(ve), Oe = "";
      Se && (Oe = Ee.shift() + "/");
      for (var xe = 0; xe < Ee.length; )
        Ee[xe] === ".." ? xe > 0 && Ee[xe - 1] !== ".." ? Ee.splice(--xe, 2) : Se ? Ee.splice(xe, 1) : ++xe : Ee[xe] === "." ? Ee.splice(xe, 1) : ++xe;
      return Oe + Ee.join("/");
    }
  );
  e.resolve = function(ve, Ee, Se) {
    return Se || (Ee = be(Ee)), fe(Ee) ? Ee : (Se || (ve = be(ve)), (ve = ve.replace(/(?:\/|^)[^/]+$/, "")).length ? be(ve + "/" + Ee) : Ee);
  };
})(path);
var types$1 = {}, hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(v) {
    var e = v, fe = requireUtil(), be = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function ye(ve, Ee) {
      var Se = 0, Oe = {};
      for (Ee |= 0; Se < ve.length; )
        Oe[be[Se + Ee]] = ve[Se++];
      return Oe;
    }
    e.basic = ye([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]), e.defaults = ye([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      !1,
      /* string   */
      "",
      /* bytes    */
      fe.emptyArray,
      /* message  */
      null
    ]), e.long = ye([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7), e.mapKey = ye([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2), e.packed = ye([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }(types$1)), types$1;
}
var field, hasRequiredField;
function requireField() {
  if (hasRequiredField)
    return field;
  hasRequiredField = 1, field = Ee;
  var v = requireObject();
  ((Ee.prototype = Object.create(v.prototype)).constructor = Ee).className = "Field";
  var e = require_enum(), fe = requireTypes(), be = requireUtil(), ye, ve = /^required|optional|repeated$/;
  Ee.fromJSON = function(Oe, xe) {
    return new Ee(Oe, xe.id, xe.type, xe.rule, xe.extend, xe.options, xe.comment);
  };
  function Ee(Se, Oe, xe, me, we, ur, lr) {
    if (be.isObject(me) ? (lr = we, ur = me, me = we = void 0) : be.isObject(we) && (lr = ur, ur = we, we = void 0), v.call(this, Se, ur), !be.isInteger(Oe) || Oe < 0)
      throw TypeError("id must be a non-negative integer");
    if (!be.isString(xe))
      throw TypeError("type must be a string");
    if (me !== void 0 && !ve.test(me = me.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (we !== void 0 && !be.isString(we))
      throw TypeError("extend must be a string");
    me === "proto3_optional" && (me = "optional"), this.rule = me && me !== "optional" ? me : void 0, this.type = xe, this.id = Oe, this.extend = we || void 0, this.required = me === "required", this.optional = !this.required, this.repeated = me === "repeated", this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = be.Long ? fe.long[xe] !== void 0 : (
      /* istanbul ignore next */
      !1
    ), this.bytes = xe === "bytes", this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = lr;
  }
  return Object.defineProperty(Ee.prototype, "packed", {
    get: function() {
      return this._packed === null && (this._packed = this.getOption("packed") !== !1), this._packed;
    }
  }), Ee.prototype.setOption = function(Oe, xe, me) {
    return Oe === "packed" && (this._packed = null), v.prototype.setOption.call(this, Oe, xe, me);
  }, Ee.prototype.toJSON = function(Oe) {
    var xe = Oe ? !!Oe.keepComments : !1;
    return be.toObject([
      "rule",
      this.rule !== "optional" && this.rule || void 0,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      xe ? this.comment : void 0
    ]);
  }, Ee.prototype.resolve = function() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = fe.defaults[this.type]) === void 0 ? (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof ye ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]) : this.options && this.options.proto3_optional && (this.typeDefault = null), this.options && this.options.default != null && (this.typeDefault = this.options.default, this.resolvedType instanceof e && typeof this.typeDefault == "string" && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && ((this.options.packed === !0 || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof e)) && delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long)
      this.typeDefault = be.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u"), Object.freeze && Object.freeze(this.typeDefault);
    else if (this.bytes && typeof this.typeDefault == "string") {
      var Oe;
      be.base64.test(this.typeDefault) ? be.base64.decode(this.typeDefault, Oe = be.newBuffer(be.base64.length(this.typeDefault)), 0) : be.utf8.write(this.typeDefault, Oe = be.newBuffer(be.utf8.length(this.typeDefault)), 0), this.typeDefault = Oe;
    }
    return this.map ? this.defaultValue = be.emptyObject : this.repeated ? this.defaultValue = be.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof ye && (this.parent.ctor.prototype[this.name] = this.defaultValue), v.prototype.resolve.call(this);
  }, Ee.d = function(Oe, xe, me, we) {
    return typeof xe == "function" ? xe = be.decorateType(xe).name : xe && typeof xe == "object" && (xe = be.decorateEnum(xe).name), function(lr, Ar) {
      be.decorateType(lr.constructor).add(new Ee(Ar, Oe, xe, me, { default: we }));
    };
  }, Ee._configure = function(Oe) {
    ye = Oe;
  }, field;
}
var oneof, hasRequiredOneof;
function requireOneof() {
  if (hasRequiredOneof)
    return oneof;
  hasRequiredOneof = 1, oneof = be;
  var v = requireObject();
  ((be.prototype = Object.create(v.prototype)).constructor = be).className = "OneOf";
  var e = requireField(), fe = requireUtil();
  function be(ve, Ee, Se, Oe) {
    if (Array.isArray(Ee) || (Se = Ee, Ee = void 0), v.call(this, ve, Se), !(Ee === void 0 || Array.isArray(Ee)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = Ee || [], this.fieldsArray = [], this.comment = Oe;
  }
  be.fromJSON = function(Ee, Se) {
    return new be(Ee, Se.oneof, Se.options, Se.comment);
  }, be.prototype.toJSON = function(Ee) {
    var Se = Ee ? !!Ee.keepComments : !1;
    return fe.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      Se ? this.comment : void 0
    ]);
  };
  function ye(ve) {
    if (ve.parent)
      for (var Ee = 0; Ee < ve.fieldsArray.length; ++Ee)
        ve.fieldsArray[Ee].parent || ve.parent.add(ve.fieldsArray[Ee]);
  }
  return be.prototype.add = function(Ee) {
    if (!(Ee instanceof e))
      throw TypeError("field must be a Field");
    return Ee.parent && Ee.parent !== this.parent && Ee.parent.remove(Ee), this.oneof.push(Ee.name), this.fieldsArray.push(Ee), Ee.partOf = this, ye(this), this;
  }, be.prototype.remove = function(Ee) {
    if (!(Ee instanceof e))
      throw TypeError("field must be a Field");
    var Se = this.fieldsArray.indexOf(Ee);
    if (Se < 0)
      throw Error(Ee + " is not a member of " + this);
    return this.fieldsArray.splice(Se, 1), Se = this.oneof.indexOf(Ee.name), Se > -1 && this.oneof.splice(Se, 1), Ee.partOf = null, this;
  }, be.prototype.onAdd = function(Ee) {
    v.prototype.onAdd.call(this, Ee);
    for (var Se = this, Oe = 0; Oe < this.oneof.length; ++Oe) {
      var xe = Ee.get(this.oneof[Oe]);
      xe && !xe.partOf && (xe.partOf = Se, Se.fieldsArray.push(xe));
    }
    ye(this);
  }, be.prototype.onRemove = function(Ee) {
    for (var Se = 0, Oe; Se < this.fieldsArray.length; ++Se)
      (Oe = this.fieldsArray[Se]).parent && Oe.parent.remove(Oe);
    v.prototype.onRemove.call(this, Ee);
  }, be.d = function() {
    for (var Ee = new Array(arguments.length), Se = 0; Se < arguments.length; )
      Ee[Se] = arguments[Se++];
    return function(xe, me) {
      fe.decorateType(xe.constructor).add(new be(me, Ee)), Object.defineProperty(xe, me, {
        get: fe.oneOfGetter(Ee),
        set: fe.oneOfSetter(Ee)
      });
    };
  }, oneof;
}
var namespace, hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace)
    return namespace;
  hasRequiredNamespace = 1, namespace = Oe;
  var v = requireObject();
  ((Oe.prototype = Object.create(v.prototype)).constructor = Oe).className = "Namespace";
  var e = requireField(), fe = requireUtil(), be = requireOneof(), ye, ve, Ee;
  Oe.fromJSON = function(we, ur) {
    return new Oe(we, ur.options).addJSON(ur.nested);
  };
  function Se(me, we) {
    if (me && me.length) {
      for (var ur = {}, lr = 0; lr < me.length; ++lr)
        ur[me[lr].name] = me[lr].toJSON(we);
      return ur;
    }
  }
  Oe.arrayToJSON = Se, Oe.isReservedId = function(we, ur) {
    if (we) {
      for (var lr = 0; lr < we.length; ++lr)
        if (typeof we[lr] != "string" && we[lr][0] <= ur && we[lr][1] > ur)
          return !0;
    }
    return !1;
  }, Oe.isReservedName = function(we, ur) {
    if (we) {
      for (var lr = 0; lr < we.length; ++lr)
        if (we[lr] === ur)
          return !0;
    }
    return !1;
  };
  function Oe(me, we) {
    v.call(this, me, we), this.nested = void 0, this._nestedArray = null;
  }
  function xe(me) {
    return me._nestedArray = null, me;
  }
  return Object.defineProperty(Oe.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = fe.toArray(this.nested));
    }
  }), Oe.prototype.toJSON = function(we) {
    return fe.toObject([
      "options",
      this.options,
      "nested",
      Se(this.nestedArray, we)
    ]);
  }, Oe.prototype.addJSON = function(we) {
    var ur = this;
    if (we)
      for (var lr = Object.keys(we), Ar = 0, Br; Ar < lr.length; ++Ar)
        Br = we[lr[Ar]], ur.add(
          // most to least likely
          (Br.fields !== void 0 ? ye.fromJSON : Br.values !== void 0 ? Ee.fromJSON : Br.methods !== void 0 ? ve.fromJSON : Br.id !== void 0 ? e.fromJSON : Oe.fromJSON)(lr[Ar], Br)
        );
    return this;
  }, Oe.prototype.get = function(we) {
    return this.nested && this.nested[we] || null;
  }, Oe.prototype.getEnum = function(we) {
    if (this.nested && this.nested[we] instanceof Ee)
      return this.nested[we].values;
    throw Error("no such enum: " + we);
  }, Oe.prototype.add = function(we) {
    if (!(we instanceof e && we.extend !== void 0 || we instanceof ye || we instanceof be || we instanceof Ee || we instanceof ve || we instanceof Oe))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var ur = this.get(we.name);
      if (ur)
        if (ur instanceof Oe && we instanceof Oe && !(ur instanceof ye || ur instanceof ve)) {
          for (var lr = ur.nestedArray, Ar = 0; Ar < lr.length; ++Ar)
            we.add(lr[Ar]);
          this.remove(ur), this.nested || (this.nested = {}), we.setOptions(ur.options, !0);
        } else
          throw Error("duplicate name '" + we.name + "' in " + this);
    }
    return this.nested[we.name] = we, we.onAdd(this), xe(this);
  }, Oe.prototype.remove = function(we) {
    if (!(we instanceof v))
      throw TypeError("object must be a ReflectionObject");
    if (we.parent !== this)
      throw Error(we + " is not a member of " + this);
    return delete this.nested[we.name], Object.keys(this.nested).length || (this.nested = void 0), we.onRemove(this), xe(this);
  }, Oe.prototype.define = function(we, ur) {
    if (fe.isString(we))
      we = we.split(".");
    else if (!Array.isArray(we))
      throw TypeError("illegal path");
    if (we && we.length && we[0] === "")
      throw Error("path must be relative");
    for (var lr = this; we.length > 0; ) {
      var Ar = we.shift();
      if (lr.nested && lr.nested[Ar]) {
        if (lr = lr.nested[Ar], !(lr instanceof Oe))
          throw Error("path conflicts with non-namespace objects");
      } else
        lr.add(lr = new Oe(Ar));
    }
    return ur && lr.addJSON(ur), lr;
  }, Oe.prototype.resolveAll = function() {
    for (var we = this.nestedArray, ur = 0; ur < we.length; )
      we[ur] instanceof Oe ? we[ur++].resolveAll() : we[ur++].resolve();
    return this.resolve();
  }, Oe.prototype.lookup = function(we, ur, lr) {
    if (typeof ur == "boolean" ? (lr = ur, ur = void 0) : ur && !Array.isArray(ur) && (ur = [ur]), fe.isString(we) && we.length) {
      if (we === ".")
        return this.root;
      we = we.split(".");
    } else if (!we.length)
      return this;
    if (we[0] === "")
      return this.root.lookup(we.slice(1), ur);
    var Ar = this.get(we[0]);
    if (Ar) {
      if (we.length === 1) {
        if (!ur || ur.indexOf(Ar.constructor) > -1)
          return Ar;
      } else if (Ar instanceof Oe && (Ar = Ar.lookup(we.slice(1), ur, !0)))
        return Ar;
    } else
      for (var Br = 0; Br < this.nestedArray.length; ++Br)
        if (this._nestedArray[Br] instanceof Oe && (Ar = this._nestedArray[Br].lookup(we, ur, !0)))
          return Ar;
    return this.parent === null || lr ? null : this.parent.lookup(we, ur);
  }, Oe.prototype.lookupType = function(we) {
    var ur = this.lookup(we, [ye]);
    if (!ur)
      throw Error("no such type: " + we);
    return ur;
  }, Oe.prototype.lookupEnum = function(we) {
    var ur = this.lookup(we, [Ee]);
    if (!ur)
      throw Error("no such Enum '" + we + "' in " + this);
    return ur;
  }, Oe.prototype.lookupTypeOrEnum = function(we) {
    var ur = this.lookup(we, [ye, Ee]);
    if (!ur)
      throw Error("no such Type or Enum '" + we + "' in " + this);
    return ur;
  }, Oe.prototype.lookupService = function(we) {
    var ur = this.lookup(we, [ve]);
    if (!ur)
      throw Error("no such Service '" + we + "' in " + this);
    return ur;
  }, Oe._configure = function(me, we, ur) {
    ye = me, ve = we, Ee = ur;
  }, namespace;
}
var mapfield, hasRequiredMapfield;
function requireMapfield() {
  if (hasRequiredMapfield)
    return mapfield;
  hasRequiredMapfield = 1, mapfield = be;
  var v = requireField();
  ((be.prototype = Object.create(v.prototype)).constructor = be).className = "MapField";
  var e = requireTypes(), fe = requireUtil();
  function be(ye, ve, Ee, Se, Oe, xe) {
    if (v.call(this, ye, ve, Se, void 0, void 0, Oe, xe), !fe.isString(Ee))
      throw TypeError("keyType must be a string");
    this.keyType = Ee, this.resolvedKeyType = null, this.map = !0;
  }
  return be.fromJSON = function(ve, Ee) {
    return new be(ve, Ee.id, Ee.keyType, Ee.type, Ee.options, Ee.comment);
  }, be.prototype.toJSON = function(ve) {
    var Ee = ve ? !!ve.keepComments : !1;
    return fe.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      Ee ? this.comment : void 0
    ]);
  }, be.prototype.resolve = function() {
    if (this.resolved)
      return this;
    if (e.mapKey[this.keyType] === void 0)
      throw Error("invalid key type: " + this.keyType);
    return v.prototype.resolve.call(this);
  }, be.d = function(ve, Ee, Se) {
    return typeof Se == "function" ? Se = fe.decorateType(Se).name : Se && typeof Se == "object" && (Se = fe.decorateEnum(Se).name), function(xe, me) {
      fe.decorateType(xe.constructor).add(new be(me, ve, Ee, Se));
    };
  }, mapfield;
}
var method, hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod)
    return method;
  hasRequiredMethod = 1, method = fe;
  var v = requireObject();
  ((fe.prototype = Object.create(v.prototype)).constructor = fe).className = "Method";
  var e = requireUtil();
  function fe(be, ye, ve, Ee, Se, Oe, xe, me, we) {
    if (e.isObject(Se) ? (xe = Se, Se = Oe = void 0) : e.isObject(Oe) && (xe = Oe, Oe = void 0), !(ye === void 0 || e.isString(ye)))
      throw TypeError("type must be a string");
    if (!e.isString(ve))
      throw TypeError("requestType must be a string");
    if (!e.isString(Ee))
      throw TypeError("responseType must be a string");
    v.call(this, be, xe), this.type = ye || "rpc", this.requestType = ve, this.requestStream = Se ? !0 : void 0, this.responseType = Ee, this.responseStream = Oe ? !0 : void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = me, this.parsedOptions = we;
  }
  return fe.fromJSON = function(ye, ve) {
    return new fe(ye, ve.type, ve.requestType, ve.responseType, ve.requestStream, ve.responseStream, ve.options, ve.comment, ve.parsedOptions);
  }, fe.prototype.toJSON = function(ye) {
    var ve = ye ? !!ye.keepComments : !1;
    return e.toObject([
      "type",
      this.type !== "rpc" && /* istanbul ignore next */
      this.type || void 0,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      ve ? this.comment : void 0,
      "parsedOptions",
      this.parsedOptions
    ]);
  }, fe.prototype.resolve = function() {
    return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), v.prototype.resolve.call(this));
  }, method;
}
var service, hasRequiredService;
function requireService() {
  if (hasRequiredService)
    return service;
  hasRequiredService = 1, service = ye;
  var v = requireNamespace();
  ((ye.prototype = Object.create(v.prototype)).constructor = ye).className = "Service";
  var e = requireMethod(), fe = requireUtil(), be = rpc;
  function ye(Ee, Se) {
    v.call(this, Ee, Se), this.methods = {}, this._methodsArray = null;
  }
  ye.fromJSON = function(Se, Oe) {
    var xe = new ye(Se, Oe.options);
    if (Oe.methods)
      for (var me = Object.keys(Oe.methods), we = 0; we < me.length; ++we)
        xe.add(e.fromJSON(me[we], Oe.methods[me[we]]));
    return Oe.nested && xe.addJSON(Oe.nested), xe.comment = Oe.comment, xe;
  }, ye.prototype.toJSON = function(Se) {
    var Oe = v.prototype.toJSON.call(this, Se), xe = Se ? !!Se.keepComments : !1;
    return fe.toObject([
      "options",
      Oe && Oe.options || void 0,
      "methods",
      v.arrayToJSON(this.methodsArray, Se) || /* istanbul ignore next */
      {},
      "nested",
      Oe && Oe.nested || void 0,
      "comment",
      xe ? this.comment : void 0
    ]);
  }, Object.defineProperty(ye.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = fe.toArray(this.methods));
    }
  });
  function ve(Ee) {
    return Ee._methodsArray = null, Ee;
  }
  return ye.prototype.get = function(Se) {
    return this.methods[Se] || v.prototype.get.call(this, Se);
  }, ye.prototype.resolveAll = function() {
    for (var Se = this.methodsArray, Oe = 0; Oe < Se.length; ++Oe)
      Se[Oe].resolve();
    return v.prototype.resolve.call(this);
  }, ye.prototype.add = function(Se) {
    if (this.get(Se.name))
      throw Error("duplicate name '" + Se.name + "' in " + this);
    return Se instanceof e ? (this.methods[Se.name] = Se, Se.parent = this, ve(this)) : v.prototype.add.call(this, Se);
  }, ye.prototype.remove = function(Se) {
    if (Se instanceof e) {
      if (this.methods[Se.name] !== Se)
        throw Error(Se + " is not a member of " + this);
      return delete this.methods[Se.name], Se.parent = null, ve(this);
    }
    return v.prototype.remove.call(this, Se);
  }, ye.prototype.create = function(Se, Oe, xe) {
    for (var me = new be.Service(Se, Oe, xe), we = 0, ur; we < /* initializes */
    this.methodsArray.length; ++we) {
      var lr = fe.lcFirst((ur = this._methodsArray[we]).resolve().name).replace(/[^$\w_]/g, "");
      me[lr] = fe.codegen(["r", "c"], fe.isReserved(lr) ? lr + "_" : lr)("return this.rpcCall(m,q,s,r,c)")({
        m: ur,
        q: ur.resolvedRequestType.ctor,
        s: ur.resolvedResponseType.ctor
      });
    }
    return me;
  }, service;
}
var message = Message, util$2 = requireMinimal$1();
function Message(v) {
  if (v)
    for (var e = Object.keys(v), fe = 0; fe < e.length; ++fe)
      this[e[fe]] = v[e[fe]];
}
Message.create = function v(e) {
  return this.$type.create(e);
};
Message.encode = function v(e, fe) {
  return this.$type.encode(e, fe);
};
Message.encodeDelimited = function v(e, fe) {
  return this.$type.encodeDelimited(e, fe);
};
Message.decode = function v(e) {
  return this.$type.decode(e);
};
Message.decodeDelimited = function v(e) {
  return this.$type.decodeDelimited(e);
};
Message.verify = function v(e) {
  return this.$type.verify(e);
};
Message.fromObject = function v(e) {
  return this.$type.fromObject(e);
};
Message.toObject = function v(e, fe) {
  return this.$type.toObject(e, fe);
};
Message.prototype.toJSON = function v() {
  return this.$type.toObject(this, util$2.toJSONOptions);
};
var decoder_1, hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder)
    return decoder_1;
  hasRequiredDecoder = 1, decoder_1 = ye;
  var v = require_enum(), e = requireTypes(), fe = requireUtil();
  function be(ve) {
    return "missing required '" + ve.name + "'";
  }
  function ye(ve) {
    var Ee = fe.codegen(["r", "l"], ve.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (ve.fieldsArray.filter(function(ur) {
      return ur.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
    ve.group && Ee("if((t&7)===4)")("break"), Ee("switch(t>>>3){");
    for (var Se = 0; Se < /* initializes */
    ve.fieldsArray.length; ++Se) {
      var Oe = ve._fieldsArray[Se].resolve(), xe = Oe.resolvedType instanceof v ? "int32" : Oe.type, me = "m" + fe.safeProp(Oe.name);
      Ee("case %i: {", Oe.id), Oe.map ? (Ee("if(%s===util.emptyObject)", me)("%s={}", me)("var c2 = r.uint32()+r.pos"), e.defaults[Oe.keyType] !== void 0 ? Ee("k=%j", e.defaults[Oe.keyType]) : Ee("k=null"), e.defaults[xe] !== void 0 ? Ee("value=%j", e.defaults[xe]) : Ee("value=null"), Ee("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", Oe.keyType)("case 2:"), e.basic[xe] === void 0 ? Ee("value=types[%i].decode(r,r.uint32())", Se) : Ee("value=r.%s()", xe), Ee("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), e.long[Oe.keyType] !== void 0 ? Ee('%s[typeof k==="object"?util.longToHash(k):k]=value', me) : Ee("%s[k]=value", me)) : Oe.repeated ? (Ee("if(!(%s&&%s.length))", me, me)("%s=[]", me), e.packed[xe] !== void 0 && Ee("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", me, xe)("}else"), e.basic[xe] === void 0 ? Ee(Oe.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", me, Se) : Ee("%s.push(r.%s())", me, xe)) : e.basic[xe] === void 0 ? Ee(Oe.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", me, Se) : Ee("%s=r.%s()", me, xe), Ee("break")("}");
    }
    for (Ee("default:")("r.skipType(t&7)")("break")("}")("}"), Se = 0; Se < ve._fieldsArray.length; ++Se) {
      var we = ve._fieldsArray[Se];
      we.required && Ee("if(!m.hasOwnProperty(%j))", we.name)("throw util.ProtocolError(%j,{instance:m})", be(we));
    }
    return Ee("return m");
  }
  return decoder_1;
}
var verifier_1, hasRequiredVerifier;
function requireVerifier() {
  if (hasRequiredVerifier)
    return verifier_1;
  hasRequiredVerifier = 1, verifier_1 = ve;
  var v = require_enum(), e = requireUtil();
  function fe(Ee, Se) {
    return Ee.name + ": " + Se + (Ee.repeated && Se !== "array" ? "[]" : Ee.map && Se !== "object" ? "{k:" + Ee.keyType + "}" : "") + " expected";
  }
  function be(Ee, Se, Oe, xe) {
    if (Se.resolvedType)
      if (Se.resolvedType instanceof v) {
        Ee("switch(%s){", xe)("default:")("return%j", fe(Se, "enum value"));
        for (var me = Object.keys(Se.resolvedType.values), we = 0; we < me.length; ++we)
          Ee("case %i:", Se.resolvedType.values[me[we]]);
        Ee("break")("}");
      } else
        Ee("{")("var e=types[%i].verify(%s);", Oe, xe)("if(e)")("return%j+e", Se.name + ".")("}");
    else
      switch (Se.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          Ee("if(!util.isInteger(%s))", xe)("return%j", fe(Se, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          Ee("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", xe, xe, xe, xe)("return%j", fe(Se, "integer|Long"));
          break;
        case "float":
        case "double":
          Ee('if(typeof %s!=="number")', xe)("return%j", fe(Se, "number"));
          break;
        case "bool":
          Ee('if(typeof %s!=="boolean")', xe)("return%j", fe(Se, "boolean"));
          break;
        case "string":
          Ee("if(!util.isString(%s))", xe)("return%j", fe(Se, "string"));
          break;
        case "bytes":
          Ee('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', xe, xe, xe)("return%j", fe(Se, "buffer"));
          break;
      }
    return Ee;
  }
  function ye(Ee, Se, Oe) {
    switch (Se.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        Ee("if(!util.key32Re.test(%s))", Oe)("return%j", fe(Se, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        Ee("if(!util.key64Re.test(%s))", Oe)("return%j", fe(Se, "integer|Long key"));
        break;
      case "bool":
        Ee("if(!util.key2Re.test(%s))", Oe)("return%j", fe(Se, "boolean key"));
        break;
    }
    return Ee;
  }
  function ve(Ee) {
    var Se = e.codegen(["m"], Ee.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"), Oe = Ee.oneofsArray, xe = {};
    Oe.length && Se("var p={}");
    for (var me = 0; me < /* initializes */
    Ee.fieldsArray.length; ++me) {
      var we = Ee._fieldsArray[me].resolve(), ur = "m" + e.safeProp(we.name);
      if (we.optional && Se("if(%s!=null&&m.hasOwnProperty(%j)){", ur, we.name), we.map)
        Se("if(!util.isObject(%s))", ur)("return%j", fe(we, "object"))("var k=Object.keys(%s)", ur)("for(var i=0;i<k.length;++i){"), ye(Se, we, "k[i]"), be(Se, we, me, ur + "[k[i]]")("}");
      else if (we.repeated)
        Se("if(!Array.isArray(%s))", ur)("return%j", fe(we, "array"))("for(var i=0;i<%s.length;++i){", ur), be(Se, we, me, ur + "[i]")("}");
      else {
        if (we.partOf) {
          var lr = e.safeProp(we.partOf.name);
          xe[we.partOf.name] === 1 && Se("if(p%s===1)", lr)("return%j", we.partOf.name + ": multiple values"), xe[we.partOf.name] = 1, Se("p%s=1", lr);
        }
        be(Se, we, me, ur);
      }
      we.optional && Se("}");
    }
    return Se("return null");
  }
  return verifier_1;
}
var converter = {}, hasRequiredConverter;
function requireConverter() {
  return hasRequiredConverter || (hasRequiredConverter = 1, function(v) {
    var e = v, fe = require_enum(), be = requireUtil();
    function ye(Ee, Se, Oe, xe) {
      var me = !1;
      if (Se.resolvedType)
        if (Se.resolvedType instanceof fe) {
          Ee("switch(d%s){", xe);
          for (var we = Se.resolvedType.values, ur = Object.keys(we), lr = 0; lr < ur.length; ++lr)
            we[ur[lr]] === Se.typeDefault && !me && (Ee("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', xe, xe, xe), Se.repeated || Ee("break"), me = !0), Ee("case%j:", ur[lr])("case %i:", we[ur[lr]])("m%s=%j", xe, we[ur[lr]])("break");
          Ee("}");
        } else
          Ee('if(typeof d%s!=="object")', xe)("throw TypeError(%j)", Se.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", xe, Oe, xe);
      else {
        var Ar = !1;
        switch (Se.type) {
          case "double":
          case "float":
            Ee("m%s=Number(d%s)", xe, xe);
            break;
          case "uint32":
          case "fixed32":
            Ee("m%s=d%s>>>0", xe, xe);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            Ee("m%s=d%s|0", xe, xe);
            break;
          case "uint64":
            Ar = !0;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            Ee("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", xe, xe, Ar)('else if(typeof d%s==="string")', xe)("m%s=parseInt(d%s,10)", xe, xe)('else if(typeof d%s==="number")', xe)("m%s=d%s", xe, xe)('else if(typeof d%s==="object")', xe)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", xe, xe, xe, Ar ? "true" : "");
            break;
          case "bytes":
            Ee('if(typeof d%s==="string")', xe)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", xe, xe, xe)("else if(d%s.length >= 0)", xe)("m%s=d%s", xe, xe);
            break;
          case "string":
            Ee("m%s=String(d%s)", xe, xe);
            break;
          case "bool":
            Ee("m%s=Boolean(d%s)", xe, xe);
            break;
        }
      }
      return Ee;
    }
    e.fromObject = function(Se) {
      var Oe = Se.fieldsArray, xe = be.codegen(["d"], Se.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!Oe.length)
        return xe("return new this.ctor");
      xe("var m=new this.ctor");
      for (var me = 0; me < Oe.length; ++me) {
        var we = Oe[me].resolve(), ur = be.safeProp(we.name);
        we.map ? (xe("if(d%s){", ur)('if(typeof d%s!=="object")', ur)("throw TypeError(%j)", we.fullName + ": object expected")("m%s={}", ur)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", ur), ye(
          xe,
          we,
          /* not sorted */
          me,
          ur + "[ks[i]]"
        )("}")("}")) : we.repeated ? (xe("if(d%s){", ur)("if(!Array.isArray(d%s))", ur)("throw TypeError(%j)", we.fullName + ": array expected")("m%s=[]", ur)("for(var i=0;i<d%s.length;++i){", ur), ye(
          xe,
          we,
          /* not sorted */
          me,
          ur + "[i]"
        )("}")("}")) : (we.resolvedType instanceof fe || xe("if(d%s!=null){", ur), ye(
          xe,
          we,
          /* not sorted */
          me,
          ur
        ), we.resolvedType instanceof fe || xe("}"));
      }
      return xe("return m");
    };
    function ve(Ee, Se, Oe, xe) {
      if (Se.resolvedType)
        Se.resolvedType instanceof fe ? Ee("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", xe, Oe, xe, xe, Oe, xe, xe) : Ee("d%s=types[%i].toObject(m%s,o)", xe, Oe, xe);
      else {
        var me = !1;
        switch (Se.type) {
          case "double":
          case "float":
            Ee("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", xe, xe, xe, xe);
            break;
          case "uint64":
            me = !0;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            Ee('if(typeof m%s==="number")', xe)("d%s=o.longs===String?String(m%s):m%s", xe, xe, xe)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", xe, xe, xe, xe, me ? "true" : "", xe);
            break;
          case "bytes":
            Ee("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", xe, xe, xe, xe, xe);
            break;
          default:
            Ee("d%s=m%s", xe, xe);
            break;
        }
      }
      return Ee;
    }
    e.toObject = function(Se) {
      var Oe = Se.fieldsArray.slice().sort(be.compareFieldsById);
      if (!Oe.length)
        return be.codegen()("return {}");
      for (var xe = be.codegen(["m", "o"], Se.name + "$toObject")("if(!o)")("o={}")("var d={}"), me = [], we = [], ur = [], lr = 0; lr < Oe.length; ++lr)
        Oe[lr].partOf || (Oe[lr].resolve().repeated ? me : Oe[lr].map ? we : ur).push(Oe[lr]);
      if (me.length) {
        for (xe("if(o.arrays||o.defaults){"), lr = 0; lr < me.length; ++lr)
          xe("d%s=[]", be.safeProp(me[lr].name));
        xe("}");
      }
      if (we.length) {
        for (xe("if(o.objects||o.defaults){"), lr = 0; lr < we.length; ++lr)
          xe("d%s={}", be.safeProp(we[lr].name));
        xe("}");
      }
      if (ur.length) {
        for (xe("if(o.defaults){"), lr = 0; lr < ur.length; ++lr) {
          var Ar = ur[lr], Br = be.safeProp(Ar.name);
          if (Ar.resolvedType instanceof fe)
            xe("d%s=o.enums===String?%j:%j", Br, Ar.resolvedType.valuesById[Ar.typeDefault], Ar.typeDefault);
          else if (Ar.long)
            xe("if(util.Long){")("var n=new util.Long(%i,%i,%j)", Ar.typeDefault.low, Ar.typeDefault.high, Ar.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", Br)("}else")("d%s=o.longs===String?%j:%i", Br, Ar.typeDefault.toString(), Ar.typeDefault.toNumber());
          else if (Ar.bytes) {
            var Xr = "[" + Array.prototype.slice.call(Ar.typeDefault).join(",") + "]";
            xe("if(o.bytes===String)d%s=%j", Br, String.fromCharCode.apply(String, Ar.typeDefault))("else{")("d%s=%s", Br, Xr)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", Br, Br)("}");
          } else
            xe("d%s=%j", Br, Ar.typeDefault);
        }
        xe("}");
      }
      var eo = !1;
      for (lr = 0; lr < Oe.length; ++lr) {
        var Ar = Oe[lr], jr = Se._fieldsArray.indexOf(Ar), Br = be.safeProp(Ar.name);
        Ar.map ? (eo || (eo = !0, xe("var ks2")), xe("if(m%s&&(ks2=Object.keys(m%s)).length){", Br, Br)("d%s={}", Br)("for(var j=0;j<ks2.length;++j){"), ve(
          xe,
          Ar,
          /* sorted */
          jr,
          Br + "[ks2[j]]"
        )("}")) : Ar.repeated ? (xe("if(m%s&&m%s.length){", Br, Br)("d%s=[]", Br)("for(var j=0;j<m%s.length;++j){", Br), ve(
          xe,
          Ar,
          /* sorted */
          jr,
          Br + "[j]"
        )("}")) : (xe("if(m%s!=null&&m.hasOwnProperty(%j)){", Br, Ar.name), ve(
          xe,
          Ar,
          /* sorted */
          jr,
          Br
        ), Ar.partOf && xe("if(o.oneofs)")("d%s=%j", be.safeProp(Ar.partOf.name), Ar.name)), xe("}");
      }
      return xe("return d");
    };
  }(converter)), converter;
}
var wrappers = {};
(function(v) {
  var e = v, fe = message;
  e[".google.protobuf.Any"] = {
    fromObject: function(be) {
      if (be && be["@type"]) {
        var ye = be["@type"].substring(be["@type"].lastIndexOf("/") + 1), ve = this.lookup(ye);
        if (ve) {
          var Ee = be["@type"].charAt(0) === "." ? be["@type"].slice(1) : be["@type"];
          return Ee.indexOf("/") === -1 && (Ee = "/" + Ee), this.create({
            type_url: Ee,
            value: ve.encode(ve.fromObject(be)).finish()
          });
        }
      }
      return this.fromObject(be);
    },
    toObject: function(be, ye) {
      var ve = "type.googleapis.com/", Ee = "", Se = "";
      if (ye && ye.json && be.type_url && be.value) {
        Se = be.type_url.substring(be.type_url.lastIndexOf("/") + 1), Ee = be.type_url.substring(0, be.type_url.lastIndexOf("/") + 1);
        var Oe = this.lookup(Se);
        Oe && (be = Oe.decode(be.value));
      }
      if (!(be instanceof this.ctor) && be instanceof fe) {
        var xe = be.$type.toObject(be, ye), me = be.$type.fullName[0] === "." ? be.$type.fullName.slice(1) : be.$type.fullName;
        return Ee === "" && (Ee = ve), Se = Ee + me, xe["@type"] = Se, xe;
      }
      return this.toObject(be, ye);
    }
  };
})(wrappers);
var type, hasRequiredType;
function requireType() {
  if (hasRequiredType)
    return type;
  hasRequiredType = 1, type = Br;
  var v = requireNamespace();
  ((Br.prototype = Object.create(v.prototype)).constructor = Br).className = "Type";
  var e = require_enum(), fe = requireOneof(), be = requireField(), ye = requireMapfield(), ve = requireService(), Ee = message, Se = reader, Oe = writer, xe = requireUtil(), me = requireEncoder(), we = requireDecoder(), ur = requireVerifier(), lr = requireConverter(), Ar = wrappers;
  function Br(eo, jr) {
    v.call(this, eo, jr), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;
  }
  Object.defineProperties(Br.prototype, {
    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var eo = Object.keys(this.fields), jr = 0; jr < eo.length; ++jr) {
          var kr = this.fields[eo[jr]], $r = kr.id;
          if (this._fieldsById[$r])
            throw Error("duplicate id " + $r + " in " + this);
          this._fieldsById[$r] = kr;
        }
        return this._fieldsById;
      }
    },
    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = xe.toArray(this.fields));
      }
    },
    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = xe.toArray(this.oneofs));
      }
    },
    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Br.generateConstructor(this)());
      },
      set: function(eo) {
        var jr = eo.prototype;
        jr instanceof Ee || ((eo.prototype = new Ee()).constructor = eo, xe.merge(eo.prototype, jr)), eo.$type = eo.prototype.$type = this, xe.merge(eo, Ee, !0), this._ctor = eo;
        for (var kr = 0; kr < /* initializes */
        this.fieldsArray.length; ++kr)
          this._fieldsArray[kr].resolve();
        var $r = {};
        for (kr = 0; kr < /* initializes */
        this.oneofsArray.length; ++kr)
          $r[this._oneofsArray[kr].resolve().name] = {
            get: xe.oneOfGetter(this._oneofsArray[kr].oneof),
            set: xe.oneOfSetter(this._oneofsArray[kr].oneof)
          };
        kr && Object.defineProperties(eo.prototype, $r);
      }
    }
  }), Br.generateConstructor = function(jr) {
    for (var kr = xe.codegen(["p"], jr.name), $r = 0, Vr; $r < jr.fieldsArray.length; ++$r)
      (Vr = jr._fieldsArray[$r]).map ? kr("this%s={}", xe.safeProp(Vr.name)) : Vr.repeated && kr("this%s=[]", xe.safeProp(Vr.name));
    return kr("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function Xr(eo) {
    return eo._fieldsById = eo._fieldsArray = eo._oneofsArray = null, delete eo.encode, delete eo.decode, delete eo.verify, eo;
  }
  return Br.fromJSON = function(jr, kr) {
    var $r = new Br(jr, kr.options);
    $r.extensions = kr.extensions, $r.reserved = kr.reserved;
    for (var Vr = Object.keys(kr.fields), Mr = 0; Mr < Vr.length; ++Mr)
      $r.add(
        (typeof kr.fields[Vr[Mr]].keyType < "u" ? ye.fromJSON : be.fromJSON)(Vr[Mr], kr.fields[Vr[Mr]])
      );
    if (kr.oneofs)
      for (Vr = Object.keys(kr.oneofs), Mr = 0; Mr < Vr.length; ++Mr)
        $r.add(fe.fromJSON(Vr[Mr], kr.oneofs[Vr[Mr]]));
    if (kr.nested)
      for (Vr = Object.keys(kr.nested), Mr = 0; Mr < Vr.length; ++Mr) {
        var gr = kr.nested[Vr[Mr]];
        $r.add(
          // most to least likely
          (gr.id !== void 0 ? be.fromJSON : gr.fields !== void 0 ? Br.fromJSON : gr.values !== void 0 ? e.fromJSON : gr.methods !== void 0 ? ve.fromJSON : v.fromJSON)(Vr[Mr], gr)
        );
      }
    return kr.extensions && kr.extensions.length && ($r.extensions = kr.extensions), kr.reserved && kr.reserved.length && ($r.reserved = kr.reserved), kr.group && ($r.group = !0), kr.comment && ($r.comment = kr.comment), $r;
  }, Br.prototype.toJSON = function(jr) {
    var kr = v.prototype.toJSON.call(this, jr), $r = jr ? !!jr.keepComments : !1;
    return xe.toObject([
      "options",
      kr && kr.options || void 0,
      "oneofs",
      v.arrayToJSON(this.oneofsArray, jr),
      "fields",
      v.arrayToJSON(this.fieldsArray.filter(function(Vr) {
        return !Vr.declaringField;
      }), jr) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : void 0,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "group",
      this.group || void 0,
      "nested",
      kr && kr.nested || void 0,
      "comment",
      $r ? this.comment : void 0
    ]);
  }, Br.prototype.resolveAll = function() {
    for (var jr = this.fieldsArray, kr = 0; kr < jr.length; )
      jr[kr++].resolve();
    var $r = this.oneofsArray;
    for (kr = 0; kr < $r.length; )
      $r[kr++].resolve();
    return v.prototype.resolveAll.call(this);
  }, Br.prototype.get = function(jr) {
    return this.fields[jr] || this.oneofs && this.oneofs[jr] || this.nested && this.nested[jr] || null;
  }, Br.prototype.add = function(jr) {
    if (this.get(jr.name))
      throw Error("duplicate name '" + jr.name + "' in " + this);
    if (jr instanceof be && jr.extend === void 0) {
      if (this._fieldsById ? (
        /* istanbul ignore next */
        this._fieldsById[jr.id]
      ) : this.fieldsById[jr.id])
        throw Error("duplicate id " + jr.id + " in " + this);
      if (this.isReservedId(jr.id))
        throw Error("id " + jr.id + " is reserved in " + this);
      if (this.isReservedName(jr.name))
        throw Error("name '" + jr.name + "' is reserved in " + this);
      return jr.parent && jr.parent.remove(jr), this.fields[jr.name] = jr, jr.message = this, jr.onAdd(this), Xr(this);
    }
    return jr instanceof fe ? (this.oneofs || (this.oneofs = {}), this.oneofs[jr.name] = jr, jr.onAdd(this), Xr(this)) : v.prototype.add.call(this, jr);
  }, Br.prototype.remove = function(jr) {
    if (jr instanceof be && jr.extend === void 0) {
      if (!this.fields || this.fields[jr.name] !== jr)
        throw Error(jr + " is not a member of " + this);
      return delete this.fields[jr.name], jr.parent = null, jr.onRemove(this), Xr(this);
    }
    if (jr instanceof fe) {
      if (!this.oneofs || this.oneofs[jr.name] !== jr)
        throw Error(jr + " is not a member of " + this);
      return delete this.oneofs[jr.name], jr.parent = null, jr.onRemove(this), Xr(this);
    }
    return v.prototype.remove.call(this, jr);
  }, Br.prototype.isReservedId = function(jr) {
    return v.isReservedId(this.reserved, jr);
  }, Br.prototype.isReservedName = function(jr) {
    return v.isReservedName(this.reserved, jr);
  }, Br.prototype.create = function(jr) {
    return new this.ctor(jr);
  }, Br.prototype.setup = function() {
    for (var jr = this.fullName, kr = [], $r = 0; $r < /* initializes */
    this.fieldsArray.length; ++$r)
      kr.push(this._fieldsArray[$r].resolve().resolvedType);
    this.encode = me(this)({
      Writer: Oe,
      types: kr,
      util: xe
    }), this.decode = we(this)({
      Reader: Se,
      types: kr,
      util: xe
    }), this.verify = ur(this)({
      types: kr,
      util: xe
    }), this.fromObject = lr.fromObject(this)({
      types: kr,
      util: xe
    }), this.toObject = lr.toObject(this)({
      types: kr,
      util: xe
    });
    var Vr = Ar[jr];
    if (Vr) {
      var Mr = Object.create(this);
      Mr.fromObject = this.fromObject, this.fromObject = Vr.fromObject.bind(Mr), Mr.toObject = this.toObject, this.toObject = Vr.toObject.bind(Mr);
    }
    return this;
  }, Br.prototype.encode = function(jr, kr) {
    return this.setup().encode(jr, kr);
  }, Br.prototype.encodeDelimited = function(jr, kr) {
    return this.encode(jr, kr && kr.len ? kr.fork() : kr).ldelim();
  }, Br.prototype.decode = function(jr, kr) {
    return this.setup().decode(jr, kr);
  }, Br.prototype.decodeDelimited = function(jr) {
    return jr instanceof Se || (jr = Se.create(jr)), this.decode(jr, jr.uint32());
  }, Br.prototype.verify = function(jr) {
    return this.setup().verify(jr);
  }, Br.prototype.fromObject = function(jr) {
    return this.setup().fromObject(jr);
  }, Br.prototype.toObject = function(jr, kr) {
    return this.setup().toObject(jr, kr);
  }, Br.d = function(jr) {
    return function($r) {
      xe.decorateType($r, jr);
    };
  }, type;
}
var root, hasRequiredRoot;
function requireRoot() {
  if (hasRequiredRoot)
    return root;
  hasRequiredRoot = 1, root = Oe;
  var v = requireNamespace();
  ((Oe.prototype = Object.create(v.prototype)).constructor = Oe).className = "Root";
  var e = requireField(), fe = require_enum(), be = requireOneof(), ye = requireUtil(), ve, Ee, Se;
  function Oe(ur) {
    v.call(this, "", ur), this.deferred = [], this.files = [];
  }
  Oe.fromJSON = function(lr, Ar) {
    return Ar || (Ar = new Oe()), lr.options && Ar.setOptions(lr.options), Ar.addJSON(lr.nested);
  }, Oe.prototype.resolvePath = ye.path.resolve, Oe.prototype.fetch = ye.fetch;
  function xe() {
  }
  Oe.prototype.load = function ur(lr, Ar, Br) {
    typeof Ar == "function" && (Br = Ar, Ar = void 0);
    var Xr = this;
    if (!Br)
      return ye.asPromise(ur, Xr, lr, Ar);
    var eo = Br === xe;
    function jr(Zr, Wr) {
      if (Br) {
        var qr = Br;
        if (Br = null, eo)
          throw Zr;
        qr(Zr, Wr);
      }
    }
    function kr(Zr) {
      var Wr = Zr.lastIndexOf("google/protobuf/");
      if (Wr > -1) {
        var qr = Zr.substring(Wr);
        if (qr in Se)
          return qr;
      }
      return null;
    }
    function $r(Zr, Wr) {
      try {
        if (ye.isString(Wr) && Wr.charAt(0) === "{" && (Wr = JSON.parse(Wr)), !ye.isString(Wr))
          Xr.setOptions(Wr.options).addJSON(Wr.nested);
        else {
          Ee.filename = Zr;
          var qr = Ee(Wr, Xr, Ar), Qr, lo = 0;
          if (qr.imports)
            for (; lo < qr.imports.length; ++lo)
              (Qr = kr(qr.imports[lo]) || Xr.resolvePath(Zr, qr.imports[lo])) && Vr(Qr);
          if (qr.weakImports)
            for (lo = 0; lo < qr.weakImports.length; ++lo)
              (Qr = kr(qr.weakImports[lo]) || Xr.resolvePath(Zr, qr.weakImports[lo])) && Vr(Qr, !0);
        }
      } catch (Nr) {
        jr(Nr);
      }
      !eo && !Mr && jr(null, Xr);
    }
    function Vr(Zr, Wr) {
      if (Zr = kr(Zr) || Zr, !(Xr.files.indexOf(Zr) > -1)) {
        if (Xr.files.push(Zr), Zr in Se) {
          eo ? $r(Zr, Se[Zr]) : (++Mr, setTimeout(function() {
            --Mr, $r(Zr, Se[Zr]);
          }));
          return;
        }
        if (eo) {
          var qr;
          try {
            qr = ye.fs.readFileSync(Zr).toString("utf8");
          } catch (Qr) {
            Wr || jr(Qr);
            return;
          }
          $r(Zr, qr);
        } else
          ++Mr, Xr.fetch(Zr, function(Qr, lo) {
            if (--Mr, !!Br) {
              if (Qr) {
                Wr ? Mr || jr(null, Xr) : jr(Qr);
                return;
              }
              $r(Zr, lo);
            }
          });
      }
    }
    var Mr = 0;
    ye.isString(lr) && (lr = [lr]);
    for (var gr = 0, Fr; gr < lr.length; ++gr)
      (Fr = Xr.resolvePath("", lr[gr])) && Vr(Fr);
    if (eo)
      return Xr;
    Mr || jr(null, Xr);
  }, Oe.prototype.loadSync = function(lr, Ar) {
    if (!ye.isNode)
      throw Error("not supported");
    return this.load(lr, Ar, xe);
  }, Oe.prototype.resolveAll = function() {
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(lr) {
        return "'extend " + lr.extend + "' in " + lr.parent.fullName;
      }).join(", "));
    return v.prototype.resolveAll.call(this);
  };
  var me = /^[A-Z]/;
  function we(ur, lr) {
    var Ar = lr.parent.lookup(lr.extend);
    if (Ar) {
      var Br = new e(lr.fullName, lr.id, lr.type, lr.rule, void 0, lr.options);
      return Ar.get(Br.name) || (Br.declaringField = lr, lr.extensionField = Br, Ar.add(Br)), !0;
    }
    return !1;
  }
  return Oe.prototype._handleAdd = function(lr) {
    if (lr instanceof e)
      /* an extension field (implies not part of a oneof) */
      lr.extend !== void 0 && /* not already handled */
      !lr.extensionField && (we(this, lr) || this.deferred.push(lr));
    else if (lr instanceof fe)
      me.test(lr.name) && (lr.parent[lr.name] = lr.values);
    else if (!(lr instanceof be)) {
      if (lr instanceof ve)
        for (var Ar = 0; Ar < this.deferred.length; )
          we(this, this.deferred[Ar]) ? this.deferred.splice(Ar, 1) : ++Ar;
      for (var Br = 0; Br < /* initializes */
      lr.nestedArray.length; ++Br)
        this._handleAdd(lr._nestedArray[Br]);
      me.test(lr.name) && (lr.parent[lr.name] = lr);
    }
  }, Oe.prototype._handleRemove = function(lr) {
    if (lr instanceof e) {
      if (
        /* an extension field */
        lr.extend !== void 0
      )
        if (
          /* already handled */
          lr.extensionField
        )
          lr.extensionField.parent.remove(lr.extensionField), lr.extensionField = null;
        else {
          var Ar = this.deferred.indexOf(lr);
          Ar > -1 && this.deferred.splice(Ar, 1);
        }
    } else if (lr instanceof fe)
      me.test(lr.name) && delete lr.parent[lr.name];
    else if (lr instanceof v) {
      for (var Br = 0; Br < /* initializes */
      lr.nestedArray.length; ++Br)
        this._handleRemove(lr._nestedArray[Br]);
      me.test(lr.name) && delete lr.parent[lr.name];
    }
  }, Oe._configure = function(ur, lr, Ar) {
    ve = ur, Ee = lr, Se = Ar;
  }, root;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$3.exports;
  hasRequiredUtil = 1;
  var v = util$3.exports = requireMinimal$1(), e = roots, fe, be;
  v.codegen = codegen_1, v.fetch = fetch_1, v.path = path, v.fs = v.inquire("fs"), v.toArray = function(xe) {
    if (xe) {
      for (var me = Object.keys(xe), we = new Array(me.length), ur = 0; ur < me.length; )
        we[ur] = xe[me[ur++]];
      return we;
    }
    return [];
  }, v.toObject = function(xe) {
    for (var me = {}, we = 0; we < xe.length; ) {
      var ur = xe[we++], lr = xe[we++];
      lr !== void 0 && (me[ur] = lr);
    }
    return me;
  };
  var ye = /\\/g, ve = /"/g;
  v.isReserved = function(xe) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(xe);
  }, v.safeProp = function(xe) {
    return !/^[$\w_]+$/.test(xe) || v.isReserved(xe) ? '["' + xe.replace(ye, "\\\\").replace(ve, '\\"') + '"]' : "." + xe;
  }, v.ucFirst = function(xe) {
    return xe.charAt(0).toUpperCase() + xe.substring(1);
  };
  var Ee = /_([a-z])/g;
  v.camelCase = function(xe) {
    return xe.substring(0, 1) + xe.substring(1).replace(Ee, function(me, we) {
      return we.toUpperCase();
    });
  }, v.compareFieldsById = function(xe, me) {
    return xe.id - me.id;
  }, v.decorateType = function(xe, me) {
    if (xe.$type)
      return me && xe.$type.name !== me && (v.decorateRoot.remove(xe.$type), xe.$type.name = me, v.decorateRoot.add(xe.$type)), xe.$type;
    fe || (fe = requireType());
    var we = new fe(me || xe.name);
    return v.decorateRoot.add(we), we.ctor = xe, Object.defineProperty(xe, "$type", { value: we, enumerable: !1 }), Object.defineProperty(xe.prototype, "$type", { value: we, enumerable: !1 }), we;
  };
  var Se = 0;
  return v.decorateEnum = function(xe) {
    if (xe.$type)
      return xe.$type;
    be || (be = require_enum());
    var me = new be("Enum" + Se++, xe);
    return v.decorateRoot.add(me), Object.defineProperty(xe, "$type", { value: me, enumerable: !1 }), me;
  }, v.setProperty = function(xe, me, we) {
    function ur(lr, Ar, Br) {
      var Xr = Ar.shift();
      if (Xr === "__proto__")
        return lr;
      if (Ar.length > 0)
        lr[Xr] = ur(lr[Xr] || {}, Ar, Br);
      else {
        var eo = lr[Xr];
        eo && (Br = [].concat(eo).concat(Br)), lr[Xr] = Br;
      }
      return lr;
    }
    if (typeof xe != "object")
      throw TypeError("dst must be an object");
    if (!me)
      throw TypeError("path must be specified");
    return me = me.split("."), ur(xe, me, we);
  }, Object.defineProperty(v, "decorateRoot", {
    get: function() {
      return e.decorated || (e.decorated = new (requireRoot())());
    }
  }), util$3.exports;
}
var object, hasRequiredObject;
function requireObject() {
  if (hasRequiredObject)
    return object;
  hasRequiredObject = 1, object = fe, fe.className = "ReflectionObject";
  var v = requireUtil(), e;
  function fe(be, ye) {
    if (!v.isString(be))
      throw TypeError("name must be a string");
    if (ye && !v.isObject(ye))
      throw TypeError("options must be an object");
    this.options = ye, this.parsedOptions = null, this.name = be, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;
  }
  return Object.defineProperties(fe.prototype, {
    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
      get: function() {
        for (var be = this; be.parent !== null; )
          be = be.parent;
        return be;
      }
    },
    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
      get: function() {
        for (var be = [this.name], ye = this.parent; ye; )
          be.unshift(ye.name), ye = ye.parent;
        return be.join(".");
      }
    }
  }), fe.prototype.toJSON = /* istanbul ignore next */
  function() {
    throw Error();
  }, fe.prototype.onAdd = function(ye) {
    this.parent && this.parent !== ye && this.parent.remove(this), this.parent = ye, this.resolved = !1;
    var ve = ye.root;
    ve instanceof e && ve._handleAdd(this);
  }, fe.prototype.onRemove = function(ye) {
    var ve = ye.root;
    ve instanceof e && ve._handleRemove(this), this.parent = null, this.resolved = !1;
  }, fe.prototype.resolve = function() {
    return this.resolved ? this : (this.root instanceof e && (this.resolved = !0), this);
  }, fe.prototype.getOption = function(ye) {
    if (this.options)
      return this.options[ye];
  }, fe.prototype.setOption = function(ye, ve, Ee) {
    return (!Ee || !this.options || this.options[ye] === void 0) && ((this.options || (this.options = {}))[ye] = ve), this;
  }, fe.prototype.setParsedOption = function(ye, ve, Ee) {
    this.parsedOptions || (this.parsedOptions = []);
    var Se = this.parsedOptions;
    if (Ee) {
      var Oe = Se.find(function(we) {
        return Object.prototype.hasOwnProperty.call(we, ye);
      });
      if (Oe) {
        var xe = Oe[ye];
        v.setProperty(xe, Ee, ve);
      } else
        Oe = {}, Oe[ye] = v.setProperty({}, Ee, ve), Se.push(Oe);
    } else {
      var me = {};
      me[ye] = ve, Se.push(me);
    }
    return this;
  }, fe.prototype.setOptions = function(ye, ve) {
    if (ye)
      for (var Ee = Object.keys(ye), Se = 0; Se < Ee.length; ++Se)
        this.setOption(Ee[Se], ye[Ee[Se]], ve);
    return this;
  }, fe.prototype.toString = function() {
    var ye = this.constructor.className, ve = this.fullName;
    return ve.length ? ye + " " + ve : ye;
  }, fe._configure = function(be) {
    e = be;
  }, object;
}
var _enum, hasRequired_enum;
function require_enum() {
  if (hasRequired_enum)
    return _enum;
  hasRequired_enum = 1, _enum = be;
  var v = requireObject();
  ((be.prototype = Object.create(v.prototype)).constructor = be).className = "Enum";
  var e = requireNamespace(), fe = requireUtil();
  function be(ye, ve, Ee, Se, Oe, xe) {
    if (v.call(this, ye, Ee), ve && typeof ve != "object")
      throw TypeError("values must be an object");
    if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = Se, this.comments = Oe || {}, this.valuesOptions = xe, this.reserved = void 0, ve)
      for (var me = Object.keys(ve), we = 0; we < me.length; ++we)
        typeof ve[me[we]] == "number" && (this.valuesById[this.values[me[we]] = ve[me[we]]] = me[we]);
  }
  return be.fromJSON = function(ve, Ee) {
    var Se = new be(ve, Ee.values, Ee.options, Ee.comment, Ee.comments);
    return Se.reserved = Ee.reserved, Se;
  }, be.prototype.toJSON = function(ve) {
    var Ee = ve ? !!ve.keepComments : !1;
    return fe.toObject([
      "options",
      this.options,
      "valuesOptions",
      this.valuesOptions,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "comment",
      Ee ? this.comment : void 0,
      "comments",
      Ee ? this.comments : void 0
    ]);
  }, be.prototype.add = function(ve, Ee, Se, Oe) {
    if (!fe.isString(ve))
      throw TypeError("name must be a string");
    if (!fe.isInteger(Ee))
      throw TypeError("id must be an integer");
    if (this.values[ve] !== void 0)
      throw Error("duplicate name '" + ve + "' in " + this);
    if (this.isReservedId(Ee))
      throw Error("id " + Ee + " is reserved in " + this);
    if (this.isReservedName(ve))
      throw Error("name '" + ve + "' is reserved in " + this);
    if (this.valuesById[Ee] !== void 0) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + Ee + " in " + this);
      this.values[ve] = Ee;
    } else
      this.valuesById[this.values[ve] = Ee] = ve;
    return Oe && (this.valuesOptions === void 0 && (this.valuesOptions = {}), this.valuesOptions[ve] = Oe || null), this.comments[ve] = Se || null, this;
  }, be.prototype.remove = function(ve) {
    if (!fe.isString(ve))
      throw TypeError("name must be a string");
    var Ee = this.values[ve];
    if (Ee == null)
      throw Error("name '" + ve + "' does not exist in " + this);
    return delete this.valuesById[Ee], delete this.values[ve], delete this.comments[ve], this.valuesOptions && delete this.valuesOptions[ve], this;
  }, be.prototype.isReservedId = function(ve) {
    return e.isReservedId(this.reserved, ve);
  }, be.prototype.isReservedName = function(ve) {
    return e.isReservedName(this.reserved, ve);
  }, _enum;
}
var encoder_1, hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder)
    return encoder_1;
  hasRequiredEncoder = 1, encoder_1 = ye;
  var v = require_enum(), e = requireTypes(), fe = requireUtil();
  function be(ve, Ee, Se, Oe) {
    return Ee.resolvedType.group ? ve("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", Se, Oe, (Ee.id << 3 | 3) >>> 0, (Ee.id << 3 | 4) >>> 0) : ve("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", Se, Oe, (Ee.id << 3 | 2) >>> 0);
  }
  function ye(ve) {
    for (var Ee = fe.codegen(["m", "w"], ve.name + "$encode")("if(!w)")("w=Writer.create()"), Se, Oe, xe = (
      /* initializes */
      ve.fieldsArray.slice().sort(fe.compareFieldsById)
    ), Se = 0; Se < xe.length; ++Se) {
      var me = xe[Se].resolve(), we = ve._fieldsArray.indexOf(me), ur = me.resolvedType instanceof v ? "int32" : me.type, lr = e.basic[ur];
      Oe = "m" + fe.safeProp(me.name), me.map ? (Ee("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", Oe, me.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", Oe)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (me.id << 3 | 2) >>> 0, 8 | e.mapKey[me.keyType], me.keyType), lr === void 0 ? Ee("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", we, Oe) : Ee(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | lr, ur, Oe), Ee("}")("}")) : me.repeated ? (Ee("if(%s!=null&&%s.length){", Oe, Oe), me.packed && e.packed[ur] !== void 0 ? Ee("w.uint32(%i).fork()", (me.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", Oe)("w.%s(%s[i])", ur, Oe)("w.ldelim()") : (Ee("for(var i=0;i<%s.length;++i)", Oe), lr === void 0 ? be(Ee, me, we, Oe + "[i]") : Ee("w.uint32(%i).%s(%s[i])", (me.id << 3 | lr) >>> 0, ur, Oe)), Ee("}")) : (me.optional && Ee("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", Oe, me.name), lr === void 0 ? be(Ee, me, we, Oe) : Ee("w.uint32(%i).%s(%s)", (me.id << 3 | lr) >>> 0, ur, Oe));
    }
    return Ee("return w");
  }
  return encoder_1;
}
var protobuf$1 = indexLight.exports = indexMinimal;
protobuf$1.build = "light";
function load(v, e, fe) {
  return typeof e == "function" ? (fe = e, e = new protobuf$1.Root()) : e || (e = new protobuf$1.Root()), e.load(v, fe);
}
protobuf$1.load = load;
function loadSync(v, e) {
  return e || (e = new protobuf$1.Root()), e.loadSync(v);
}
protobuf$1.loadSync = loadSync;
protobuf$1.encoder = requireEncoder();
protobuf$1.decoder = requireDecoder();
protobuf$1.verifier = requireVerifier();
protobuf$1.converter = requireConverter();
protobuf$1.ReflectionObject = requireObject();
protobuf$1.Namespace = requireNamespace();
protobuf$1.Root = requireRoot();
protobuf$1.Enum = require_enum();
protobuf$1.Type = requireType();
protobuf$1.Field = requireField();
protobuf$1.OneOf = requireOneof();
protobuf$1.MapField = requireMapfield();
protobuf$1.Service = requireService();
protobuf$1.Method = requireMethod();
protobuf$1.Message = message;
protobuf$1.wrappers = wrappers;
protobuf$1.types = requireTypes();
protobuf$1.util = requireUtil();
protobuf$1.ReflectionObject._configure(protobuf$1.Root);
protobuf$1.Namespace._configure(protobuf$1.Type, protobuf$1.Service, protobuf$1.Enum);
protobuf$1.Root._configure(protobuf$1.Type);
protobuf$1.Field._configure(protobuf$1.Type);
var indexLightExports = indexLight.exports, tokenize_1 = tokenize$1, delimRe = /[\s{}=;:[\],'"()<>]/g, stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g, stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g, setCommentRe = /^ *[*/]+ */, setCommentAltRe = /^\s*\*?\/*/, setCommentSplitRe = /\n/g, whitespaceRe = /\s/, unescapeRe = /\\(.?)/g, unescapeMap = {
  0: "\0",
  r: "\r",
  n: `
`,
  t: "	"
};
function unescape(v) {
  return v.replace(unescapeRe, function(e, fe) {
    switch (fe) {
      case "\\":
      case "":
        return fe;
      default:
        return unescapeMap[fe] || "";
    }
  });
}
tokenize$1.unescape = unescape;
function tokenize$1(v, e) {
  v = v.toString();
  var fe = 0, be = v.length, ye = 1, ve = 0, Ee = {}, Se = [], Oe = null;
  function xe($r) {
    return Error("illegal " + $r + " (line " + ye + ")");
  }
  function me() {
    var $r = Oe === "'" ? stringSingleRe : stringDoubleRe;
    $r.lastIndex = fe - 1;
    var Vr = $r.exec(v);
    if (!Vr)
      throw xe("string");
    return fe = $r.lastIndex, Xr(Oe), Oe = null, unescape(Vr[1]);
  }
  function we($r) {
    return v.charAt($r);
  }
  function ur($r, Vr, Mr) {
    var gr = {
      type: v.charAt($r++),
      lineEmpty: !1,
      leading: Mr
    }, Fr;
    e ? Fr = 2 : Fr = 3;
    var Zr = $r - Fr, Wr;
    do
      if (--Zr < 0 || (Wr = v.charAt(Zr)) === `
`) {
        gr.lineEmpty = !0;
        break;
      }
    while (Wr === " " || Wr === "	");
    for (var qr = v.substring($r, Vr).split(setCommentSplitRe), Qr = 0; Qr < qr.length; ++Qr)
      qr[Qr] = qr[Qr].replace(e ? setCommentAltRe : setCommentRe, "").trim();
    gr.text = qr.join(`
`).trim(), Ee[ye] = gr, ve = ye;
  }
  function lr($r) {
    var Vr = Ar($r), Mr = v.substring($r, Vr), gr = /^\s*\/{1,2}/.test(Mr);
    return gr;
  }
  function Ar($r) {
    for (var Vr = $r; Vr < be && we(Vr) !== `
`; )
      Vr++;
    return Vr;
  }
  function Br() {
    if (Se.length > 0)
      return Se.shift();
    if (Oe)
      return me();
    var $r, Vr, Mr, gr, Fr, Zr = fe === 0;
    do {
      if (fe === be)
        return null;
      for ($r = !1; whitespaceRe.test(Mr = we(fe)); )
        if (Mr === `
` && (Zr = !0, ++ye), ++fe === be)
          return null;
      if (we(fe) === "/") {
        if (++fe === be)
          throw xe("comment");
        if (we(fe) === "/")
          if (e) {
            if (gr = fe, Fr = !1, lr(fe)) {
              Fr = !0;
              do
                if (fe = Ar(fe), fe === be || (fe++, !Zr))
                  break;
              while (lr(fe));
            } else
              fe = Math.min(be, Ar(fe) + 1);
            Fr && (ur(gr, fe, Zr), Zr = !0), ye++, $r = !0;
          } else {
            for (Fr = we(gr = fe + 1) === "/"; we(++fe) !== `
`; )
              if (fe === be)
                return null;
            ++fe, Fr && (ur(gr, fe - 1, Zr), Zr = !0), ++ye, $r = !0;
          }
        else if ((Mr = we(fe)) === "*") {
          gr = fe + 1, Fr = e || we(gr) === "*";
          do {
            if (Mr === `
` && ++ye, ++fe === be)
              throw xe("comment");
            Vr = Mr, Mr = we(fe);
          } while (Vr !== "*" || Mr !== "/");
          ++fe, Fr && (ur(gr, fe - 2, Zr), Zr = !0), $r = !0;
        } else
          return "/";
      }
    } while ($r);
    var Wr = fe;
    delimRe.lastIndex = 0;
    var qr = delimRe.test(we(Wr++));
    if (!qr)
      for (; Wr < be && !delimRe.test(we(Wr)); )
        ++Wr;
    var Qr = v.substring(fe, fe = Wr);
    return (Qr === '"' || Qr === "'") && (Oe = Qr), Qr;
  }
  function Xr($r) {
    Se.push($r);
  }
  function eo() {
    if (!Se.length) {
      var $r = Br();
      if ($r === null)
        return null;
      Xr($r);
    }
    return Se[0];
  }
  function jr($r, Vr) {
    var Mr = eo(), gr = Mr === $r;
    if (gr)
      return Br(), !0;
    if (!Vr)
      throw xe("token '" + Mr + "', '" + $r + "' expected");
    return !1;
  }
  function kr($r) {
    var Vr = null, Mr;
    return $r === void 0 ? (Mr = Ee[ye - 1], delete Ee[ye - 1], Mr && (e || Mr.type === "*" || Mr.lineEmpty) && (Vr = Mr.leading ? Mr.text : null)) : (ve < $r && eo(), Mr = Ee[$r], delete Ee[$r], Mr && !Mr.lineEmpty && (e || Mr.type === "/") && (Vr = Mr.leading ? null : Mr.text)), Vr;
  }
  return Object.defineProperty({
    next: Br,
    peek: eo,
    push: Xr,
    skip: jr,
    cmnt: kr
  }, "line", {
    get: function() {
      return ye;
    }
  });
}
var parse_1 = parse;
parse.filename = null;
parse.defaults = { keepCase: !1 };
var tokenize = tokenize_1, Root = requireRoot(), Type = requireType(), Field = requireField(), MapField = requireMapfield(), OneOf = requireOneof(), Enum = require_enum(), Service = requireService(), Method = requireMethod(), types = requireTypes(), util$1 = requireUtil(), base10Re = /^[1-9][0-9]*$/, base10NegRe = /^-?[1-9][0-9]*$/, base16Re = /^0[x][0-9a-fA-F]+$/, base16NegRe = /^-?0[x][0-9a-fA-F]+$/, base8Re = /^0[0-7]+$/, base8NegRe = /^-?0[0-7]+$/, numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/, typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/, fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
function parse(v, e, fe) {
  e instanceof Root || (fe = e, e = new Root()), fe || (fe = parse.defaults);
  var be = fe.preferTrailingComment || !1, ye = tokenize(v, fe.alternateCommentMode || !1), ve = ye.next, Ee = ye.push, Se = ye.peek, Oe = ye.skip, xe = ye.cmnt, me = !0, we, ur, lr, Ar, Br = !1, Xr = e, eo = fe.keepCase ? function(zr) {
    return zr;
  } : util$1.camelCase;
  function jr(zr, dr, Hr) {
    var go = parse.filename;
    return Hr || (parse.filename = null), Error("illegal " + (dr || "token") + " '" + zr + "' (" + (go ? go + ", " : "") + "line " + ye.line + ")");
  }
  function kr() {
    var zr = [], dr;
    do {
      if ((dr = ve()) !== '"' && dr !== "'")
        throw jr(dr);
      zr.push(ve()), Oe(dr), dr = Se();
    } while (dr === '"' || dr === "'");
    return zr.join("");
  }
  function $r(zr) {
    var dr = ve();
    switch (dr) {
      case "'":
      case '"':
        return Ee(dr), kr();
      case "true":
      case "TRUE":
        return !0;
      case "false":
      case "FALSE":
        return !1;
    }
    try {
      return Mr(
        dr,
        /* insideTryCatch */
        !0
      );
    } catch {
      if (zr && typeRefRe.test(dr))
        return dr;
      throw jr(dr, "value");
    }
  }
  function Vr(zr, dr) {
    var Hr, go;
    do
      dr && ((Hr = Se()) === '"' || Hr === "'") ? zr.push(kr()) : zr.push([go = gr(ve()), Oe("to", !0) ? gr(ve()) : go]);
    while (Oe(",", !0));
    Oe(";");
  }
  function Mr(zr, dr) {
    var Hr = 1;
    switch (zr.charAt(0) === "-" && (Hr = -1, zr = zr.substring(1)), zr) {
      case "inf":
      case "INF":
      case "Inf":
        return Hr * (1 / 0);
      case "nan":
      case "NAN":
      case "Nan":
      case "NaN":
        return NaN;
      case "0":
        return 0;
    }
    if (base10Re.test(zr))
      return Hr * parseInt(zr, 10);
    if (base16Re.test(zr))
      return Hr * parseInt(zr, 16);
    if (base8Re.test(zr))
      return Hr * parseInt(zr, 8);
    if (numberRe.test(zr))
      return Hr * parseFloat(zr);
    throw jr(zr, "number", dr);
  }
  function gr(zr, dr) {
    switch (zr) {
      case "max":
      case "MAX":
      case "Max":
        return 536870911;
      case "0":
        return 0;
    }
    if (!dr && zr.charAt(0) === "-")
      throw jr(zr, "id");
    if (base10NegRe.test(zr))
      return parseInt(zr, 10);
    if (base16NegRe.test(zr))
      return parseInt(zr, 16);
    if (base8NegRe.test(zr))
      return parseInt(zr, 8);
    throw jr(zr, "id");
  }
  function Fr() {
    if (we !== void 0)
      throw jr("package");
    if (we = ve(), !typeRefRe.test(we))
      throw jr(we, "name");
    Xr = Xr.define(we), Oe(";");
  }
  function Zr() {
    var zr = Se(), dr;
    switch (zr) {
      case "weak":
        dr = lr || (lr = []), ve();
        break;
      case "public":
        ve();
      default:
        dr = ur || (ur = []);
        break;
    }
    zr = kr(), Oe(";"), dr.push(zr);
  }
  function Wr() {
    if (Oe("="), Ar = kr(), Br = Ar === "proto3", !Br && Ar !== "proto2")
      throw jr(Ar, "syntax");
    Oe(";");
  }
  function qr(zr, dr) {
    switch (dr) {
      case "option":
        return uo(zr, dr), Oe(";"), !0;
      case "message":
        return lo(zr, dr), !0;
      case "enum":
        return co(zr, dr), !0;
      case "service":
        return Oo(zr, dr), !0;
      case "extend":
        return ao(zr, dr), !0;
    }
    return !1;
  }
  function Qr(zr, dr, Hr) {
    var go = ye.line;
    if (zr && (typeof zr.comment != "string" && (zr.comment = xe()), zr.filename = parse.filename), Oe("{", !0)) {
      for (var ho; (ho = ve()) !== "}"; )
        dr(ho);
      Oe(";", !0);
    } else
      Hr && Hr(), Oe(";"), zr && (typeof zr.comment != "string" || be) && (zr.comment = xe(go) || zr.comment);
  }
  function lo(zr, dr) {
    if (!nameRe.test(dr = ve()))
      throw jr(dr, "type name");
    var Hr = new Type(dr);
    Qr(Hr, function(ho) {
      if (!qr(Hr, ho))
        switch (ho) {
          case "map":
            so(Hr);
            break;
          case "required":
          case "repeated":
            Nr(Hr, ho);
            break;
          case "optional":
            Br ? Nr(Hr, "proto3_optional") : Nr(Hr, "optional");
            break;
          case "oneof":
            fo(Hr, ho);
            break;
          case "extensions":
            Vr(Hr.extensions || (Hr.extensions = []));
            break;
          case "reserved":
            Vr(Hr.reserved || (Hr.reserved = []), !0);
            break;
          default:
            if (!Br || !typeRefRe.test(ho))
              throw jr(ho);
            Ee(ho), Nr(Hr, "optional");
            break;
        }
    }), zr.add(Hr);
  }
  function Nr(zr, dr, Hr) {
    var go = ve();
    if (go === "group") {
      Lr(zr, dr);
      return;
    }
    for (; go.endsWith(".") || Se().startsWith("."); )
      go += ve();
    if (!typeRefRe.test(go))
      throw jr(go, "type");
    var ho = ve();
    if (!nameRe.test(ho))
      throw jr(ho, "name");
    ho = eo(ho), Oe("=");
    var Eo = new Field(ho, gr(ve()), go, dr, Hr);
    if (Qr(Eo, function(jo) {
      if (jo === "option")
        uo(Eo, jo), Oe(";");
      else
        throw jr(jo);
    }, function() {
      To(Eo);
    }), dr === "proto3_optional") {
      var Fo = new OneOf("_" + ho);
      Eo.setOption("proto3_optional", !0), Fo.add(Eo), zr.add(Fo);
    } else
      zr.add(Eo);
    !Br && Eo.repeated && (types.packed[go] !== void 0 || types.basic[go] === void 0) && Eo.setOption(
      "packed",
      !1,
      /* ifNotSet */
      !0
    );
  }
  function Lr(zr, dr) {
    var Hr = ve();
    if (!nameRe.test(Hr))
      throw jr(Hr, "name");
    var go = util$1.lcFirst(Hr);
    Hr === go && (Hr = util$1.ucFirst(Hr)), Oe("=");
    var ho = gr(ve()), Eo = new Type(Hr);
    Eo.group = !0;
    var Fo = new Field(go, ho, Hr, dr);
    Fo.filename = parse.filename, Qr(Eo, function(jo) {
      switch (jo) {
        case "option":
          uo(Eo, jo), Oe(";");
          break;
        case "required":
        case "repeated":
          Nr(Eo, jo);
          break;
        case "optional":
          Br ? Nr(Eo, "proto3_optional") : Nr(Eo, "optional");
          break;
        case "message":
          lo(Eo, jo);
          break;
        case "enum":
          co(Eo, jo);
          break;
        default:
          throw jr(jo);
      }
    }), zr.add(Eo).add(Fo);
  }
  function so(zr) {
    Oe("<");
    var dr = ve();
    if (types.mapKey[dr] === void 0)
      throw jr(dr, "type");
    Oe(",");
    var Hr = ve();
    if (!typeRefRe.test(Hr))
      throw jr(Hr, "type");
    Oe(">");
    var go = ve();
    if (!nameRe.test(go))
      throw jr(go, "name");
    Oe("=");
    var ho = new MapField(eo(go), gr(ve()), dr, Hr);
    Qr(ho, function(Fo) {
      if (Fo === "option")
        uo(ho, Fo), Oe(";");
      else
        throw jr(Fo);
    }, function() {
      To(ho);
    }), zr.add(ho);
  }
  function fo(zr, dr) {
    if (!nameRe.test(dr = ve()))
      throw jr(dr, "name");
    var Hr = new OneOf(eo(dr));
    Qr(Hr, function(ho) {
      ho === "option" ? (uo(Hr, ho), Oe(";")) : (Ee(ho), Nr(Hr, "optional"));
    }), zr.add(Hr);
  }
  function co(zr, dr) {
    if (!nameRe.test(dr = ve()))
      throw jr(dr, "name");
    var Hr = new Enum(dr);
    Qr(Hr, function(ho) {
      switch (ho) {
        case "option":
          uo(Hr, ho), Oe(";");
          break;
        case "reserved":
          Vr(Hr.reserved || (Hr.reserved = []), !0);
          break;
        default:
          no(Hr, ho);
      }
    }), zr.add(Hr);
  }
  function no(zr, dr) {
    if (!nameRe.test(dr))
      throw jr(dr, "name");
    Oe("=");
    var Hr = gr(ve(), !0), go = {
      options: void 0
    };
    go.setOption = function(ho, Eo) {
      this.options === void 0 && (this.options = {}), this.options[ho] = Eo;
    }, Qr(go, function(Eo) {
      if (Eo === "option")
        uo(go, Eo), Oe(";");
      else
        throw jr(Eo);
    }, function() {
      To(go);
    }), zr.add(dr, Hr, go.comment, go.options);
  }
  function uo(zr, dr) {
    var Hr = Oe("(", !0);
    if (!typeRefRe.test(dr = ve()))
      throw jr(dr, "name");
    var go = dr, ho = go, Eo;
    Hr && (Oe(")"), go = "(" + go + ")", ho = go, dr = Se(), fqTypeRefRe.test(dr) && (Eo = dr.slice(1), go += dr, ve())), Oe("=");
    var Fo = bo(zr, go);
    io(zr, ho, Fo, Eo);
  }
  function bo(zr, dr) {
    if (Oe("{", !0)) {
      for (var Hr = {}; !Oe("}", !0); ) {
        if (!nameRe.test(oo = ve()))
          throw jr(oo, "name");
        var go, ho = oo;
        if (Oe(":", !0), Se() === "{")
          go = bo(zr, dr + "." + oo);
        else if (Se() === "[") {
          go = [];
          var Eo;
          if (Oe("[", !0)) {
            do
              Eo = $r(!0), go.push(Eo);
            while (Oe(",", !0));
            Oe("]"), typeof Eo < "u" && So(zr, dr + "." + oo, Eo);
          }
        } else
          go = $r(!0), So(zr, dr + "." + oo, go);
        var Fo = Hr[ho];
        Fo && (go = [].concat(Fo).concat(go)), Hr[ho] = go, Oe(",", !0), Oe(";", !0);
      }
      return Hr;
    }
    var Po = $r(!0);
    return So(zr, dr, Po), Po;
  }
  function So(zr, dr, Hr) {
    zr.setOption && zr.setOption(dr, Hr);
  }
  function io(zr, dr, Hr, go) {
    zr.setParsedOption && zr.setParsedOption(dr, Hr, go);
  }
  function To(zr) {
    if (Oe("[", !0)) {
      do
        uo(zr, "option");
      while (Oe(",", !0));
      Oe("]");
    }
    return zr;
  }
  function Oo(zr, dr) {
    if (!nameRe.test(dr = ve()))
      throw jr(dr, "service name");
    var Hr = new Service(dr);
    Qr(Hr, function(ho) {
      if (!qr(Hr, ho))
        if (ho === "rpc")
          Mo(Hr, ho);
        else
          throw jr(ho);
    }), zr.add(Hr);
  }
  function Mo(zr, dr) {
    var Hr = xe(), go = dr;
    if (!nameRe.test(dr = ve()))
      throw jr(dr, "name");
    var ho = dr, Eo, Fo, Po, jo;
    if (Oe("("), Oe("stream", !0) && (Fo = !0), !typeRefRe.test(dr = ve()) || (Eo = dr, Oe(")"), Oe("returns"), Oe("("), Oe("stream", !0) && (jo = !0), !typeRefRe.test(dr = ve())))
      throw jr(dr);
    Po = dr, Oe(")");
    var Qo = new Method(ho, go, Eo, Po, Fo, jo);
    Qo.comment = Hr, Qr(Qo, function(Lo) {
      if (Lo === "option")
        uo(Qo, Lo), Oe(";");
      else
        throw jr(Lo);
    }), zr.add(Qo);
  }
  function ao(zr, dr) {
    if (!typeRefRe.test(dr = ve()))
      throw jr(dr, "reference");
    var Hr = dr;
    Qr(null, function(ho) {
      switch (ho) {
        case "required":
        case "repeated":
          Nr(zr, ho, Hr);
          break;
        case "optional":
          Br ? Nr(zr, "proto3_optional", Hr) : Nr(zr, "optional", Hr);
          break;
        default:
          if (!Br || !typeRefRe.test(ho))
            throw jr(ho);
          Ee(ho), Nr(zr, "optional", Hr);
          break;
      }
    });
  }
  for (var oo; (oo = ve()) !== null; )
    switch (oo) {
      case "package":
        if (!me)
          throw jr(oo);
        Fr();
        break;
      case "import":
        if (!me)
          throw jr(oo);
        Zr();
        break;
      case "syntax":
        if (!me)
          throw jr(oo);
        Wr();
        break;
      case "option":
        uo(Xr, oo), Oe(";");
        break;
      default:
        if (qr(Xr, oo)) {
          me = !1;
          continue;
        }
        throw jr(oo);
    }
  return parse.filename = null, {
    package: we,
    imports: ur,
    weakImports: lr,
    syntax: Ar,
    root: e
  };
}
var common_1 = common, commonRe = /\/|\./;
function common(v, e) {
  commonRe.test(v) || (v = "google/protobuf/" + v + ".proto", e = { nested: { google: { nested: { protobuf: { nested: e } } } } }), common[v] = e;
}
common("any", {
  /**
   * Properties of a google.protobuf.Any message.
   * @interface IAny
   * @type {Object}
   * @property {string} [typeUrl]
   * @property {Uint8Array} [bytes]
   * @memberof common
   */
  Any: {
    fields: {
      type_url: {
        type: "string",
        id: 1
      },
      value: {
        type: "bytes",
        id: 2
      }
    }
  }
});
var timeType;
common("duration", {
  /**
   * Properties of a google.protobuf.Duration message.
   * @interface IDuration
   * @type {Object}
   * @property {number|Long} [seconds]
   * @property {number} [nanos]
   * @memberof common
   */
  Duration: timeType = {
    fields: {
      seconds: {
        type: "int64",
        id: 1
      },
      nanos: {
        type: "int32",
        id: 2
      }
    }
  }
});
common("timestamp", {
  /**
   * Properties of a google.protobuf.Timestamp message.
   * @interface ITimestamp
   * @type {Object}
   * @property {number|Long} [seconds]
   * @property {number} [nanos]
   * @memberof common
   */
  Timestamp: timeType
});
common("empty", {
  /**
   * Properties of a google.protobuf.Empty message.
   * @interface IEmpty
   * @memberof common
   */
  Empty: {
    fields: {}
  }
});
common("struct", {
  /**
   * Properties of a google.protobuf.Struct message.
   * @interface IStruct
   * @type {Object}
   * @property {Object.<string,IValue>} [fields]
   * @memberof common
   */
  Struct: {
    fields: {
      fields: {
        keyType: "string",
        type: "Value",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.Value message.
   * @interface IValue
   * @type {Object}
   * @property {string} [kind]
   * @property {0} [nullValue]
   * @property {number} [numberValue]
   * @property {string} [stringValue]
   * @property {boolean} [boolValue]
   * @property {IStruct} [structValue]
   * @property {IListValue} [listValue]
   * @memberof common
   */
  Value: {
    oneofs: {
      kind: {
        oneof: [
          "nullValue",
          "numberValue",
          "stringValue",
          "boolValue",
          "structValue",
          "listValue"
        ]
      }
    },
    fields: {
      nullValue: {
        type: "NullValue",
        id: 1
      },
      numberValue: {
        type: "double",
        id: 2
      },
      stringValue: {
        type: "string",
        id: 3
      },
      boolValue: {
        type: "bool",
        id: 4
      },
      structValue: {
        type: "Struct",
        id: 5
      },
      listValue: {
        type: "ListValue",
        id: 6
      }
    }
  },
  NullValue: {
    values: {
      NULL_VALUE: 0
    }
  },
  /**
   * Properties of a google.protobuf.ListValue message.
   * @interface IListValue
   * @type {Object}
   * @property {Array.<IValue>} [values]
   * @memberof common
   */
  ListValue: {
    fields: {
      values: {
        rule: "repeated",
        type: "Value",
        id: 1
      }
    }
  }
});
common("wrappers", {
  /**
   * Properties of a google.protobuf.DoubleValue message.
   * @interface IDoubleValue
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  DoubleValue: {
    fields: {
      value: {
        type: "double",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.FloatValue message.
   * @interface IFloatValue
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  FloatValue: {
    fields: {
      value: {
        type: "float",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.Int64Value message.
   * @interface IInt64Value
   * @type {Object}
   * @property {number|Long} [value]
   * @memberof common
   */
  Int64Value: {
    fields: {
      value: {
        type: "int64",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.UInt64Value message.
   * @interface IUInt64Value
   * @type {Object}
   * @property {number|Long} [value]
   * @memberof common
   */
  UInt64Value: {
    fields: {
      value: {
        type: "uint64",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.Int32Value message.
   * @interface IInt32Value
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  Int32Value: {
    fields: {
      value: {
        type: "int32",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.UInt32Value message.
   * @interface IUInt32Value
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  UInt32Value: {
    fields: {
      value: {
        type: "uint32",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.BoolValue message.
   * @interface IBoolValue
   * @type {Object}
   * @property {boolean} [value]
   * @memberof common
   */
  BoolValue: {
    fields: {
      value: {
        type: "bool",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.StringValue message.
   * @interface IStringValue
   * @type {Object}
   * @property {string} [value]
   * @memberof common
   */
  StringValue: {
    fields: {
      value: {
        type: "string",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.BytesValue message.
   * @interface IBytesValue
   * @type {Object}
   * @property {Uint8Array} [value]
   * @memberof common
   */
  BytesValue: {
    fields: {
      value: {
        type: "bytes",
        id: 1
      }
    }
  }
});
common("field_mask", {
  /**
   * Properties of a google.protobuf.FieldMask message.
   * @interface IDoubleValue
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  FieldMask: {
    fields: {
      paths: {
        rule: "repeated",
        type: "string",
        id: 1
      }
    }
  }
});
common.get = function v(e) {
  return common[e] || null;
};
var protobuf = src.exports = indexLightExports;
protobuf.build = "full";
protobuf.tokenize = tokenize_1;
protobuf.parse = parse_1;
protobuf.common = common_1;
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
var srcExports = src.exports, protobufjs = srcExports, lib$1 = {}, descriptor_pb = {}, googleProtobuf = {};
(function(exports) {
  var $jscomp = $jscomp || {};
  $jscomp.scope = {}, $jscomp.findInternal = function(v, e, fe) {
    v instanceof String && (v = String(v));
    for (var be = v.length, ye = 0; ye < be; ye++) {
      var ve = v[ye];
      if (e.call(fe, ve, ye, v))
        return { i: ye, v: ve };
    }
    return { i: -1, v: void 0 };
  }, $jscomp.ASSUME_ES5 = !1, $jscomp.ASSUME_NO_NATIVE_MAP = !1, $jscomp.ASSUME_NO_NATIVE_SET = !1, $jscomp.SIMPLE_FROUND_POLYFILL = !1, $jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(v, e, fe) {
    v != Array.prototype && v != Object.prototype && (v[e] = fe.value);
  }, $jscomp.getGlobal = function(v) {
    return typeof window < "u" && window === v ? v : typeof commonjsGlobal < "u" && commonjsGlobal != null ? commonjsGlobal : v;
  }, $jscomp.global = $jscomp.getGlobal(commonjsGlobal), $jscomp.polyfill = function(v, e, fe, be) {
    if (e) {
      for (fe = $jscomp.global, v = v.split("."), be = 0; be < v.length - 1; be++) {
        var ye = v[be];
        ye in fe || (fe[ye] = {}), fe = fe[ye];
      }
      v = v[v.length - 1], be = fe[v], e = e(be), e != be && e != null && $jscomp.defineProperty(fe, v, { configurable: !0, writable: !0, value: e });
    }
  }, $jscomp.polyfill("Array.prototype.findIndex", function(v) {
    return v || function(e, fe) {
      return $jscomp.findInternal(this, e, fe).i;
    };
  }, "es6", "es3"), $jscomp.checkStringArgs = function(v, e, fe) {
    if (v == null)
      throw new TypeError("The 'this' value for String.prototype." + fe + " must not be null or undefined");
    if (e instanceof RegExp)
      throw new TypeError("First argument to String.prototype." + fe + " must not be a regular expression");
    return v + "";
  }, $jscomp.polyfill("String.prototype.endsWith", function(v) {
    return v || function(e, fe) {
      var be = $jscomp.checkStringArgs(this, e, "endsWith");
      e += "", fe === void 0 && (fe = be.length), fe = Math.max(0, Math.min(fe | 0, be.length));
      for (var ye = e.length; 0 < ye && 0 < fe; )
        if (be[--fe] != e[--ye])
          return !1;
      return 0 >= ye;
    };
  }, "es6", "es3"), $jscomp.polyfill("Array.prototype.find", function(v) {
    return v || function(e, fe) {
      return $jscomp.findInternal(this, e, fe).v;
    };
  }, "es6", "es3"), $jscomp.polyfill("String.prototype.startsWith", function(v) {
    return v || function(e, fe) {
      var be = $jscomp.checkStringArgs(this, e, "startsWith");
      e += "";
      var ye = be.length, ve = e.length;
      fe = Math.max(0, Math.min(fe | 0, be.length));
      for (var Ee = 0; Ee < ve && fe < ye; )
        if (be[fe++] != e[Ee++])
          return !1;
      return Ee >= ve;
    };
  }, "es6", "es3"), $jscomp.polyfill("String.prototype.repeat", function(v) {
    return v || function(e) {
      var fe = $jscomp.checkStringArgs(this, null, "repeat");
      if (0 > e || 1342177279 < e)
        throw new RangeError("Invalid count value");
      e |= 0;
      for (var be = ""; e; )
        e & 1 && (be += fe), (e >>>= 1) && (fe += fe);
      return be;
    };
  }, "es6", "es3");
  var COMPILED = !0, goog = goog || {};
  goog.global = commonjsGlobal || self, goog.exportPath_ = function(v, e, fe) {
    v = v.split("."), fe = fe || goog.global, v[0] in fe || typeof fe.execScript > "u" || fe.execScript("var " + v[0]);
    for (var be; v.length && (be = v.shift()); )
      v.length || e === void 0 ? fe = fe[be] && fe[be] !== Object.prototype[be] ? fe[be] : fe[be] = {} : fe[be] = e;
  }, goog.define = function(v, e) {
    return e;
  }, goog.FEATURESET_YEAR = 2012, goog.DEBUG = !0, goog.LOCALE = "en", goog.TRUSTED_SITE = !0, goog.STRICT_MODE_COMPATIBLE = !1, goog.DISALLOW_TEST_ONLY_CODE = !goog.DEBUG, goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1, goog.provide = function(v) {
    if (goog.isInModuleLoader_())
      throw Error("goog.provide cannot be used within a module.");
    goog.constructNamespace_(v);
  }, goog.constructNamespace_ = function(v, e) {
    goog.exportPath_(v, e);
  }, goog.getScriptNonce = function(v) {
    return v && v != goog.global ? goog.getScriptNonce_(v.document) : (goog.cspNonce_ === null && (goog.cspNonce_ = goog.getScriptNonce_(goog.global.document)), goog.cspNonce_);
  }, goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/, goog.cspNonce_ = null, goog.getScriptNonce_ = function(v) {
    return (v = v.querySelector && v.querySelector("script[nonce]")) && (v = v.nonce || v.getAttribute("nonce")) && goog.NONCE_PATTERN_.test(v) ? v : "";
  }, goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/, goog.module = function(v) {
    if (typeof v != "string" || !v || v.search(goog.VALID_MODULE_RE_) == -1)
      throw Error("Invalid module identifier");
    if (!goog.isInGoogModuleLoader_())
      throw Error("Module " + v + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
    if (goog.moduleLoaderState_.moduleName)
      throw Error("goog.module may only be called once per module.");
    goog.moduleLoaderState_.moduleName = v;
  }, goog.module.get = function(v) {
    return goog.module.getInternal_(v);
  }, goog.module.getInternal_ = function(v) {
    return null;
  }, goog.ModuleType = { ES6: "es6", GOOG: "goog" }, goog.moduleLoaderState_ = null, goog.isInModuleLoader_ = function() {
    return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
  }, goog.isInGoogModuleLoader_ = function() {
    return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
  }, goog.isInEs6ModuleLoader_ = function() {
    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6)
      return !0;
    var v = goog.global.$jscomp;
    return v ? typeof v.getCurrentModulePath != "function" ? !1 : !!v.getCurrentModulePath() : !1;
  }, goog.module.declareLegacyNamespace = function() {
    goog.moduleLoaderState_.declareLegacyNamespace = !0;
  }, goog.declareModuleId = function(v) {
    if (goog.moduleLoaderState_)
      goog.moduleLoaderState_.moduleName = v;
    else {
      var e = goog.global.$jscomp;
      if (!e || typeof e.getCurrentModulePath != "function")
        throw Error('Module with namespace "' + v + '" has been loaded incorrectly.');
      e = e.require(e.getCurrentModulePath()), goog.loadedModules_[v] = { exports: e, type: goog.ModuleType.ES6, moduleId: v };
    }
  }, goog.setTestOnly = function(v) {
    if (goog.DISALLOW_TEST_ONLY_CODE)
      throw v = v || "", Error("Importing test-only code into non-debug environment" + (v ? ": " + v : "."));
  }, goog.forwardDeclare = function(v) {
  }, goog.getObjectByName = function(v, e) {
    v = v.split("."), e = e || goog.global;
    for (var fe = 0; fe < v.length; fe++)
      if (e = e[v[fe]], e == null)
        return null;
    return e;
  }, goog.globalize = function(v, e) {
    e = e || goog.global;
    for (var fe in v)
      e[fe] = v[fe];
  }, goog.addDependency = function(v, e, fe, be) {
  }, goog.ENABLE_DEBUG_LOADER = !0, goog.logToConsole_ = function(v) {
    goog.global.console && goog.global.console.error(v);
  }, goog.require = function(v) {
  }, goog.requireType = function(v) {
    return {};
  }, goog.basePath = "", goog.nullFunction = function() {
  }, goog.abstractMethod = function() {
    throw Error("unimplemented abstract method");
  }, goog.addSingletonGetter = function(v) {
    v.instance_ = void 0, v.getInstance = function() {
      return v.instance_ ? v.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = v), v.instance_ = new v());
    };
  }, goog.instantiatedSingletons_ = [], goog.LOAD_MODULE_USING_EVAL = !0, goog.SEAL_MODULE_EXPORTS = goog.DEBUG, goog.loadedModules_ = {}, goog.DEPENDENCIES_ENABLED = !COMPILED, goog.TRANSPILE = "detect", goog.ASSUME_ES_MODULES_TRANSPILED = !1, goog.TRANSPILE_TO_LANGUAGE = "", goog.TRANSPILER = "transpile.js", goog.hasBadLetScoping = null, goog.useSafari10Workaround = function() {
    if (goog.hasBadLetScoping == null) {
      try {
        var a = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');
      } catch (v) {
        a = !1;
      }
      goog.hasBadLetScoping = a;
    }
    return goog.hasBadLetScoping;
  }, goog.workaroundSafari10EvalBug = function(v) {
    return "(function(){" + v + `
;})();
`;
  }, goog.loadModule = function(v) {
    var e = goog.moduleLoaderState_;
    try {
      if (goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: !1, type: goog.ModuleType.GOOG }, goog.isFunction(v))
        var fe = v.call(void 0, {});
      else if (typeof v == "string")
        goog.useSafari10Workaround() && (v = goog.workaroundSafari10EvalBug(v)), fe = goog.loadModuleFromSource_.call(void 0, v);
      else
        throw Error("Invalid module definition");
      var be = goog.moduleLoaderState_.moduleName;
      if (typeof be == "string" && be)
        goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(
          be,
          fe
        ) : goog.SEAL_MODULE_EXPORTS && Object.seal && typeof fe == "object" && fe != null && Object.seal(fe), goog.loadedModules_[be] = { exports: fe, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
      else
        throw Error('Invalid module name "' + be + '"');
    } finally {
      goog.moduleLoaderState_ = e;
    }
  }, goog.loadModuleFromSource_ = function(a) {
    return eval(a), {};
  }, goog.normalizePath_ = function(v) {
    v = v.split("/");
    for (var e = 0; e < v.length; )
      v[e] == "." ? v.splice(e, 1) : e && v[e] == ".." && v[e - 1] && v[e - 1] != ".." ? v.splice(--e, 2) : e++;
    return v.join("/");
  }, goog.loadFileSync_ = function(v) {
    if (goog.global.CLOSURE_LOAD_FILE_SYNC)
      return goog.global.CLOSURE_LOAD_FILE_SYNC(v);
    try {
      var e = new goog.global.XMLHttpRequest();
      return e.open("get", v, !1), e.send(), e.status == 0 || e.status == 200 ? e.responseText : null;
    } catch {
      return null;
    }
  }, goog.transpile_ = function(v, e, fe) {
    var be = goog.global.$jscomp;
    be || (goog.global.$jscomp = be = {});
    var ye = be.transpile;
    if (!ye) {
      var ve = goog.basePath + goog.TRANSPILER, Ee = goog.loadFileSync_(ve);
      if (Ee) {
        if (function() {
          (0, eval)(Ee + `
//# sourceURL=` + ve);
        }.call(goog.global), goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile)
          throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));
        goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile, be = goog.global.$jscomp, ye = be.transpile;
      }
    }
    return ye || (ye = be.transpile = function(Se, Oe) {
      return goog.logToConsole_(Oe + " requires transpilation but no transpiler was found."), Se;
    }), ye(v, e, fe);
  }, goog.typeOf = function(v) {
    var e = typeof v;
    if (e == "object")
      if (v) {
        if (v instanceof Array)
          return "array";
        if (v instanceof Object)
          return e;
        var fe = Object.prototype.toString.call(v);
        if (fe == "[object Window]")
          return "object";
        if (fe == "[object Array]" || typeof v.length == "number" && typeof v.splice < "u" && typeof v.propertyIsEnumerable < "u" && !v.propertyIsEnumerable("splice"))
          return "array";
        if (fe == "[object Function]" || typeof v.call < "u" && typeof v.propertyIsEnumerable < "u" && !v.propertyIsEnumerable("call"))
          return "function";
      } else
        return "null";
    else if (e == "function" && typeof v.call > "u")
      return "object";
    return e;
  }, goog.isArray = function(v) {
    return goog.typeOf(v) == "array";
  }, goog.isArrayLike = function(v) {
    var e = goog.typeOf(v);
    return e == "array" || e == "object" && typeof v.length == "number";
  }, goog.isDateLike = function(v) {
    return goog.isObject(v) && typeof v.getFullYear == "function";
  }, goog.isFunction = function(v) {
    return goog.typeOf(v) == "function";
  }, goog.isObject = function(v) {
    var e = typeof v;
    return e == "object" && v != null || e == "function";
  }, goog.getUid = function(v) {
    return Object.prototype.hasOwnProperty.call(v, goog.UID_PROPERTY_) && v[goog.UID_PROPERTY_] || (v[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  }, goog.hasUid = function(v) {
    return !!v[goog.UID_PROPERTY_];
  }, goog.removeUid = function(v) {
    v !== null && "removeAttribute" in v && v.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete v[goog.UID_PROPERTY_];
    } catch {
    }
  }, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(v) {
    var e = goog.typeOf(v);
    if (e == "object" || e == "array") {
      if (typeof v.clone == "function")
        return v.clone();
      e = e == "array" ? [] : {};
      for (var fe in v)
        e[fe] = goog.cloneObject(v[fe]);
      return e;
    }
    return v;
  }, goog.bindNative_ = function(v, e, fe) {
    return v.call.apply(v.bind, arguments);
  }, goog.bindJs_ = function(v, e, fe) {
    if (!v)
      throw Error();
    if (2 < arguments.length) {
      var be = Array.prototype.slice.call(arguments, 2);
      return function() {
        var ye = Array.prototype.slice.call(arguments);
        return Array.prototype.unshift.apply(ye, be), v.apply(e, ye);
      };
    }
    return function() {
      return v.apply(e, arguments);
    };
  }, goog.bind = function(v, e, fe) {
    return Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_, goog.bind.apply(null, arguments);
  }, goog.partial = function(v, e) {
    var fe = Array.prototype.slice.call(arguments, 1);
    return function() {
      var be = fe.slice();
      return be.push.apply(be, arguments), v.apply(this, be);
    };
  }, goog.mixin = function(v, e) {
    for (var fe in e)
      v[fe] = e[fe];
  }, goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return +/* @__PURE__ */ new Date();
  }, goog.globalEval = function(v) {
    if (goog.global.execScript)
      goog.global.execScript(v, "JavaScript");
    else if (goog.global.eval) {
      if (goog.evalWorksForGlobals_ == null) {
        try {
          goog.global.eval("var _evalTest_ = 1;");
        } catch {
        }
        if (typeof goog.global._evalTest_ < "u") {
          try {
            delete goog.global._evalTest_;
          } catch {
          }
          goog.evalWorksForGlobals_ = !0;
        } else
          goog.evalWorksForGlobals_ = !1;
      }
      if (goog.evalWorksForGlobals_)
        goog.global.eval(v);
      else {
        var e = goog.global.document, fe = e.createElement("script");
        fe.type = "text/javascript", fe.defer = !1, fe.appendChild(e.createTextNode(v)), e.head.appendChild(fe), e.head.removeChild(fe);
      }
    } else
      throw Error("goog.globalEval not available");
  }, goog.evalWorksForGlobals_ = null, goog.getCssName = function(v, e) {
    if (String(v).charAt(0) == ".")
      throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + v);
    var fe = function(ye) {
      return goog.cssNameMapping_[ye] || ye;
    }, be = function(ye) {
      ye = ye.split("-");
      for (var ve = [], Ee = 0; Ee < ye.length; Ee++)
        ve.push(fe(ye[Ee]));
      return ve.join("-");
    };
    return be = goog.cssNameMapping_ ? goog.cssNameMappingStyle_ == "BY_WHOLE" ? fe : be : function(ye) {
      return ye;
    }, v = e ? v + "-" + be(e) : be(v), goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(v) : v;
  }, goog.setCssNameMapping = function(v, e) {
    goog.cssNameMapping_ = v, goog.cssNameMappingStyle_ = e;
  }, goog.getMsg = function(v, e, fe) {
    return fe && fe.html && (v = v.replace(/</g, "&lt;")), e && (v = v.replace(/\{\$([^}]+)}/g, function(be, ye) {
      return e != null && ye in e ? e[ye] : be;
    })), v;
  }, goog.getMsgWithFallback = function(v, e) {
    return v;
  }, goog.exportSymbol = function(v, e, fe) {
    goog.exportPath_(v, e, fe);
  }, goog.exportProperty = function(v, e, fe) {
    v[e] = fe;
  }, goog.inherits = function(v, e) {
    function fe() {
    }
    fe.prototype = e.prototype, v.superClass_ = e.prototype, v.prototype = new fe(), v.prototype.constructor = v, v.base = function(be, ye, ve) {
      for (var Ee = Array(arguments.length - 2), Se = 2; Se < arguments.length; Se++)
        Ee[Se - 2] = arguments[Se];
      return e.prototype[ye].apply(be, Ee);
    };
  }, goog.scope = function(v) {
    if (goog.isInModuleLoader_())
      throw Error("goog.scope is not supported within a module.");
    v.call(goog.global);
  }, goog.defineClass = function(v, e) {
    var fe = e.constructor, be = e.statics;
    return fe && fe != Object.prototype.constructor || (fe = function() {
      throw Error("cannot instantiate an interface (no constructor defined).");
    }), fe = goog.defineClass.createSealingConstructor_(fe, v), v && goog.inherits(fe, v), delete e.constructor, delete e.statics, goog.defineClass.applyProperties_(fe.prototype, e), be != null && (be instanceof Function ? be(fe) : goog.defineClass.applyProperties_(fe, be)), fe;
  }, goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG, goog.defineClass.createSealingConstructor_ = function(v, e) {
    if (!goog.defineClass.SEAL_CLASS_INSTANCES)
      return v;
    var fe = !goog.defineClass.isUnsealable_(e), be = function() {
      var ye = v.apply(this, arguments) || this;
      return ye[goog.UID_PROPERTY_] = ye[goog.UID_PROPERTY_], this.constructor === be && fe && Object.seal instanceof Function && Object.seal(ye), ye;
    };
    return be;
  }, goog.defineClass.isUnsealable_ = function(v) {
    return v && v.prototype && v.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
  }, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.defineClass.applyProperties_ = function(v, e) {
    for (var fe in e)
      Object.prototype.hasOwnProperty.call(e, fe) && (v[fe] = e[fe]);
    for (var be = 0; be < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; be++)
      fe = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[be], Object.prototype.hasOwnProperty.call(e, fe) && (v[fe] = e[fe]);
  }, goog.tagUnsealableClass = function(v) {
  }, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.TRUSTED_TYPES_POLICY_NAME = "", goog.identity_ = function(v) {
    return v;
  }, goog.createTrustedTypesPolicy = function(v) {
    var e = null, fe = goog.global.trustedTypes || goog.global.TrustedTypes;
    if (!fe || !fe.createPolicy)
      return e;
    try {
      e = fe.createPolicy(v, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_, createURL: goog.identity_ });
    } catch (be) {
      goog.logToConsole_(be.message);
    }
    return e;
  }, goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#base") : null, goog.object = {}, goog.object.is = function(v, e) {
    return v === e ? v !== 0 || 1 / v === 1 / e : v !== v && e !== e;
  }, goog.object.forEach = function(v, e, fe) {
    for (var be in v)
      e.call(fe, v[be], be, v);
  }, goog.object.filter = function(v, e, fe) {
    var be = {}, ye;
    for (ye in v)
      e.call(fe, v[ye], ye, v) && (be[ye] = v[ye]);
    return be;
  }, goog.object.map = function(v, e, fe) {
    var be = {}, ye;
    for (ye in v)
      be[ye] = e.call(fe, v[ye], ye, v);
    return be;
  }, goog.object.some = function(v, e, fe) {
    for (var be in v)
      if (e.call(fe, v[be], be, v))
        return !0;
    return !1;
  }, goog.object.every = function(v, e, fe) {
    for (var be in v)
      if (!e.call(fe, v[be], be, v))
        return !1;
    return !0;
  }, goog.object.getCount = function(v) {
    var e = 0, fe;
    for (fe in v)
      e++;
    return e;
  }, goog.object.getAnyKey = function(v) {
    for (var e in v)
      return e;
  }, goog.object.getAnyValue = function(v) {
    for (var e in v)
      return v[e];
  }, goog.object.contains = function(v, e) {
    return goog.object.containsValue(v, e);
  }, goog.object.getValues = function(v) {
    var e = [], fe = 0, be;
    for (be in v)
      e[fe++] = v[be];
    return e;
  }, goog.object.getKeys = function(v) {
    var e = [], fe = 0, be;
    for (be in v)
      e[fe++] = be;
    return e;
  }, goog.object.getValueByKeys = function(v, e) {
    var fe = goog.isArrayLike(e), be = fe ? e : arguments;
    for (fe = fe ? 0 : 1; fe < be.length; fe++) {
      if (v == null)
        return;
      v = v[be[fe]];
    }
    return v;
  }, goog.object.containsKey = function(v, e) {
    return v !== null && e in v;
  }, goog.object.containsValue = function(v, e) {
    for (var fe in v)
      if (v[fe] == e)
        return !0;
    return !1;
  }, goog.object.findKey = function(v, e, fe) {
    for (var be in v)
      if (e.call(fe, v[be], be, v))
        return be;
  }, goog.object.findValue = function(v, e, fe) {
    return (e = goog.object.findKey(v, e, fe)) && v[e];
  }, goog.object.isEmpty = function(v) {
    for (var e in v)
      return !1;
    return !0;
  }, goog.object.clear = function(v) {
    for (var e in v)
      delete v[e];
  }, goog.object.remove = function(v, e) {
    var fe;
    return (fe = e in v) && delete v[e], fe;
  }, goog.object.add = function(v, e, fe) {
    if (v !== null && e in v)
      throw Error('The object already contains the key "' + e + '"');
    goog.object.set(v, e, fe);
  }, goog.object.get = function(v, e, fe) {
    return v !== null && e in v ? v[e] : fe;
  }, goog.object.set = function(v, e, fe) {
    v[e] = fe;
  }, goog.object.setIfUndefined = function(v, e, fe) {
    return e in v ? v[e] : v[e] = fe;
  }, goog.object.setWithReturnValueIfNotSet = function(v, e, fe) {
    return e in v ? v[e] : (fe = fe(), v[e] = fe);
  }, goog.object.equals = function(v, e) {
    for (var fe in v)
      if (!(fe in e) || v[fe] !== e[fe])
        return !1;
    for (var be in e)
      if (!(be in v))
        return !1;
    return !0;
  }, goog.object.clone = function(v) {
    var e = {}, fe;
    for (fe in v)
      e[fe] = v[fe];
    return e;
  }, goog.object.unsafeClone = function(v) {
    var e = goog.typeOf(v);
    if (e == "object" || e == "array") {
      if (goog.isFunction(v.clone))
        return v.clone();
      e = e == "array" ? [] : {};
      for (var fe in v)
        e[fe] = goog.object.unsafeClone(v[fe]);
      return e;
    }
    return v;
  }, goog.object.transpose = function(v) {
    var e = {}, fe;
    for (fe in v)
      e[v[fe]] = fe;
    return e;
  }, goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.object.extend = function(v, e) {
    for (var fe, be, ye = 1; ye < arguments.length; ye++) {
      be = arguments[ye];
      for (fe in be)
        v[fe] = be[fe];
      for (var ve = 0; ve < goog.object.PROTOTYPE_FIELDS_.length; ve++)
        fe = goog.object.PROTOTYPE_FIELDS_[ve], Object.prototype.hasOwnProperty.call(be, fe) && (v[fe] = be[fe]);
    }
  }, goog.object.create = function(v) {
    var e = arguments.length;
    if (e == 1 && Array.isArray(arguments[0]))
      return goog.object.create.apply(null, arguments[0]);
    if (e % 2)
      throw Error("Uneven number of arguments");
    for (var fe = {}, be = 0; be < e; be += 2)
      fe[arguments[be]] = arguments[be + 1];
    return fe;
  }, goog.object.createSet = function(v) {
    var e = arguments.length;
    if (e == 1 && Array.isArray(arguments[0]))
      return goog.object.createSet.apply(null, arguments[0]);
    for (var fe = {}, be = 0; be < e; be++)
      fe[arguments[be]] = !0;
    return fe;
  }, goog.object.createImmutableView = function(v) {
    var e = v;
    return Object.isFrozen && !Object.isFrozen(v) && (e = Object.create(v), Object.freeze(e)), e;
  }, goog.object.isImmutableView = function(v) {
    return !!Object.isFrozen && Object.isFrozen(v);
  }, goog.object.getAllPropertyNames = function(v, e, fe) {
    if (!v)
      return [];
    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf)
      return goog.object.getKeys(v);
    for (var be = {}; v && (v !== Object.prototype || e) && (v !== Function.prototype || fe); ) {
      for (var ye = Object.getOwnPropertyNames(v), ve = 0; ve < ye.length; ve++)
        be[ye[ve]] = !0;
      v = Object.getPrototypeOf(v);
    }
    return goog.object.getKeys(be);
  }, goog.object.getSuperClass = function(v) {
    return (v = Object.getPrototypeOf(v.prototype)) && v.constructor;
  };
  var jspb = { asserts: {} };
  jspb.asserts.doAssertFailure = function(v, e, fe, be) {
    var ye = "Assertion failed";
    if (fe) {
      ye += ": " + fe;
      var ve = be;
    } else
      v && (ye += ": " + v, ve = e);
    throw Error("" + ye, ve || []);
  }, jspb.asserts.assert = function(v, e, fe) {
    for (var be = [], ye = 2; ye < arguments.length; ++ye)
      be[ye - 2] = arguments[ye];
    return v || jspb.asserts.doAssertFailure("", null, e, be), v;
  }, jspb.asserts.assertString = function(v, e, fe) {
    for (var be = [], ye = 2; ye < arguments.length; ++ye)
      be[ye - 2] = arguments[ye];
    return typeof v != "string" && jspb.asserts.doAssertFailure("Expected string but got %s: %s.", [goog.typeOf(v), v], e, be), v;
  }, jspb.asserts.assertArray = function(v, e, fe) {
    for (var be = [], ye = 2; ye < arguments.length; ++ye)
      be[ye - 2] = arguments[ye];
    return Array.isArray(v) || jspb.asserts.doAssertFailure("Expected array but got %s: %s.", [goog.typeOf(v), v], e, be), v;
  }, jspb.asserts.fail = function(v, e) {
    for (var fe = [], be = 1; be < arguments.length; ++be)
      fe[be - 1] = arguments[be];
    throw Error("Failure" + (v ? ": " + v : ""), fe);
  }, jspb.asserts.assertInstanceof = function(v, e, fe, be) {
    for (var ye = [], ve = 3; ve < arguments.length; ++ve)
      ye[ve - 3] = arguments[ve];
    return v instanceof e || jspb.asserts.doAssertFailure("Expected instanceof %s but got %s.", [jspb.asserts.getType(e), jspb.asserts.getType(v)], fe, ye), v;
  }, jspb.asserts.getType = function(v) {
    return v instanceof Function ? v.displayName || v.name || "unknown type name" : v instanceof Object ? v.constructor.displayName || v.constructor.name || Object.prototype.toString.call(v) : v === null ? "null" : typeof v;
  }, jspb.BinaryConstants = {}, jspb.ConstBinaryMessage = function() {
  }, jspb.BinaryMessage = function() {
  }, jspb.BinaryConstants.FieldType = { INVALID: -1, DOUBLE: 1, FLOAT: 2, INT64: 3, UINT64: 4, INT32: 5, FIXED64: 6, FIXED32: 7, BOOL: 8, STRING: 9, GROUP: 10, MESSAGE: 11, BYTES: 12, UINT32: 13, ENUM: 14, SFIXED32: 15, SFIXED64: 16, SINT32: 17, SINT64: 18, FHASH64: 30, VHASH64: 31 }, jspb.BinaryConstants.WireType = { INVALID: -1, VARINT: 0, FIXED64: 1, DELIMITED: 2, START_GROUP: 3, END_GROUP: 4, FIXED32: 5 }, jspb.BinaryConstants.FieldTypeToWireType = function(v) {
    var e = jspb.BinaryConstants.FieldType, fe = jspb.BinaryConstants.WireType;
    switch (v) {
      case e.INT32:
      case e.INT64:
      case e.UINT32:
      case e.UINT64:
      case e.SINT32:
      case e.SINT64:
      case e.BOOL:
      case e.ENUM:
      case e.VHASH64:
        return fe.VARINT;
      case e.DOUBLE:
      case e.FIXED64:
      case e.SFIXED64:
      case e.FHASH64:
        return fe.FIXED64;
      case e.STRING:
      case e.MESSAGE:
      case e.BYTES:
        return fe.DELIMITED;
      case e.FLOAT:
      case e.FIXED32:
      case e.SFIXED32:
        return fe.FIXED32;
      default:
        return fe.INVALID;
    }
  }, jspb.BinaryConstants.INVALID_FIELD_NUMBER = -1, jspb.BinaryConstants.FLOAT32_EPS = 1401298464324817e-60, jspb.BinaryConstants.FLOAT32_MIN = 11754943508222875e-54, jspb.BinaryConstants.FLOAT32_MAX = 34028234663852886e22, jspb.BinaryConstants.FLOAT64_EPS = 5e-324, jspb.BinaryConstants.FLOAT64_MIN = 22250738585072014e-324, jspb.BinaryConstants.FLOAT64_MAX = 17976931348623157e292, jspb.BinaryConstants.TWO_TO_20 = 1048576, jspb.BinaryConstants.TWO_TO_23 = 8388608, jspb.BinaryConstants.TWO_TO_31 = 2147483648, jspb.BinaryConstants.TWO_TO_32 = 4294967296, jspb.BinaryConstants.TWO_TO_52 = 4503599627370496, jspb.BinaryConstants.TWO_TO_63 = 9223372036854776e3, jspb.BinaryConstants.TWO_TO_64 = 18446744073709552e3, jspb.BinaryConstants.ZERO_HASH = "\0\0\0\0\0\0\0\0", goog.debug = {}, goog.debug.Error = function(v) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, goog.debug.Error);
    else {
      var e = Error().stack;
      e && (this.stack = e);
    }
    v && (this.message = String(v)), this.reportErrorToServer = !0;
  }, goog.inherits(goog.debug.Error, Error), goog.debug.Error.prototype.name = "CustomError", goog.dom = {}, goog.dom.NodeType = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, CDATA_SECTION: 4, ENTITY_REFERENCE: 5, ENTITY: 6, PROCESSING_INSTRUCTION: 7, COMMENT: 8, DOCUMENT: 9, DOCUMENT_TYPE: 10, DOCUMENT_FRAGMENT: 11, NOTATION: 12 }, goog.asserts = {}, goog.asserts.ENABLE_ASSERTS = goog.DEBUG, goog.asserts.AssertionError = function(v, e) {
    goog.debug.Error.call(this, goog.asserts.subs_(v, e)), this.messagePattern = v;
  }, goog.inherits(goog.asserts.AssertionError, goog.debug.Error), goog.asserts.AssertionError.prototype.name = "AssertionError", goog.asserts.DEFAULT_ERROR_HANDLER = function(v) {
    throw v;
  }, goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER, goog.asserts.subs_ = function(v, e) {
    v = v.split("%s");
    for (var fe = "", be = v.length - 1, ye = 0; ye < be; ye++)
      fe += v[ye] + (ye < e.length ? e[ye] : "%s");
    return fe + v[be];
  }, goog.asserts.doAssertFailure_ = function(v, e, fe, be) {
    var ye = "Assertion failed";
    if (fe) {
      ye += ": " + fe;
      var ve = be;
    } else
      v && (ye += ": " + v, ve = e);
    v = new goog.asserts.AssertionError("" + ye, ve || []), goog.asserts.errorHandler_(v);
  }, goog.asserts.setErrorHandler = function(v) {
    goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = v);
  }, goog.asserts.assert = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && !v && goog.asserts.doAssertFailure_("", null, e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertExists = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && v == null && goog.asserts.doAssertFailure_("Expected to exist: %s.", [v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.fail = function(v, e) {
    goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (v ? ": " + v : ""), Array.prototype.slice.call(arguments, 1)));
  }, goog.asserts.assertNumber = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && typeof v != "number" && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertString = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && typeof v != "string" && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertFunction = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && !goog.isFunction(v) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertObject = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && !goog.isObject(v) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertArray = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && !Array.isArray(v) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertBoolean = function(v, e, fe) {
    return goog.asserts.ENABLE_ASSERTS && typeof v != "boolean" && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertElement = function(v, e, fe) {
    return !goog.asserts.ENABLE_ASSERTS || goog.isObject(v) && v.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(v), v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertInstanceof = function(v, e, fe, be) {
    return !goog.asserts.ENABLE_ASSERTS || v instanceof e || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(e), goog.asserts.getType_(v)], fe, Array.prototype.slice.call(arguments, 3)), v;
  }, goog.asserts.assertFinite = function(v, e, fe) {
    return !goog.asserts.ENABLE_ASSERTS || typeof v == "number" && isFinite(v) || goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [v], e, Array.prototype.slice.call(arguments, 2)), v;
  }, goog.asserts.assertObjectPrototypeIsIntact = function() {
    for (var v in Object.prototype)
      goog.asserts.fail(v + " should not be enumerable in Object.prototype.");
  }, goog.asserts.getType_ = function(v) {
    return v instanceof Function ? v.displayName || v.name || "unknown type name" : v instanceof Object ? v.constructor.displayName || v.constructor.name || Object.prototype.toString.call(v) : v === null ? "null" : typeof v;
  }, goog.array = {}, goog.NATIVE_ARRAY_PROTOTYPES = goog.TRUSTED_SITE, goog.array.ASSUME_NATIVE_FUNCTIONS = 2012 < goog.FEATURESET_YEAR, goog.array.peek = function(v) {
    return v[v.length - 1];
  }, goog.array.last = goog.array.peek, goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function(v, e, fe) {
    return goog.asserts.assert(v.length != null), Array.prototype.indexOf.call(v, e, fe);
  } : function(v, e, fe) {
    if (fe = fe == null ? 0 : 0 > fe ? Math.max(0, v.length + fe) : fe, typeof v == "string")
      return typeof e != "string" || e.length != 1 ? -1 : v.indexOf(e, fe);
    for (; fe < v.length; fe++)
      if (fe in v && v[fe] === e)
        return fe;
    return -1;
  }, goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function(v, e, fe) {
    return goog.asserts.assert(v.length != null), Array.prototype.lastIndexOf.call(v, e, fe ?? v.length - 1);
  } : function(v, e, fe) {
    if (fe = fe ?? v.length - 1, 0 > fe && (fe = Math.max(0, v.length + fe)), typeof v == "string")
      return typeof e != "string" || e.length != 1 ? -1 : v.lastIndexOf(e, fe);
    for (; 0 <= fe; fe--)
      if (fe in v && v[fe] === e)
        return fe;
    return -1;
  }, goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function(v, e, fe) {
    goog.asserts.assert(v.length != null), Array.prototype.forEach.call(v, e, fe);
  } : function(v, e, fe) {
    for (var be = v.length, ye = typeof v == "string" ? v.split("") : v, ve = 0; ve < be; ve++)
      ve in ye && e.call(fe, ye[ve], ve, v);
  }, goog.array.forEachRight = function(v, e, fe) {
    var be = v.length, ye = typeof v == "string" ? v.split("") : v;
    for (--be; 0 <= be; --be)
      be in ye && e.call(fe, ye[be], be, v);
  }, goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function(v, e, fe) {
    return goog.asserts.assert(v.length != null), Array.prototype.filter.call(v, e, fe);
  } : function(v, e, fe) {
    for (var be = v.length, ye = [], ve = 0, Ee = typeof v == "string" ? v.split("") : v, Se = 0; Se < be; Se++)
      if (Se in Ee) {
        var Oe = Ee[Se];
        e.call(fe, Oe, Se, v) && (ye[ve++] = Oe);
      }
    return ye;
  }, goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function(v, e, fe) {
    return goog.asserts.assert(v.length != null), Array.prototype.map.call(v, e, fe);
  } : function(v, e, fe) {
    for (var be = v.length, ye = Array(be), ve = typeof v == "string" ? v.split("") : v, Ee = 0; Ee < be; Ee++)
      Ee in ve && (ye[Ee] = e.call(fe, ve[Ee], Ee, v));
    return ye;
  }, goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function(v, e, fe, be) {
    return goog.asserts.assert(v.length != null), be && (e = goog.bind(e, be)), Array.prototype.reduce.call(v, e, fe);
  } : function(v, e, fe, be) {
    var ye = fe;
    return goog.array.forEach(v, function(ve, Ee) {
      ye = e.call(be, ye, ve, Ee, v);
    }), ye;
  }, goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function(v, e, fe, be) {
    return goog.asserts.assert(v.length != null), goog.asserts.assert(e != null), be && (e = goog.bind(e, be)), Array.prototype.reduceRight.call(v, e, fe);
  } : function(v, e, fe, be) {
    var ye = fe;
    return goog.array.forEachRight(v, function(ve, Ee) {
      ye = e.call(be, ye, ve, Ee, v);
    }), ye;
  }, goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function(v, e, fe) {
    return goog.asserts.assert(v.length != null), Array.prototype.some.call(v, e, fe);
  } : function(v, e, fe) {
    for (var be = v.length, ye = typeof v == "string" ? v.split("") : v, ve = 0; ve < be; ve++)
      if (ve in ye && e.call(fe, ye[ve], ve, v))
        return !0;
    return !1;
  }, goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function(v, e, fe) {
    return goog.asserts.assert(v.length != null), Array.prototype.every.call(v, e, fe);
  } : function(v, e, fe) {
    for (var be = v.length, ye = typeof v == "string" ? v.split("") : v, ve = 0; ve < be; ve++)
      if (ve in ye && !e.call(fe, ye[ve], ve, v))
        return !1;
    return !0;
  }, goog.array.count = function(v, e, fe) {
    var be = 0;
    return goog.array.forEach(v, function(ye, ve, Ee) {
      e.call(fe, ye, ve, Ee) && ++be;
    }, fe), be;
  }, goog.array.find = function(v, e, fe) {
    return e = goog.array.findIndex(v, e, fe), 0 > e ? null : typeof v == "string" ? v.charAt(e) : v[e];
  }, goog.array.findIndex = function(v, e, fe) {
    for (var be = v.length, ye = typeof v == "string" ? v.split("") : v, ve = 0; ve < be; ve++)
      if (ve in ye && e.call(fe, ye[ve], ve, v))
        return ve;
    return -1;
  }, goog.array.findRight = function(v, e, fe) {
    return e = goog.array.findIndexRight(v, e, fe), 0 > e ? null : typeof v == "string" ? v.charAt(e) : v[e];
  }, goog.array.findIndexRight = function(v, e, fe) {
    var be = v.length, ye = typeof v == "string" ? v.split("") : v;
    for (--be; 0 <= be; be--)
      if (be in ye && e.call(fe, ye[be], be, v))
        return be;
    return -1;
  }, goog.array.contains = function(v, e) {
    return 0 <= goog.array.indexOf(v, e);
  }, goog.array.isEmpty = function(v) {
    return v.length == 0;
  }, goog.array.clear = function(v) {
    if (!Array.isArray(v))
      for (var e = v.length - 1; 0 <= e; e--)
        delete v[e];
    v.length = 0;
  }, goog.array.insert = function(v, e) {
    goog.array.contains(v, e) || v.push(e);
  }, goog.array.insertAt = function(v, e, fe) {
    goog.array.splice(v, fe, 0, e);
  }, goog.array.insertArrayAt = function(v, e, fe) {
    goog.partial(goog.array.splice, v, fe, 0).apply(null, e);
  }, goog.array.insertBefore = function(v, e, fe) {
    var be;
    arguments.length == 2 || 0 > (be = goog.array.indexOf(v, fe)) ? v.push(e) : goog.array.insertAt(v, e, be);
  }, goog.array.remove = function(v, e) {
    e = goog.array.indexOf(v, e);
    var fe;
    return (fe = 0 <= e) && goog.array.removeAt(v, e), fe;
  }, goog.array.removeLast = function(v, e) {
    return e = goog.array.lastIndexOf(v, e), 0 <= e ? (goog.array.removeAt(v, e), !0) : !1;
  }, goog.array.removeAt = function(v, e) {
    return goog.asserts.assert(v.length != null), Array.prototype.splice.call(v, e, 1).length == 1;
  }, goog.array.removeIf = function(v, e, fe) {
    return e = goog.array.findIndex(v, e, fe), 0 <= e ? (goog.array.removeAt(v, e), !0) : !1;
  }, goog.array.removeAllIf = function(v, e, fe) {
    var be = 0;
    return goog.array.forEachRight(v, function(ye, ve) {
      e.call(fe, ye, ve, v) && goog.array.removeAt(v, ve) && be++;
    }), be;
  }, goog.array.concat = function(v) {
    return Array.prototype.concat.apply([], arguments);
  }, goog.array.join = function(v) {
    return Array.prototype.concat.apply([], arguments);
  }, goog.array.toArray = function(v) {
    var e = v.length;
    if (0 < e) {
      for (var fe = Array(e), be = 0; be < e; be++)
        fe[be] = v[be];
      return fe;
    }
    return [];
  }, goog.array.clone = goog.array.toArray, goog.array.extend = function(v, e) {
    for (var fe = 1; fe < arguments.length; fe++) {
      var be = arguments[fe];
      if (goog.isArrayLike(be)) {
        var ye = v.length || 0, ve = be.length || 0;
        v.length = ye + ve;
        for (var Ee = 0; Ee < ve; Ee++)
          v[ye + Ee] = be[Ee];
      } else
        v.push(be);
    }
  }, goog.array.splice = function(v, e, fe, be) {
    return goog.asserts.assert(v.length != null), Array.prototype.splice.apply(v, goog.array.slice(arguments, 1));
  }, goog.array.slice = function(v, e, fe) {
    return goog.asserts.assert(v.length != null), 2 >= arguments.length ? Array.prototype.slice.call(v, e) : Array.prototype.slice.call(v, e, fe);
  }, goog.array.removeDuplicates = function(v, e, fe) {
    e = e || v;
    var be = function(Oe) {
      return goog.isObject(Oe) ? "o" + goog.getUid(Oe) : (typeof Oe).charAt(0) + Oe;
    };
    fe = fe || be, be = {};
    for (var ye = 0, ve = 0; ve < v.length; ) {
      var Ee = v[ve++], Se = fe(Ee);
      Object.prototype.hasOwnProperty.call(be, Se) || (be[Se] = !0, e[ye++] = Ee);
    }
    e.length = ye;
  }, goog.array.binarySearch = function(v, e, fe) {
    return goog.array.binarySearch_(v, fe || goog.array.defaultCompare, !1, e);
  }, goog.array.binarySelect = function(v, e, fe) {
    return goog.array.binarySearch_(v, e, !0, void 0, fe);
  }, goog.array.binarySearch_ = function(v, e, fe, be, ye) {
    for (var ve = 0, Ee = v.length, Se; ve < Ee; ) {
      var Oe = ve + (Ee - ve >>> 1), xe = fe ? e.call(ye, v[Oe], Oe, v) : e(be, v[Oe]);
      0 < xe ? ve = Oe + 1 : (Ee = Oe, Se = !xe);
    }
    return Se ? ve : -ve - 1;
  }, goog.array.sort = function(v, e) {
    v.sort(e || goog.array.defaultCompare);
  }, goog.array.stableSort = function(v, e) {
    for (var fe = Array(v.length), be = 0; be < v.length; be++)
      fe[be] = { index: be, value: v[be] };
    var ye = e || goog.array.defaultCompare;
    for (goog.array.sort(fe, function(ve, Ee) {
      return ye(ve.value, Ee.value) || ve.index - Ee.index;
    }), be = 0; be < v.length; be++)
      v[be] = fe[be].value;
  }, goog.array.sortByKey = function(v, e, fe) {
    var be = fe || goog.array.defaultCompare;
    goog.array.sort(v, function(ye, ve) {
      return be(e(ye), e(ve));
    });
  }, goog.array.sortObjectsByKey = function(v, e, fe) {
    goog.array.sortByKey(v, function(be) {
      return be[e];
    }, fe);
  }, goog.array.isSorted = function(v, e, fe) {
    e = e || goog.array.defaultCompare;
    for (var be = 1; be < v.length; be++) {
      var ye = e(v[be - 1], v[be]);
      if (0 < ye || ye == 0 && fe)
        return !1;
    }
    return !0;
  }, goog.array.equals = function(v, e, fe) {
    if (!goog.isArrayLike(v) || !goog.isArrayLike(e) || v.length != e.length)
      return !1;
    var be = v.length;
    fe = fe || goog.array.defaultCompareEquality;
    for (var ye = 0; ye < be; ye++)
      if (!fe(v[ye], e[ye]))
        return !1;
    return !0;
  }, goog.array.compare3 = function(v, e, fe) {
    fe = fe || goog.array.defaultCompare;
    for (var be = Math.min(v.length, e.length), ye = 0; ye < be; ye++) {
      var ve = fe(v[ye], e[ye]);
      if (ve != 0)
        return ve;
    }
    return goog.array.defaultCompare(v.length, e.length);
  }, goog.array.defaultCompare = function(v, e) {
    return v > e ? 1 : v < e ? -1 : 0;
  }, goog.array.inverseDefaultCompare = function(v, e) {
    return -goog.array.defaultCompare(v, e);
  }, goog.array.defaultCompareEquality = function(v, e) {
    return v === e;
  }, goog.array.binaryInsert = function(v, e, fe) {
    return fe = goog.array.binarySearch(v, e, fe), 0 > fe ? (goog.array.insertAt(v, e, -(fe + 1)), !0) : !1;
  }, goog.array.binaryRemove = function(v, e, fe) {
    return e = goog.array.binarySearch(v, e, fe), 0 <= e ? goog.array.removeAt(v, e) : !1;
  }, goog.array.bucket = function(v, e, fe) {
    for (var be = {}, ye = 0; ye < v.length; ye++) {
      var ve = v[ye], Ee = e.call(fe, ve, ye, v);
      Ee !== void 0 && (be[Ee] || (be[Ee] = [])).push(ve);
    }
    return be;
  }, goog.array.toObject = function(v, e, fe) {
    var be = {};
    return goog.array.forEach(v, function(ye, ve) {
      be[e.call(fe, ye, ve, v)] = ye;
    }), be;
  }, goog.array.range = function(v, e, fe) {
    var be = [], ye = 0, ve = v;
    if (fe = fe || 1, e !== void 0 && (ye = v, ve = e), 0 > fe * (ve - ye))
      return [];
    if (0 < fe)
      for (v = ye; v < ve; v += fe)
        be.push(v);
    else
      for (v = ye; v > ve; v += fe)
        be.push(v);
    return be;
  }, goog.array.repeat = function(v, e) {
    for (var fe = [], be = 0; be < e; be++)
      fe[be] = v;
    return fe;
  }, goog.array.flatten = function(v) {
    for (var e = [], fe = 0; fe < arguments.length; fe++) {
      var be = arguments[fe];
      if (Array.isArray(be))
        for (var ye = 0; ye < be.length; ye += 8192) {
          var ve = goog.array.slice(be, ye, ye + 8192);
          ve = goog.array.flatten.apply(null, ve);
          for (var Ee = 0; Ee < ve.length; Ee++)
            e.push(ve[Ee]);
        }
      else
        e.push(be);
    }
    return e;
  }, goog.array.rotate = function(v, e) {
    return goog.asserts.assert(v.length != null), v.length && (e %= v.length, 0 < e ? Array.prototype.unshift.apply(v, v.splice(-e, e)) : 0 > e && Array.prototype.push.apply(v, v.splice(0, -e))), v;
  }, goog.array.moveItem = function(v, e, fe) {
    goog.asserts.assert(0 <= e && e < v.length), goog.asserts.assert(0 <= fe && fe < v.length), e = Array.prototype.splice.call(v, e, 1), Array.prototype.splice.call(v, fe, 0, e[0]);
  }, goog.array.zip = function(v) {
    if (!arguments.length)
      return [];
    for (var e = [], fe = arguments[0].length, be = 1; be < arguments.length; be++)
      arguments[be].length < fe && (fe = arguments[be].length);
    for (be = 0; be < fe; be++) {
      for (var ye = [], ve = 0; ve < arguments.length; ve++)
        ye.push(arguments[ve][be]);
      e.push(ye);
    }
    return e;
  }, goog.array.shuffle = function(v, e) {
    e = e || Math.random;
    for (var fe = v.length - 1; 0 < fe; fe--) {
      var be = Math.floor(e() * (fe + 1)), ye = v[fe];
      v[fe] = v[be], v[be] = ye;
    }
  }, goog.array.copyByIndex = function(v, e) {
    var fe = [];
    return goog.array.forEach(e, function(be) {
      fe.push(v[be]);
    }), fe;
  }, goog.array.concatMap = function(v, e, fe) {
    return goog.array.concat.apply([], goog.array.map(v, e, fe));
  }, goog.crypt = {}, goog.crypt.stringToByteArray = function(v) {
    for (var e = [], fe = 0, be = 0; be < v.length; be++) {
      var ye = v.charCodeAt(be);
      255 < ye && (e[fe++] = ye & 255, ye >>= 8), e[fe++] = ye;
    }
    return e;
  }, goog.crypt.byteArrayToString = function(v) {
    if (8192 >= v.length)
      return String.fromCharCode.apply(null, v);
    for (var e = "", fe = 0; fe < v.length; fe += 8192) {
      var be = goog.array.slice(v, fe, fe + 8192);
      e += String.fromCharCode.apply(null, be);
    }
    return e;
  }, goog.crypt.byteArrayToHex = function(v, e) {
    return goog.array.map(v, function(fe) {
      return fe = fe.toString(16), 1 < fe.length ? fe : "0" + fe;
    }).join(e || "");
  }, goog.crypt.hexToByteArray = function(v) {
    goog.asserts.assert(v.length % 2 == 0, "Key string length must be multiple of 2");
    for (var e = [], fe = 0; fe < v.length; fe += 2)
      e.push(parseInt(v.substring(fe, fe + 2), 16));
    return e;
  }, goog.crypt.stringToUtf8ByteArray = function(v) {
    for (var e = [], fe = 0, be = 0; be < v.length; be++) {
      var ye = v.charCodeAt(be);
      128 > ye ? e[fe++] = ye : (2048 > ye ? e[fe++] = ye >> 6 | 192 : ((ye & 64512) == 55296 && be + 1 < v.length && (v.charCodeAt(be + 1) & 64512) == 56320 ? (ye = 65536 + ((ye & 1023) << 10) + (v.charCodeAt(++be) & 1023), e[fe++] = ye >> 18 | 240, e[fe++] = ye >> 12 & 63 | 128) : e[fe++] = ye >> 12 | 224, e[fe++] = ye >> 6 & 63 | 128), e[fe++] = ye & 63 | 128);
    }
    return e;
  }, goog.crypt.utf8ByteArrayToString = function(v) {
    for (var e = [], fe = 0, be = 0; fe < v.length; ) {
      var ye = v[fe++];
      if (128 > ye)
        e[be++] = String.fromCharCode(ye);
      else if (191 < ye && 224 > ye) {
        var ve = v[fe++];
        e[be++] = String.fromCharCode((ye & 31) << 6 | ve & 63);
      } else if (239 < ye && 365 > ye) {
        ve = v[fe++];
        var Ee = v[fe++], Se = v[fe++];
        ye = ((ye & 7) << 18 | (ve & 63) << 12 | (Ee & 63) << 6 | Se & 63) - 65536, e[be++] = String.fromCharCode(55296 + (ye >> 10)), e[be++] = String.fromCharCode(56320 + (ye & 1023));
      } else
        ve = v[fe++], Ee = v[fe++], e[be++] = String.fromCharCode((ye & 15) << 12 | (ve & 63) << 6 | Ee & 63);
    }
    return e.join("");
  }, goog.crypt.xorByteArray = function(v, e) {
    goog.asserts.assert(v.length == e.length, "XOR array lengths must match");
    for (var fe = [], be = 0; be < v.length; be++)
      fe.push(v[be] ^ e[be]);
    return fe;
  }, goog.dom.asserts = {}, goog.dom.asserts.assertIsLocation = function(v) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var e = goog.dom.asserts.getWindow_(v);
      e && (!v || !(v instanceof e.Location) && v instanceof e.Element) && goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s", goog.dom.asserts.debugStringForType_(v));
    }
    return v;
  }, goog.dom.asserts.assertIsElementType_ = function(v, e) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var fe = goog.dom.asserts.getWindow_(v);
      fe && typeof fe[e] < "u" && (v && (v instanceof fe[e] || !(v instanceof fe.Location || v instanceof fe.Element)) || goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s", e, goog.dom.asserts.debugStringForType_(v)));
    }
    return v;
  }, goog.dom.asserts.assertIsHTMLAnchorElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLAnchorElement");
  }, goog.dom.asserts.assertIsHTMLButtonElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLButtonElement");
  }, goog.dom.asserts.assertIsHTMLLinkElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLLinkElement");
  }, goog.dom.asserts.assertIsHTMLImageElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLImageElement");
  }, goog.dom.asserts.assertIsHTMLAudioElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLAudioElement");
  }, goog.dom.asserts.assertIsHTMLVideoElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLVideoElement");
  }, goog.dom.asserts.assertIsHTMLInputElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLInputElement");
  }, goog.dom.asserts.assertIsHTMLTextAreaElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLTextAreaElement");
  }, goog.dom.asserts.assertIsHTMLCanvasElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLCanvasElement");
  }, goog.dom.asserts.assertIsHTMLEmbedElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLEmbedElement");
  }, goog.dom.asserts.assertIsHTMLFormElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLFormElement");
  }, goog.dom.asserts.assertIsHTMLFrameElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLFrameElement");
  }, goog.dom.asserts.assertIsHTMLIFrameElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLIFrameElement");
  }, goog.dom.asserts.assertIsHTMLObjectElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLObjectElement");
  }, goog.dom.asserts.assertIsHTMLScriptElement = function(v) {
    return goog.dom.asserts.assertIsElementType_(v, "HTMLScriptElement");
  }, goog.dom.asserts.debugStringForType_ = function(v) {
    if (goog.isObject(v))
      try {
        return v.constructor.displayName || v.constructor.name || Object.prototype.toString.call(v);
      } catch {
        return "<object could not be stringified>";
      }
    else
      return v === void 0 ? "undefined" : v === null ? "null" : typeof v;
  }, goog.dom.asserts.getWindow_ = function(v) {
    try {
      var e = v && v.ownerDocument, fe = e && (e.defaultView || e.parentWindow);
      if (fe = fe || goog.global, fe.Element && fe.Location)
        return fe;
    } catch {
    }
    return null;
  }, goog.functions = {}, goog.functions.constant = function(v) {
    return function() {
      return v;
    };
  }, goog.functions.FALSE = function() {
    return !1;
  }, goog.functions.TRUE = function() {
    return !0;
  }, goog.functions.NULL = function() {
    return null;
  }, goog.functions.identity = function(v, e) {
    return v;
  }, goog.functions.error = function(v) {
    return function() {
      throw Error(v);
    };
  }, goog.functions.fail = function(v) {
    return function() {
      throw v;
    };
  }, goog.functions.lock = function(v, e) {
    return e = e || 0, function() {
      return v.apply(this, Array.prototype.slice.call(arguments, 0, e));
    };
  }, goog.functions.nth = function(v) {
    return function() {
      return arguments[v];
    };
  }, goog.functions.partialRight = function(v, e) {
    var fe = Array.prototype.slice.call(arguments, 1);
    return function() {
      var be = Array.prototype.slice.call(arguments);
      return be.push.apply(be, fe), v.apply(this, be);
    };
  }, goog.functions.withReturnValue = function(v, e) {
    return goog.functions.sequence(v, goog.functions.constant(e));
  }, goog.functions.equalTo = function(v, e) {
    return function(fe) {
      return e ? v == fe : v === fe;
    };
  }, goog.functions.compose = function(v, e) {
    var fe = arguments, be = fe.length;
    return function() {
      var ye;
      be && (ye = fe[be - 1].apply(this, arguments));
      for (var ve = be - 2; 0 <= ve; ve--)
        ye = fe[ve].call(this, ye);
      return ye;
    };
  }, goog.functions.sequence = function(v) {
    var e = arguments, fe = e.length;
    return function() {
      for (var be, ye = 0; ye < fe; ye++)
        be = e[ye].apply(this, arguments);
      return be;
    };
  }, goog.functions.and = function(v) {
    var e = arguments, fe = e.length;
    return function() {
      for (var be = 0; be < fe; be++)
        if (!e[be].apply(this, arguments))
          return !1;
      return !0;
    };
  }, goog.functions.or = function(v) {
    var e = arguments, fe = e.length;
    return function() {
      for (var be = 0; be < fe; be++)
        if (e[be].apply(this, arguments))
          return !0;
      return !1;
    };
  }, goog.functions.not = function(v) {
    return function() {
      return !v.apply(this, arguments);
    };
  }, goog.functions.create = function(v, e) {
    var fe = function() {
    };
    return fe.prototype = v.prototype, fe = new fe(), v.apply(fe, Array.prototype.slice.call(arguments, 1)), fe;
  }, goog.functions.CACHE_RETURN_VALUE = !0, goog.functions.cacheReturnValue = function(v) {
    var e = !1, fe;
    return function() {
      return goog.functions.CACHE_RETURN_VALUE ? (e || (fe = v(), e = !0), fe) : v();
    };
  }, goog.functions.once = function(v) {
    var e = v;
    return function() {
      if (e) {
        var fe = e;
        e = null, fe();
      }
    };
  }, goog.functions.debounce = function(v, e, fe) {
    var be = 0;
    return function(ye) {
      goog.global.clearTimeout(be);
      var ve = arguments;
      be = goog.global.setTimeout(function() {
        v.apply(fe, ve);
      }, e);
    };
  }, goog.functions.throttle = function(v, e, fe) {
    var be = 0, ye = !1, ve = [], Ee = function() {
      be = 0, ye && (ye = !1, Se());
    }, Se = function() {
      be = goog.global.setTimeout(Ee, e), v.apply(fe, ve);
    };
    return function(Oe) {
      ve = arguments, be ? ye = !0 : Se();
    };
  }, goog.functions.rateLimit = function(v, e, fe) {
    var be = 0, ye = function() {
      be = 0;
    };
    return function(ve) {
      be || (be = goog.global.setTimeout(ye, e), v.apply(fe, arguments));
    };
  }, goog.dom.HtmlElement = function() {
  }, goog.dom.TagName = function(v) {
    this.tagName_ = v;
  }, goog.dom.TagName.prototype.toString = function() {
    return this.tagName_;
  }, goog.dom.TagName.A = new goog.dom.TagName("A"), goog.dom.TagName.ABBR = new goog.dom.TagName("ABBR"), goog.dom.TagName.ACRONYM = new goog.dom.TagName("ACRONYM"), goog.dom.TagName.ADDRESS = new goog.dom.TagName("ADDRESS"), goog.dom.TagName.APPLET = new goog.dom.TagName("APPLET"), goog.dom.TagName.AREA = new goog.dom.TagName("AREA"), goog.dom.TagName.ARTICLE = new goog.dom.TagName("ARTICLE"), goog.dom.TagName.ASIDE = new goog.dom.TagName("ASIDE"), goog.dom.TagName.AUDIO = new goog.dom.TagName("AUDIO"), goog.dom.TagName.B = new goog.dom.TagName("B"), goog.dom.TagName.BASE = new goog.dom.TagName("BASE"), goog.dom.TagName.BASEFONT = new goog.dom.TagName("BASEFONT"), goog.dom.TagName.BDI = new goog.dom.TagName("BDI"), goog.dom.TagName.BDO = new goog.dom.TagName("BDO"), goog.dom.TagName.BIG = new goog.dom.TagName("BIG"), goog.dom.TagName.BLOCKQUOTE = new goog.dom.TagName("BLOCKQUOTE"), goog.dom.TagName.BODY = new goog.dom.TagName("BODY"), goog.dom.TagName.BR = new goog.dom.TagName("BR"), goog.dom.TagName.BUTTON = new goog.dom.TagName("BUTTON"), goog.dom.TagName.CANVAS = new goog.dom.TagName("CANVAS"), goog.dom.TagName.CAPTION = new goog.dom.TagName("CAPTION"), goog.dom.TagName.CENTER = new goog.dom.TagName("CENTER"), goog.dom.TagName.CITE = new goog.dom.TagName("CITE"), goog.dom.TagName.CODE = new goog.dom.TagName("CODE"), goog.dom.TagName.COL = new goog.dom.TagName("COL"), goog.dom.TagName.COLGROUP = new goog.dom.TagName("COLGROUP"), goog.dom.TagName.COMMAND = new goog.dom.TagName("COMMAND"), goog.dom.TagName.DATA = new goog.dom.TagName("DATA"), goog.dom.TagName.DATALIST = new goog.dom.TagName("DATALIST"), goog.dom.TagName.DD = new goog.dom.TagName("DD"), goog.dom.TagName.DEL = new goog.dom.TagName("DEL"), goog.dom.TagName.DETAILS = new goog.dom.TagName("DETAILS"), goog.dom.TagName.DFN = new goog.dom.TagName("DFN"), goog.dom.TagName.DIALOG = new goog.dom.TagName("DIALOG"), goog.dom.TagName.DIR = new goog.dom.TagName("DIR"), goog.dom.TagName.DIV = new goog.dom.TagName("DIV"), goog.dom.TagName.DL = new goog.dom.TagName("DL"), goog.dom.TagName.DT = new goog.dom.TagName("DT"), goog.dom.TagName.EM = new goog.dom.TagName("EM"), goog.dom.TagName.EMBED = new goog.dom.TagName("EMBED"), goog.dom.TagName.FIELDSET = new goog.dom.TagName("FIELDSET"), goog.dom.TagName.FIGCAPTION = new goog.dom.TagName("FIGCAPTION"), goog.dom.TagName.FIGURE = new goog.dom.TagName("FIGURE"), goog.dom.TagName.FONT = new goog.dom.TagName("FONT"), goog.dom.TagName.FOOTER = new goog.dom.TagName("FOOTER"), goog.dom.TagName.FORM = new goog.dom.TagName("FORM"), goog.dom.TagName.FRAME = new goog.dom.TagName("FRAME"), goog.dom.TagName.FRAMESET = new goog.dom.TagName("FRAMESET"), goog.dom.TagName.H1 = new goog.dom.TagName("H1"), goog.dom.TagName.H2 = new goog.dom.TagName("H2"), goog.dom.TagName.H3 = new goog.dom.TagName("H3"), goog.dom.TagName.H4 = new goog.dom.TagName("H4"), goog.dom.TagName.H5 = new goog.dom.TagName("H5"), goog.dom.TagName.H6 = new goog.dom.TagName("H6"), goog.dom.TagName.HEAD = new goog.dom.TagName("HEAD"), goog.dom.TagName.HEADER = new goog.dom.TagName("HEADER"), goog.dom.TagName.HGROUP = new goog.dom.TagName("HGROUP"), goog.dom.TagName.HR = new goog.dom.TagName("HR"), goog.dom.TagName.HTML = new goog.dom.TagName("HTML"), goog.dom.TagName.I = new goog.dom.TagName("I"), goog.dom.TagName.IFRAME = new goog.dom.TagName("IFRAME"), goog.dom.TagName.IMG = new goog.dom.TagName("IMG"), goog.dom.TagName.INPUT = new goog.dom.TagName("INPUT"), goog.dom.TagName.INS = new goog.dom.TagName("INS"), goog.dom.TagName.ISINDEX = new goog.dom.TagName("ISINDEX"), goog.dom.TagName.KBD = new goog.dom.TagName("KBD"), goog.dom.TagName.KEYGEN = new goog.dom.TagName("KEYGEN"), goog.dom.TagName.LABEL = new goog.dom.TagName("LABEL"), goog.dom.TagName.LEGEND = new goog.dom.TagName("LEGEND"), goog.dom.TagName.LI = new goog.dom.TagName("LI"), goog.dom.TagName.LINK = new goog.dom.TagName("LINK"), goog.dom.TagName.MAIN = new goog.dom.TagName("MAIN"), goog.dom.TagName.MAP = new goog.dom.TagName("MAP"), goog.dom.TagName.MARK = new goog.dom.TagName("MARK"), goog.dom.TagName.MATH = new goog.dom.TagName("MATH"), goog.dom.TagName.MENU = new goog.dom.TagName("MENU"), goog.dom.TagName.MENUITEM = new goog.dom.TagName("MENUITEM"), goog.dom.TagName.META = new goog.dom.TagName("META"), goog.dom.TagName.METER = new goog.dom.TagName("METER"), goog.dom.TagName.NAV = new goog.dom.TagName("NAV"), goog.dom.TagName.NOFRAMES = new goog.dom.TagName("NOFRAMES"), goog.dom.TagName.NOSCRIPT = new goog.dom.TagName("NOSCRIPT"), goog.dom.TagName.OBJECT = new goog.dom.TagName("OBJECT"), goog.dom.TagName.OL = new goog.dom.TagName("OL"), goog.dom.TagName.OPTGROUP = new goog.dom.TagName("OPTGROUP"), goog.dom.TagName.OPTION = new goog.dom.TagName("OPTION"), goog.dom.TagName.OUTPUT = new goog.dom.TagName("OUTPUT"), goog.dom.TagName.P = new goog.dom.TagName("P"), goog.dom.TagName.PARAM = new goog.dom.TagName("PARAM"), goog.dom.TagName.PICTURE = new goog.dom.TagName("PICTURE"), goog.dom.TagName.PRE = new goog.dom.TagName("PRE"), goog.dom.TagName.PROGRESS = new goog.dom.TagName("PROGRESS"), goog.dom.TagName.Q = new goog.dom.TagName("Q"), goog.dom.TagName.RP = new goog.dom.TagName("RP"), goog.dom.TagName.RT = new goog.dom.TagName("RT"), goog.dom.TagName.RTC = new goog.dom.TagName("RTC"), goog.dom.TagName.RUBY = new goog.dom.TagName("RUBY"), goog.dom.TagName.S = new goog.dom.TagName("S"), goog.dom.TagName.SAMP = new goog.dom.TagName("SAMP"), goog.dom.TagName.SCRIPT = new goog.dom.TagName("SCRIPT"), goog.dom.TagName.SECTION = new goog.dom.TagName("SECTION"), goog.dom.TagName.SELECT = new goog.dom.TagName("SELECT"), goog.dom.TagName.SMALL = new goog.dom.TagName("SMALL"), goog.dom.TagName.SOURCE = new goog.dom.TagName("SOURCE"), goog.dom.TagName.SPAN = new goog.dom.TagName("SPAN"), goog.dom.TagName.STRIKE = new goog.dom.TagName("STRIKE"), goog.dom.TagName.STRONG = new goog.dom.TagName("STRONG"), goog.dom.TagName.STYLE = new goog.dom.TagName("STYLE"), goog.dom.TagName.SUB = new goog.dom.TagName("SUB"), goog.dom.TagName.SUMMARY = new goog.dom.TagName("SUMMARY"), goog.dom.TagName.SUP = new goog.dom.TagName("SUP"), goog.dom.TagName.SVG = new goog.dom.TagName("SVG"), goog.dom.TagName.TABLE = new goog.dom.TagName("TABLE"), goog.dom.TagName.TBODY = new goog.dom.TagName("TBODY"), goog.dom.TagName.TD = new goog.dom.TagName("TD"), goog.dom.TagName.TEMPLATE = new goog.dom.TagName("TEMPLATE"), goog.dom.TagName.TEXTAREA = new goog.dom.TagName("TEXTAREA"), goog.dom.TagName.TFOOT = new goog.dom.TagName("TFOOT"), goog.dom.TagName.TH = new goog.dom.TagName("TH"), goog.dom.TagName.THEAD = new goog.dom.TagName("THEAD"), goog.dom.TagName.TIME = new goog.dom.TagName("TIME"), goog.dom.TagName.TITLE = new goog.dom.TagName("TITLE"), goog.dom.TagName.TR = new goog.dom.TagName("TR"), goog.dom.TagName.TRACK = new goog.dom.TagName("TRACK"), goog.dom.TagName.TT = new goog.dom.TagName("TT"), goog.dom.TagName.U = new goog.dom.TagName("U"), goog.dom.TagName.UL = new goog.dom.TagName("UL"), goog.dom.TagName.VAR = new goog.dom.TagName("VAR"), goog.dom.TagName.VIDEO = new goog.dom.TagName("VIDEO"), goog.dom.TagName.WBR = new goog.dom.TagName("WBR"), goog.dom.tags = {}, goog.dom.tags.VOID_TAGS_ = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, goog.dom.tags.isVoidTag = function(v) {
    return goog.dom.tags.VOID_TAGS_[v] === !0;
  }, goog.html = {}, goog.html.trustedtypes = {}, goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#html") : null, goog.string = {}, goog.string.TypedString = function() {
  }, goog.string.Const = function(v, e) {
    this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = v === goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ && e || "", this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_;
  }, goog.string.Const.prototype.implementsGoogStringTypedString = !0, goog.string.Const.prototype.getTypedStringValue = function() {
    return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
  }, goog.DEBUG && (goog.string.Const.prototype.toString = function() {
    return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}";
  }), goog.string.Const.unwrap = function(v) {
    return v instanceof goog.string.Const && v.constructor === goog.string.Const && v.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_ ? v.stringConstValueWithSecurityContract__googStringSecurityPrivate_ : (goog.asserts.fail("expected object of type Const, got '" + v + "'"), "type_error:Const");
  }, goog.string.Const.from = function(v) {
    return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, v);
  }, goog.string.Const.TYPE_MARKER_ = {}, goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.Const.EMPTY = goog.string.Const.from(""), goog.html.SafeScript = function() {
    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "", this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeScript.prototype.implementsGoogStringTypedString = !0, goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeScript.fromConstant = function(v) {
    return v = goog.string.Const.unwrap(v), v.length === 0 ? goog.html.SafeScript.EMPTY : goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeScript.fromConstantAndArgs = function(v, e) {
    for (var fe = [], be = 1; be < arguments.length; be++)
      fe.push(goog.html.SafeScript.stringify_(arguments[be]));
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("(" + goog.string.Const.unwrap(v) + ")(" + fe.join(", ") + ");");
  }, goog.html.SafeScript.fromJson = function(v) {
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(v));
  }, goog.html.SafeScript.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
  }, goog.DEBUG && (goog.html.SafeScript.prototype.toString = function() {
    return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}";
  }), goog.html.SafeScript.unwrap = function(v) {
    return goog.html.SafeScript.unwrapTrustedScript(v).toString();
  }, goog.html.SafeScript.unwrapTrustedScript = function(v) {
    return v instanceof goog.html.SafeScript && v.constructor === goog.html.SafeScript && v.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? v.privateDoNotAccessOrElseSafeScriptWrappedValue_ : (goog.asserts.fail("expected object of type SafeScript, got '" + v + "' of type " + goog.typeOf(v)), "type_error:SafeScript");
  }, goog.html.SafeScript.stringify_ = function(v) {
    return JSON.stringify(v).replace(/</g, "\\x3c");
  }, goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(v) {
    return new goog.html.SafeScript().initSecurityPrivateDoNotAccessOrElse_(v);
  }, goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(v) {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(v) : v, this;
  }, goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(""), goog.fs = {}, goog.fs.url = {}, goog.fs.url.createObjectUrl = function(v) {
    return goog.fs.url.getUrlObject_().createObjectURL(v);
  }, goog.fs.url.revokeObjectUrl = function(v) {
    goog.fs.url.getUrlObject_().revokeObjectURL(v);
  }, goog.fs.url.UrlObject_ = function() {
  }, goog.fs.url.UrlObject_.prototype.createObjectURL = function(v) {
  }, goog.fs.url.UrlObject_.prototype.revokeObjectURL = function(v) {
  }, goog.fs.url.getUrlObject_ = function() {
    var v = goog.fs.url.findUrlObject_();
    if (v != null)
      return v;
    throw Error("This browser doesn't seem to support blob URLs");
  }, goog.fs.url.findUrlObject_ = function() {
    return goog.global.URL !== void 0 && goog.global.URL.createObjectURL !== void 0 ? goog.global.URL : goog.global.webkitURL !== void 0 && goog.global.webkitURL.createObjectURL !== void 0 ? goog.global.webkitURL : goog.global.createObjectURL !== void 0 ? goog.global : null;
  }, goog.fs.url.browserSupportsObjectUrls = function() {
    return goog.fs.url.findUrlObject_() != null;
  }, goog.fs.blob = {}, goog.fs.blob.getBlob = function(v) {
    var e = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
    if (e !== void 0) {
      e = new e();
      for (var fe = 0; fe < arguments.length; fe++)
        e.append(arguments[fe]);
      return e.getBlob();
    }
    return goog.fs.blob.getBlobWithProperties(goog.array.toArray(arguments));
  }, goog.fs.blob.getBlobWithProperties = function(v, e, fe) {
    var be = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
    if (be !== void 0) {
      be = new be();
      for (var ye = 0; ye < v.length; ye++)
        be.append(v[ye], fe);
      return be.getBlob(e);
    }
    if (goog.global.Blob !== void 0)
      return be = {}, e && (be.type = e), fe && (be.endings = fe), new Blob(v, be);
    throw Error("This browser doesn't seem to support creating Blobs");
  }, goog.i18n = {}, goog.i18n.bidi = {}, goog.i18n.bidi.FORCE_RTL = !1, goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == "ar" || goog.LOCALE.substring(0, 2).toLowerCase() == "fa" || goog.LOCALE.substring(0, 2).toLowerCase() == "he" || goog.LOCALE.substring(0, 2).toLowerCase() == "iw" || goog.LOCALE.substring(0, 2).toLowerCase() == "ps" || goog.LOCALE.substring(0, 2).toLowerCase() == "sd" || goog.LOCALE.substring(0, 2).toLowerCase() == "ug" || goog.LOCALE.substring(0, 2).toLowerCase() == "ur" || goog.LOCALE.substring(0, 2).toLowerCase() == "yi") && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") || 3 <= goog.LOCALE.length && goog.LOCALE.substring(0, 3).toLowerCase() == "ckb" && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") || 7 <= goog.LOCALE.length && (goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") && (goog.LOCALE.substring(3, 7).toLowerCase() == "adlm" || goog.LOCALE.substring(3, 7).toLowerCase() == "arab" || goog.LOCALE.substring(3, 7).toLowerCase() == "hebr" || goog.LOCALE.substring(
    3,
    7
  ).toLowerCase() == "nkoo" || goog.LOCALE.substring(3, 7).toLowerCase() == "rohg" || goog.LOCALE.substring(3, 7).toLowerCase() == "thaa") || 8 <= goog.LOCALE.length && (goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") && (goog.LOCALE.substring(4, 8).toLowerCase() == "adlm" || goog.LOCALE.substring(4, 8).toLowerCase() == "arab" || goog.LOCALE.substring(4, 8).toLowerCase() == "hebr" || goog.LOCALE.substring(4, 8).toLowerCase() == "nkoo" || goog.LOCALE.substring(4, 8).toLowerCase() == "rohg" || goog.LOCALE.substring(4, 8).toLowerCase() == "thaa"), goog.i18n.bidi.Format = { LRE: "", RLE: "", PDF: "", LRM: "", RLM: "" }, goog.i18n.bidi.Dir = { LTR: 1, RTL: -1, NEUTRAL: 0 }, goog.i18n.bidi.RIGHT = "right", goog.i18n.bidi.LEFT = "left", goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT, goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, goog.i18n.bidi.toDir = function(v, e) {
    return typeof v == "number" ? 0 < v ? goog.i18n.bidi.Dir.LTR : 0 > v ? goog.i18n.bidi.Dir.RTL : e ? null : goog.i18n.bidi.Dir.NEUTRAL : v == null ? null : v ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }, goog.i18n.bidi.ltrChars_ = "A-Za-z------\uD801\uD804-\uD839\uD83C-\uDBFF---", goog.i18n.bidi.rtlChars_ = "--\uD802-\uD803\uD83A-\uD83B--", goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g, goog.i18n.bidi.stripHtmlIfNeeded_ = function(v, e) {
    return e ? v.replace(goog.i18n.bidi.htmlSkipReg_, "") : v;
  }, goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.hasAnyRtl = function(v, e) {
    return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(v, e));
  }, goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl, goog.i18n.bidi.hasAnyLtr = function(v, e) {
    return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(v, e));
  }, goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.isRtlChar = function(v) {
    return goog.i18n.bidi.rtlRe_.test(v);
  }, goog.i18n.bidi.isLtrChar = function(v) {
    return goog.i18n.bidi.ltrRe_.test(v);
  }, goog.i18n.bidi.isNeutralChar = function(v) {
    return !goog.i18n.bidi.isLtrChar(v) && !goog.i18n.bidi.isRtlChar(v);
  }, goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.startsWithRtl = function(v, e) {
    return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(v, e));
  }, goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl, goog.i18n.bidi.startsWithLtr = function(v, e) {
    return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(v, e));
  }, goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr, goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/, goog.i18n.bidi.isNeutralText = function(v, e) {
    return v = goog.i18n.bidi.stripHtmlIfNeeded_(v, e), goog.i18n.bidi.isRequiredLtrRe_.test(v) || !goog.i18n.bidi.hasAnyLtr(v) && !goog.i18n.bidi.hasAnyRtl(v);
  }, goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "][^" + goog.i18n.bidi.rtlChars_ + "]*$"), goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "][^" + goog.i18n.bidi.ltrChars_ + "]*$"), goog.i18n.bidi.endsWithLtr = function(v, e) {
    return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(v, e));
  }, goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr, goog.i18n.bidi.endsWithRtl = function(v, e) {
    return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(v, e));
  }, goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl, goog.i18n.bidi.rtlLocalesRe_ = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i, goog.i18n.bidi.isRtlLanguage = function(v) {
    return goog.i18n.bidi.rtlLocalesRe_.test(v);
  }, goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g, goog.i18n.bidi.guardBracketInText = function(v, e) {
    return e = (e === void 0 ? goog.i18n.bidi.hasAnyRtl(v) : e) ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM, v.replace(goog.i18n.bidi.bracketGuardTextRe_, e + "$&" + e);
  }, goog.i18n.bidi.enforceRtlInHtml = function(v) {
    return v.charAt(0) == "<" ? v.replace(/<\w+/, "$& dir=rtl") : `
<span dir=rtl>` + v + "</span>";
  }, goog.i18n.bidi.enforceRtlInText = function(v) {
    return goog.i18n.bidi.Format.RLE + v + goog.i18n.bidi.Format.PDF;
  }, goog.i18n.bidi.enforceLtrInHtml = function(v) {
    return v.charAt(0) == "<" ? v.replace(/<\w+/, "$& dir=ltr") : `
<span dir=ltr>` + v + "</span>";
  }, goog.i18n.bidi.enforceLtrInText = function(v) {
    return goog.i18n.bidi.Format.LRE + v + goog.i18n.bidi.Format.PDF;
  }, goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g, goog.i18n.bidi.leftRe_ = /left/gi, goog.i18n.bidi.rightRe_ = /right/gi, goog.i18n.bidi.tempRe_ = /%%%%/g, goog.i18n.bidi.mirrorCSS = function(v) {
    return v.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
  }, goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g, goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g, goog.i18n.bidi.normalizeHebrewQuote = function(v) {
    return v.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1");
  }, goog.i18n.bidi.wordSeparatorRe_ = /\s+/, goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/, goog.i18n.bidi.rtlDetectionThreshold_ = 0.4, goog.i18n.bidi.estimateDirection = function(v, e) {
    var fe = 0, be = 0, ye = !1;
    for (v = goog.i18n.bidi.stripHtmlIfNeeded_(v, e).split(goog.i18n.bidi.wordSeparatorRe_), e = 0; e < v.length; e++) {
      var ve = v[e];
      goog.i18n.bidi.startsWithRtl(ve) ? (fe++, be++) : goog.i18n.bidi.isRequiredLtrRe_.test(ve) ? ye = !0 : goog.i18n.bidi.hasAnyLtr(ve) ? be++ : goog.i18n.bidi.hasNumeralsRe_.test(ve) && (ye = !0);
    }
    return be == 0 ? ye ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : fe / be > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }, goog.i18n.bidi.detectRtlDirectionality = function(v, e) {
    return goog.i18n.bidi.estimateDirection(v, e) == goog.i18n.bidi.Dir.RTL;
  }, goog.i18n.bidi.setElementDirAndAlign = function(v, e) {
    v && (e = goog.i18n.bidi.toDir(e)) && (v.style.textAlign = e == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, v.dir = e == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
  }, goog.i18n.bidi.setElementDirByTextDirectionality = function(v, e) {
    switch (goog.i18n.bidi.estimateDirection(e)) {
      case goog.i18n.bidi.Dir.LTR:
        v.dir = "ltr";
        break;
      case goog.i18n.bidi.Dir.RTL:
        v.dir = "rtl";
        break;
      default:
        v.removeAttribute("dir");
    }
  }, goog.i18n.bidi.DirectionalString = function() {
  }, goog.html.TrustedResourceUrl = function(v, e) {
    this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = v === goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && e || "", this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = !0, goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString();
  }, goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.TrustedResourceUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR;
  }, goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(v, e) {
    var fe = goog.html.TrustedResourceUrl.unwrap(this);
    fe = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(fe);
    var be = fe[3] || "";
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(fe[1] + goog.html.TrustedResourceUrl.stringifyParams_("?", fe[2] || "", v) + goog.html.TrustedResourceUrl.stringifyParams_("#", be, e));
  }, goog.DEBUG && (goog.html.TrustedResourceUrl.prototype.toString = function() {
    return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}";
  }), goog.html.TrustedResourceUrl.unwrap = function(v) {
    return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(v).toString();
  }, goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(v) {
    return v instanceof goog.html.TrustedResourceUrl && v.constructor === goog.html.TrustedResourceUrl && v.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? v.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ : (goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + v + "' of type " + goog.typeOf(v)), "type_error:TrustedResourceUrl");
  }, goog.html.TrustedResourceUrl.format = function(v, e) {
    var fe = goog.string.Const.unwrap(v);
    if (!goog.html.TrustedResourceUrl.BASE_URL_.test(fe))
      throw Error("Invalid TrustedResourceUrl format: " + fe);
    return v = fe.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(be, ye) {
      if (!Object.prototype.hasOwnProperty.call(e, ye))
        throw Error('Found marker, "' + ye + '", in format string, "' + fe + '", but no valid label mapping found in args: ' + JSON.stringify(e));
      return be = e[ye], be instanceof goog.string.Const ? goog.string.Const.unwrap(be) : encodeURIComponent(String(be));
    }), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g, goog.html.TrustedResourceUrl.BASE_URL_ = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ = /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/, goog.html.TrustedResourceUrl.formatWithParams = function(v, e, fe, be) {
    return goog.html.TrustedResourceUrl.format(v, e).cloneWithParams(fe, be);
  }, goog.html.TrustedResourceUrl.fromConstant = function(v) {
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(v));
  }, goog.html.TrustedResourceUrl.fromConstants = function(v) {
    for (var e = "", fe = 0; fe < v.length; fe++)
      e += goog.string.Const.unwrap(v[fe]);
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.TrustedResourceUrl.fromSafeScript = function(v) {
    return v = goog.fs.blob.getBlobWithProperties([goog.html.SafeScript.unwrap(v)], "text/javascript"), v = goog.fs.url.createObjectUrl(v), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(v) {
    return v = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(v) : v, new goog.html.TrustedResourceUrl(goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_, v);
  }, goog.html.TrustedResourceUrl.stringifyParams_ = function(v, e, fe) {
    if (fe == null)
      return e;
    if (typeof fe == "string")
      return fe ? v + encodeURIComponent(fe) : "";
    for (var be in fe) {
      var ye = fe[be];
      ye = Array.isArray(ye) ? ye : [ye];
      for (var ve = 0; ve < ye.length; ve++) {
        var Ee = ye[ve];
        Ee != null && (e || (e = v), e += (e.length > v.length ? "&" : "") + encodeURIComponent(be) + "=" + encodeURIComponent(String(Ee)));
      }
    }
    return e;
  }, goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.internal = {}, goog.string.internal.startsWith = function(v, e) {
    return v.lastIndexOf(e, 0) == 0;
  }, goog.string.internal.endsWith = function(v, e) {
    var fe = v.length - e.length;
    return 0 <= fe && v.indexOf(e, fe) == fe;
  }, goog.string.internal.caseInsensitiveStartsWith = function(v, e) {
    return goog.string.internal.caseInsensitiveCompare(e, v.substr(0, e.length)) == 0;
  }, goog.string.internal.caseInsensitiveEndsWith = function(v, e) {
    return goog.string.internal.caseInsensitiveCompare(e, v.substr(v.length - e.length, e.length)) == 0;
  }, goog.string.internal.caseInsensitiveEquals = function(v, e) {
    return v.toLowerCase() == e.toLowerCase();
  }, goog.string.internal.isEmptyOrWhitespace = function(v) {
    return /^[\s\xa0]*$/.test(v);
  }, goog.string.internal.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(v) {
    return v.trim();
  } : function(v) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(v)[1];
  }, goog.string.internal.caseInsensitiveCompare = function(v, e) {
    return v = String(v).toLowerCase(), e = String(e).toLowerCase(), v < e ? -1 : v == e ? 0 : 1;
  }, goog.string.internal.newLineToBr = function(v, e) {
    return v.replace(/(\r\n|\r|\n)/g, e ? "<br />" : "<br>");
  }, goog.string.internal.htmlEscape = function(v, e) {
    if (e)
      v = v.replace(goog.string.internal.AMP_RE_, "&amp;").replace(goog.string.internal.LT_RE_, "&lt;").replace(goog.string.internal.GT_RE_, "&gt;").replace(goog.string.internal.QUOT_RE_, "&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.internal.NULL_RE_, "&#0;");
    else {
      if (!goog.string.internal.ALL_RE_.test(v))
        return v;
      v.indexOf("&") != -1 && (v = v.replace(goog.string.internal.AMP_RE_, "&amp;")), v.indexOf("<") != -1 && (v = v.replace(
        goog.string.internal.LT_RE_,
        "&lt;"
      )), v.indexOf(">") != -1 && (v = v.replace(goog.string.internal.GT_RE_, "&gt;")), v.indexOf('"') != -1 && (v = v.replace(goog.string.internal.QUOT_RE_, "&quot;")), v.indexOf("'") != -1 && (v = v.replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;")), v.indexOf("\0") != -1 && (v = v.replace(goog.string.internal.NULL_RE_, "&#0;"));
    }
    return v;
  }, goog.string.internal.AMP_RE_ = /&/g, goog.string.internal.LT_RE_ = /</g, goog.string.internal.GT_RE_ = />/g, goog.string.internal.QUOT_RE_ = /"/g, goog.string.internal.SINGLE_QUOTE_RE_ = /'/g, goog.string.internal.NULL_RE_ = /\x00/g, goog.string.internal.ALL_RE_ = /[\x00&<>"']/, goog.string.internal.whitespaceEscape = function(v, e) {
    return goog.string.internal.newLineToBr(v.replace(/  /g, " &#160;"), e);
  }, goog.string.internal.contains = function(v, e) {
    return v.indexOf(e) != -1;
  }, goog.string.internal.caseInsensitiveContains = function(v, e) {
    return goog.string.internal.contains(v.toLowerCase(), e.toLowerCase());
  }, goog.string.internal.compareVersions = function(v, e) {
    var fe = 0;
    v = goog.string.internal.trim(String(v)).split("."), e = goog.string.internal.trim(String(e)).split(".");
    for (var be = Math.max(v.length, e.length), ye = 0; fe == 0 && ye < be; ye++) {
      var ve = v[ye] || "", Ee = e[ye] || "";
      do {
        if (ve = /(\d*)(\D*)(.*)/.exec(ve) || ["", "", "", ""], Ee = /(\d*)(\D*)(.*)/.exec(Ee) || ["", "", "", ""], ve[0].length == 0 && Ee[0].length == 0)
          break;
        fe = ve[1].length == 0 ? 0 : parseInt(ve[1], 10);
        var Se = Ee[1].length == 0 ? 0 : parseInt(Ee[1], 10);
        fe = goog.string.internal.compareElements_(fe, Se) || goog.string.internal.compareElements_(ve[2].length == 0, Ee[2].length == 0) || goog.string.internal.compareElements_(ve[2], Ee[2]), ve = ve[3], Ee = Ee[3];
      } while (fe == 0);
    }
    return fe;
  }, goog.string.internal.compareElements_ = function(v, e) {
    return v < e ? -1 : v > e ? 1 : 0;
  }, goog.html.SafeUrl = function(v, e) {
    this.privateDoNotAccessOrElseSafeUrlWrappedValue_ = v === goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && e || "", this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez", goog.html.SafeUrl.prototype.implementsGoogStringTypedString = !0, goog.html.SafeUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
  }, goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.SafeUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR;
  }, goog.DEBUG && (goog.html.SafeUrl.prototype.toString = function() {
    return "SafeUrl{" + this.privateDoNotAccessOrElseSafeUrlWrappedValue_ + "}";
  }), goog.html.SafeUrl.unwrap = function(v) {
    return v instanceof goog.html.SafeUrl && v.constructor === goog.html.SafeUrl && v.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? v.privateDoNotAccessOrElseSafeUrlWrappedValue_ : (goog.asserts.fail("expected object of type SafeUrl, got '" + v + "' of type " + goog.typeOf(v)), "type_error:SafeUrl");
  }, goog.html.SafeUrl.fromConstant = function(v) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(v));
  }, goog.html.SAFE_MIME_TYPE_PATTERN_ = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i, goog.html.SafeUrl.isSafeMimeType = function(v) {
    return goog.html.SAFE_MIME_TYPE_PATTERN_.test(v);
  }, goog.html.SafeUrl.fromBlob = function(v) {
    return v = goog.html.SafeUrl.isSafeMimeType(v.type) ? goog.fs.url.createObjectUrl(v) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeUrl.fromMediaSource = function(v) {
    return goog.asserts.assert("MediaSource" in goog.global, "No support for MediaSource"), v = v instanceof MediaSource ? goog.fs.url.createObjectUrl(v) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.DATA_URL_PATTERN_ = /^data:(.*);base64,[a-z0-9+\/]+=*$/i, goog.html.SafeUrl.fromDataUrl = function(v) {
    v = v.replace(/(%0A|%0D)/g, "");
    var e = v.match(goog.html.DATA_URL_PATTERN_);
    return e = e && goog.html.SafeUrl.isSafeMimeType(e[1]), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e ? v : goog.html.SafeUrl.INNOCUOUS_STRING);
  }, goog.html.SafeUrl.fromTelUrl = function(v) {
    return goog.string.internal.caseInsensitiveStartsWith(v, "tel:") || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SIP_URL_PATTERN_ = /^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i, goog.html.SafeUrl.fromSipUrl = function(v) {
    return goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(v)) || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeUrl.fromFacebookMessengerUrl = function(v) {
    return goog.string.internal.caseInsensitiveStartsWith(v, "fb-messenger://share") || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeUrl.fromWhatsAppUrl = function(v) {
    return goog.string.internal.caseInsensitiveStartsWith(v, "whatsapp://send") || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeUrl.fromSmsUrl = function(v) {
    return goog.string.internal.caseInsensitiveStartsWith(v, "sms:") && goog.html.SafeUrl.isSmsUrlBodyValid_(v) || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeUrl.isSmsUrlBodyValid_ = function(v) {
    var e = v.indexOf("#");
    if (0 < e && (v = v.substring(0, e)), e = v.match(/[?&]body=/gi), !e)
      return !0;
    if (1 < e.length)
      return !1;
    if (v = v.match(/[?&]body=([^&]*)/)[1], !v)
      return !0;
    try {
      decodeURIComponent(v);
    } catch {
      return !1;
    }
    return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(v);
  }, goog.html.SafeUrl.fromSshUrl = function(v) {
    return goog.string.internal.caseInsensitiveStartsWith(v, "ssh://") || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(v, e) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//, v, e);
  }, goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(v, e) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//, v, e);
  }, goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(v, e) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//, v, e);
  }, goog.html.SafeUrl.sanitizeExtensionUrl_ = function(v, e, fe) {
    return (v = v.exec(e)) ? (v = v[1], (fe instanceof goog.string.Const ? [goog.string.Const.unwrap(fe)] : fe.map(function(be) {
      return goog.string.Const.unwrap(be);
    })).indexOf(v) == -1 && (e = goog.html.SafeUrl.INNOCUOUS_STRING)) : e = goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.SafeUrl.fromTrustedResourceUrl = function(v) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(v));
  }, goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i, goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_, goog.html.SafeUrl.sanitize = function(v) {
    return v instanceof goog.html.SafeUrl ? v : (v = typeof v == "object" && v.implementsGoogStringTypedString ? v.getTypedStringValue() : String(v), goog.html.SAFE_URL_PATTERN_.test(v) || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v));
  }, goog.html.SafeUrl.sanitizeAssertUnchanged = function(v, e) {
    return v instanceof goog.html.SafeUrl ? v : (v = typeof v == "object" && v.implementsGoogStringTypedString ? v.getTypedStringValue() : String(v), e && /^data:/i.test(v) && (e = goog.html.SafeUrl.fromDataUrl(v), e.getTypedStringValue() == v) ? e : (goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(v), "%s does not match the safe URL pattern", v) || (v = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(v)));
  }, goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(v) {
    return new goog.html.SafeUrl(goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_, v);
  }, goog.html.SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank"), goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.html.SafeStyle = function() {
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "", this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeStyle.prototype.implementsGoogStringTypedString = !0, goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyle.fromConstant = function(v) {
    return v = goog.string.Const.unwrap(v), v.length === 0 ? goog.html.SafeStyle.EMPTY : (goog.asserts.assert(goog.string.internal.endsWith(v, ";"), "Last character of style string is not ';': " + v), goog.asserts.assert(goog.string.internal.contains(v, ":"), `Style string must contain at least one ':', to specify a "name: value" pair: ` + v), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(v));
  }, goog.html.SafeStyle.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
  }, goog.DEBUG && (goog.html.SafeStyle.prototype.toString = function() {
    return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}";
  }), goog.html.SafeStyle.unwrap = function(v) {
    return v instanceof goog.html.SafeStyle && v.constructor === goog.html.SafeStyle && v.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? v.privateDoNotAccessOrElseSafeStyleWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyle, got '" + v + "' of type " + goog.typeOf(v)), "type_error:SafeStyle");
  }, goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(v) {
    return new goog.html.SafeStyle().initSecurityPrivateDoNotAccessOrElse_(v);
  }, goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(v) {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = v, this;
  }, goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(""), goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez", goog.html.SafeStyle.create = function(v) {
    var e = "", fe;
    for (fe in v) {
      if (!/^[-_a-zA-Z0-9]+$/.test(fe))
        throw Error("Name allows only [-_a-zA-Z0-9], got: " + fe);
      var be = v[fe];
      be != null && (be = Array.isArray(be) ? goog.array.map(be, goog.html.SafeStyle.sanitizePropertyValue_).join(" ") : goog.html.SafeStyle.sanitizePropertyValue_(be), e += fe + ":" + be + ";");
    }
    return e ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e) : goog.html.SafeStyle.EMPTY;
  }, goog.html.SafeStyle.sanitizePropertyValue_ = function(v) {
    if (v instanceof goog.html.SafeUrl)
      return 'url("' + goog.html.SafeUrl.unwrap(v).replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")';
    if (v = v instanceof goog.string.Const ? goog.string.Const.unwrap(v) : goog.html.SafeStyle.sanitizePropertyValueString_(String(v)), /[{;}]/.test(v))
      throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.", [v]);
    return v;
  }, goog.html.SafeStyle.sanitizePropertyValueString_ = function(v) {
    var e = v.replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.URL_RE_, "url");
    if (goog.html.SafeStyle.VALUE_RE_.test(e)) {
      if (goog.html.SafeStyle.COMMENT_RE_.test(v))
        return goog.asserts.fail("String value disallows comments, got: " + v), goog.html.SafeStyle.INNOCUOUS_STRING;
      if (!goog.html.SafeStyle.hasBalancedQuotes_(v))
        return goog.asserts.fail("String value requires balanced quotes, got: " + v), goog.html.SafeStyle.INNOCUOUS_STRING;
      if (!goog.html.SafeStyle.hasBalancedSquareBrackets_(v))
        return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: " + v), goog.html.SafeStyle.INNOCUOUS_STRING;
    } else
      return goog.asserts.fail("String value allows only " + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + " and simple functions, got: " + v), goog.html.SafeStyle.INNOCUOUS_STRING;
    return goog.html.SafeStyle.sanitizeUrl_(v);
  }, goog.html.SafeStyle.hasBalancedQuotes_ = function(v) {
    for (var e = !0, fe = !0, be = 0; be < v.length; be++) {
      var ye = v.charAt(be);
      ye == "'" && fe ? e = !e : ye == '"' && e && (fe = !fe);
    }
    return e && fe;
  }, goog.html.SafeStyle.hasBalancedSquareBrackets_ = function(v) {
    for (var e = !0, fe = /^[-_a-zA-Z0-9]$/, be = 0; be < v.length; be++) {
      var ye = v.charAt(be);
      if (ye == "]") {
        if (e)
          return !1;
        e = !0;
      } else if (ye == "[") {
        if (!e)
          return !1;
        e = !1;
      } else if (!e && !fe.test(ye))
        return !1;
    }
    return e;
  }, goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ = `[-,."'%_!# a-zA-Z0-9\\[\\]]`, goog.html.SafeStyle.VALUE_RE_ = new RegExp("^" + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + "+$"), goog.html.SafeStyle.URL_RE_ = /\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g, goog.html.SafeStyle.ALLOWED_FUNCTIONS_ = "calc cubic-bezier fit-content hsl hsla linear-gradient matrix minmax repeat rgb rgba (rotate|scale|translate)(X|Y|Z|3d)?".split(" "), goog.html.SafeStyle.FUNCTIONS_RE_ = new RegExp("\\b(" + goog.html.SafeStyle.ALLOWED_FUNCTIONS_.join("|") + ")\\([-+*/0-9a-z.%\\[\\], ]+\\)", "g"), goog.html.SafeStyle.COMMENT_RE_ = /\/\*/, goog.html.SafeStyle.sanitizeUrl_ = function(v) {
    return v.replace(goog.html.SafeStyle.URL_RE_, function(e, fe, be, ye) {
      var ve = "";
      return be = be.replace(/^(['"])(.*)\1$/, function(Ee, Se, Oe) {
        return ve = Se, Oe;
      }), e = goog.html.SafeUrl.sanitize(be).getTypedStringValue(), fe + ve + e + ve + ye;
    });
  }, goog.html.SafeStyle.concat = function(v) {
    var e = "", fe = function(be) {
      Array.isArray(be) ? goog.array.forEach(be, fe) : e += goog.html.SafeStyle.unwrap(be);
    };
    return goog.array.forEach(arguments, fe), e ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e) : goog.html.SafeStyle.EMPTY;
  }, goog.html.SafeStyleSheet = function() {
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "", this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = !0, goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyleSheet.createRule = function(v, e) {
    if (goog.string.internal.contains(v, "<"))
      throw Error("Selector does not allow '<', got: " + v);
    var fe = v.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");
    if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(fe))
      throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: " + v);
    if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(fe))
      throw Error("() and [] in selector must be balanced, got: " + v);
    return e instanceof goog.html.SafeStyle || (e = goog.html.SafeStyle.create(e)), v = v + "{" + goog.html.SafeStyle.unwrap(e).replace(/</g, "\\3C ") + "}", goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(v);
  }, goog.html.SafeStyleSheet.hasBalancedBrackets_ = function(v) {
    for (var e = { "(": ")", "[": "]" }, fe = [], be = 0; be < v.length; be++) {
      var ye = v[be];
      if (e[ye])
        fe.push(e[ye]);
      else if (goog.object.contains(e, ye) && fe.pop() != ye)
        return !1;
    }
    return fe.length == 0;
  }, goog.html.SafeStyleSheet.concat = function(v) {
    var e = "", fe = function(be) {
      Array.isArray(be) ? goog.array.forEach(be, fe) : e += goog.html.SafeStyleSheet.unwrap(be);
    };
    return goog.array.forEach(arguments, fe), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.SafeStyleSheet.fromConstant = function(v) {
    return v = goog.string.Const.unwrap(v), v.length === 0 ? goog.html.SafeStyleSheet.EMPTY : (goog.asserts.assert(!goog.string.internal.contains(v, "<"), "Forbidden '<' character in style sheet string: " + v), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(v));
  }, goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
  }, goog.DEBUG && (goog.html.SafeStyleSheet.prototype.toString = function() {
    return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}";
  }), goog.html.SafeStyleSheet.unwrap = function(v) {
    return v instanceof goog.html.SafeStyleSheet && v.constructor === goog.html.SafeStyleSheet && v.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? v.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyleSheet, got '" + v + "' of type " + goog.typeOf(v)), "type_error:SafeStyleSheet");
  }, goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(v) {
    return new goog.html.SafeStyleSheet().initSecurityPrivateDoNotAccessOrElse_(v);
  }, goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(v) {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = v, this;
  }, goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(""), goog.labs = {}, goog.labs.userAgent = {}, goog.labs.userAgent.util = {}, goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
    var v = goog.labs.userAgent.util.getNavigator_();
    return v && (v = v.userAgent) ? v : "";
  }, goog.labs.userAgent.util.getNavigator_ = function() {
    return goog.global.navigator;
  }, goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_(), goog.labs.userAgent.util.setUserAgent = function(v) {
    goog.labs.userAgent.util.userAgent_ = v || goog.labs.userAgent.util.getNativeUserAgentString_();
  }, goog.labs.userAgent.util.getUserAgent = function() {
    return goog.labs.userAgent.util.userAgent_;
  }, goog.labs.userAgent.util.matchUserAgent = function(v) {
    var e = goog.labs.userAgent.util.getUserAgent();
    return goog.string.internal.contains(e, v);
  }, goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(v) {
    var e = goog.labs.userAgent.util.getUserAgent();
    return goog.string.internal.caseInsensitiveContains(e, v);
  }, goog.labs.userAgent.util.extractVersionTuples = function(v) {
    for (var e = /(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g, fe = [], be; be = e.exec(v); )
      fe.push([be[1], be[2], be[3] || void 0]);
    return fe;
  }, goog.labs.userAgent.browser = {}, goog.labs.userAgent.browser.matchOpera_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Opera");
  }, goog.labs.userAgent.browser.matchIE_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
  }, goog.labs.userAgent.browser.matchEdgeHtml_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge");
  }, goog.labs.userAgent.browser.matchEdgeChromium_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edg/");
  }, goog.labs.userAgent.browser.matchOperaChromium_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("OPR");
  }, goog.labs.userAgent.browser.matchFirefox_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Firefox") || goog.labs.userAgent.util.matchUserAgent("FxiOS");
  }, goog.labs.userAgent.browser.matchSafari_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdgeHtml_() || goog.labs.userAgent.browser.matchEdgeChromium_() || goog.labs.userAgent.browser.matchOperaChromium_() || goog.labs.userAgent.browser.matchFirefox_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"));
  }, goog.labs.userAgent.browser.matchCoast_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Coast");
  }, goog.labs.userAgent.browser.matchIosWebview_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && !goog.labs.userAgent.browser.matchFirefox_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit");
  }, goog.labs.userAgent.browser.matchChrome_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchEdgeHtml_();
  }, goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk());
  }, goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_, goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_, goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_, goog.labs.userAgent.browser.isEdgeChromium = goog.labs.userAgent.browser.matchEdgeChromium_, goog.labs.userAgent.browser.isOperaChromium = goog.labs.userAgent.browser.matchOperaChromium_, goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_, goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_, goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_, goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_, goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_, goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_, goog.labs.userAgent.browser.isSilk = function() {
    return goog.labs.userAgent.util.matchUserAgent("Silk");
  }, goog.labs.userAgent.browser.getVersion = function() {
    function v(ye) {
      return ye = goog.array.find(ye, be), fe[ye] || "";
    }
    var e = goog.labs.userAgent.util.getUserAgent();
    if (goog.labs.userAgent.browser.isIE())
      return goog.labs.userAgent.browser.getIEVersion_(e);
    e = goog.labs.userAgent.util.extractVersionTuples(e);
    var fe = {};
    goog.array.forEach(e, function(ye) {
      fe[ye[0]] = ye[1];
    });
    var be = goog.partial(goog.object.containsKey, fe);
    return goog.labs.userAgent.browser.isOpera() ? v(["Version", "Opera"]) : goog.labs.userAgent.browser.isEdge() ? v(["Edge"]) : goog.labs.userAgent.browser.isEdgeChromium() ? v(["Edg"]) : goog.labs.userAgent.browser.isChrome() ? v(["Chrome", "CriOS", "HeadlessChrome"]) : (e = e[2]) && e[1] || "";
  }, goog.labs.userAgent.browser.isVersionOrHigher = function(v) {
    return 0 <= goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(), v);
  }, goog.labs.userAgent.browser.getIEVersion_ = function(v) {
    var e = /rv: *([\d\.]*)/.exec(v);
    if (e && e[1])
      return e[1];
    e = "";
    var fe = /MSIE +([\d\.]+)/.exec(v);
    if (fe && fe[1])
      if (v = /Trident\/(\d.\d)/.exec(v), fe[1] == "7.0")
        if (v && v[1])
          switch (v[1]) {
            case "4.0":
              e = "8.0";
              break;
            case "5.0":
              e = "9.0";
              break;
            case "6.0":
              e = "10.0";
              break;
            case "7.0":
              e = "11.0";
          }
        else
          e = "7.0";
      else
        e = fe[1];
    return e;
  }, goog.html.SafeHtml = function() {
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "", this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_, this.dir_ = null;
  }, goog.html.SafeHtml.ENABLE_ERROR_MESSAGES = goog.DEBUG, goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE = !0, goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.SafeHtml.prototype.getDirection = function() {
    return this.dir_;
  }, goog.html.SafeHtml.prototype.implementsGoogStringTypedString = !0, goog.html.SafeHtml.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
  }, goog.DEBUG && (goog.html.SafeHtml.prototype.toString = function() {
    return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
  }), goog.html.SafeHtml.unwrap = function(v) {
    return goog.html.SafeHtml.unwrapTrustedHTML(v).toString();
  }, goog.html.SafeHtml.unwrapTrustedHTML = function(v) {
    return v instanceof goog.html.SafeHtml && v.constructor === goog.html.SafeHtml && v.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? v.privateDoNotAccessOrElseSafeHtmlWrappedValue_ : (goog.asserts.fail("expected object of type SafeHtml, got '" + v + "' of type " + goog.typeOf(v)), "type_error:SafeHtml");
  }, goog.html.SafeHtml.htmlEscape = function(v) {
    if (v instanceof goog.html.SafeHtml)
      return v;
    var e = typeof v == "object", fe = null;
    return e && v.implementsGoogI18nBidiDirectionalString && (fe = v.getDirection()), v = e && v.implementsGoogStringTypedString ? v.getTypedStringValue() : String(v), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(v), fe);
  }, goog.html.SafeHtml.htmlEscapePreservingNewlines = function(v) {
    return v instanceof goog.html.SafeHtml ? v : (v = goog.html.SafeHtml.htmlEscape(v), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(v)), v.getDirection()));
  }, goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(v) {
    return v instanceof goog.html.SafeHtml ? v : (v = goog.html.SafeHtml.htmlEscape(v), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(v)), v.getDirection()));
  }, goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape, goog.html.SafeHtml.comment = function(v) {
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!--" + goog.string.internal.htmlEscape(v) + "-->", null);
  }, goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/, goog.html.SafeHtml.URL_ATTRIBUTES_ = { action: !0, cite: !0, data: !0, formaction: !0, href: !0, manifest: !0, poster: !0, src: !0 }, goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = { APPLET: !0, BASE: !0, EMBED: !0, IFRAME: !0, LINK: !0, MATH: !0, META: !0, OBJECT: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 }, goog.html.SafeHtml.create = function(v, e, fe) {
    return goog.html.SafeHtml.verifyTagName(String(v)), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(v), e, fe);
  }, goog.html.SafeHtml.verifyTagName = function(v) {
    if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(v))
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Invalid tag name <" + v + ">." : "");
    if (v.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Tag name <" + v + "> is not allowed for SafeHtml." : "");
  }, goog.html.SafeHtml.createIframe = function(v, e, fe, be) {
    v && goog.html.TrustedResourceUrl.unwrap(v);
    var ye = {};
    return ye.src = v || null, ye.srcdoc = e && goog.html.SafeHtml.unwrap(e), v = goog.html.SafeHtml.combineAttributes(ye, { sandbox: "" }, fe), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", v, be);
  }, goog.html.SafeHtml.createSandboxIframe = function(v, e, fe, be) {
    if (!goog.html.SafeHtml.canUseSandboxIframe())
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "The browser does not support sandboxed iframes." : "");
    var ye = {};
    return ye.src = v ? goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(v)) : null, ye.srcdoc = e || null, ye.sandbox = "", v = goog.html.SafeHtml.combineAttributes(ye, {}, fe), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", v, be);
  }, goog.html.SafeHtml.canUseSandboxIframe = function() {
    return goog.global.HTMLIFrameElement && "sandbox" in goog.global.HTMLIFrameElement.prototype;
  }, goog.html.SafeHtml.createScriptSrc = function(v, e) {
    return goog.html.TrustedResourceUrl.unwrap(v), v = goog.html.SafeHtml.combineAttributes({ src: v }, {}, e), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", v);
  }, goog.html.SafeHtml.createScript = function(v, e) {
    for (var fe in e) {
      var be = fe.toLowerCase();
      if (be == "language" || be == "src" || be == "text" || be == "type")
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot set "' + be + '" attribute' : "");
    }
    for (fe = "", v = goog.array.concat(v), be = 0; be < v.length; be++)
      fe += goog.html.SafeScript.unwrap(v[be]);
    return v = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(fe, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", e, v);
  }, goog.html.SafeHtml.createStyle = function(v, e) {
    e = goog.html.SafeHtml.combineAttributes({ type: "text/css" }, {}, e);
    var fe = "";
    v = goog.array.concat(v);
    for (var be = 0; be < v.length; be++)
      fe += goog.html.SafeStyleSheet.unwrap(v[be]);
    return v = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(fe, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style", e, v);
  }, goog.html.SafeHtml.createMetaRefresh = function(v, e) {
    return v = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(v)), (goog.labs.userAgent.browser.isIE() || goog.labs.userAgent.browser.isEdge()) && goog.string.internal.contains(v, ";") && (v = "'" + v.replace(/'/g, "%27") + "'"), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta", { "http-equiv": "refresh", content: (e || 0) + "; url=" + v });
  }, goog.html.SafeHtml.getAttrNameAndValue_ = function(v, e, fe) {
    if (fe instanceof goog.string.Const)
      fe = goog.string.Const.unwrap(fe);
    else if (e.toLowerCase() == "style")
      if (goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE)
        fe = goog.html.SafeHtml.getStyleValue_(fe);
      else
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "style" not supported.' : "");
    else {
      if (/^on/i.test(e))
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + e + '" requires goog.string.Const value, "' + fe + '" given.' : "");
      if (e.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_)
        if (fe instanceof goog.html.TrustedResourceUrl)
          fe = goog.html.TrustedResourceUrl.unwrap(fe);
        else if (fe instanceof goog.html.SafeUrl)
          fe = goog.html.SafeUrl.unwrap(fe);
        else if (typeof fe == "string")
          fe = goog.html.SafeUrl.sanitize(fe).getTypedStringValue();
        else
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + e + '" on tag "' + v + '" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + fe + '" given.' : "");
    }
    return fe.implementsGoogStringTypedString && (fe = fe.getTypedStringValue()), goog.asserts.assert(typeof fe == "string" || typeof fe == "number", "String or number value expected, got " + typeof fe + " with value: " + fe), e + '="' + goog.string.internal.htmlEscape(String(fe)) + '"';
  }, goog.html.SafeHtml.getStyleValue_ = function(v) {
    if (!goog.isObject(v))
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof v + " given: " + v : "");
    return v instanceof goog.html.SafeStyle || (v = goog.html.SafeStyle.create(v)), goog.html.SafeStyle.unwrap(v);
  }, goog.html.SafeHtml.createWithDir = function(v, e, fe, be) {
    return e = goog.html.SafeHtml.create(e, fe, be), e.dir_ = v, e;
  }, goog.html.SafeHtml.join = function(v, e) {
    v = goog.html.SafeHtml.htmlEscape(v);
    var fe = v.getDirection(), be = [], ye = function(ve) {
      Array.isArray(ve) ? goog.array.forEach(ve, ye) : (ve = goog.html.SafeHtml.htmlEscape(ve), be.push(goog.html.SafeHtml.unwrap(ve)), ve = ve.getDirection(), fe == goog.i18n.bidi.Dir.NEUTRAL ? fe = ve : ve != goog.i18n.bidi.Dir.NEUTRAL && fe != ve && (fe = null));
    };
    return goog.array.forEach(e, ye), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(be.join(goog.html.SafeHtml.unwrap(v)), fe);
  }, goog.html.SafeHtml.concat = function(v) {
    return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
  }, goog.html.SafeHtml.concatWithDir = function(v, e) {
    var fe = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
    return fe.dir_ = v, fe;
  }, goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(v, e) {
    return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(v, e);
  }, goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(v, e) {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(v) : v, this.dir_ = e, this;
  }, goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(v, e, fe) {
    var be = null, ye = "<" + v + goog.html.SafeHtml.stringifyAttributes(v, e);
    return fe == null ? fe = [] : Array.isArray(fe) || (fe = [fe]), goog.dom.tags.isVoidTag(v.toLowerCase()) ? (goog.asserts.assert(!fe.length, "Void tag <" + v + "> does not allow content."), ye += ">") : (be = goog.html.SafeHtml.concat(fe), ye += ">" + goog.html.SafeHtml.unwrap(be) + "</" + v + ">", be = be.getDirection()), (v = e && e.dir) && (be = /^(ltr|rtl|auto)$/i.test(v) ? goog.i18n.bidi.Dir.NEUTRAL : null), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
      ye,
      be
    );
  }, goog.html.SafeHtml.stringifyAttributes = function(v, e) {
    var fe = "";
    if (e)
      for (var be in e) {
        if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(be))
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Invalid attribute name "' + be + '".' : "");
        var ye = e[be];
        ye != null && (fe += " " + goog.html.SafeHtml.getAttrNameAndValue_(v, be, ye));
      }
    return fe;
  }, goog.html.SafeHtml.combineAttributes = function(v, e, fe) {
    var be = {}, ye;
    for (ye in v)
      goog.asserts.assert(ye.toLowerCase() == ye, "Must be lower case"), be[ye] = v[ye];
    for (ye in e)
      goog.asserts.assert(ye.toLowerCase() == ye, "Must be lower case"), be[ye] = e[ye];
    if (fe)
      for (ye in fe) {
        var ve = ye.toLowerCase();
        if (ve in v)
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot override "' + ve + '" attribute, got "' + ye + '" with value "' + fe[ye] + '"' : "");
        ve in e && delete be[ve], be[ye] = fe[ye];
      }
    return be;
  }, goog.html.SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.uncheckedconversions = {}, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(v, e, fe) {
    return goog.asserts.assertString(goog.string.Const.unwrap(v), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(v)), "must provide non-empty justification"), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e, fe || null);
  }, goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(v, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(v), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(v)), "must provide non-empty justification"), goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(v, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(v), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(v)), "must provide non-empty justification"), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(v, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(v), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(v)), "must provide non-empty justification"), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(v, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(v), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(v)), "must provide non-empty justification"), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(v, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(v), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(v)), "must provide non-empty justification"), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.dom.safe = {}, goog.dom.safe.InsertAdjacentHtmlPosition = { AFTERBEGIN: "afterbegin", AFTEREND: "afterend", BEFOREBEGIN: "beforebegin", BEFOREEND: "beforeend" }, goog.dom.safe.insertAdjacentHtml = function(v, e, fe) {
    v.insertAdjacentHTML(e, goog.html.SafeHtml.unwrapTrustedHTML(fe));
  }, goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = { MATH: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 }, goog.dom.safe.isInnerHtmlCleanupRecursive_ = goog.functions.cacheReturnValue(function() {
    if (goog.DEBUG && typeof document > "u")
      return !1;
    var v = document.createElement("div"), e = document.createElement("div");
    return e.appendChild(document.createElement("div")), v.appendChild(e), goog.DEBUG && !v.firstChild ? !1 : (e = v.firstChild.firstChild, v.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY), !e.parentElement);
  }), goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(v, e) {
    if (goog.dom.safe.isInnerHtmlCleanupRecursive_())
      for (; v.lastChild; )
        v.removeChild(v.lastChild);
    v.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(e);
  }, goog.dom.safe.setInnerHtml = function(v, e) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var fe = v.tagName.toUpperCase();
      if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[fe])
        throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + v.tagName + ".");
    }
    goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(v, e);
  }, goog.dom.safe.setOuterHtml = function(v, e) {
    v.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(e);
  }, goog.dom.safe.setFormElementAction = function(v, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), goog.dom.asserts.assertIsHTMLFormElement(v).action = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setButtonFormAction = function(v, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), goog.dom.asserts.assertIsHTMLButtonElement(v).formAction = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setInputFormAction = function(v, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), goog.dom.asserts.assertIsHTMLInputElement(v).formAction = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setStyle = function(v, e) {
    v.style.cssText = goog.html.SafeStyle.unwrap(e);
  }, goog.dom.safe.documentWrite = function(v, e) {
    v.write(goog.html.SafeHtml.unwrapTrustedHTML(e));
  }, goog.dom.safe.setAnchorHref = function(v, e) {
    goog.dom.asserts.assertIsHTMLAnchorElement(v), e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), v.href = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setImageSrc = function(v, e) {
    if (goog.dom.asserts.assertIsHTMLImageElement(v), !(e instanceof goog.html.SafeUrl)) {
      var fe = /^data:image\//i.test(e);
      e = goog.html.SafeUrl.sanitizeAssertUnchanged(e, fe);
    }
    v.src = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setAudioSrc = function(v, e) {
    if (goog.dom.asserts.assertIsHTMLAudioElement(v), !(e instanceof goog.html.SafeUrl)) {
      var fe = /^data:audio\//i.test(e);
      e = goog.html.SafeUrl.sanitizeAssertUnchanged(e, fe);
    }
    v.src = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setVideoSrc = function(v, e) {
    if (goog.dom.asserts.assertIsHTMLVideoElement(v), !(e instanceof goog.html.SafeUrl)) {
      var fe = /^data:video\//i.test(e);
      e = goog.html.SafeUrl.sanitizeAssertUnchanged(e, fe);
    }
    v.src = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setEmbedSrc = function(v, e) {
    goog.dom.asserts.assertIsHTMLEmbedElement(v), v.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e);
  }, goog.dom.safe.setFrameSrc = function(v, e) {
    goog.dom.asserts.assertIsHTMLFrameElement(v), v.src = goog.html.TrustedResourceUrl.unwrap(e);
  }, goog.dom.safe.setIframeSrc = function(v, e) {
    goog.dom.asserts.assertIsHTMLIFrameElement(v), v.src = goog.html.TrustedResourceUrl.unwrap(e);
  }, goog.dom.safe.setIframeSrcdoc = function(v, e) {
    goog.dom.asserts.assertIsHTMLIFrameElement(v), v.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(e);
  }, goog.dom.safe.setLinkHrefAndRel = function(v, e, fe) {
    goog.dom.asserts.assertIsHTMLLinkElement(v), v.rel = fe, goog.string.internal.caseInsensitiveContains(fe, "stylesheet") ? (goog.asserts.assert(e instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'), v.href = goog.html.TrustedResourceUrl.unwrap(e)) : v.href = e instanceof goog.html.TrustedResourceUrl ? goog.html.TrustedResourceUrl.unwrap(e) : e instanceof goog.html.SafeUrl ? goog.html.SafeUrl.unwrap(e) : goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitizeAssertUnchanged(e));
  }, goog.dom.safe.setObjectData = function(v, e) {
    goog.dom.asserts.assertIsHTMLObjectElement(v), v.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e);
  }, goog.dom.safe.setScriptSrc = function(v, e) {
    goog.dom.asserts.assertIsHTMLScriptElement(v), v.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e), (e = goog.getScriptNonce()) && v.setAttribute("nonce", e);
  }, goog.dom.safe.setScriptContent = function(v, e) {
    goog.dom.asserts.assertIsHTMLScriptElement(v), v.text = goog.html.SafeScript.unwrapTrustedScript(e), (e = goog.getScriptNonce()) && v.setAttribute("nonce", e);
  }, goog.dom.safe.setLocationHref = function(v, e) {
    goog.dom.asserts.assertIsLocation(v), e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), v.href = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.assignLocation = function(v, e) {
    goog.dom.asserts.assertIsLocation(v), e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), v.assign(goog.html.SafeUrl.unwrap(e));
  }, goog.dom.safe.replaceLocation = function(v, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), v.replace(goog.html.SafeUrl.unwrap(e));
  }, goog.dom.safe.openInWindow = function(v, e, fe, be, ye) {
    return v = v instanceof goog.html.SafeUrl ? v : goog.html.SafeUrl.sanitizeAssertUnchanged(v), e = e || goog.global, fe = fe instanceof goog.string.Const ? goog.string.Const.unwrap(fe) : fe || "", e.open(goog.html.SafeUrl.unwrap(v), fe, be, ye);
  }, goog.dom.safe.parseFromStringHtml = function(v, e) {
    return goog.dom.safe.parseFromString(v, e, "text/html");
  }, goog.dom.safe.parseFromString = function(v, e, fe) {
    return v.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(e), fe);
  }, goog.dom.safe.createImageFromBlob = function(v) {
    if (!/^image\/.*/g.test(v.type))
      throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");
    var e = goog.global.URL.createObjectURL(v);
    return v = new goog.global.Image(), v.onload = function() {
      goog.global.URL.revokeObjectURL(e);
    }, goog.dom.safe.setImageSrc(v, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."), e)), v;
  }, goog.string.DETECT_DOUBLE_ESCAPING = !1, goog.string.FORCE_NON_DOM_HTML_UNESCAPING = !1, goog.string.Unicode = { NBSP: "" }, goog.string.startsWith = goog.string.internal.startsWith, goog.string.endsWith = goog.string.internal.endsWith, goog.string.caseInsensitiveStartsWith = goog.string.internal.caseInsensitiveStartsWith, goog.string.caseInsensitiveEndsWith = goog.string.internal.caseInsensitiveEndsWith, goog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals, goog.string.subs = function(v, e) {
    for (var fe = v.split("%s"), be = "", ye = Array.prototype.slice.call(arguments, 1); ye.length && 1 < fe.length; )
      be += fe.shift() + ye.shift();
    return be + fe.join("%s");
  }, goog.string.collapseWhitespace = function(v) {
    return v.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
  }, goog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace, goog.string.isEmptyString = function(v) {
    return v.length == 0;
  }, goog.string.isEmpty = goog.string.isEmptyOrWhitespace, goog.string.isEmptyOrWhitespaceSafe = function(v) {
    return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(v));
  }, goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe, goog.string.isBreakingWhitespace = function(v) {
    return !/[^\t\n\r ]/.test(v);
  }, goog.string.isAlpha = function(v) {
    return !/[^a-zA-Z]/.test(v);
  }, goog.string.isNumeric = function(v) {
    return !/[^0-9]/.test(v);
  }, goog.string.isAlphaNumeric = function(v) {
    return !/[^a-zA-Z0-9]/.test(v);
  }, goog.string.isSpace = function(v) {
    return v == " ";
  }, goog.string.isUnicodeChar = function(v) {
    return v.length == 1 && " " <= v && "~" >= v || "" <= v && "" >= v;
  }, goog.string.stripNewlines = function(v) {
    return v.replace(/(\r\n|\r|\n)+/g, " ");
  }, goog.string.canonicalizeNewlines = function(v) {
    return v.replace(/(\r\n|\r|\n)/g, `
`);
  }, goog.string.normalizeWhitespace = function(v) {
    return v.replace(/\xa0|\s/g, " ");
  }, goog.string.normalizeSpaces = function(v) {
    return v.replace(/\xa0|[ \t]+/g, " ");
  }, goog.string.collapseBreakingSpaces = function(v) {
    return v.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
  }, goog.string.trim = goog.string.internal.trim, goog.string.trimLeft = function(v) {
    return v.replace(/^[\s\xa0]+/, "");
  }, goog.string.trimRight = function(v) {
    return v.replace(/[\s\xa0]+$/, "");
  }, goog.string.caseInsensitiveCompare = goog.string.internal.caseInsensitiveCompare, goog.string.numberAwareCompare_ = function(v, e, fe) {
    if (v == e)
      return 0;
    if (!v)
      return -1;
    if (!e)
      return 1;
    for (var be = v.toLowerCase().match(fe), ye = e.toLowerCase().match(fe), ve = Math.min(be.length, ye.length), Ee = 0; Ee < ve; Ee++) {
      fe = be[Ee];
      var Se = ye[Ee];
      if (fe != Se)
        return v = parseInt(fe, 10), !isNaN(v) && (e = parseInt(Se, 10), !isNaN(e) && v - e) ? v - e : fe < Se ? -1 : 1;
    }
    return be.length != ye.length ? be.length - ye.length : v < e ? -1 : 1;
  }, goog.string.intAwareCompare = function(v, e) {
    return goog.string.numberAwareCompare_(v, e, /\d+|\D+/g);
  }, goog.string.floatAwareCompare = function(v, e) {
    return goog.string.numberAwareCompare_(v, e, /\d+|\.\d+|\D+/g);
  }, goog.string.numerateCompare = goog.string.floatAwareCompare, goog.string.urlEncode = function(v) {
    return encodeURIComponent(String(v));
  }, goog.string.urlDecode = function(v) {
    return decodeURIComponent(v.replace(/\+/g, " "));
  }, goog.string.newLineToBr = goog.string.internal.newLineToBr, goog.string.htmlEscape = function(v, e) {
    return v = goog.string.internal.htmlEscape(v, e), goog.string.DETECT_DOUBLE_ESCAPING && (v = v.replace(goog.string.E_RE_, "&#101;")), v;
  }, goog.string.E_RE_ = /e/g, goog.string.unescapeEntities = function(v) {
    return goog.string.contains(v, "&") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global ? goog.string.unescapeEntitiesUsingDom_(v) : goog.string.unescapePureXmlEntities_(v) : v;
  }, goog.string.unescapeEntitiesWithDocument = function(v, e) {
    return goog.string.contains(v, "&") ? goog.string.unescapeEntitiesUsingDom_(v, e) : v;
  }, goog.string.unescapeEntitiesUsingDom_ = function(v, e) {
    var fe = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' }, be = e ? e.createElement("div") : goog.global.document.createElement("div");
    return v.replace(goog.string.HTML_ENTITY_PATTERN_, function(ye, ve) {
      var Ee = fe[ye];
      return Ee || (ve.charAt(0) == "#" && (ve = +("0" + ve.substr(1)), isNaN(ve) || (Ee = String.fromCharCode(ve))), Ee || (goog.dom.safe.setInnerHtml(be, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(
        goog.string.Const.from("Single HTML entity."),
        ye + " "
      )), Ee = be.firstChild.nodeValue.slice(0, -1)), fe[ye] = Ee);
    });
  }, goog.string.unescapePureXmlEntities_ = function(v) {
    return v.replace(/&([^;]+);/g, function(e, fe) {
      switch (fe) {
        case "amp":
          return "&";
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "quot":
          return '"';
        default:
          return fe.charAt(0) != "#" || (fe = +("0" + fe.substr(1)), isNaN(fe)) ? e : String.fromCharCode(fe);
      }
    });
  }, goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g, goog.string.whitespaceEscape = function(v, e) {
    return goog.string.newLineToBr(v.replace(/  /g, " &#160;"), e);
  }, goog.string.preserveSpaces = function(v) {
    return v.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
  }, goog.string.stripQuotes = function(v, e) {
    for (var fe = e.length, be = 0; be < fe; be++) {
      var ye = fe == 1 ? e : e.charAt(be);
      if (v.charAt(0) == ye && v.charAt(v.length - 1) == ye)
        return v.substring(1, v.length - 1);
    }
    return v;
  }, goog.string.truncate = function(v, e, fe) {
    return fe && (v = goog.string.unescapeEntities(v)), v.length > e && (v = v.substring(0, e - 3) + "..."), fe && (v = goog.string.htmlEscape(v)), v;
  }, goog.string.truncateMiddle = function(v, e, fe, be) {
    if (fe && (v = goog.string.unescapeEntities(v)), be && v.length > e) {
      be > e && (be = e);
      var ye = v.length - be;
      v = v.substring(0, e - be) + "..." + v.substring(ye);
    } else
      v.length > e && (be = Math.floor(e / 2), ye = v.length - be, v = v.substring(0, be + e % 2) + "..." + v.substring(ye));
    return fe && (v = goog.string.htmlEscape(v)), v;
  }, goog.string.specialEscapeChars_ = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" }, goog.string.jsEscapeCache_ = { "'": "\\'" }, goog.string.quote = function(v) {
    v = String(v);
    for (var e = ['"'], fe = 0; fe < v.length; fe++) {
      var be = v.charAt(fe), ye = be.charCodeAt(0);
      e[fe + 1] = goog.string.specialEscapeChars_[be] || (31 < ye && 127 > ye ? be : goog.string.escapeChar(be));
    }
    return e.push('"'), e.join("");
  }, goog.string.escapeString = function(v) {
    for (var e = [], fe = 0; fe < v.length; fe++)
      e[fe] = goog.string.escapeChar(v.charAt(fe));
    return e.join("");
  }, goog.string.escapeChar = function(v) {
    if (v in goog.string.jsEscapeCache_)
      return goog.string.jsEscapeCache_[v];
    if (v in goog.string.specialEscapeChars_)
      return goog.string.jsEscapeCache_[v] = goog.string.specialEscapeChars_[v];
    var e = v.charCodeAt(0);
    if (31 < e && 127 > e)
      var fe = v;
    else
      256 > e ? (fe = "\\x", (16 > e || 256 < e) && (fe += "0")) : (fe = "\\u", 4096 > e && (fe += "0")), fe += e.toString(16).toUpperCase();
    return goog.string.jsEscapeCache_[v] = fe;
  }, goog.string.contains = goog.string.internal.contains, goog.string.caseInsensitiveContains = goog.string.internal.caseInsensitiveContains, goog.string.countOf = function(v, e) {
    return v && e ? v.split(e).length - 1 : 0;
  }, goog.string.removeAt = function(v, e, fe) {
    var be = v;
    return 0 <= e && e < v.length && 0 < fe && (be = v.substr(0, e) + v.substr(e + fe, v.length - e - fe)), be;
  }, goog.string.remove = function(v, e) {
    return v.replace(e, "");
  }, goog.string.removeAll = function(v, e) {
    return e = new RegExp(goog.string.regExpEscape(e), "g"), v.replace(e, "");
  }, goog.string.replaceAll = function(v, e, fe) {
    return e = new RegExp(goog.string.regExpEscape(e), "g"), v.replace(e, fe.replace(/\$/g, "$$$$"));
  }, goog.string.regExpEscape = function(v) {
    return String(v).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
  }, goog.string.repeat = String.prototype.repeat ? function(v, e) {
    return v.repeat(e);
  } : function(v, e) {
    return Array(e + 1).join(v);
  }, goog.string.padNumber = function(v, e, fe) {
    return v = fe !== void 0 ? v.toFixed(fe) : String(v), fe = v.indexOf("."), fe == -1 && (fe = v.length), goog.string.repeat("0", Math.max(0, e - fe)) + v;
  }, goog.string.makeSafe = function(v) {
    return v == null ? "" : String(v);
  }, goog.string.buildString = function(v) {
    return Array.prototype.join.call(arguments, "");
  }, goog.string.getRandomString = function() {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
  }, goog.string.compareVersions = goog.string.internal.compareVersions, goog.string.hashCode = function(v) {
    for (var e = 0, fe = 0; fe < v.length; ++fe)
      e = 31 * e + v.charCodeAt(fe) >>> 0;
    return e;
  }, goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0, goog.string.createUniqueString = function() {
    return "goog_" + goog.string.uniqueStringCounter_++;
  }, goog.string.toNumber = function(v) {
    var e = Number(v);
    return e == 0 && goog.string.isEmptyOrWhitespace(v) ? NaN : e;
  }, goog.string.isLowerCamelCase = function(v) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(v);
  }, goog.string.isUpperCamelCase = function(v) {
    return /^([A-Z][a-z]*)+$/.test(v);
  }, goog.string.toCamelCase = function(v) {
    return String(v).replace(/\-([a-z])/g, function(e, fe) {
      return fe.toUpperCase();
    });
  }, goog.string.toSelectorCase = function(v) {
    return String(v).replace(/([A-Z])/g, "-$1").toLowerCase();
  }, goog.string.toTitleCase = function(v, e) {
    return e = typeof e == "string" ? goog.string.regExpEscape(e) : "\\s", v.replace(new RegExp("(^" + (e ? "|[" + e + "]+" : "") + ")([a-z])", "g"), function(fe, be, ye) {
      return be + ye.toUpperCase();
    });
  }, goog.string.capitalize = function(v) {
    return String(v.charAt(0)).toUpperCase() + String(v.substr(1)).toLowerCase();
  }, goog.string.parseInt = function(v) {
    return isFinite(v) && (v = String(v)), typeof v == "string" ? /^\s*-?0x/i.test(v) ? parseInt(v, 16) : parseInt(v, 10) : NaN;
  }, goog.string.splitLimit = function(v, e, fe) {
    v = v.split(e);
    for (var be = []; 0 < fe && v.length; )
      be.push(v.shift()), fe--;
    return v.length && be.push(v.join(e)), be;
  }, goog.string.lastComponent = function(v, e) {
    if (e)
      typeof e == "string" && (e = [e]);
    else
      return v;
    for (var fe = -1, be = 0; be < e.length; be++)
      if (e[be] != "") {
        var ye = v.lastIndexOf(e[be]);
        ye > fe && (fe = ye);
      }
    return fe == -1 ? v : v.slice(fe + 1);
  }, goog.string.editDistance = function(v, e) {
    var fe = [], be = [];
    if (v == e)
      return 0;
    if (!v.length || !e.length)
      return Math.max(v.length, e.length);
    for (var ye = 0; ye < e.length + 1; ye++)
      fe[ye] = ye;
    for (ye = 0; ye < v.length; ye++) {
      be[0] = ye + 1;
      for (var ve = 0; ve < e.length; ve++)
        be[ve + 1] = Math.min(be[ve] + 1, fe[ve + 1] + 1, fe[ve] + +(v[ye] != e[ve]));
      for (ve = 0; ve < fe.length; ve++)
        fe[ve] = be[ve];
    }
    return be[e.length];
  }, goog.labs.userAgent.engine = {}, goog.labs.userAgent.engine.isPresto = function() {
    return goog.labs.userAgent.util.matchUserAgent("Presto");
  }, goog.labs.userAgent.engine.isTrident = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
  }, goog.labs.userAgent.engine.isEdge = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge");
  }, goog.labs.userAgent.engine.isWebKit = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge();
  }, goog.labs.userAgent.engine.isGecko = function() {
    return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge();
  }, goog.labs.userAgent.engine.getVersion = function() {
    var v = goog.labs.userAgent.util.getUserAgent();
    if (v) {
      v = goog.labs.userAgent.util.extractVersionTuples(v);
      var e = goog.labs.userAgent.engine.getEngineTuple_(v);
      if (e)
        return e[0] == "Gecko" ? goog.labs.userAgent.engine.getVersionForKey_(v, "Firefox") : e[1];
      v = v[0];
      var fe;
      if (v && (fe = v[2]) && (fe = /Trident\/([^\s;]+)/.exec(fe)))
        return fe[1];
    }
    return "";
  }, goog.labs.userAgent.engine.getEngineTuple_ = function(v) {
    if (!goog.labs.userAgent.engine.isEdge())
      return v[1];
    for (var e = 0; e < v.length; e++) {
      var fe = v[e];
      if (fe[0] == "Edge")
        return fe;
    }
  }, goog.labs.userAgent.engine.isVersionOrHigher = function(v) {
    return 0 <= goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), v);
  }, goog.labs.userAgent.engine.getVersionForKey_ = function(v, e) {
    return (v = goog.array.find(v, function(fe) {
      return e == fe[0];
    })) && v[1] || "";
  }, goog.labs.userAgent.platform = {}, goog.labs.userAgent.platform.isAndroid = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android");
  }, goog.labs.userAgent.platform.isIpod = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPod");
  }, goog.labs.userAgent.platform.isIphone = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad");
  }, goog.labs.userAgent.platform.isIpad = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPad");
  }, goog.labs.userAgent.platform.isIos = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod();
  }, goog.labs.userAgent.platform.isMacintosh = function() {
    return goog.labs.userAgent.util.matchUserAgent("Macintosh");
  }, goog.labs.userAgent.platform.isLinux = function() {
    return goog.labs.userAgent.util.matchUserAgent("Linux");
  }, goog.labs.userAgent.platform.isWindows = function() {
    return goog.labs.userAgent.util.matchUserAgent("Windows");
  }, goog.labs.userAgent.platform.isChromeOS = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrOS");
  }, goog.labs.userAgent.platform.isChromecast = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrKey");
  }, goog.labs.userAgent.platform.isKaiOS = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS");
  }, goog.labs.userAgent.platform.getVersion = function() {
    var v = goog.labs.userAgent.util.getUserAgent(), e = "";
    return goog.labs.userAgent.platform.isWindows() ? (e = /Windows (?:NT|Phone) ([0-9.]+)/, e = (v = e.exec(v)) ? v[1] : "0.0") : goog.labs.userAgent.platform.isIos() ? (e = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/, e = (v = e.exec(v)) && v[1].replace(/_/g, ".")) : goog.labs.userAgent.platform.isMacintosh() ? (e = /Mac OS X ([0-9_.]+)/, e = (v = e.exec(v)) ? v[1].replace(/_/g, ".") : "10") : goog.labs.userAgent.platform.isKaiOS() ? (e = /(?:KaiOS)\/(\S+)/i, e = (v = e.exec(v)) && v[1]) : goog.labs.userAgent.platform.isAndroid() ? (e = /Android\s+([^\);]+)(\)|;)/, e = (v = e.exec(v)) && v[1]) : goog.labs.userAgent.platform.isChromeOS() && (e = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/, e = (v = e.exec(v)) && v[1]), e || "";
  }, goog.labs.userAgent.platform.isVersionOrHigher = function(v) {
    return 0 <= goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), v);
  }, goog.reflect = {}, goog.reflect.object = function(v, e) {
    return e;
  }, goog.reflect.objectProperty = function(v, e) {
    return v;
  }, goog.reflect.sinkValue = function(v) {
    return goog.reflect.sinkValue[" "](v), v;
  }, goog.reflect.sinkValue[" "] = goog.nullFunction, goog.reflect.canAccessProperty = function(v, e) {
    try {
      return goog.reflect.sinkValue(v[e]), !0;
    } catch {
    }
    return !1;
  }, goog.reflect.cache = function(v, e, fe, be) {
    return be = be ? be(e) : e, Object.prototype.hasOwnProperty.call(v, be) ? v[be] : v[be] = fe(e);
  }, goog.userAgent = {}, goog.userAgent.ASSUME_IE = !1, goog.userAgent.ASSUME_EDGE = !1, goog.userAgent.ASSUME_GECKO = !1, goog.userAgent.ASSUME_WEBKIT = !1, goog.userAgent.ASSUME_MOBILE_WEBKIT = !1, goog.userAgent.ASSUME_OPERA = !1, goog.userAgent.ASSUME_ANY_VERSION = !1, goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA, goog.userAgent.getUserAgentString = function() {
    return goog.labs.userAgent.util.getUserAgent();
  }, goog.userAgent.getNavigatorTyped = function() {
    return goog.global.navigator || null;
  }, goog.userAgent.getNavigator = function() {
    return goog.userAgent.getNavigatorTyped();
  }, goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera(), goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE(), goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge(), goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE, goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko(), goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit(), goog.userAgent.isMobile_ = function() {
    return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile");
  }, goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_(), goog.userAgent.SAFARI = goog.userAgent.WEBKIT, goog.userAgent.determinePlatform_ = function() {
    var v = goog.userAgent.getNavigatorTyped();
    return v && v.platform || "";
  }, goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_(), goog.userAgent.ASSUME_MAC = !1, goog.userAgent.ASSUME_WINDOWS = !1, goog.userAgent.ASSUME_LINUX = !1, goog.userAgent.ASSUME_X11 = !1, goog.userAgent.ASSUME_ANDROID = !1, goog.userAgent.ASSUME_IPHONE = !1, goog.userAgent.ASSUME_IPAD = !1, goog.userAgent.ASSUME_IPOD = !1, goog.userAgent.ASSUME_KAIOS = !1, goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD, goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh(), goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows(), goog.userAgent.isLegacyLinux_ = function() {
    return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS();
  }, goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_(), goog.userAgent.isX11_ = function() {
    var v = goog.userAgent.getNavigatorTyped();
    return !!v && goog.string.contains(v.appVersion || "", "X11");
  }, goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_(), goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid(), goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone(), goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIpod(), goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIos(), goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_KAIOS : goog.labs.userAgent.platform.isKaiOS(), goog.userAgent.determineVersion_ = function() {
    var v = "", e = goog.userAgent.getVersionRegexResult_();
    return e && (v = e ? e[1] : ""), goog.userAgent.IE && (e = goog.userAgent.getDocumentMode_(), e != null && e > parseFloat(v)) ? String(e) : v;
  }, goog.userAgent.getVersionRegexResult_ = function() {
    var v = goog.userAgent.getUserAgentString();
    if (goog.userAgent.GECKO)
      return /rv:([^\);]+)(\)|;)/.exec(v);
    if (goog.userAgent.EDGE)
      return /Edge\/([\d\.]+)/.exec(v);
    if (goog.userAgent.IE)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(v);
    if (goog.userAgent.WEBKIT)
      return /WebKit\/(\S+)/.exec(v);
    if (goog.userAgent.OPERA)
      return /(?:Version)[ \/]?(\S+)/.exec(v);
  }, goog.userAgent.getDocumentMode_ = function() {
    var v = goog.global.document;
    return v ? v.documentMode : void 0;
  }, goog.userAgent.VERSION = goog.userAgent.determineVersion_(), goog.userAgent.compare = function(v, e) {
    return goog.string.compareVersions(v, e);
  }, goog.userAgent.isVersionOrHigherCache_ = {}, goog.userAgent.isVersionOrHigher = function(v) {
    return goog.userAgent.ASSUME_ANY_VERSION || goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, v, function() {
      return 0 <= goog.string.compareVersions(goog.userAgent.VERSION, v);
    });
  }, goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher, goog.userAgent.isDocumentModeOrHigher = function(v) {
    return Number(goog.userAgent.DOCUMENT_MODE) >= v;
  }, goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher, goog.userAgent.DOCUMENT_MODE = function() {
    if (goog.global.document && goog.userAgent.IE) {
      var v = goog.userAgent.getDocumentMode_();
      return v || parseInt(goog.userAgent.VERSION, 10) || void 0;
    }
  }(), goog.userAgent.product = {}, goog.userAgent.product.ASSUME_FIREFOX = !1, goog.userAgent.product.ASSUME_IPHONE = !1, goog.userAgent.product.ASSUME_IPAD = !1, goog.userAgent.product.ASSUME_ANDROID = !1, goog.userAgent.product.ASSUME_CHROME = !1, goog.userAgent.product.ASSUME_SAFARI = !1, goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI, goog.userAgent.product.OPERA = goog.userAgent.OPERA, goog.userAgent.product.IE = goog.userAgent.IE, goog.userAgent.product.EDGE = goog.userAgent.EDGE, goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.labs.userAgent.browser.isFirefox(), goog.userAgent.product.isIphoneOrIpod_ = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpod();
  }, goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.isIphoneOrIpod_(), goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.labs.userAgent.browser.isAndroidBrowser(), goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.labs.userAgent.browser.isChrome(), goog.userAgent.product.isSafariDesktop_ = function() {
    return goog.labs.userAgent.browser.isSafari() && !goog.labs.userAgent.platform.isIos();
  }, goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.isSafariDesktop_(), goog.crypt.base64 = {}, goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "+/=", goog.crypt.base64.ENCODED_VALS_WEBSAFE = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "-_.", goog.crypt.base64.Alphabet = { DEFAULT: 0, NO_PADDING: 1, WEBSAFE: 2, WEBSAFE_DOT_PADDING: 3, WEBSAFE_NO_PADDING: 4 }, goog.crypt.base64.paddingChars_ = "=.", goog.crypt.base64.isPadding_ = function(v) {
    return goog.string.contains(goog.crypt.base64.paddingChars_, v);
  }, goog.crypt.base64.byteToCharMaps_ = {}, goog.crypt.base64.charToByteMap_ = null, goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO || goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI || goog.userAgent.OPERA, goog.crypt.base64.HAS_NATIVE_ENCODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || typeof goog.global.btoa == "function", goog.crypt.base64.HAS_NATIVE_DECODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || !goog.userAgent.product.SAFARI && !goog.userAgent.IE && typeof goog.global.atob == "function", goog.crypt.base64.encodeByteArray = function(v, e) {
    goog.asserts.assert(goog.isArrayLike(v), "encodeByteArray takes an array as a parameter"), e === void 0 && (e = goog.crypt.base64.Alphabet.DEFAULT), goog.crypt.base64.init_(), e = goog.crypt.base64.byteToCharMaps_[e];
    for (var fe = [], be = 0; be < v.length; be += 3) {
      var ye = v[be], ve = be + 1 < v.length, Ee = ve ? v[be + 1] : 0, Se = be + 2 < v.length, Oe = Se ? v[be + 2] : 0, xe = ye >> 2;
      ye = (ye & 3) << 4 | Ee >> 4, Ee = (Ee & 15) << 2 | Oe >> 6, Oe &= 63, Se || (Oe = 64, ve || (Ee = 64)), fe.push(e[xe], e[ye], e[Ee] || "", e[Oe] || "");
    }
    return fe.join("");
  }, goog.crypt.base64.encodeString = function(v, e) {
    return goog.crypt.base64.HAS_NATIVE_ENCODE_ && !e ? goog.global.btoa(v) : goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(v), e);
  }, goog.crypt.base64.decodeString = function(v, e) {
    if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !e)
      return goog.global.atob(v);
    var fe = "";
    return goog.crypt.base64.decodeStringInternal_(v, function(be) {
      fe += String.fromCharCode(be);
    }), fe;
  }, goog.crypt.base64.decodeStringToByteArray = function(v, e) {
    var fe = [];
    return goog.crypt.base64.decodeStringInternal_(v, function(be) {
      fe.push(be);
    }), fe;
  }, goog.crypt.base64.decodeStringToUint8Array = function(v) {
    goog.asserts.assert(!goog.userAgent.IE || goog.userAgent.isVersionOrHigher("10"), "Browser does not support typed arrays");
    var e = v.length, fe = 3 * e / 4;
    fe % 3 ? fe = Math.floor(fe) : goog.crypt.base64.isPadding_(v[e - 1]) && (fe = goog.crypt.base64.isPadding_(v[e - 2]) ? fe - 2 : fe - 1);
    var be = new Uint8Array(fe), ye = 0;
    return goog.crypt.base64.decodeStringInternal_(v, function(ve) {
      be[ye++] = ve;
    }), be.subarray(0, ye);
  }, goog.crypt.base64.decodeStringInternal_ = function(v, e) {
    function fe(Oe) {
      for (; be < v.length; ) {
        var xe = v.charAt(be++), me = goog.crypt.base64.charToByteMap_[xe];
        if (me != null)
          return me;
        if (!goog.string.isEmptyOrWhitespace(xe))
          throw Error("Unknown base64 encoding at char: " + xe);
      }
      return Oe;
    }
    goog.crypt.base64.init_();
    for (var be = 0; ; ) {
      var ye = fe(-1), ve = fe(0), Ee = fe(64), Se = fe(64);
      if (Se === 64 && ye === -1)
        break;
      e(ye << 2 | ve >> 4), Ee != 64 && (e(ve << 4 & 240 | Ee >> 2), Se != 64 && e(Ee << 6 & 192 | Se));
    }
  }, goog.crypt.base64.init_ = function() {
    if (!goog.crypt.base64.charToByteMap_) {
      goog.crypt.base64.charToByteMap_ = {};
      for (var v = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""), e = ["+/=", "+/", "-_=", "-_.", "-_"], fe = 0; 5 > fe; fe++) {
        var be = v.concat(e[fe].split(""));
        goog.crypt.base64.byteToCharMaps_[fe] = be;
        for (var ye = 0; ye < be.length; ye++) {
          var ve = be[ye], Ee = goog.crypt.base64.charToByteMap_[ve];
          Ee === void 0 ? goog.crypt.base64.charToByteMap_[ve] = ye : goog.asserts.assert(Ee === ye);
        }
      }
    }
  }, jspb.utils = {}, jspb.utils.split64Low = 0, jspb.utils.split64High = 0, jspb.utils.splitUint64 = function(v) {
    var e = v >>> 0;
    v = Math.floor((v - e) / jspb.BinaryConstants.TWO_TO_32) >>> 0, jspb.utils.split64Low = e, jspb.utils.split64High = v;
  }, jspb.utils.splitInt64 = function(v) {
    var e = 0 > v;
    v = Math.abs(v);
    var fe = v >>> 0;
    v = Math.floor((v - fe) / jspb.BinaryConstants.TWO_TO_32), v >>>= 0, e && (v = ~v >>> 0, fe = (~fe >>> 0) + 1, 4294967295 < fe && (fe = 0, v++, 4294967295 < v && (v = 0))), jspb.utils.split64Low = fe, jspb.utils.split64High = v;
  }, jspb.utils.splitZigzag64 = function(v) {
    var e = 0 > v;
    v = 2 * Math.abs(v), jspb.utils.splitUint64(v), v = jspb.utils.split64Low;
    var fe = jspb.utils.split64High;
    e && (v == 0 ? fe == 0 ? fe = v = 4294967295 : (fe--, v = 4294967295) : v--), jspb.utils.split64Low = v, jspb.utils.split64High = fe;
  }, jspb.utils.splitFloat32 = function(v) {
    var e = 0 > v ? 1 : 0;
    if (v = e ? -v : v, v === 0)
      0 < 1 / v ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 0) : (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483648);
    else if (isNaN(v))
      jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483647;
    else if (v > jspb.BinaryConstants.FLOAT32_MAX)
      jspb.utils.split64High = 0, jspb.utils.split64Low = (e << 31 | 2139095040) >>> 0;
    else if (v < jspb.BinaryConstants.FLOAT32_MIN)
      v = Math.round(v / Math.pow(2, -149)), jspb.utils.split64High = 0, jspb.utils.split64Low = (e << 31 | v) >>> 0;
    else {
      var fe = Math.floor(Math.log(v) / Math.LN2);
      v *= Math.pow(2, -fe), v = Math.round(v * jspb.BinaryConstants.TWO_TO_23), 16777216 <= v && ++fe, jspb.utils.split64High = 0, jspb.utils.split64Low = (e << 31 | fe + 127 << 23 | v & 8388607) >>> 0;
    }
  }, jspb.utils.splitFloat64 = function(v) {
    var e = 0 > v ? 1 : 0;
    if (v = e ? -v : v, v === 0)
      jspb.utils.split64High = 0 < 1 / v ? 0 : 2147483648, jspb.utils.split64Low = 0;
    else if (isNaN(v))
      jspb.utils.split64High = 2147483647, jspb.utils.split64Low = 4294967295;
    else if (v > jspb.BinaryConstants.FLOAT64_MAX)
      jspb.utils.split64High = (e << 31 | 2146435072) >>> 0, jspb.utils.split64Low = 0;
    else if (v < jspb.BinaryConstants.FLOAT64_MIN) {
      var fe = v / Math.pow(2, -1074);
      v = fe / jspb.BinaryConstants.TWO_TO_32, jspb.utils.split64High = (e << 31 | v) >>> 0, jspb.utils.split64Low = fe >>> 0;
    } else {
      fe = v;
      var be = 0;
      if (2 <= fe)
        for (; 2 <= fe && 1023 > be; )
          be++, fe /= 2;
      else
        for (; 1 > fe && -1022 < be; )
          fe *= 2, be--;
      fe = v * Math.pow(2, -be), v = fe * jspb.BinaryConstants.TWO_TO_20 & 1048575, fe = fe * jspb.BinaryConstants.TWO_TO_52 >>> 0, jspb.utils.split64High = (e << 31 | be + 1023 << 20 | v) >>> 0, jspb.utils.split64Low = fe;
    }
  }, jspb.utils.splitHash64 = function(v) {
    var e = v.charCodeAt(0), fe = v.charCodeAt(1), be = v.charCodeAt(2), ye = v.charCodeAt(3), ve = v.charCodeAt(4), Ee = v.charCodeAt(5), Se = v.charCodeAt(6);
    v = v.charCodeAt(7), jspb.utils.split64Low = e + (fe << 8) + (be << 16) + (ye << 24) >>> 0, jspb.utils.split64High = ve + (Ee << 8) + (Se << 16) + (v << 24) >>> 0;
  }, jspb.utils.joinUint64 = function(v, e) {
    return e * jspb.BinaryConstants.TWO_TO_32 + (v >>> 0);
  }, jspb.utils.joinInt64 = function(v, e) {
    var fe = e & 2147483648;
    return fe && (v = ~v + 1 >>> 0, e = ~e >>> 0, v == 0 && (e = e + 1 >>> 0)), v = jspb.utils.joinUint64(v, e), fe ? -v : v;
  }, jspb.utils.toZigzag64 = function(v, e, fe) {
    var be = e >> 31;
    return fe(v << 1 ^ be, (e << 1 | v >>> 31) ^ be);
  }, jspb.utils.joinZigzag64 = function(v, e) {
    return jspb.utils.fromZigzag64(v, e, jspb.utils.joinInt64);
  }, jspb.utils.fromZigzag64 = function(v, e, fe) {
    var be = -(v & 1);
    return fe((v >>> 1 | e << 31) ^ be, e >>> 1 ^ be);
  }, jspb.utils.joinFloat32 = function(v, e) {
    e = 2 * (v >> 31) + 1;
    var fe = v >>> 23 & 255;
    return v &= 8388607, fe == 255 ? v ? NaN : 1 / 0 * e : fe == 0 ? e * Math.pow(2, -149) * v : e * Math.pow(2, fe - 150) * (v + Math.pow(2, 23));
  }, jspb.utils.joinFloat64 = function(v, e) {
    var fe = 2 * (e >> 31) + 1, be = e >>> 20 & 2047;
    return v = jspb.BinaryConstants.TWO_TO_32 * (e & 1048575) + v, be == 2047 ? v ? NaN : 1 / 0 * fe : be == 0 ? fe * Math.pow(2, -1074) * v : fe * Math.pow(2, be - 1075) * (v + jspb.BinaryConstants.TWO_TO_52);
  }, jspb.utils.joinHash64 = function(v, e) {
    return String.fromCharCode(v >>> 0 & 255, v >>> 8 & 255, v >>> 16 & 255, v >>> 24 & 255, e >>> 0 & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255);
  }, jspb.utils.DIGITS = "0123456789abcdef".split(""), jspb.utils.ZERO_CHAR_CODE_ = 48, jspb.utils.A_CHAR_CODE_ = 97, jspb.utils.joinUnsignedDecimalString = function(v, e) {
    function fe(ye, ve) {
      return ye = ye ? String(ye) : "", ve ? "0000000".slice(ye.length) + ye : ye;
    }
    if (2097151 >= e)
      return "" + jspb.utils.joinUint64(v, e);
    var be = (v >>> 24 | e << 8) >>> 0 & 16777215;
    return e = e >> 16 & 65535, v = (v & 16777215) + 6777216 * be + 6710656 * e, be += 8147497 * e, e *= 2, 1e7 <= v && (be += Math.floor(v / 1e7), v %= 1e7), 1e7 <= be && (e += Math.floor(be / 1e7), be %= 1e7), fe(e, 0) + fe(be, e) + fe(v, 1);
  }, jspb.utils.joinSignedDecimalString = function(v, e) {
    var fe = e & 2147483648;
    return fe && (v = ~v + 1 >>> 0, e = ~e + (v == 0 ? 1 : 0) >>> 0), v = jspb.utils.joinUnsignedDecimalString(v, e), fe ? "-" + v : v;
  }, jspb.utils.hash64ToDecimalString = function(v, e) {
    jspb.utils.splitHash64(v), v = jspb.utils.split64Low;
    var fe = jspb.utils.split64High;
    return e ? jspb.utils.joinSignedDecimalString(v, fe) : jspb.utils.joinUnsignedDecimalString(v, fe);
  }, jspb.utils.hash64ArrayToDecimalStrings = function(v, e) {
    for (var fe = Array(v.length), be = 0; be < v.length; be++)
      fe[be] = jspb.utils.hash64ToDecimalString(v[be], e);
    return fe;
  }, jspb.utils.decimalStringToHash64 = function(v) {
    function e(Ee, Se) {
      for (var Oe = 0; 8 > Oe && (Ee !== 1 || 0 < Se); Oe++)
        Se = Ee * ye[Oe] + Se, ye[Oe] = Se & 255, Se >>>= 8;
    }
    function fe() {
      for (var Ee = 0; 8 > Ee; Ee++)
        ye[Ee] = ~ye[Ee] & 255;
    }
    jspb.asserts.assert(0 < v.length);
    var be = !1;
    v[0] === "-" && (be = !0, v = v.slice(1));
    for (var ye = [0, 0, 0, 0, 0, 0, 0, 0], ve = 0; ve < v.length; ve++)
      e(10, v.charCodeAt(ve) - jspb.utils.ZERO_CHAR_CODE_);
    return be && (fe(), e(1, 1)), goog.crypt.byteArrayToString(ye);
  }, jspb.utils.splitDecimalString = function(v) {
    jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(v));
  }, jspb.utils.toHexDigit_ = function(v) {
    return String.fromCharCode(10 > v ? jspb.utils.ZERO_CHAR_CODE_ + v : jspb.utils.A_CHAR_CODE_ - 10 + v);
  }, jspb.utils.fromHexCharCode_ = function(v) {
    return v >= jspb.utils.A_CHAR_CODE_ ? v - jspb.utils.A_CHAR_CODE_ + 10 : v - jspb.utils.ZERO_CHAR_CODE_;
  }, jspb.utils.hash64ToHexString = function(v) {
    var e = Array(18);
    e[0] = "0", e[1] = "x";
    for (var fe = 0; 8 > fe; fe++) {
      var be = v.charCodeAt(7 - fe);
      e[2 * fe + 2] = jspb.utils.toHexDigit_(be >> 4), e[2 * fe + 3] = jspb.utils.toHexDigit_(be & 15);
    }
    return e.join("");
  }, jspb.utils.hexStringToHash64 = function(v) {
    v = v.toLowerCase(), jspb.asserts.assert(v.length == 18), jspb.asserts.assert(v[0] == "0"), jspb.asserts.assert(v[1] == "x");
    for (var e = "", fe = 0; 8 > fe; fe++) {
      var be = jspb.utils.fromHexCharCode_(v.charCodeAt(2 * fe + 2)), ye = jspb.utils.fromHexCharCode_(v.charCodeAt(2 * fe + 3));
      e = String.fromCharCode(16 * be + ye) + e;
    }
    return e;
  }, jspb.utils.hash64ToNumber = function(v, e) {
    jspb.utils.splitHash64(v), v = jspb.utils.split64Low;
    var fe = jspb.utils.split64High;
    return e ? jspb.utils.joinInt64(v, fe) : jspb.utils.joinUint64(v, fe);
  }, jspb.utils.numberToHash64 = function(v) {
    return jspb.utils.splitInt64(v), jspb.utils.joinHash64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.utils.countVarints = function(v, e, fe) {
    for (var be = 0, ye = e; ye < fe; ye++)
      be += v[ye] >> 7;
    return fe - e - be;
  }, jspb.utils.countVarintFields = function(v, e, fe, be) {
    var ye = 0;
    if (be = 8 * be + jspb.BinaryConstants.WireType.VARINT, 128 > be)
      for (; e < fe && v[e++] == be; )
        for (ye++; ; ) {
          var ve = v[e++];
          if (!(ve & 128))
            break;
        }
    else
      for (; e < fe; ) {
        for (ve = be; 128 < ve; ) {
          if (v[e] != (ve & 127 | 128))
            return ye;
          e++, ve >>= 7;
        }
        if (v[e++] != ve)
          break;
        for (ye++; ve = v[e++], (ve & 128) != 0; )
          ;
      }
    return ye;
  }, jspb.utils.countFixedFields_ = function(v, e, fe, be, ye) {
    var ve = 0;
    if (128 > be)
      for (; e < fe && v[e++] == be; )
        ve++, e += ye;
    else
      for (; e < fe; ) {
        for (var Ee = be; 128 < Ee; ) {
          if (v[e++] != (Ee & 127 | 128))
            return ve;
          Ee >>= 7;
        }
        if (v[e++] != Ee)
          break;
        ve++, e += ye;
      }
    return ve;
  }, jspb.utils.countFixed32Fields = function(v, e, fe, be) {
    return jspb.utils.countFixedFields_(v, e, fe, 8 * be + jspb.BinaryConstants.WireType.FIXED32, 4);
  }, jspb.utils.countFixed64Fields = function(v, e, fe, be) {
    return jspb.utils.countFixedFields_(v, e, fe, 8 * be + jspb.BinaryConstants.WireType.FIXED64, 8);
  }, jspb.utils.countDelimitedFields = function(v, e, fe, be) {
    var ye = 0;
    for (be = 8 * be + jspb.BinaryConstants.WireType.DELIMITED; e < fe; ) {
      for (var ve = be; 128 < ve; ) {
        if (v[e++] != (ve & 127 | 128))
          return ye;
        ve >>= 7;
      }
      if (v[e++] != ve)
        break;
      ye++;
      for (var Ee = 0, Se = 1; ve = v[e++], Ee += (ve & 127) * Se, Se *= 128, (ve & 128) != 0; )
        ;
      e += Ee;
    }
    return ye;
  }, jspb.utils.debugBytesToTextFormat = function(v) {
    var e = '"';
    if (v) {
      v = jspb.utils.byteSourceToUint8Array(v);
      for (var fe = 0; fe < v.length; fe++)
        e += "\\x", 16 > v[fe] && (e += "0"), e += v[fe].toString(16);
    }
    return e + '"';
  }, jspb.utils.debugScalarToTextFormat = function(v) {
    return typeof v == "string" ? goog.string.quote(v) : v.toString();
  }, jspb.utils.stringToByteArray = function(v) {
    for (var e = new Uint8Array(v.length), fe = 0; fe < v.length; fe++) {
      var be = v.charCodeAt(fe);
      if (255 < be)
        throw Error("Conversion error: string contains codepoint outside of byte range");
      e[fe] = be;
    }
    return e;
  }, jspb.utils.byteSourceToUint8Array = function(v) {
    return v.constructor === Uint8Array ? v : v.constructor === ArrayBuffer || v.constructor === Array ? new Uint8Array(v) : v.constructor === String ? goog.crypt.base64.decodeStringToUint8Array(v) : v instanceof Uint8Array ? new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : (jspb.asserts.fail("Type not convertible to Uint8Array."), new Uint8Array(0));
  }, jspb.BinaryDecoder = function(v, e, fe) {
    this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = !1, v && this.setBlock(v, e, fe);
  }, jspb.BinaryDecoder.instanceCache_ = [], jspb.BinaryDecoder.alloc = function(v, e, fe) {
    if (jspb.BinaryDecoder.instanceCache_.length) {
      var be = jspb.BinaryDecoder.instanceCache_.pop();
      return v && be.setBlock(v, e, fe), be;
    }
    return new jspb.BinaryDecoder(v, e, fe);
  }, jspb.BinaryDecoder.prototype.free = function() {
    this.clear(), 100 > jspb.BinaryDecoder.instanceCache_.length && jspb.BinaryDecoder.instanceCache_.push(this);
  }, jspb.BinaryDecoder.prototype.clone = function() {
    return jspb.BinaryDecoder.alloc(this.bytes_, this.start_, this.end_ - this.start_);
  }, jspb.BinaryDecoder.prototype.clear = function() {
    this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = !1;
  }, jspb.BinaryDecoder.prototype.getBuffer = function() {
    return this.bytes_;
  }, jspb.BinaryDecoder.prototype.setBlock = function(v, e, fe) {
    this.bytes_ = jspb.utils.byteSourceToUint8Array(v), this.start_ = e !== void 0 ? e : 0, this.end_ = fe !== void 0 ? this.start_ + fe : this.bytes_.length, this.cursor_ = this.start_;
  }, jspb.BinaryDecoder.prototype.getEnd = function() {
    return this.end_;
  }, jspb.BinaryDecoder.prototype.setEnd = function(v) {
    this.end_ = v;
  }, jspb.BinaryDecoder.prototype.reset = function() {
    this.cursor_ = this.start_;
  }, jspb.BinaryDecoder.prototype.getCursor = function() {
    return this.cursor_;
  }, jspb.BinaryDecoder.prototype.setCursor = function(v) {
    this.cursor_ = v;
  }, jspb.BinaryDecoder.prototype.advance = function(v) {
    this.cursor_ += v, jspb.asserts.assert(this.cursor_ <= this.end_);
  }, jspb.BinaryDecoder.prototype.atEnd = function() {
    return this.cursor_ == this.end_;
  }, jspb.BinaryDecoder.prototype.pastEnd = function() {
    return this.cursor_ > this.end_;
  }, jspb.BinaryDecoder.prototype.getError = function() {
    return this.error_ || 0 > this.cursor_ || this.cursor_ > this.end_;
  }, jspb.BinaryDecoder.prototype.readSplitVarint64 = function(v) {
    for (var e = 128, fe = 0, be = 0, ye = 0; 4 > ye && 128 <= e; ye++)
      e = this.bytes_[this.cursor_++], fe |= (e & 127) << 7 * ye;
    if (128 <= e && (e = this.bytes_[this.cursor_++], fe |= (e & 127) << 28, be |= (e & 127) >> 4), 128 <= e)
      for (ye = 0; 5 > ye && 128 <= e; ye++)
        e = this.bytes_[this.cursor_++], be |= (e & 127) << 7 * ye + 3;
    if (128 > e)
      return v(fe >>> 0, be >>> 0);
    jspb.asserts.fail("Failed to read varint, encoding is invalid."), this.error_ = !0;
  }, jspb.BinaryDecoder.prototype.readSplitZigzagVarint64 = function(v) {
    return this.readSplitVarint64(function(e, fe) {
      return jspb.utils.fromZigzag64(e, fe, v);
    });
  }, jspb.BinaryDecoder.prototype.readSplitFixed64 = function(v) {
    var e = this.bytes_, fe = this.cursor_;
    this.cursor_ += 8;
    for (var be = 0, ye = 0, ve = fe + 7; ve >= fe; ve--)
      be = be << 8 | e[ve], ye = ye << 8 | e[ve + 4];
    return v(be, ye);
  }, jspb.BinaryDecoder.prototype.skipVarint = function() {
    for (; this.bytes_[this.cursor_] & 128; )
      this.cursor_++;
    this.cursor_++;
  }, jspb.BinaryDecoder.prototype.unskipVarint = function(v) {
    for (; 128 < v; )
      this.cursor_--, v >>>= 7;
    this.cursor_--;
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function() {
    var v = this.bytes_, e = v[this.cursor_ + 0], fe = e & 127;
    return 128 > e ? (this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), fe) : (e = v[this.cursor_ + 1], fe |= (e & 127) << 7, 128 > e ? (this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), fe) : (e = v[this.cursor_ + 2], fe |= (e & 127) << 14, 128 > e ? (this.cursor_ += 3, jspb.asserts.assert(this.cursor_ <= this.end_), fe) : (e = v[this.cursor_ + 3], fe |= (e & 127) << 21, 128 > e ? (this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), fe) : (e = v[this.cursor_ + 4], fe |= (e & 15) << 28, 128 > e ? (this.cursor_ += 5, jspb.asserts.assert(this.cursor_ <= this.end_), fe >>> 0) : (this.cursor_ += 5, 128 <= v[this.cursor_++] && 128 <= v[this.cursor_++] && 128 <= v[this.cursor_++] && 128 <= v[this.cursor_++] && 128 <= v[this.cursor_++] && jspb.asserts.assert(!1), jspb.asserts.assert(this.cursor_ <= this.end_), fe)))));
  }, jspb.BinaryDecoder.prototype.readSignedVarint32 = function() {
    return ~~this.readUnsignedVarint32();
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function() {
    return this.readUnsignedVarint32().toString();
  }, jspb.BinaryDecoder.prototype.readSignedVarint32String = function() {
    return this.readSignedVarint32().toString();
  }, jspb.BinaryDecoder.prototype.readZigzagVarint32 = function() {
    var v = this.readUnsignedVarint32();
    return v >>> 1 ^ -(v & 1);
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinUint64);
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function() {
    return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readSignedVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinInt64);
  }, jspb.BinaryDecoder.prototype.readSignedVarint64String = function() {
    return this.readSplitVarint64(jspb.utils.joinSignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readZigzagVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinZigzag64);
  }, jspb.BinaryDecoder.prototype.readZigzagVarintHash64 = function() {
    return this.readSplitZigzagVarint64(jspb.utils.joinHash64);
  }, jspb.BinaryDecoder.prototype.readZigzagVarint64String = function() {
    return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readUint8 = function() {
    var v = this.bytes_[this.cursor_ + 0];
    return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), v;
  }, jspb.BinaryDecoder.prototype.readUint16 = function() {
    var v = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1];
    return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), v << 0 | e << 8;
  }, jspb.BinaryDecoder.prototype.readUint32 = function() {
    var v = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1], fe = this.bytes_[this.cursor_ + 2], be = this.bytes_[this.cursor_ + 3];
    return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), (v << 0 | e << 8 | fe << 16 | be << 24) >>> 0;
  }, jspb.BinaryDecoder.prototype.readUint64 = function() {
    var v = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinUint64(v, e);
  }, jspb.BinaryDecoder.prototype.readUint64String = function() {
    var v = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinUnsignedDecimalString(v, e);
  }, jspb.BinaryDecoder.prototype.readInt8 = function() {
    var v = this.bytes_[this.cursor_ + 0];
    return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), v << 24 >> 24;
  }, jspb.BinaryDecoder.prototype.readInt16 = function() {
    var v = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1];
    return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), (v << 0 | e << 8) << 16 >> 16;
  }, jspb.BinaryDecoder.prototype.readInt32 = function() {
    var v = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1], fe = this.bytes_[this.cursor_ + 2], be = this.bytes_[this.cursor_ + 3];
    return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), v << 0 | e << 8 | fe << 16 | be << 24;
  }, jspb.BinaryDecoder.prototype.readInt64 = function() {
    var v = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinInt64(v, e);
  }, jspb.BinaryDecoder.prototype.readInt64String = function() {
    var v = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinSignedDecimalString(v, e);
  }, jspb.BinaryDecoder.prototype.readFloat = function() {
    var v = this.readUint32();
    return jspb.utils.joinFloat32(v, 0);
  }, jspb.BinaryDecoder.prototype.readDouble = function() {
    var v = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinFloat64(v, e);
  }, jspb.BinaryDecoder.prototype.readBool = function() {
    return !!this.bytes_[this.cursor_++];
  }, jspb.BinaryDecoder.prototype.readEnum = function() {
    return this.readSignedVarint32();
  }, jspb.BinaryDecoder.prototype.readString = function(v) {
    var e = this.bytes_, fe = this.cursor_;
    v = fe + v;
    for (var be = [], ye = ""; fe < v; ) {
      var ve = e[fe++];
      if (128 > ve)
        be.push(ve);
      else {
        if (192 > ve)
          continue;
        if (224 > ve) {
          var Ee = e[fe++];
          be.push((ve & 31) << 6 | Ee & 63);
        } else if (240 > ve) {
          Ee = e[fe++];
          var Se = e[fe++];
          be.push((ve & 15) << 12 | (Ee & 63) << 6 | Se & 63);
        } else if (248 > ve) {
          Ee = e[fe++], Se = e[fe++];
          var Oe = e[fe++];
          ve = (ve & 7) << 18 | (Ee & 63) << 12 | (Se & 63) << 6 | Oe & 63, ve -= 65536, be.push((ve >> 10 & 1023) + 55296, (ve & 1023) + 56320);
        }
      }
      8192 <= be.length && (ye += String.fromCharCode.apply(null, be), be.length = 0);
    }
    return ye += goog.crypt.byteArrayToString(be), this.cursor_ = fe, ye;
  }, jspb.BinaryDecoder.prototype.readStringWithLength = function() {
    var v = this.readUnsignedVarint32();
    return this.readString(v);
  }, jspb.BinaryDecoder.prototype.readBytes = function(v) {
    if (0 > v || this.cursor_ + v > this.bytes_.length)
      return this.error_ = !0, jspb.asserts.fail("Invalid byte length!"), new Uint8Array(0);
    var e = this.bytes_.subarray(this.cursor_, this.cursor_ + v);
    return this.cursor_ += v, jspb.asserts.assert(this.cursor_ <= this.end_), e;
  }, jspb.BinaryDecoder.prototype.readVarintHash64 = function() {
    return this.readSplitVarint64(jspb.utils.joinHash64);
  }, jspb.BinaryDecoder.prototype.readFixedHash64 = function() {
    var v = this.bytes_, e = this.cursor_, fe = v[e + 0], be = v[e + 1], ye = v[e + 2], ve = v[e + 3], Ee = v[e + 4], Se = v[e + 5], Oe = v[e + 6];
    return v = v[e + 7], this.cursor_ += 8, String.fromCharCode(fe, be, ye, ve, Ee, Se, Oe, v);
  }, jspb.BinaryReader = function(v, e, fe) {
    this.decoder_ = jspb.BinaryDecoder.alloc(v, e, fe), this.fieldCursor_ = this.decoder_.getCursor(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = !1, this.readCallbacks_ = null;
  }, jspb.BinaryReader.instanceCache_ = [], jspb.BinaryReader.alloc = function(v, e, fe) {
    if (jspb.BinaryReader.instanceCache_.length) {
      var be = jspb.BinaryReader.instanceCache_.pop();
      return v && be.decoder_.setBlock(v, e, fe), be;
    }
    return new jspb.BinaryReader(v, e, fe);
  }, jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc, jspb.BinaryReader.prototype.free = function() {
    this.decoder_.clear(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = !1, this.readCallbacks_ = null, 100 > jspb.BinaryReader.instanceCache_.length && jspb.BinaryReader.instanceCache_.push(this);
  }, jspb.BinaryReader.prototype.getFieldCursor = function() {
    return this.fieldCursor_;
  }, jspb.BinaryReader.prototype.getCursor = function() {
    return this.decoder_.getCursor();
  }, jspb.BinaryReader.prototype.getBuffer = function() {
    return this.decoder_.getBuffer();
  }, jspb.BinaryReader.prototype.getFieldNumber = function() {
    return this.nextField_;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "getFieldNumber", jspb.BinaryReader.prototype.getFieldNumber), jspb.BinaryReader.prototype.getWireType = function() {
    return this.nextWireType_;
  }, jspb.BinaryReader.prototype.isDelimited = function() {
    return this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "isDelimited", jspb.BinaryReader.prototype.isDelimited), jspb.BinaryReader.prototype.isEndGroup = function() {
    return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "isEndGroup", jspb.BinaryReader.prototype.isEndGroup), jspb.BinaryReader.prototype.getError = function() {
    return this.error_ || this.decoder_.getError();
  }, jspb.BinaryReader.prototype.setBlock = function(v, e, fe) {
    this.decoder_.setBlock(v, e, fe), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
  }, jspb.BinaryReader.prototype.reset = function() {
    this.decoder_.reset(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
  }, jspb.BinaryReader.prototype.advance = function(v) {
    this.decoder_.advance(v);
  }, jspb.BinaryReader.prototype.nextField = function() {
    if (this.decoder_.atEnd())
      return !1;
    if (this.getError())
      return jspb.asserts.fail("Decoder hit an error"), !1;
    this.fieldCursor_ = this.decoder_.getCursor();
    var v = this.decoder_.readUnsignedVarint32(), e = v >>> 3;
    return v &= 7, v != jspb.BinaryConstants.WireType.VARINT && v != jspb.BinaryConstants.WireType.FIXED32 && v != jspb.BinaryConstants.WireType.FIXED64 && v != jspb.BinaryConstants.WireType.DELIMITED && v != jspb.BinaryConstants.WireType.START_GROUP && v != jspb.BinaryConstants.WireType.END_GROUP ? (jspb.asserts.fail(
      "Invalid wire type: %s (at position %s)",
      v,
      this.fieldCursor_
    ), this.error_ = !0, !1) : (this.nextField_ = e, this.nextWireType_ = v, !0);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "nextField", jspb.BinaryReader.prototype.nextField), jspb.BinaryReader.prototype.unskipHeader = function() {
    this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
  }, jspb.BinaryReader.prototype.skipMatchingFields = function() {
    var v = this.nextField_;
    for (this.unskipHeader(); this.nextField() && this.getFieldNumber() == v; )
      this.skipField();
    this.decoder_.atEnd() || this.unskipHeader();
  }, jspb.BinaryReader.prototype.skipVarintField = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT ? (jspb.asserts.fail("Invalid wire type for skipVarintField"), this.skipField()) : this.decoder_.skipVarint();
  }, jspb.BinaryReader.prototype.skipDelimitedField = function() {
    if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED)
      jspb.asserts.fail("Invalid wire type for skipDelimitedField"), this.skipField();
    else {
      var v = this.decoder_.readUnsignedVarint32();
      this.decoder_.advance(v);
    }
  }, jspb.BinaryReader.prototype.skipFixed32Field = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32 ? (jspb.asserts.fail("Invalid wire type for skipFixed32Field"), this.skipField()) : this.decoder_.advance(4);
  }, jspb.BinaryReader.prototype.skipFixed64Field = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64 ? (jspb.asserts.fail("Invalid wire type for skipFixed64Field"), this.skipField()) : this.decoder_.advance(8);
  }, jspb.BinaryReader.prototype.skipGroup = function() {
    var v = this.nextField_;
    do {
      if (!this.nextField()) {
        jspb.asserts.fail("Unmatched start-group tag: stream EOF"), this.error_ = !0;
        break;
      }
      if (this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP) {
        this.nextField_ != v && (jspb.asserts.fail("Unmatched end-group tag"), this.error_ = !0);
        break;
      }
      this.skipField();
    } while (1);
  }, jspb.BinaryReader.prototype.skipField = function() {
    switch (this.nextWireType_) {
      case jspb.BinaryConstants.WireType.VARINT:
        this.skipVarintField();
        break;
      case jspb.BinaryConstants.WireType.FIXED64:
        this.skipFixed64Field();
        break;
      case jspb.BinaryConstants.WireType.DELIMITED:
        this.skipDelimitedField();
        break;
      case jspb.BinaryConstants.WireType.FIXED32:
        this.skipFixed32Field();
        break;
      case jspb.BinaryConstants.WireType.START_GROUP:
        this.skipGroup();
        break;
      default:
        jspb.asserts.fail("Invalid wire encoding for field.");
    }
  }, jspb.BinaryReader.prototype.registerReadCallback = function(v, e) {
    this.readCallbacks_ === null && (this.readCallbacks_ = {}), jspb.asserts.assert(!this.readCallbacks_[v]), this.readCallbacks_[v] = e;
  }, jspb.BinaryReader.prototype.runReadCallback = function(v) {
    return jspb.asserts.assert(this.readCallbacks_ !== null), v = this.readCallbacks_[v], jspb.asserts.assert(v), v(this);
  }, jspb.BinaryReader.prototype.readAny = function(v) {
    this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(v);
    var e = jspb.BinaryConstants.FieldType;
    switch (v) {
      case e.DOUBLE:
        return this.readDouble();
      case e.FLOAT:
        return this.readFloat();
      case e.INT64:
        return this.readInt64();
      case e.UINT64:
        return this.readUint64();
      case e.INT32:
        return this.readInt32();
      case e.FIXED64:
        return this.readFixed64();
      case e.FIXED32:
        return this.readFixed32();
      case e.BOOL:
        return this.readBool();
      case e.STRING:
        return this.readString();
      case e.GROUP:
        jspb.asserts.fail("Group field type not supported in readAny()");
      case e.MESSAGE:
        jspb.asserts.fail("Message field type not supported in readAny()");
      case e.BYTES:
        return this.readBytes();
      case e.UINT32:
        return this.readUint32();
      case e.ENUM:
        return this.readEnum();
      case e.SFIXED32:
        return this.readSfixed32();
      case e.SFIXED64:
        return this.readSfixed64();
      case e.SINT32:
        return this.readSint32();
      case e.SINT64:
        return this.readSint64();
      case e.FHASH64:
        return this.readFixedHash64();
      case e.VHASH64:
        return this.readVarintHash64();
      default:
        jspb.asserts.fail("Invalid field type in readAny()");
    }
    return 0;
  }, jspb.BinaryReader.prototype.readMessage = function(v, e) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var fe = this.decoder_.getEnd(), be = this.decoder_.readUnsignedVarint32();
    be = this.decoder_.getCursor() + be, this.decoder_.setEnd(be), e(v, this), this.decoder_.setCursor(be), this.decoder_.setEnd(fe);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readMessage", jspb.BinaryReader.prototype.readMessage), jspb.BinaryReader.prototype.readGroup = function(v, e, fe) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP), jspb.asserts.assert(this.nextField_ == v), fe(e, this), this.error_ || this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP || (jspb.asserts.fail("Group submessage did not end with an END_GROUP tag"), this.error_ = !0);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readGroup", jspb.BinaryReader.prototype.readGroup), jspb.BinaryReader.prototype.getFieldDecoder = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var v = this.decoder_.readUnsignedVarint32(), e = this.decoder_.getCursor(), fe = e + v;
    return v = jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), e, v), this.decoder_.setCursor(fe), v;
  }, jspb.BinaryReader.prototype.readInt32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readInt32", jspb.BinaryReader.prototype.readInt32), jspb.BinaryReader.prototype.readInt32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32String();
  }, jspb.BinaryReader.prototype.readInt64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readInt64", jspb.BinaryReader.prototype.readInt64), jspb.BinaryReader.prototype.readInt64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64String();
  }, jspb.BinaryReader.prototype.readUint32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readUint32", jspb.BinaryReader.prototype.readUint32), jspb.BinaryReader.prototype.readUint32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32String();
  }, jspb.BinaryReader.prototype.readUint64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readUint64", jspb.BinaryReader.prototype.readUint64), jspb.BinaryReader.prototype.readUint64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64String();
  }, jspb.BinaryReader.prototype.readSint32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSint32", jspb.BinaryReader.prototype.readSint32), jspb.BinaryReader.prototype.readSint64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSint64", jspb.BinaryReader.prototype.readSint64), jspb.BinaryReader.prototype.readSint64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64String();
  }, jspb.BinaryReader.prototype.readFixed32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readUint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFixed32", jspb.BinaryReader.prototype.readFixed32), jspb.BinaryReader.prototype.readFixed64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFixed64", jspb.BinaryReader.prototype.readFixed64), jspb.BinaryReader.prototype.readFixed64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64String();
  }, jspb.BinaryReader.prototype.readSfixed32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed32", jspb.BinaryReader.prototype.readSfixed32), jspb.BinaryReader.prototype.readSfixed32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32().toString();
  }, jspb.BinaryReader.prototype.readSfixed64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed64", jspb.BinaryReader.prototype.readSfixed64), jspb.BinaryReader.prototype.readSfixed64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64String();
  }, jspb.BinaryReader.prototype.readFloat = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readFloat();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFloat", jspb.BinaryReader.prototype.readFloat), jspb.BinaryReader.prototype.readDouble = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readDouble();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readDouble", jspb.BinaryReader.prototype.readDouble), jspb.BinaryReader.prototype.readBool = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), !!this.decoder_.readUnsignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readBool", jspb.BinaryReader.prototype.readBool), jspb.BinaryReader.prototype.readEnum = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readEnum", jspb.BinaryReader.prototype.readEnum), jspb.BinaryReader.prototype.readString = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var v = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(v);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readString", jspb.BinaryReader.prototype.readString), jspb.BinaryReader.prototype.readBytes = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var v = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(v);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readBytes", jspb.BinaryReader.prototype.readBytes), jspb.BinaryReader.prototype.readVarintHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readVarintHash64();
  }, jspb.BinaryReader.prototype.readSintHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarintHash64();
  }, jspb.BinaryReader.prototype.readSplitVarint64 = function(v) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(v);
  }, jspb.BinaryReader.prototype.readSplitZigzagVarint64 = function(v) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(function(e, fe) {
      return jspb.utils.fromZigzag64(e, fe, v);
    });
  }, jspb.BinaryReader.prototype.readFixedHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readFixedHash64();
  }, jspb.BinaryReader.prototype.readSplitFixed64 = function(v) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readSplitFixed64(v);
  }, jspb.BinaryReader.prototype.readPackedField_ = function(v) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var e = this.decoder_.readUnsignedVarint32();
    e = this.decoder_.getCursor() + e;
    for (var fe = []; this.decoder_.getCursor() < e; )
      fe.push(v.call(this.decoder_));
    return fe;
  }, jspb.BinaryReader.prototype.readPackedInt32 = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt32", jspb.BinaryReader.prototype.readPackedInt32), jspb.BinaryReader.prototype.readPackedInt32String = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint32String);
  }, jspb.BinaryReader.prototype.readPackedInt64 = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt64", jspb.BinaryReader.prototype.readPackedInt64), jspb.BinaryReader.prototype.readPackedInt64String = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint64String);
  }, jspb.BinaryReader.prototype.readPackedUint32 = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint32", jspb.BinaryReader.prototype.readPackedUint32), jspb.BinaryReader.prototype.readPackedUint32String = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
  }, jspb.BinaryReader.prototype.readPackedUint64 = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint64", jspb.BinaryReader.prototype.readPackedUint64), jspb.BinaryReader.prototype.readPackedUint64String = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
  }, jspb.BinaryReader.prototype.readPackedSint32 = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint32", jspb.BinaryReader.prototype.readPackedSint32), jspb.BinaryReader.prototype.readPackedSint64 = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint64", jspb.BinaryReader.prototype.readPackedSint64), jspb.BinaryReader.prototype.readPackedSint64String = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64String);
  }, jspb.BinaryReader.prototype.readPackedFixed32 = function() {
    return this.readPackedField_(this.decoder_.readUint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed32", jspb.BinaryReader.prototype.readPackedFixed32), jspb.BinaryReader.prototype.readPackedFixed64 = function() {
    return this.readPackedField_(this.decoder_.readUint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed64", jspb.BinaryReader.prototype.readPackedFixed64), jspb.BinaryReader.prototype.readPackedFixed64String = function() {
    return this.readPackedField_(this.decoder_.readUint64String);
  }, jspb.BinaryReader.prototype.readPackedSfixed32 = function() {
    return this.readPackedField_(this.decoder_.readInt32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed32", jspb.BinaryReader.prototype.readPackedSfixed32), jspb.BinaryReader.prototype.readPackedSfixed64 = function() {
    return this.readPackedField_(this.decoder_.readInt64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed64", jspb.BinaryReader.prototype.readPackedSfixed64), jspb.BinaryReader.prototype.readPackedSfixed64String = function() {
    return this.readPackedField_(this.decoder_.readInt64String);
  }, jspb.BinaryReader.prototype.readPackedFloat = function() {
    return this.readPackedField_(this.decoder_.readFloat);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFloat", jspb.BinaryReader.prototype.readPackedFloat), jspb.BinaryReader.prototype.readPackedDouble = function() {
    return this.readPackedField_(this.decoder_.readDouble);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedDouble", jspb.BinaryReader.prototype.readPackedDouble), jspb.BinaryReader.prototype.readPackedBool = function() {
    return this.readPackedField_(this.decoder_.readBool);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedBool", jspb.BinaryReader.prototype.readPackedBool), jspb.BinaryReader.prototype.readPackedEnum = function() {
    return this.readPackedField_(this.decoder_.readEnum);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedEnum", jspb.BinaryReader.prototype.readPackedEnum), jspb.BinaryReader.prototype.readPackedVarintHash64 = function() {
    return this.readPackedField_(this.decoder_.readVarintHash64);
  }, jspb.BinaryReader.prototype.readPackedFixedHash64 = function() {
    return this.readPackedField_(this.decoder_.readFixedHash64);
  }, jspb.BinaryEncoder = function() {
    this.buffer_ = [];
  }, jspb.BinaryEncoder.prototype.length = function() {
    return this.buffer_.length;
  }, jspb.BinaryEncoder.prototype.end = function() {
    var v = this.buffer_;
    return this.buffer_ = [], v;
  }, jspb.BinaryEncoder.prototype.writeSplitVarint64 = function(v, e) {
    for (jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(e == Math.floor(e)), jspb.asserts.assert(0 <= v && v < jspb.BinaryConstants.TWO_TO_32), jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32); 0 < e || 127 < v; )
      this.buffer_.push(v & 127 | 128), v = (v >>> 7 | e << 25) >>> 0, e >>>= 7;
    this.buffer_.push(v);
  }, jspb.BinaryEncoder.prototype.writeSplitFixed64 = function(v, e) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(e == Math.floor(e)), jspb.asserts.assert(0 <= v && v < jspb.BinaryConstants.TWO_TO_32), jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeUint32(v), this.writeUint32(e);
  }, jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function(v) {
    for (jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(0 <= v && v < jspb.BinaryConstants.TWO_TO_32); 127 < v; )
      this.buffer_.push(v & 127 | 128), v >>>= 7;
    this.buffer_.push(v);
  }, jspb.BinaryEncoder.prototype.writeSignedVarint32 = function(v) {
    if (jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_31 && v < jspb.BinaryConstants.TWO_TO_31), 0 <= v)
      this.writeUnsignedVarint32(v);
    else {
      for (var e = 0; 9 > e; e++)
        this.buffer_.push(v & 127 | 128), v >>= 7;
      this.buffer_.push(1);
    }
  }, jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(0 <= v && v < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitInt64(v), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeSignedVarint64 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_63 && v < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(v), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_31 && v < jspb.BinaryConstants.TWO_TO_31), this.writeUnsignedVarint32((v << 1 ^ v >> 31) >>> 0);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_63 && v < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitZigzag64(v), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function(v) {
    this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(v));
  }, jspb.BinaryEncoder.prototype.writeZigzagVarintHash64 = function(v) {
    var e = this;
    jspb.utils.splitHash64(v), jspb.utils.toZigzag64(jspb.utils.split64Low, jspb.utils.split64High, function(fe, be) {
      e.writeSplitVarint64(fe >>> 0, be >>> 0);
    });
  }, jspb.BinaryEncoder.prototype.writeUint8 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(0 <= v && 256 > v), this.buffer_.push(v >>> 0 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint16 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(0 <= v && 65536 > v), this.buffer_.push(v >>> 0 & 255), this.buffer_.push(v >>> 8 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint32 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(0 <= v && v < jspb.BinaryConstants.TWO_TO_32), this.buffer_.push(v >>> 0 & 255), this.buffer_.push(v >>> 8 & 255), this.buffer_.push(v >>> 16 & 255), this.buffer_.push(v >>> 24 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint64 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(0 <= v && v < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitUint64(v), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeInt8 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(-128 <= v && 128 > v), this.buffer_.push(v >>> 0 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt16 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(-32768 <= v && 32768 > v), this.buffer_.push(v >>> 0 & 255), this.buffer_.push(v >>> 8 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt32 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_31 && v < jspb.BinaryConstants.TWO_TO_31), this.buffer_.push(v >>> 0 & 255), this.buffer_.push(v >>> 8 & 255), this.buffer_.push(v >>> 16 & 255), this.buffer_.push(v >>> 24 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt64 = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_63 && v < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(v), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeInt64String = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(+v >= -jspb.BinaryConstants.TWO_TO_63 && +v < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(v)), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeFloat = function(v) {
    jspb.asserts.assert(v === 1 / 0 || v === -1 / 0 || isNaN(v) || v >= -jspb.BinaryConstants.FLOAT32_MAX && v <= jspb.BinaryConstants.FLOAT32_MAX), jspb.utils.splitFloat32(v), this.writeUint32(jspb.utils.split64Low);
  }, jspb.BinaryEncoder.prototype.writeDouble = function(v) {
    jspb.asserts.assert(v === 1 / 0 || v === -1 / 0 || isNaN(v) || v >= -jspb.BinaryConstants.FLOAT64_MAX && v <= jspb.BinaryConstants.FLOAT64_MAX), jspb.utils.splitFloat64(v), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeBool = function(v) {
    jspb.asserts.assert(typeof v == "boolean" || typeof v == "number"), this.buffer_.push(v ? 1 : 0);
  }, jspb.BinaryEncoder.prototype.writeEnum = function(v) {
    jspb.asserts.assert(v == Math.floor(v)), jspb.asserts.assert(v >= -jspb.BinaryConstants.TWO_TO_31 && v < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32(v);
  }, jspb.BinaryEncoder.prototype.writeBytes = function(v) {
    this.buffer_.push.apply(this.buffer_, v);
  }, jspb.BinaryEncoder.prototype.writeVarintHash64 = function(v) {
    jspb.utils.splitHash64(v), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeFixedHash64 = function(v) {
    jspb.utils.splitHash64(v), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeString = function(v) {
    var e = this.buffer_.length;
    jspb.asserts.assertString(v);
    for (var fe = 0; fe < v.length; fe++) {
      var be = v.charCodeAt(fe);
      if (128 > be)
        this.buffer_.push(be);
      else if (2048 > be)
        this.buffer_.push(be >> 6 | 192), this.buffer_.push(be & 63 | 128);
      else if (65536 > be)
        if (55296 <= be && 56319 >= be && fe + 1 < v.length) {
          var ye = v.charCodeAt(fe + 1);
          56320 <= ye && 57343 >= ye && (be = 1024 * (be - 55296) + ye - 56320 + 65536, this.buffer_.push(be >> 18 | 240), this.buffer_.push(be >> 12 & 63 | 128), this.buffer_.push(be >> 6 & 63 | 128), this.buffer_.push(be & 63 | 128), fe++);
        } else
          this.buffer_.push(be >> 12 | 224), this.buffer_.push(be >> 6 & 63 | 128), this.buffer_.push(be & 63 | 128);
    }
    return this.buffer_.length - e;
  }, jspb.arith = {}, jspb.arith.UInt64 = function(v, e) {
    this.lo = v, this.hi = e;
  }, jspb.arith.UInt64.prototype.cmp = function(v) {
    return this.hi < v.hi || this.hi == v.hi && this.lo < v.lo ? -1 : this.hi == v.hi && this.lo == v.lo ? 0 : 1;
  }, jspb.arith.UInt64.prototype.rightShift = function() {
    return new jspb.arith.UInt64((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
  }, jspb.arith.UInt64.prototype.leftShift = function() {
    return new jspb.arith.UInt64(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
  }, jspb.arith.UInt64.prototype.msb = function() {
    return !!(this.hi & 2147483648);
  }, jspb.arith.UInt64.prototype.lsb = function() {
    return !!(this.lo & 1);
  }, jspb.arith.UInt64.prototype.zero = function() {
    return this.lo == 0 && this.hi == 0;
  }, jspb.arith.UInt64.prototype.add = function(v) {
    return new jspb.arith.UInt64((this.lo + v.lo & 4294967295) >>> 0 >>> 0, ((this.hi + v.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + v.lo ? 1 : 0) >>> 0);
  }, jspb.arith.UInt64.prototype.sub = function(v) {
    return new jspb.arith.UInt64((this.lo - v.lo & 4294967295) >>> 0 >>> 0, ((this.hi - v.hi & 4294967295) >>> 0) - (0 > this.lo - v.lo ? 1 : 0) >>> 0);
  }, jspb.arith.UInt64.mul32x32 = function(v, e) {
    var fe = v & 65535;
    v >>>= 16;
    var be = e & 65535, ye = e >>> 16;
    for (e = fe * be + 65536 * (fe * ye & 65535) + 65536 * (v * be & 65535), fe = v * ye + (fe * ye >>> 16) + (v * be >>> 16); 4294967296 <= e; )
      e -= 4294967296, fe += 1;
    return new jspb.arith.UInt64(e >>> 0, fe >>> 0);
  }, jspb.arith.UInt64.prototype.mul = function(v) {
    var e = jspb.arith.UInt64.mul32x32(this.lo, v);
    return v = jspb.arith.UInt64.mul32x32(this.hi, v), v.hi = v.lo, v.lo = 0, e.add(v);
  }, jspb.arith.UInt64.prototype.div = function(v) {
    if (v == 0)
      return [];
    var e = new jspb.arith.UInt64(0, 0), fe = new jspb.arith.UInt64(this.lo, this.hi);
    v = new jspb.arith.UInt64(v, 0);
    for (var be = new jspb.arith.UInt64(1, 0); !v.msb(); )
      v = v.leftShift(), be = be.leftShift();
    for (; !be.zero(); )
      0 >= v.cmp(fe) && (e = e.add(be), fe = fe.sub(v)), v = v.rightShift(), be = be.rightShift();
    return [e, fe];
  }, jspb.arith.UInt64.prototype.toString = function() {
    for (var v = "", e = this; !e.zero(); ) {
      e = e.div(10);
      var fe = e[0];
      v = e[1].lo + v, e = fe;
    }
    return v == "" && (v = "0"), v;
  }, jspb.arith.UInt64.fromString = function(v) {
    for (var e = new jspb.arith.UInt64(0, 0), fe = new jspb.arith.UInt64(0, 0), be = 0; be < v.length; be++) {
      if ("0" > v[be] || "9" < v[be])
        return null;
      var ye = parseInt(v[be], 10);
      fe.lo = ye, e = e.mul(10).add(fe);
    }
    return e;
  }, jspb.arith.UInt64.prototype.clone = function() {
    return new jspb.arith.UInt64(this.lo, this.hi);
  }, jspb.arith.Int64 = function(v, e) {
    this.lo = v, this.hi = e;
  }, jspb.arith.Int64.prototype.add = function(v) {
    return new jspb.arith.Int64((this.lo + v.lo & 4294967295) >>> 0 >>> 0, ((this.hi + v.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + v.lo ? 1 : 0) >>> 0);
  }, jspb.arith.Int64.prototype.sub = function(v) {
    return new jspb.arith.Int64((this.lo - v.lo & 4294967295) >>> 0 >>> 0, ((this.hi - v.hi & 4294967295) >>> 0) - (0 > this.lo - v.lo ? 1 : 0) >>> 0);
  }, jspb.arith.Int64.prototype.clone = function() {
    return new jspb.arith.Int64(this.lo, this.hi);
  }, jspb.arith.Int64.prototype.toString = function() {
    var v = (this.hi & 2147483648) != 0, e = new jspb.arith.UInt64(this.lo, this.hi);
    return v && (e = new jspb.arith.UInt64(0, 0).sub(e)), (v ? "-" : "") + e.toString();
  }, jspb.arith.Int64.fromString = function(v) {
    var e = 0 < v.length && v[0] == "-";
    return e && (v = v.substring(1)), v = jspb.arith.UInt64.fromString(v), v === null ? null : (e && (v = new jspb.arith.UInt64(0, 0).sub(v)), new jspb.arith.Int64(v.lo, v.hi));
  }, jspb.BinaryWriter = function() {
    this.blocks_ = [], this.totalLength_ = 0, this.encoder_ = new jspb.BinaryEncoder(), this.bookmarks_ = [];
  }, jspb.BinaryWriter.prototype.appendUint8Array_ = function(v) {
    var e = this.encoder_.end();
    this.blocks_.push(e), this.blocks_.push(v), this.totalLength_ += e.length + v.length;
  }, jspb.BinaryWriter.prototype.beginDelimited_ = function(v) {
    return this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), v = this.encoder_.end(), this.blocks_.push(v), this.totalLength_ += v.length, v.push(this.totalLength_), v;
  }, jspb.BinaryWriter.prototype.endDelimited_ = function(v) {
    var e = v.pop();
    for (e = this.totalLength_ + this.encoder_.length() - e, jspb.asserts.assert(0 <= e); 127 < e; )
      v.push(e & 127 | 128), e >>>= 7, this.totalLength_++;
    v.push(e), this.totalLength_++;
  }, jspb.BinaryWriter.prototype.writeSerializedMessage = function(v, e, fe) {
    this.appendUint8Array_(v.subarray(e, fe));
  }, jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function(v, e, fe) {
    v != null && e != null && fe != null && this.writeSerializedMessage(v, e, fe);
  }, jspb.BinaryWriter.prototype.reset = function() {
    this.blocks_ = [], this.encoder_.end(), this.totalLength_ = 0, this.bookmarks_ = [];
  }, jspb.BinaryWriter.prototype.getResultBuffer = function() {
    jspb.asserts.assert(this.bookmarks_.length == 0);
    for (var v = new Uint8Array(this.totalLength_ + this.encoder_.length()), e = this.blocks_, fe = e.length, be = 0, ye = 0; ye < fe; ye++) {
      var ve = e[ye];
      v.set(ve, be), be += ve.length;
    }
    return e = this.encoder_.end(), v.set(e, be), be += e.length, jspb.asserts.assert(be == v.length), this.blocks_ = [v], v;
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "getResultBuffer", jspb.BinaryWriter.prototype.getResultBuffer), jspb.BinaryWriter.prototype.getResultBase64String = function(v) {
    return goog.crypt.base64.encodeByteArray(this.getResultBuffer(), v);
  }, jspb.BinaryWriter.prototype.beginSubMessage = function(v) {
    this.bookmarks_.push(this.beginDelimited_(v));
  }, jspb.BinaryWriter.prototype.endSubMessage = function() {
    jspb.asserts.assert(0 <= this.bookmarks_.length), this.endDelimited_(this.bookmarks_.pop());
  }, jspb.BinaryWriter.prototype.writeFieldHeader_ = function(v, e) {
    jspb.asserts.assert(1 <= v && v == Math.floor(v)), this.encoder_.writeUnsignedVarint32(8 * v + e);
  }, jspb.BinaryWriter.prototype.writeAny = function(v, e, fe) {
    var be = jspb.BinaryConstants.FieldType;
    switch (v) {
      case be.DOUBLE:
        this.writeDouble(e, fe);
        break;
      case be.FLOAT:
        this.writeFloat(e, fe);
        break;
      case be.INT64:
        this.writeInt64(e, fe);
        break;
      case be.UINT64:
        this.writeUint64(e, fe);
        break;
      case be.INT32:
        this.writeInt32(e, fe);
        break;
      case be.FIXED64:
        this.writeFixed64(e, fe);
        break;
      case be.FIXED32:
        this.writeFixed32(e, fe);
        break;
      case be.BOOL:
        this.writeBool(e, fe);
        break;
      case be.STRING:
        this.writeString(e, fe);
        break;
      case be.GROUP:
        jspb.asserts.fail("Group field type not supported in writeAny()");
        break;
      case be.MESSAGE:
        jspb.asserts.fail("Message field type not supported in writeAny()");
        break;
      case be.BYTES:
        this.writeBytes(e, fe);
        break;
      case be.UINT32:
        this.writeUint32(e, fe);
        break;
      case be.ENUM:
        this.writeEnum(e, fe);
        break;
      case be.SFIXED32:
        this.writeSfixed32(e, fe);
        break;
      case be.SFIXED64:
        this.writeSfixed64(e, fe);
        break;
      case be.SINT32:
        this.writeSint32(e, fe);
        break;
      case be.SINT64:
        this.writeSint64(e, fe);
        break;
      case be.FHASH64:
        this.writeFixedHash64(e, fe);
        break;
      case be.VHASH64:
        this.writeVarintHash64(e, fe);
        break;
      default:
        jspb.asserts.fail("Invalid field type in writeAny()");
    }
  }, jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint32(e));
  }, jspb.BinaryWriter.prototype.writeSignedVarint32_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(e));
  }, jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint64(e));
  }, jspb.BinaryWriter.prototype.writeSignedVarint64_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint64(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint32(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64String(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarintHash64_ = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarintHash64(e));
  }, jspb.BinaryWriter.prototype.writeInt32 = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(v, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt32", jspb.BinaryWriter.prototype.writeInt32), jspb.BinaryWriter.prototype.writeInt32String = function(v, e) {
    e != null && (e = parseInt(e, 10), jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(v, e));
  }, jspb.BinaryWriter.prototype.writeInt64 = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), this.writeSignedVarint64_(v, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt64", jspb.BinaryWriter.prototype.writeInt64), jspb.BinaryWriter.prototype.writeInt64String = function(v, e) {
    e != null && (e = jspb.arith.Int64.fromString(e), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeUint32 = function(v, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(v, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint32", jspb.BinaryWriter.prototype.writeUint32), jspb.BinaryWriter.prototype.writeUint32String = function(v, e) {
    e != null && (e = parseInt(e, 10), jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(v, e));
  }, jspb.BinaryWriter.prototype.writeUint64 = function(v, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_64), this.writeUnsignedVarint64_(v, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint64", jspb.BinaryWriter.prototype.writeUint64), jspb.BinaryWriter.prototype.writeUint64String = function(v, e) {
    e != null && (e = jspb.arith.UInt64.fromString(e), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeSint32 = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeZigzagVarint32_(v, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint32", jspb.BinaryWriter.prototype.writeSint32), jspb.BinaryWriter.prototype.writeSint64 = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64_(v, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint64", jspb.BinaryWriter.prototype.writeSint64), jspb.BinaryWriter.prototype.writeSintHash64 = function(v, e) {
    e != null && this.writeZigzagVarintHash64_(v, e);
  }, jspb.BinaryWriter.prototype.writeSint64String = function(v, e) {
    e != null && this.writeZigzagVarint64String_(v, e);
  }, jspb.BinaryWriter.prototype.writeFixed32 = function(v, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeUint32(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed32", jspb.BinaryWriter.prototype.writeFixed32), jspb.BinaryWriter.prototype.writeFixed64 = function(v, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_64), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeUint64(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed64", jspb.BinaryWriter.prototype.writeFixed64), jspb.BinaryWriter.prototype.writeFixed64String = function(v, e) {
    e != null && (e = jspb.arith.UInt64.fromString(e), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeSfixed32 = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeInt32(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed32", jspb.BinaryWriter.prototype.writeSfixed32), jspb.BinaryWriter.prototype.writeSfixed64 = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeInt64(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed64", jspb.BinaryWriter.prototype.writeSfixed64), jspb.BinaryWriter.prototype.writeSfixed64String = function(v, e) {
    e != null && (e = jspb.arith.Int64.fromString(e), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeFloat = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeFloat(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFloat", jspb.BinaryWriter.prototype.writeFloat), jspb.BinaryWriter.prototype.writeDouble = function(v, e) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeDouble(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeDouble", jspb.BinaryWriter.prototype.writeDouble), jspb.BinaryWriter.prototype.writeBool = function(v, e) {
    e != null && (jspb.asserts.assert(typeof e == "boolean" || typeof e == "number"), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeBool(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeBool", jspb.BinaryWriter.prototype.writeBool), jspb.BinaryWriter.prototype.writeEnum = function(v, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeEnum", jspb.BinaryWriter.prototype.writeEnum), jspb.BinaryWriter.prototype.writeString = function(v, e) {
    e != null && (v = this.beginDelimited_(v), this.encoder_.writeString(e), this.endDelimited_(v));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeString", jspb.BinaryWriter.prototype.writeString), jspb.BinaryWriter.prototype.writeBytes = function(v, e) {
    e != null && (e = jspb.utils.byteSourceToUint8Array(e), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(e.length), this.appendUint8Array_(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeBytes", jspb.BinaryWriter.prototype.writeBytes), jspb.BinaryWriter.prototype.writeMessage = function(v, e, fe) {
    e != null && (v = this.beginDelimited_(v), fe(e, this), this.endDelimited_(v));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeMessage", jspb.BinaryWriter.prototype.writeMessage), jspb.BinaryWriter.prototype.writeMessageSet = function(v, e, fe) {
    e != null && (this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.START_GROUP), this.writeFieldHeader_(2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(v), v = this.beginDelimited_(3), fe(e, this), this.endDelimited_(v), this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.END_GROUP));
  }, jspb.BinaryWriter.prototype.writeGroup = function(v, e, fe) {
    e != null && (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.START_GROUP), fe(e, this), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.END_GROUP));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeGroup", jspb.BinaryWriter.prototype.writeGroup), jspb.BinaryWriter.prototype.writeFixedHash64 = function(v, e) {
    e != null && (jspb.asserts.assert(e.length == 8), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeFixedHash64(e));
  }, jspb.BinaryWriter.prototype.writeVarintHash64 = function(v, e) {
    e != null && (jspb.asserts.assert(e.length == 8), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeVarintHash64(e));
  }, jspb.BinaryWriter.prototype.writeSplitFixed64 = function(v, e, fe) {
    this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(e, fe);
  }, jspb.BinaryWriter.prototype.writeSplitVarint64 = function(v, e, fe) {
    this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(e, fe);
  }, jspb.BinaryWriter.prototype.writeSplitZigzagVarint64 = function(v, e, fe) {
    this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.VARINT);
    var be = this.encoder_;
    jspb.utils.toZigzag64(e, fe, function(ye, ve) {
      be.writeSplitVarint64(ye >>> 0, ve >>> 0);
    });
  }, jspb.BinaryWriter.prototype.writeRepeatedInt32 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeSignedVarint32_(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt32", jspb.BinaryWriter.prototype.writeRepeatedInt32), jspb.BinaryWriter.prototype.writeRepeatedInt32String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeInt32String(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedInt64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeSignedVarint64_(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt64", jspb.BinaryWriter.prototype.writeRepeatedInt64), jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64 = function(v, e, fe, be) {
    if (e != null)
      for (var ye = 0; ye < e.length; ye++)
        this.writeSplitFixed64(v, fe(e[ye]), be(e[ye]));
  }, jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64 = function(v, e, fe, be) {
    if (e != null)
      for (var ye = 0; ye < e.length; ye++)
        this.writeSplitVarint64(v, fe(e[ye]), be(e[ye]));
  }, jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64 = function(v, e, fe, be) {
    if (e != null)
      for (var ye = 0; ye < e.length; ye++)
        this.writeSplitZigzagVarint64(v, fe(e[ye]), be(e[ye]));
  }, jspb.BinaryWriter.prototype.writeRepeatedInt64String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeInt64String(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedUint32 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeUnsignedVarint32_(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint32", jspb.BinaryWriter.prototype.writeRepeatedUint32), jspb.BinaryWriter.prototype.writeRepeatedUint32String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeUint32String(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedUint64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeUnsignedVarint64_(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint64", jspb.BinaryWriter.prototype.writeRepeatedUint64), jspb.BinaryWriter.prototype.writeRepeatedUint64String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeUint64String(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedSint32 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeZigzagVarint32_(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint32", jspb.BinaryWriter.prototype.writeRepeatedSint32), jspb.BinaryWriter.prototype.writeRepeatedSint64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeZigzagVarint64_(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint64", jspb.BinaryWriter.prototype.writeRepeatedSint64), jspb.BinaryWriter.prototype.writeRepeatedSint64String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeZigzagVarint64String_(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedSintHash64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeZigzagVarintHash64_(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeFixed32(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed32", jspb.BinaryWriter.prototype.writeRepeatedFixed32), jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeFixed64(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64", jspb.BinaryWriter.prototype.writeRepeatedFixed64), jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeFixed64String(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64String", jspb.BinaryWriter.prototype.writeRepeatedFixed64String), jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeSfixed32(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed32", jspb.BinaryWriter.prototype.writeRepeatedSfixed32), jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeSfixed64(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed64", jspb.BinaryWriter.prototype.writeRepeatedSfixed64), jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeSfixed64String(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedFloat = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeFloat(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFloat", jspb.BinaryWriter.prototype.writeRepeatedFloat), jspb.BinaryWriter.prototype.writeRepeatedDouble = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeDouble(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedDouble", jspb.BinaryWriter.prototype.writeRepeatedDouble), jspb.BinaryWriter.prototype.writeRepeatedBool = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeBool(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBool", jspb.BinaryWriter.prototype.writeRepeatedBool), jspb.BinaryWriter.prototype.writeRepeatedEnum = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeEnum(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedEnum", jspb.BinaryWriter.prototype.writeRepeatedEnum), jspb.BinaryWriter.prototype.writeRepeatedString = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeString(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedString", jspb.BinaryWriter.prototype.writeRepeatedString), jspb.BinaryWriter.prototype.writeRepeatedBytes = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeBytes(v, e[fe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBytes", jspb.BinaryWriter.prototype.writeRepeatedBytes), jspb.BinaryWriter.prototype.writeRepeatedMessage = function(v, e, fe) {
    if (e != null)
      for (var be = 0; be < e.length; be++) {
        var ye = this.beginDelimited_(v);
        fe(e[be], this), this.endDelimited_(ye);
      }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedMessage", jspb.BinaryWriter.prototype.writeRepeatedMessage), jspb.BinaryWriter.prototype.writeRepeatedGroup = function(v, e, fe) {
    if (e != null)
      for (var be = 0; be < e.length; be++)
        this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.START_GROUP), fe(e[be], this), this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.END_GROUP);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedGroup", jspb.BinaryWriter.prototype.writeRepeatedGroup), jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeFixedHash64(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 = function(v, e) {
    if (e != null)
      for (var fe = 0; fe < e.length; fe++)
        this.writeVarintHash64(v, e[fe]);
  }, jspb.BinaryWriter.prototype.writePackedInt32 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeSignedVarint32(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt32", jspb.BinaryWriter.prototype.writePackedInt32), jspb.BinaryWriter.prototype.writePackedInt32String = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeSignedVarint32(parseInt(e[fe], 10));
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedInt64 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeSignedVarint64(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt64", jspb.BinaryWriter.prototype.writePackedInt64), jspb.BinaryWriter.prototype.writePackedSplitFixed64 = function(v, e, fe, be) {
    if (e != null) {
      v = this.beginDelimited_(v);
      for (var ye = 0; ye < e.length; ye++)
        this.encoder_.writeSplitFixed64(fe(e[ye]), be(e[ye]));
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedSplitVarint64 = function(v, e, fe, be) {
    if (e != null) {
      v = this.beginDelimited_(v);
      for (var ye = 0; ye < e.length; ye++)
        this.encoder_.writeSplitVarint64(fe(e[ye]), be(e[ye]));
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64 = function(v, e, fe, be) {
    if (e != null) {
      v = this.beginDelimited_(v);
      for (var ye = this.encoder_, ve = 0; ve < e.length; ve++)
        jspb.utils.toZigzag64(fe(e[ve]), be(e[ve]), function(Ee, Se) {
          ye.writeSplitVarint64(Ee >>> 0, Se >>> 0);
        });
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedInt64String = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++) {
        var be = jspb.arith.Int64.fromString(e[fe]);
        this.encoder_.writeSplitVarint64(be.lo, be.hi);
      }
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedUint32 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeUnsignedVarint32(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint32", jspb.BinaryWriter.prototype.writePackedUint32), jspb.BinaryWriter.prototype.writePackedUint32String = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeUnsignedVarint32(parseInt(e[fe], 10));
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedUint64 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeUnsignedVarint64(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint64", jspb.BinaryWriter.prototype.writePackedUint64), jspb.BinaryWriter.prototype.writePackedUint64String = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++) {
        var be = jspb.arith.UInt64.fromString(e[fe]);
        this.encoder_.writeSplitVarint64(be.lo, be.hi);
      }
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedSint32 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeZigzagVarint32(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint32", jspb.BinaryWriter.prototype.writePackedSint32), jspb.BinaryWriter.prototype.writePackedSint64 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeZigzagVarint64(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint64", jspb.BinaryWriter.prototype.writePackedSint64), jspb.BinaryWriter.prototype.writePackedSint64String = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(e[fe]));
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedSintHash64 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeZigzagVarintHash64(e[fe]);
      this.endDelimited_(v);
    }
  }, jspb.BinaryWriter.prototype.writePackedFixed32 = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeUint32(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed32", jspb.BinaryWriter.prototype.writePackedFixed32), jspb.BinaryWriter.prototype.writePackedFixed64 = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeUint64(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed64", jspb.BinaryWriter.prototype.writePackedFixed64), jspb.BinaryWriter.prototype.writePackedFixed64String = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), v = 0; v < e.length; v++) {
        var fe = jspb.arith.UInt64.fromString(e[v]);
        this.encoder_.writeSplitFixed64(fe.lo, fe.hi);
      }
  }, jspb.BinaryWriter.prototype.writePackedSfixed32 = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeInt32(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed32", jspb.BinaryWriter.prototype.writePackedSfixed32), jspb.BinaryWriter.prototype.writePackedSfixed64 = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeInt64(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed64", jspb.BinaryWriter.prototype.writePackedSfixed64), jspb.BinaryWriter.prototype.writePackedSfixed64String = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeInt64String(e[v]);
  }, jspb.BinaryWriter.prototype.writePackedFloat = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeFloat(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFloat", jspb.BinaryWriter.prototype.writePackedFloat), jspb.BinaryWriter.prototype.writePackedDouble = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeDouble(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedDouble", jspb.BinaryWriter.prototype.writePackedDouble), jspb.BinaryWriter.prototype.writePackedBool = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(e.length), v = 0; v < e.length; v++)
        this.encoder_.writeBool(e[v]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedBool", jspb.BinaryWriter.prototype.writePackedBool), jspb.BinaryWriter.prototype.writePackedEnum = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeEnum(e[fe]);
      this.endDelimited_(v);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedEnum", jspb.BinaryWriter.prototype.writePackedEnum), jspb.BinaryWriter.prototype.writePackedFixedHash64 = function(v, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(v, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), v = 0; v < e.length; v++)
        this.encoder_.writeFixedHash64(e[v]);
  }, jspb.BinaryWriter.prototype.writePackedVarintHash64 = function(v, e) {
    if (e != null && e.length) {
      v = this.beginDelimited_(v);
      for (var fe = 0; fe < e.length; fe++)
        this.encoder_.writeVarintHash64(e[fe]);
      this.endDelimited_(v);
    }
  }, jspb.Map = function(v, e) {
    this.arr_ = v, this.valueCtor_ = e, this.map_ = {}, this.arrClean = !0, 0 < this.arr_.length && this.loadFromArray_();
  }, goog.exportSymbol("jspb.Map", jspb.Map), jspb.Map.prototype.loadFromArray_ = function() {
    for (var v = 0; v < this.arr_.length; v++) {
      var e = this.arr_[v], fe = e[0];
      this.map_[fe.toString()] = new jspb.Map.Entry_(fe, e[1]);
    }
    this.arrClean = !0;
  }, jspb.Map.prototype.toArray = function() {
    if (this.arrClean) {
      if (this.valueCtor_) {
        var v = this.map_, e;
        for (e in v)
          if (Object.prototype.hasOwnProperty.call(v, e)) {
            var fe = v[e].valueWrapper;
            fe && fe.toArray();
          }
      }
    } else {
      for (this.arr_.length = 0, v = this.stringKeys_(), v.sort(), e = 0; e < v.length; e++) {
        var be = this.map_[v[e]];
        (fe = be.valueWrapper) && fe.toArray(), this.arr_.push([be.key, be.value]);
      }
      this.arrClean = !0;
    }
    return this.arr_;
  }, goog.exportProperty(jspb.Map.prototype, "toArray", jspb.Map.prototype.toArray), jspb.Map.prototype.toObject = function(v, e) {
    for (var fe = this.toArray(), be = [], ye = 0; ye < fe.length; ye++) {
      var ve = this.map_[fe[ye][0].toString()];
      this.wrapEntry_(ve);
      var Ee = ve.valueWrapper;
      Ee ? (jspb.asserts.assert(e), be.push([ve.key, e(v, Ee)])) : be.push([ve.key, ve.value]);
    }
    return be;
  }, goog.exportProperty(jspb.Map.prototype, "toObject", jspb.Map.prototype.toObject), jspb.Map.fromObject = function(v, e, fe) {
    e = new jspb.Map([], e);
    for (var be = 0; be < v.length; be++) {
      var ye = v[be][0], ve = fe(v[be][1]);
      e.set(ye, ve);
    }
    return e;
  }, goog.exportProperty(jspb.Map, "fromObject", jspb.Map.fromObject), jspb.Map.ArrayIteratorIterable_ = function(v) {
    this.idx_ = 0, this.arr_ = v;
  }, jspb.Map.ArrayIteratorIterable_.prototype.next = function() {
    return this.idx_ < this.arr_.length ? { done: !1, value: this.arr_[this.idx_++] } : { done: !0, value: void 0 };
  }, typeof Symbol < "u" && (jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function() {
    return this;
  }), jspb.Map.prototype.getLength = function() {
    return this.stringKeys_().length;
  }, goog.exportProperty(jspb.Map.prototype, "getLength", jspb.Map.prototype.getLength), jspb.Map.prototype.clear = function() {
    this.map_ = {}, this.arrClean = !1;
  }, goog.exportProperty(jspb.Map.prototype, "clear", jspb.Map.prototype.clear), jspb.Map.prototype.del = function(v) {
    v = v.toString();
    var e = this.map_.hasOwnProperty(v);
    return delete this.map_[v], this.arrClean = !1, e;
  }, goog.exportProperty(jspb.Map.prototype, "del", jspb.Map.prototype.del), jspb.Map.prototype.getEntryList = function() {
    var v = [], e = this.stringKeys_();
    e.sort();
    for (var fe = 0; fe < e.length; fe++) {
      var be = this.map_[e[fe]];
      v.push([be.key, be.value]);
    }
    return v;
  }, goog.exportProperty(jspb.Map.prototype, "getEntryList", jspb.Map.prototype.getEntryList), jspb.Map.prototype.entries = function() {
    var v = [], e = this.stringKeys_();
    e.sort();
    for (var fe = 0; fe < e.length; fe++) {
      var be = this.map_[e[fe]];
      v.push([be.key, this.wrapEntry_(be)]);
    }
    return new jspb.Map.ArrayIteratorIterable_(v);
  }, goog.exportProperty(jspb.Map.prototype, "entries", jspb.Map.prototype.entries), jspb.Map.prototype.keys = function() {
    var v = [], e = this.stringKeys_();
    e.sort();
    for (var fe = 0; fe < e.length; fe++)
      v.push(this.map_[e[fe]].key);
    return new jspb.Map.ArrayIteratorIterable_(v);
  }, goog.exportProperty(jspb.Map.prototype, "keys", jspb.Map.prototype.keys), jspb.Map.prototype.values = function() {
    var v = [], e = this.stringKeys_();
    e.sort();
    for (var fe = 0; fe < e.length; fe++)
      v.push(this.wrapEntry_(this.map_[e[fe]]));
    return new jspb.Map.ArrayIteratorIterable_(v);
  }, goog.exportProperty(jspb.Map.prototype, "values", jspb.Map.prototype.values), jspb.Map.prototype.forEach = function(v, e) {
    var fe = this.stringKeys_();
    fe.sort();
    for (var be = 0; be < fe.length; be++) {
      var ye = this.map_[fe[be]];
      v.call(e, this.wrapEntry_(ye), ye.key, this);
    }
  }, goog.exportProperty(jspb.Map.prototype, "forEach", jspb.Map.prototype.forEach), jspb.Map.prototype.set = function(v, e) {
    var fe = new jspb.Map.Entry_(v);
    return this.valueCtor_ ? (fe.valueWrapper = e, fe.value = e.toArray()) : fe.value = e, this.map_[v.toString()] = fe, this.arrClean = !1, this;
  }, goog.exportProperty(jspb.Map.prototype, "set", jspb.Map.prototype.set), jspb.Map.prototype.wrapEntry_ = function(v) {
    return this.valueCtor_ ? (v.valueWrapper || (v.valueWrapper = new this.valueCtor_(v.value)), v.valueWrapper) : v.value;
  }, jspb.Map.prototype.get = function(v) {
    if (v = this.map_[v.toString()])
      return this.wrapEntry_(v);
  }, goog.exportProperty(jspb.Map.prototype, "get", jspb.Map.prototype.get), jspb.Map.prototype.has = function(v) {
    return v.toString() in this.map_;
  }, goog.exportProperty(jspb.Map.prototype, "has", jspb.Map.prototype.has), jspb.Map.prototype.serializeBinary = function(v, e, fe, be, ye) {
    var ve = this.stringKeys_();
    ve.sort();
    for (var Ee = 0; Ee < ve.length; Ee++) {
      var Se = this.map_[ve[Ee]];
      e.beginSubMessage(v), fe.call(e, 1, Se.key), this.valueCtor_ ? be.call(e, 2, this.wrapEntry_(Se), ye) : be.call(e, 2, Se.value), e.endSubMessage();
    }
  }, goog.exportProperty(jspb.Map.prototype, "serializeBinary", jspb.Map.prototype.serializeBinary), jspb.Map.deserializeBinary = function(v, e, fe, be, ye, ve, Ee) {
    for (; e.nextField() && !e.isEndGroup(); ) {
      var Se = e.getFieldNumber();
      Se == 1 ? ve = fe.call(e) : Se == 2 && (v.valueCtor_ ? (jspb.asserts.assert(ye), Ee || (Ee = new v.valueCtor_()), be.call(e, Ee, ye)) : Ee = be.call(e));
    }
    jspb.asserts.assert(ve != null), jspb.asserts.assert(Ee != null), v.set(ve, Ee);
  }, goog.exportProperty(jspb.Map, "deserializeBinary", jspb.Map.deserializeBinary), jspb.Map.prototype.stringKeys_ = function() {
    var v = this.map_, e = [], fe;
    for (fe in v)
      Object.prototype.hasOwnProperty.call(v, fe) && e.push(fe);
    return e;
  }, jspb.Map.Entry_ = function(v, e) {
    this.key = v, this.value = e, this.valueWrapper = void 0;
  }, jspb.ExtensionFieldInfo = function(v, e, fe, be, ye) {
    this.fieldIndex = v, this.fieldName = e, this.ctor = fe, this.toObjectFn = be, this.isRepeated = ye;
  }, goog.exportSymbol("jspb.ExtensionFieldInfo", jspb.ExtensionFieldInfo), jspb.ExtensionFieldBinaryInfo = function(v, e, fe, be, ye, ve) {
    this.fieldInfo = v, this.binaryReaderFn = e, this.binaryWriterFn = fe, this.binaryMessageSerializeFn = be, this.binaryMessageDeserializeFn = ye, this.isPacked = ve;
  }, goog.exportSymbol("jspb.ExtensionFieldBinaryInfo", jspb.ExtensionFieldBinaryInfo), jspb.ExtensionFieldInfo.prototype.isMessageType = function() {
    return !!this.ctor;
  }, goog.exportProperty(jspb.ExtensionFieldInfo.prototype, "isMessageType", jspb.ExtensionFieldInfo.prototype.isMessageType), jspb.Message = function() {
  }, goog.exportSymbol("jspb.Message", jspb.Message), jspb.Message.GENERATE_TO_OBJECT = !0, goog.exportProperty(jspb.Message, "GENERATE_TO_OBJECT", jspb.Message.GENERATE_TO_OBJECT), jspb.Message.GENERATE_FROM_OBJECT = !goog.DISALLOW_TEST_ONLY_CODE, goog.exportProperty(jspb.Message, "GENERATE_FROM_OBJECT", jspb.Message.GENERATE_FROM_OBJECT), jspb.Message.GENERATE_TO_STRING = !0, jspb.Message.ASSUME_LOCAL_ARRAYS = !1, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS = !0, jspb.Message.SUPPORTS_UINT8ARRAY_ = typeof Uint8Array == "function", jspb.Message.prototype.getJsPbMessageId = function() {
    return this.messageId_;
  }, goog.exportProperty(jspb.Message.prototype, "getJsPbMessageId", jspb.Message.prototype.getJsPbMessageId), jspb.Message.getIndex_ = function(v, e) {
    return e + v.arrayIndexOffset_;
  }, jspb.Message.hiddenES6Property_ = function() {
  }, jspb.Message.getFieldNumber_ = function(v, e) {
    return e - v.arrayIndexOffset_;
  }, jspb.Message.initialize = function(v, e, fe, be, ye, ve) {
    if (v.wrappers_ = null, e || (e = fe ? [fe] : []), v.messageId_ = fe ? String(fe) : void 0, v.arrayIndexOffset_ = fe === 0 ? -1 : 0, v.array = e, jspb.Message.initPivotAndExtensionObject_(v, be), v.convertedPrimitiveFields_ = {}, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS || (v.repeatedFields = ye), ye)
      for (e = 0; e < ye.length; e++)
        fe = ye[e], fe < v.pivot_ ? (fe = jspb.Message.getIndex_(v, fe), v.array[fe] = v.array[fe] || jspb.Message.EMPTY_LIST_SENTINEL_) : (jspb.Message.maybeInitEmptyExtensionObject_(v), v.extensionObject_[fe] = v.extensionObject_[fe] || jspb.Message.EMPTY_LIST_SENTINEL_);
    if (ve && ve.length)
      for (e = 0; e < ve.length; e++)
        jspb.Message.computeOneofCase(v, ve[e]);
  }, goog.exportProperty(jspb.Message, "initialize", jspb.Message.initialize), jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG && Object.freeze ? Object.freeze([]) : [], jspb.Message.isArray_ = function(v) {
    return jspb.Message.ASSUME_LOCAL_ARRAYS ? v instanceof Array : Array.isArray(v);
  }, jspb.Message.isExtensionObject_ = function(v) {
    return v !== null && typeof v == "object" && !jspb.Message.isArray_(v) && !(jspb.Message.SUPPORTS_UINT8ARRAY_ && v instanceof Uint8Array);
  }, jspb.Message.initPivotAndExtensionObject_ = function(v, e) {
    var fe = v.array.length, be = -1;
    if (fe && (be = fe - 1, fe = v.array[be], jspb.Message.isExtensionObject_(fe))) {
      v.pivot_ = jspb.Message.getFieldNumber_(v, be), v.extensionObject_ = fe;
      return;
    }
    -1 < e ? (v.pivot_ = Math.max(e, jspb.Message.getFieldNumber_(v, be + 1)), v.extensionObject_ = null) : v.pivot_ = Number.MAX_VALUE;
  }, jspb.Message.maybeInitEmptyExtensionObject_ = function(v) {
    var e = jspb.Message.getIndex_(v, v.pivot_);
    v.array[e] || (v.extensionObject_ = v.array[e] = {});
  }, jspb.Message.toObjectList = function(v, e, fe) {
    for (var be = [], ye = 0; ye < v.length; ye++)
      be[ye] = e.call(v[ye], fe, v[ye]);
    return be;
  }, goog.exportProperty(jspb.Message, "toObjectList", jspb.Message.toObjectList), jspb.Message.toObjectExtension = function(v, e, fe, be, ye) {
    for (var ve in fe) {
      var Ee = fe[ve], Se = be.call(v, Ee);
      if (Se != null) {
        for (var Oe in Ee.fieldName)
          if (Ee.fieldName.hasOwnProperty(Oe))
            break;
        e[Oe] = Ee.toObjectFn ? Ee.isRepeated ? jspb.Message.toObjectList(Se, Ee.toObjectFn, ye) : Ee.toObjectFn(ye, Se) : Se;
      }
    }
  }, goog.exportProperty(jspb.Message, "toObjectExtension", jspb.Message.toObjectExtension), jspb.Message.serializeBinaryExtensions = function(v, e, fe, be) {
    for (var ye in fe) {
      var ve = fe[ye], Ee = ve.fieldInfo;
      if (!ve.binaryWriterFn)
        throw Error("Message extension present that was generated without binary serialization support");
      var Se = be.call(v, Ee);
      if (Se != null)
        if (Ee.isMessageType())
          if (ve.binaryMessageSerializeFn)
            ve.binaryWriterFn.call(e, Ee.fieldIndex, Se, ve.binaryMessageSerializeFn);
          else
            throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
        else
          ve.binaryWriterFn.call(e, Ee.fieldIndex, Se);
    }
  }, goog.exportProperty(jspb.Message, "serializeBinaryExtensions", jspb.Message.serializeBinaryExtensions), jspb.Message.readBinaryExtension = function(v, e, fe, be, ye) {
    var ve = fe[e.getFieldNumber()];
    if (ve) {
      if (fe = ve.fieldInfo, !ve.binaryReaderFn)
        throw Error("Deserializing extension whose generated code does not support binary format");
      if (fe.isMessageType()) {
        var Ee = new fe.ctor();
        ve.binaryReaderFn.call(e, Ee, ve.binaryMessageDeserializeFn);
      } else
        Ee = ve.binaryReaderFn.call(e);
      fe.isRepeated && !ve.isPacked ? (e = be.call(v, fe)) ? e.push(Ee) : ye.call(v, fe, [Ee]) : ye.call(v, fe, Ee);
    } else
      e.skipField();
  }, goog.exportProperty(jspb.Message, "readBinaryExtension", jspb.Message.readBinaryExtension), jspb.Message.getField = function(v, e) {
    if (e < v.pivot_) {
      e = jspb.Message.getIndex_(v, e);
      var fe = v.array[e];
      return fe === jspb.Message.EMPTY_LIST_SENTINEL_ ? v.array[e] = [] : fe;
    }
    if (v.extensionObject_)
      return fe = v.extensionObject_[e], fe === jspb.Message.EMPTY_LIST_SENTINEL_ ? v.extensionObject_[e] = [] : fe;
  }, goog.exportProperty(jspb.Message, "getField", jspb.Message.getField), jspb.Message.getRepeatedField = function(v, e) {
    return jspb.Message.getField(v, e);
  }, goog.exportProperty(jspb.Message, "getRepeatedField", jspb.Message.getRepeatedField), jspb.Message.getOptionalFloatingPointField = function(v, e) {
    return v = jspb.Message.getField(v, e), v == null ? v : +v;
  }, goog.exportProperty(jspb.Message, "getOptionalFloatingPointField", jspb.Message.getOptionalFloatingPointField), jspb.Message.getBooleanField = function(v, e) {
    return v = jspb.Message.getField(v, e), v == null ? v : !!v;
  }, goog.exportProperty(jspb.Message, "getBooleanField", jspb.Message.getBooleanField), jspb.Message.getRepeatedFloatingPointField = function(v, e) {
    var fe = jspb.Message.getRepeatedField(v, e);
    if (v.convertedPrimitiveFields_ || (v.convertedPrimitiveFields_ = {}), !v.convertedPrimitiveFields_[e]) {
      for (var be = 0; be < fe.length; be++)
        fe[be] = +fe[be];
      v.convertedPrimitiveFields_[e] = !0;
    }
    return fe;
  }, goog.exportProperty(jspb.Message, "getRepeatedFloatingPointField", jspb.Message.getRepeatedFloatingPointField), jspb.Message.getRepeatedBooleanField = function(v, e) {
    var fe = jspb.Message.getRepeatedField(v, e);
    if (v.convertedPrimitiveFields_ || (v.convertedPrimitiveFields_ = {}), !v.convertedPrimitiveFields_[e]) {
      for (var be = 0; be < fe.length; be++)
        fe[be] = !!fe[be];
      v.convertedPrimitiveFields_[e] = !0;
    }
    return fe;
  }, goog.exportProperty(jspb.Message, "getRepeatedBooleanField", jspb.Message.getRepeatedBooleanField), jspb.Message.bytesAsB64 = function(v) {
    return v == null || typeof v == "string" ? v : jspb.Message.SUPPORTS_UINT8ARRAY_ && v instanceof Uint8Array ? goog.crypt.base64.encodeByteArray(v) : (jspb.asserts.fail("Cannot coerce to b64 string: " + goog.typeOf(v)), null);
  }, goog.exportProperty(jspb.Message, "bytesAsB64", jspb.Message.bytesAsB64), jspb.Message.bytesAsU8 = function(v) {
    return v == null || v instanceof Uint8Array ? v : typeof v == "string" ? goog.crypt.base64.decodeStringToUint8Array(v) : (jspb.asserts.fail("Cannot coerce to Uint8Array: " + goog.typeOf(v)), null);
  }, goog.exportProperty(jspb.Message, "bytesAsU8", jspb.Message.bytesAsU8), jspb.Message.bytesListAsB64 = function(v) {
    return jspb.Message.assertConsistentTypes_(v), v.length && typeof v[0] != "string" ? goog.array.map(v, jspb.Message.bytesAsB64) : v;
  }, goog.exportProperty(jspb.Message, "bytesListAsB64", jspb.Message.bytesListAsB64), jspb.Message.bytesListAsU8 = function(v) {
    return jspb.Message.assertConsistentTypes_(v), !v.length || v[0] instanceof Uint8Array ? v : goog.array.map(v, jspb.Message.bytesAsU8);
  }, goog.exportProperty(jspb.Message, "bytesListAsU8", jspb.Message.bytesListAsU8), jspb.Message.assertConsistentTypes_ = function(v) {
    if (goog.DEBUG && v && 1 < v.length) {
      var e = goog.typeOf(v[0]);
      goog.array.forEach(v, function(fe) {
        goog.typeOf(fe) != e && jspb.asserts.fail("Inconsistent type in JSPB repeated field array. Got " + goog.typeOf(fe) + " expected " + e);
      });
    }
  }, jspb.Message.getFieldWithDefault = function(v, e, fe) {
    return v = jspb.Message.getField(v, e), v ?? fe;
  }, goog.exportProperty(jspb.Message, "getFieldWithDefault", jspb.Message.getFieldWithDefault), jspb.Message.getBooleanFieldWithDefault = function(v, e, fe) {
    return v = jspb.Message.getBooleanField(v, e), v ?? fe;
  }, goog.exportProperty(jspb.Message, "getBooleanFieldWithDefault", jspb.Message.getBooleanFieldWithDefault), jspb.Message.getFloatingPointFieldWithDefault = function(v, e, fe) {
    return v = jspb.Message.getOptionalFloatingPointField(v, e), v ?? fe;
  }, goog.exportProperty(jspb.Message, "getFloatingPointFieldWithDefault", jspb.Message.getFloatingPointFieldWithDefault), jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault, goog.exportProperty(jspb.Message, "getFieldProto3", jspb.Message.getFieldProto3), jspb.Message.getMapField = function(v, e, fe, be) {
    if (v.wrappers_ || (v.wrappers_ = {}), e in v.wrappers_)
      return v.wrappers_[e];
    var ye = jspb.Message.getField(v, e);
    if (!ye) {
      if (fe)
        return;
      ye = [], jspb.Message.setField(v, e, ye);
    }
    return v.wrappers_[e] = new jspb.Map(ye, be);
  }, goog.exportProperty(jspb.Message, "getMapField", jspb.Message.getMapField), jspb.Message.setField = function(v, e, fe) {
    return jspb.asserts.assertInstanceof(v, jspb.Message), e < v.pivot_ ? v.array[jspb.Message.getIndex_(v, e)] = fe : (jspb.Message.maybeInitEmptyExtensionObject_(v), v.extensionObject_[e] = fe), v;
  }, goog.exportProperty(jspb.Message, "setField", jspb.Message.setField), jspb.Message.setProto3IntField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, 0);
  }, goog.exportProperty(jspb.Message, "setProto3IntField", jspb.Message.setProto3IntField), jspb.Message.setProto3FloatField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, 0);
  }, goog.exportProperty(jspb.Message, "setProto3FloatField", jspb.Message.setProto3FloatField), jspb.Message.setProto3BooleanField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, !1);
  }, goog.exportProperty(jspb.Message, "setProto3BooleanField", jspb.Message.setProto3BooleanField), jspb.Message.setProto3StringField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, "");
  }, goog.exportProperty(jspb.Message, "setProto3StringField", jspb.Message.setProto3StringField), jspb.Message.setProto3BytesField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, "");
  }, goog.exportProperty(jspb.Message, "setProto3BytesField", jspb.Message.setProto3BytesField), jspb.Message.setProto3EnumField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, 0);
  }, goog.exportProperty(jspb.Message, "setProto3EnumField", jspb.Message.setProto3EnumField), jspb.Message.setProto3StringIntField = function(v, e, fe) {
    return jspb.Message.setFieldIgnoringDefault_(v, e, fe, "0");
  }, goog.exportProperty(jspb.Message, "setProto3StringIntField", jspb.Message.setProto3StringIntField), jspb.Message.setFieldIgnoringDefault_ = function(v, e, fe, be) {
    return jspb.asserts.assertInstanceof(v, jspb.Message), fe !== be ? jspb.Message.setField(v, e, fe) : e < v.pivot_ ? v.array[jspb.Message.getIndex_(v, e)] = null : (jspb.Message.maybeInitEmptyExtensionObject_(v), delete v.extensionObject_[e]), v;
  }, jspb.Message.addToRepeatedField = function(v, e, fe, be) {
    return jspb.asserts.assertInstanceof(v, jspb.Message), e = jspb.Message.getRepeatedField(v, e), be != null ? e.splice(be, 0, fe) : e.push(fe), v;
  }, goog.exportProperty(jspb.Message, "addToRepeatedField", jspb.Message.addToRepeatedField), jspb.Message.setOneofField = function(v, e, fe, be) {
    return jspb.asserts.assertInstanceof(v, jspb.Message), (fe = jspb.Message.computeOneofCase(v, fe)) && fe !== e && be !== void 0 && (v.wrappers_ && fe in v.wrappers_ && (v.wrappers_[fe] = void 0), jspb.Message.setField(v, fe, void 0)), jspb.Message.setField(v, e, be);
  }, goog.exportProperty(jspb.Message, "setOneofField", jspb.Message.setOneofField), jspb.Message.computeOneofCase = function(v, e) {
    for (var fe, be, ye = 0; ye < e.length; ye++) {
      var ve = e[ye], Ee = jspb.Message.getField(v, ve);
      Ee != null && (fe = ve, be = Ee, jspb.Message.setField(v, ve, void 0));
    }
    return fe ? (jspb.Message.setField(v, fe, be), fe) : 0;
  }, goog.exportProperty(jspb.Message, "computeOneofCase", jspb.Message.computeOneofCase), jspb.Message.getWrapperField = function(v, e, fe, be) {
    if (v.wrappers_ || (v.wrappers_ = {}), !v.wrappers_[fe]) {
      var ye = jspb.Message.getField(v, fe);
      (be || ye) && (v.wrappers_[fe] = new e(ye));
    }
    return v.wrappers_[fe];
  }, goog.exportProperty(jspb.Message, "getWrapperField", jspb.Message.getWrapperField), jspb.Message.getRepeatedWrapperField = function(v, e, fe) {
    return jspb.Message.wrapRepeatedField_(v, e, fe), e = v.wrappers_[fe], e == jspb.Message.EMPTY_LIST_SENTINEL_ && (e = v.wrappers_[fe] = []), e;
  }, goog.exportProperty(jspb.Message, "getRepeatedWrapperField", jspb.Message.getRepeatedWrapperField), jspb.Message.wrapRepeatedField_ = function(v, e, fe) {
    if (v.wrappers_ || (v.wrappers_ = {}), !v.wrappers_[fe]) {
      for (var be = jspb.Message.getRepeatedField(v, fe), ye = [], ve = 0; ve < be.length; ve++)
        ye[ve] = new e(be[ve]);
      v.wrappers_[fe] = ye;
    }
  }, jspb.Message.setWrapperField = function(v, e, fe) {
    jspb.asserts.assertInstanceof(v, jspb.Message), v.wrappers_ || (v.wrappers_ = {});
    var be = fe && fe.toArray();
    return v.wrappers_[e] = fe, jspb.Message.setField(v, e, be);
  }, goog.exportProperty(jspb.Message, "setWrapperField", jspb.Message.setWrapperField), jspb.Message.setOneofWrapperField = function(v, e, fe, be) {
    jspb.asserts.assertInstanceof(v, jspb.Message), v.wrappers_ || (v.wrappers_ = {});
    var ye = be && be.toArray();
    return v.wrappers_[e] = be, jspb.Message.setOneofField(v, e, fe, ye);
  }, goog.exportProperty(jspb.Message, "setOneofWrapperField", jspb.Message.setOneofWrapperField), jspb.Message.setRepeatedWrapperField = function(v, e, fe) {
    jspb.asserts.assertInstanceof(v, jspb.Message), v.wrappers_ || (v.wrappers_ = {}), fe = fe || [];
    for (var be = [], ye = 0; ye < fe.length; ye++)
      be[ye] = fe[ye].toArray();
    return v.wrappers_[e] = fe, jspb.Message.setField(v, e, be);
  }, goog.exportProperty(jspb.Message, "setRepeatedWrapperField", jspb.Message.setRepeatedWrapperField), jspb.Message.addToRepeatedWrapperField = function(v, e, fe, be, ye) {
    jspb.Message.wrapRepeatedField_(v, be, e);
    var ve = v.wrappers_[e];
    return ve || (ve = v.wrappers_[e] = []), fe = fe || new be(), v = jspb.Message.getRepeatedField(v, e), ye != null ? (ve.splice(ye, 0, fe), v.splice(ye, 0, fe.toArray())) : (ve.push(fe), v.push(fe.toArray())), fe;
  }, goog.exportProperty(jspb.Message, "addToRepeatedWrapperField", jspb.Message.addToRepeatedWrapperField), jspb.Message.toMap = function(v, e, fe, be) {
    for (var ye = {}, ve = 0; ve < v.length; ve++)
      ye[e.call(v[ve])] = fe ? fe.call(v[ve], be, v[ve]) : v[ve];
    return ye;
  }, goog.exportProperty(jspb.Message, "toMap", jspb.Message.toMap), jspb.Message.prototype.syncMapFields_ = function() {
    if (this.wrappers_)
      for (var v in this.wrappers_) {
        var e = this.wrappers_[v];
        if (Array.isArray(e))
          for (var fe = 0; fe < e.length; fe++)
            e[fe] && e[fe].toArray();
        else
          e && e.toArray();
      }
  }, jspb.Message.prototype.toArray = function() {
    return this.syncMapFields_(), this.array;
  }, goog.exportProperty(jspb.Message.prototype, "toArray", jspb.Message.prototype.toArray), jspb.Message.GENERATE_TO_STRING && (jspb.Message.prototype.toString = function() {
    return this.syncMapFields_(), this.array.toString();
  }), jspb.Message.prototype.getExtension = function(v) {
    if (this.extensionObject_) {
      this.wrappers_ || (this.wrappers_ = {});
      var e = v.fieldIndex;
      if (v.isRepeated) {
        if (v.isMessageType())
          return this.wrappers_[e] || (this.wrappers_[e] = goog.array.map(this.extensionObject_[e] || [], function(fe) {
            return new v.ctor(fe);
          })), this.wrappers_[e];
      } else if (v.isMessageType())
        return !this.wrappers_[e] && this.extensionObject_[e] && (this.wrappers_[e] = new v.ctor(this.extensionObject_[e])), this.wrappers_[e];
      return this.extensionObject_[e];
    }
  }, goog.exportProperty(jspb.Message.prototype, "getExtension", jspb.Message.prototype.getExtension), jspb.Message.prototype.setExtension = function(v, e) {
    this.wrappers_ || (this.wrappers_ = {}), jspb.Message.maybeInitEmptyExtensionObject_(this);
    var fe = v.fieldIndex;
    return v.isRepeated ? (e = e || [], v.isMessageType() ? (this.wrappers_[fe] = e, this.extensionObject_[fe] = goog.array.map(e, function(be) {
      return be.toArray();
    })) : this.extensionObject_[fe] = e) : v.isMessageType() ? (this.wrappers_[fe] = e, this.extensionObject_[fe] = e && e.toArray()) : this.extensionObject_[fe] = e, this;
  }, goog.exportProperty(jspb.Message.prototype, "setExtension", jspb.Message.prototype.setExtension), jspb.Message.difference = function(v, e) {
    if (!(v instanceof e.constructor))
      throw Error("Messages have different types.");
    var fe = v.toArray();
    e = e.toArray();
    var be = [], ye = 0, ve = fe.length > e.length ? fe.length : e.length;
    for (v.getJsPbMessageId() && (be[0] = v.getJsPbMessageId(), ye = 1); ye < ve; ye++)
      jspb.Message.compareFields(fe[ye], e[ye]) || (be[ye] = e[ye]);
    return new v.constructor(be);
  }, goog.exportProperty(jspb.Message, "difference", jspb.Message.difference), jspb.Message.equals = function(v, e) {
    return v == e || !(!v || !e) && v instanceof e.constructor && jspb.Message.compareFields(v.toArray(), e.toArray());
  }, goog.exportProperty(jspb.Message, "equals", jspb.Message.equals), jspb.Message.compareExtensions = function(v, e) {
    v = v || {}, e = e || {};
    var fe = {}, be;
    for (be in v)
      fe[be] = 0;
    for (be in e)
      fe[be] = 0;
    for (be in fe)
      if (!jspb.Message.compareFields(v[be], e[be]))
        return !1;
    return !0;
  }, goog.exportProperty(jspb.Message, "compareExtensions", jspb.Message.compareExtensions), jspb.Message.compareFields = function(v, e) {
    if (v == e)
      return !0;
    if (!goog.isObject(v) || !goog.isObject(e))
      return typeof v == "number" && isNaN(v) || typeof e == "number" && isNaN(e) ? String(v) == String(e) : !1;
    if (v.constructor != e.constructor)
      return !1;
    if (jspb.Message.SUPPORTS_UINT8ARRAY_ && v.constructor === Uint8Array) {
      if (v.length != e.length)
        return !1;
      for (var fe = 0; fe < v.length; fe++)
        if (v[fe] != e[fe])
          return !1;
      return !0;
    }
    if (v.constructor === Array) {
      var be = void 0, ye = void 0, ve = Math.max(v.length, e.length);
      for (fe = 0; fe < ve; fe++) {
        var Ee = v[fe], Se = e[fe];
        if (Ee && Ee.constructor == Object && (jspb.asserts.assert(be === void 0), jspb.asserts.assert(fe === v.length - 1), be = Ee, Ee = void 0), Se && Se.constructor == Object && (jspb.asserts.assert(ye === void 0), jspb.asserts.assert(fe === e.length - 1), ye = Se, Se = void 0), !jspb.Message.compareFields(Ee, Se))
          return !1;
      }
      return be || ye ? (be = be || {}, ye = ye || {}, jspb.Message.compareExtensions(be, ye)) : !0;
    }
    if (v.constructor === Object)
      return jspb.Message.compareExtensions(v, e);
    throw Error("Invalid type in JSPB array");
  }, goog.exportProperty(jspb.Message, "compareFields", jspb.Message.compareFields), jspb.Message.prototype.cloneMessage = function() {
    return jspb.Message.cloneMessage(this);
  }, goog.exportProperty(jspb.Message.prototype, "cloneMessage", jspb.Message.prototype.cloneMessage), jspb.Message.prototype.clone = function() {
    return jspb.Message.cloneMessage(this);
  }, goog.exportProperty(jspb.Message.prototype, "clone", jspb.Message.prototype.clone), jspb.Message.clone = function(v) {
    return jspb.Message.cloneMessage(v);
  }, goog.exportProperty(jspb.Message, "clone", jspb.Message.clone), jspb.Message.cloneMessage = function(v) {
    return new v.constructor(jspb.Message.clone_(v.toArray()));
  }, jspb.Message.copyInto = function(v, e) {
    jspb.asserts.assertInstanceof(v, jspb.Message), jspb.asserts.assertInstanceof(e, jspb.Message), jspb.asserts.assert(v.constructor == e.constructor, "Copy source and target message should have the same type."), v = jspb.Message.clone(v);
    for (var fe = e.toArray(), be = v.toArray(), ye = fe.length = 0; ye < be.length; ye++)
      fe[ye] = be[ye];
    e.wrappers_ = v.wrappers_, e.extensionObject_ = v.extensionObject_;
  }, goog.exportProperty(jspb.Message, "copyInto", jspb.Message.copyInto), jspb.Message.clone_ = function(v) {
    if (Array.isArray(v)) {
      for (var e = Array(v.length), fe = 0; fe < v.length; fe++) {
        var be = v[fe];
        be != null && (e[fe] = typeof be == "object" ? jspb.Message.clone_(jspb.asserts.assert(be)) : be);
      }
      return e;
    }
    if (jspb.Message.SUPPORTS_UINT8ARRAY_ && v instanceof Uint8Array)
      return new Uint8Array(v);
    e = {};
    for (fe in v)
      be = v[fe], be != null && (e[fe] = typeof be == "object" ? jspb.Message.clone_(jspb.asserts.assert(be)) : be);
    return e;
  }, jspb.Message.registerMessageType = function(v, e) {
    e.messageId = v;
  }, goog.exportProperty(jspb.Message, "registerMessageType", jspb.Message.registerMessageType), jspb.Message.messageSetExtensions = {}, jspb.Message.messageSetExtensionsBinary = {}, jspb.Export = {}, exports.Map = jspb.Map, exports.Message = jspb.Message, exports.BinaryReader = jspb.BinaryReader, exports.BinaryWriter = jspb.BinaryWriter, exports.ExtensionFieldInfo = jspb.ExtensionFieldInfo, exports.ExtensionFieldBinaryInfo = jspb.ExtensionFieldBinaryInfo, exports.exportSymbol = goog.exportSymbol, exports.inherits = goog.inherits, exports.object = { extend: goog.object.extend }, exports.typeOf = goog.typeOf;
})(googleProtobuf);
(function(v) {
  var e = googleProtobuf, fe = e, be = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof be < "u" && be || typeof self < "u" && self || function() {
    return this;
  }.call(null) || Function("return this")();
  fe.exportSymbol("proto.google.protobuf.DescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.DescriptorProto.ExtensionRange", null, be), fe.exportSymbol("proto.google.protobuf.DescriptorProto.ReservedRange", null, be), fe.exportSymbol("proto.google.protobuf.EnumDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.EnumDescriptorProto.EnumReservedRange", null, be), fe.exportSymbol("proto.google.protobuf.EnumOptions", null, be), fe.exportSymbol("proto.google.protobuf.EnumValueDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.EnumValueOptions", null, be), fe.exportSymbol("proto.google.protobuf.ExtensionRangeOptions", null, be), fe.exportSymbol("proto.google.protobuf.FieldDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.FieldDescriptorProto.Label", null, be), fe.exportSymbol("proto.google.protobuf.FieldDescriptorProto.Type", null, be), fe.exportSymbol("proto.google.protobuf.FieldOptions", null, be), fe.exportSymbol("proto.google.protobuf.FieldOptions.CType", null, be), fe.exportSymbol("proto.google.protobuf.FieldOptions.JSType", null, be), fe.exportSymbol("proto.google.protobuf.FileDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.FileDescriptorSet", null, be), fe.exportSymbol("proto.google.protobuf.FileOptions", null, be), fe.exportSymbol("proto.google.protobuf.FileOptions.OptimizeMode", null, be), fe.exportSymbol("proto.google.protobuf.GeneratedCodeInfo", null, be), fe.exportSymbol("proto.google.protobuf.GeneratedCodeInfo.Annotation", null, be), fe.exportSymbol("proto.google.protobuf.MessageOptions", null, be), fe.exportSymbol("proto.google.protobuf.MethodDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.MethodOptions", null, be), fe.exportSymbol("proto.google.protobuf.MethodOptions.IdempotencyLevel", null, be), fe.exportSymbol("proto.google.protobuf.OneofDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.OneofOptions", null, be), fe.exportSymbol("proto.google.protobuf.ServiceDescriptorProto", null, be), fe.exportSymbol("proto.google.protobuf.ServiceOptions", null, be), fe.exportSymbol("proto.google.protobuf.SourceCodeInfo", null, be), fe.exportSymbol("proto.google.protobuf.SourceCodeInfo.Location", null, be), fe.exportSymbol("proto.google.protobuf.UninterpretedOption", null, be), fe.exportSymbol("proto.google.protobuf.UninterpretedOption.NamePart", null, be), proto.google.protobuf.FileDescriptorSet = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.FileDescriptorSet.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.FileDescriptorSet, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.FileDescriptorSet.displayName = "proto.google.protobuf.FileDescriptorSet"), proto.google.protobuf.FileDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.FileDescriptorProto.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.FileDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.FileDescriptorProto.displayName = "proto.google.protobuf.FileDescriptorProto"), proto.google.protobuf.DescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.DescriptorProto.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.DescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.DescriptorProto.displayName = "proto.google.protobuf.DescriptorProto"), proto.google.protobuf.DescriptorProto.ExtensionRange = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.DescriptorProto.ExtensionRange, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.DescriptorProto.ExtensionRange.displayName = "proto.google.protobuf.DescriptorProto.ExtensionRange"), proto.google.protobuf.DescriptorProto.ReservedRange = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.DescriptorProto.ReservedRange, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.DescriptorProto.ReservedRange.displayName = "proto.google.protobuf.DescriptorProto.ReservedRange"), proto.google.protobuf.ExtensionRangeOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.ExtensionRangeOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.ExtensionRangeOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.ExtensionRangeOptions.displayName = "proto.google.protobuf.ExtensionRangeOptions"), proto.google.protobuf.ExtensionRangeOptions.extensions = {}, proto.google.protobuf.ExtensionRangeOptions.extensionsBinary = {}, proto.google.protobuf.FieldDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.FieldDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.FieldDescriptorProto.displayName = "proto.google.protobuf.FieldDescriptorProto"), proto.google.protobuf.OneofDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.OneofDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.OneofDescriptorProto.displayName = "proto.google.protobuf.OneofDescriptorProto"), proto.google.protobuf.EnumDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.EnumDescriptorProto.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.EnumDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.EnumDescriptorProto.displayName = "proto.google.protobuf.EnumDescriptorProto"), proto.google.protobuf.EnumDescriptorProto.EnumReservedRange = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.displayName = "proto.google.protobuf.EnumDescriptorProto.EnumReservedRange"), proto.google.protobuf.EnumValueDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.EnumValueDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.EnumValueDescriptorProto.displayName = "proto.google.protobuf.EnumValueDescriptorProto"), proto.google.protobuf.ServiceDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.ServiceDescriptorProto.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.ServiceDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.ServiceDescriptorProto.displayName = "proto.google.protobuf.ServiceDescriptorProto"), proto.google.protobuf.MethodDescriptorProto = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.MethodDescriptorProto, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.MethodDescriptorProto.displayName = "proto.google.protobuf.MethodDescriptorProto"), proto.google.protobuf.FileOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.FileOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.FileOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.FileOptions.displayName = "proto.google.protobuf.FileOptions"), proto.google.protobuf.FileOptions.extensions = {}, proto.google.protobuf.FileOptions.extensionsBinary = {}, proto.google.protobuf.MessageOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.MessageOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.MessageOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.MessageOptions.displayName = "proto.google.protobuf.MessageOptions"), proto.google.protobuf.MessageOptions.extensions = {}, proto.google.protobuf.MessageOptions.extensionsBinary = {}, proto.google.protobuf.FieldOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.FieldOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.FieldOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.FieldOptions.displayName = "proto.google.protobuf.FieldOptions"), proto.google.protobuf.FieldOptions.extensions = {}, proto.google.protobuf.FieldOptions.extensionsBinary = {}, proto.google.protobuf.OneofOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.OneofOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.OneofOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.OneofOptions.displayName = "proto.google.protobuf.OneofOptions"), proto.google.protobuf.OneofOptions.extensions = {}, proto.google.protobuf.OneofOptions.extensionsBinary = {}, proto.google.protobuf.EnumOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.EnumOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.EnumOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.EnumOptions.displayName = "proto.google.protobuf.EnumOptions"), proto.google.protobuf.EnumOptions.extensions = {}, proto.google.protobuf.EnumOptions.extensionsBinary = {}, proto.google.protobuf.EnumValueOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.EnumValueOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.EnumValueOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.EnumValueOptions.displayName = "proto.google.protobuf.EnumValueOptions"), proto.google.protobuf.EnumValueOptions.extensions = {}, proto.google.protobuf.EnumValueOptions.extensionsBinary = {}, proto.google.protobuf.ServiceOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.ServiceOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.ServiceOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.ServiceOptions.displayName = "proto.google.protobuf.ServiceOptions"), proto.google.protobuf.ServiceOptions.extensions = {}, proto.google.protobuf.ServiceOptions.extensionsBinary = {}, proto.google.protobuf.MethodOptions = function(ye) {
    e.Message.initialize(this, ye, 0, 500, proto.google.protobuf.MethodOptions.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.MethodOptions, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.MethodOptions.displayName = "proto.google.protobuf.MethodOptions"), proto.google.protobuf.MethodOptions.extensions = {}, proto.google.protobuf.MethodOptions.extensionsBinary = {}, proto.google.protobuf.UninterpretedOption = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.UninterpretedOption.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.UninterpretedOption, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.UninterpretedOption.displayName = "proto.google.protobuf.UninterpretedOption"), proto.google.protobuf.UninterpretedOption.NamePart = function(ye) {
    e.Message.initialize(this, ye, 0, -1, null, null);
  }, fe.inherits(proto.google.protobuf.UninterpretedOption.NamePart, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.UninterpretedOption.NamePart.displayName = "proto.google.protobuf.UninterpretedOption.NamePart"), proto.google.protobuf.SourceCodeInfo = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.SourceCodeInfo.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.SourceCodeInfo, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.SourceCodeInfo.displayName = "proto.google.protobuf.SourceCodeInfo"), proto.google.protobuf.SourceCodeInfo.Location = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.SourceCodeInfo.Location.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.SourceCodeInfo.Location, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.SourceCodeInfo.Location.displayName = "proto.google.protobuf.SourceCodeInfo.Location"), proto.google.protobuf.GeneratedCodeInfo = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.GeneratedCodeInfo.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.GeneratedCodeInfo, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.GeneratedCodeInfo.displayName = "proto.google.protobuf.GeneratedCodeInfo"), proto.google.protobuf.GeneratedCodeInfo.Annotation = function(ye) {
    e.Message.initialize(this, ye, 0, -1, proto.google.protobuf.GeneratedCodeInfo.Annotation.repeatedFields_, null);
  }, fe.inherits(proto.google.protobuf.GeneratedCodeInfo.Annotation, e.Message), fe.DEBUG && !COMPILED && (proto.google.protobuf.GeneratedCodeInfo.Annotation.displayName = "proto.google.protobuf.GeneratedCodeInfo.Annotation"), proto.google.protobuf.FileDescriptorSet.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FileDescriptorSet.prototype.toObject = function(ye) {
    return proto.google.protobuf.FileDescriptorSet.toObject(ye, this);
  }, proto.google.protobuf.FileDescriptorSet.toObject = function(ye, ve) {
    var Ee = {
      fileList: e.Message.toObjectList(
        ve.getFileList(),
        proto.google.protobuf.FileDescriptorProto.toObject,
        ye
      )
    };
    return ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.FileDescriptorSet.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.FileDescriptorSet();
    return proto.google.protobuf.FileDescriptorSet.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.FileDescriptorSet.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = new proto.google.protobuf.FileDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader), ye.addFile(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.FileDescriptorSet.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.FileDescriptorSet.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.FileDescriptorSet.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getFileList(), Ee.length > 0 && ve.writeRepeatedMessage(
      1,
      Ee,
      proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter
    );
  }, proto.google.protobuf.FileDescriptorSet.prototype.getFileList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FileDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FileDescriptorProto, 1)
    );
  }, proto.google.protobuf.FileDescriptorSet.prototype.setFileList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 1, ye);
  }, proto.google.protobuf.FileDescriptorSet.prototype.addFile = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 1, ye, proto.google.protobuf.FileDescriptorProto, ve);
  }, proto.google.protobuf.FileDescriptorSet.prototype.clearFileList = function() {
    return this.setFileList([]);
  }, proto.google.protobuf.FileDescriptorProto.repeatedFields_ = [3, 10, 11, 4, 5, 6, 7], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FileDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.FileDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.FileDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      pb_package: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee,
      dependencyList: (Ee = e.Message.getRepeatedField(ve, 3)) == null ? void 0 : Ee,
      publicDependencyList: (Ee = e.Message.getRepeatedField(ve, 10)) == null ? void 0 : Ee,
      weakDependencyList: (Ee = e.Message.getRepeatedField(ve, 11)) == null ? void 0 : Ee,
      messageTypeList: e.Message.toObjectList(
        ve.getMessageTypeList(),
        proto.google.protobuf.DescriptorProto.toObject,
        ye
      ),
      enumTypeList: e.Message.toObjectList(
        ve.getEnumTypeList(),
        proto.google.protobuf.EnumDescriptorProto.toObject,
        ye
      ),
      serviceList: e.Message.toObjectList(
        ve.getServiceList(),
        proto.google.protobuf.ServiceDescriptorProto.toObject,
        ye
      ),
      extensionList: e.Message.toObjectList(
        ve.getExtensionList(),
        proto.google.protobuf.FieldDescriptorProto.toObject,
        ye
      ),
      options: (Ee = ve.getOptions()) && proto.google.protobuf.FileOptions.toObject(ye, Ee),
      sourceCodeInfo: (Ee = ve.getSourceCodeInfo()) && proto.google.protobuf.SourceCodeInfo.toObject(ye, Ee),
      syntax: (Ee = e.Message.getField(ve, 12)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.FileDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.FileDescriptorProto();
    return proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(xe);
          break;
        case 2:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.setPackage(xe);
          break;
        case 3:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.addDependency(xe);
          break;
        case 10:
          for (var Oe = (
            /** @type {!Array<number>} */
            ve.isDelimited() ? ve.readPackedInt32() : [ve.readInt32()]
          ), Se = 0; Se < Oe.length; Se++)
            ye.addPublicDependency(Oe[Se]);
          break;
        case 11:
          for (var Oe = (
            /** @type {!Array<number>} */
            ve.isDelimited() ? ve.readPackedInt32() : [ve.readInt32()]
          ), Se = 0; Se < Oe.length; Se++)
            ye.addWeakDependency(Oe[Se]);
          break;
        case 4:
          var xe = new proto.google.protobuf.DescriptorProto();
          ve.readMessage(xe, proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader), ye.addMessageType(xe);
          break;
        case 5:
          var xe = new proto.google.protobuf.EnumDescriptorProto();
          ve.readMessage(xe, proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader), ye.addEnumType(xe);
          break;
        case 6:
          var xe = new proto.google.protobuf.ServiceDescriptorProto();
          ve.readMessage(xe, proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader), ye.addService(xe);
          break;
        case 7:
          var xe = new proto.google.protobuf.FieldDescriptorProto();
          ve.readMessage(xe, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader), ye.addExtension$(xe);
          break;
        case 8:
          var xe = new proto.google.protobuf.FileOptions();
          ve.readMessage(xe, proto.google.protobuf.FileOptions.deserializeBinaryFromReader), ye.setOptions(xe);
          break;
        case 9:
          var xe = new proto.google.protobuf.SourceCodeInfo();
          ve.readMessage(xe, proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader), ye.setSourceCodeInfo(xe);
          break;
        case 12:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.setSyntax(xe);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.FileDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 2), Ee != null && ve.writeString(
      2,
      Ee
    ), Ee = ye.getDependencyList(), Ee.length > 0 && ve.writeRepeatedString(
      3,
      Ee
    ), Ee = ye.getPublicDependencyList(), Ee.length > 0 && ve.writeRepeatedInt32(
      10,
      Ee
    ), Ee = ye.getWeakDependencyList(), Ee.length > 0 && ve.writeRepeatedInt32(
      11,
      Ee
    ), Ee = ye.getMessageTypeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      4,
      Ee,
      proto.google.protobuf.DescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getEnumTypeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      5,
      Ee,
      proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getServiceList(), Ee.length > 0 && ve.writeRepeatedMessage(
      6,
      Ee,
      proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getExtensionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      7,
      Ee,
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      8,
      Ee,
      proto.google.protobuf.FileOptions.serializeBinaryToWriter
    ), Ee = ye.getSourceCodeInfo(), Ee != null && ve.writeMessage(
      9,
      Ee,
      proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 12), Ee != null && ve.writeString(
      12,
      Ee
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setPackage = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearPackage = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasPackage = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getDependencyList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 3)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setDependencyList = function(ye) {
    return e.Message.setField(this, 3, ye || []);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addDependency = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 3, ye, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearDependencyList = function() {
    return this.setDependencyList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getPublicDependencyList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 10)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setPublicDependencyList = function(ye) {
    return e.Message.setField(this, 10, ye || []);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addPublicDependency = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 10, ye, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearPublicDependencyList = function() {
    return this.setPublicDependencyList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getWeakDependencyList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 11)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setWeakDependencyList = function(ye) {
    return e.Message.setField(this, 11, ye || []);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addWeakDependency = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 11, ye, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearWeakDependencyList = function() {
    return this.setWeakDependencyList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getMessageTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto, 4)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setMessageTypeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 4, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addMessageType = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 4, ye, proto.google.protobuf.DescriptorProto, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearMessageTypeList = function() {
    return this.setMessageTypeList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getEnumTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto, 5)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setEnumTypeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 5, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addEnumType = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 5, ye, proto.google.protobuf.EnumDescriptorProto, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearEnumTypeList = function() {
    return this.setEnumTypeList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getServiceList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.ServiceDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.ServiceDescriptorProto, 6)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setServiceList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 6, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addService = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 6, ye, proto.google.protobuf.ServiceDescriptorProto, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearServiceList = function() {
    return this.setServiceList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getExtensionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 7)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setExtensionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 7, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addExtension$ = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 7, ye, proto.google.protobuf.FieldDescriptorProto, ve);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearExtensionList = function() {
    return this.setExtensionList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.FileOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.FileOptions, 8)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 8, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getSourceCodeInfo = function() {
    return (
      /** @type{?proto.google.protobuf.SourceCodeInfo} */
      e.Message.getWrapperField(this, proto.google.protobuf.SourceCodeInfo, 9)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setSourceCodeInfo = function(ye) {
    return e.Message.setWrapperField(this, 9, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearSourceCodeInfo = function() {
    return this.setSourceCodeInfo(void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasSourceCodeInfo = function() {
    return e.Message.getField(this, 9) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getSyntax = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 12, "")
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setSyntax = function(ye) {
    return e.Message.setField(this, 12, ye);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearSyntax = function() {
    return e.Message.setField(this, 12, void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasSyntax = function() {
    return e.Message.getField(this, 12) != null;
  }, proto.google.protobuf.DescriptorProto.repeatedFields_ = [2, 6, 3, 4, 5, 8, 9, 10], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.DescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.DescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      fieldList: e.Message.toObjectList(
        ve.getFieldList(),
        proto.google.protobuf.FieldDescriptorProto.toObject,
        ye
      ),
      extensionList: e.Message.toObjectList(
        ve.getExtensionList(),
        proto.google.protobuf.FieldDescriptorProto.toObject,
        ye
      ),
      nestedTypeList: e.Message.toObjectList(
        ve.getNestedTypeList(),
        proto.google.protobuf.DescriptorProto.toObject,
        ye
      ),
      enumTypeList: e.Message.toObjectList(
        ve.getEnumTypeList(),
        proto.google.protobuf.EnumDescriptorProto.toObject,
        ye
      ),
      extensionRangeList: e.Message.toObjectList(
        ve.getExtensionRangeList(),
        proto.google.protobuf.DescriptorProto.ExtensionRange.toObject,
        ye
      ),
      oneofDeclList: e.Message.toObjectList(
        ve.getOneofDeclList(),
        proto.google.protobuf.OneofDescriptorProto.toObject,
        ye
      ),
      options: (Ee = ve.getOptions()) && proto.google.protobuf.MessageOptions.toObject(ye, Ee),
      reservedRangeList: e.Message.toObjectList(
        ve.getReservedRangeList(),
        proto.google.protobuf.DescriptorProto.ReservedRange.toObject,
        ye
      ),
      reservedNameList: (Ee = e.Message.getRepeatedField(ve, 10)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.DescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.DescriptorProto();
    return proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 2:
          var Se = new proto.google.protobuf.FieldDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader), ye.addField(Se);
          break;
        case 6:
          var Se = new proto.google.protobuf.FieldDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader), ye.addExtension$(Se);
          break;
        case 3:
          var Se = new proto.google.protobuf.DescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader), ye.addNestedType(Se);
          break;
        case 4:
          var Se = new proto.google.protobuf.EnumDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader), ye.addEnumType(Se);
          break;
        case 5:
          var Se = new proto.google.protobuf.DescriptorProto.ExtensionRange();
          ve.readMessage(Se, proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader), ye.addExtensionRange(Se);
          break;
        case 8:
          var Se = new proto.google.protobuf.OneofDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader), ye.addOneofDecl(Se);
          break;
        case 7:
          var Se = new proto.google.protobuf.MessageOptions();
          ve.readMessage(Se, proto.google.protobuf.MessageOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        case 9:
          var Se = new proto.google.protobuf.DescriptorProto.ReservedRange();
          ve.readMessage(Se, proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader), ye.addReservedRange(Se);
          break;
        case 10:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.addReservedName(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.DescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.DescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.DescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = ye.getFieldList(), Ee.length > 0 && ve.writeRepeatedMessage(
      2,
      Ee,
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getExtensionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      6,
      Ee,
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getNestedTypeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      3,
      Ee,
      proto.google.protobuf.DescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getEnumTypeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      4,
      Ee,
      proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getExtensionRangeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      5,
      Ee,
      proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter
    ), Ee = ye.getOneofDeclList(), Ee.length > 0 && ve.writeRepeatedMessage(
      8,
      Ee,
      proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      7,
      Ee,
      proto.google.protobuf.MessageOptions.serializeBinaryToWriter
    ), Ee = ye.getReservedRangeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      9,
      Ee,
      proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter
    ), Ee = ye.getReservedNameList(), Ee.length > 0 && ve.writeRepeatedString(
      10,
      Ee
    );
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.toObject = function(ye) {
    return proto.google.protobuf.DescriptorProto.ExtensionRange.toObject(ye, this);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.toObject = function(ye, ve) {
    var Ee, Se = {
      start: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      end: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee,
      options: (Ee = ve.getOptions()) && proto.google.protobuf.ExtensionRangeOptions.toObject(ye, Ee)
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.DescriptorProto.ExtensionRange();
    return proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setStart(Se);
          break;
        case 2:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setEnd(Se);
          break;
        case 3:
          var Se = new proto.google.protobuf.ExtensionRangeOptions();
          ve.readMessage(Se, proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {number} */
    e.Message.getField(ye, 1), Ee != null && ve.writeInt32(
      1,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 2), Ee != null && ve.writeInt32(
      2,
      Ee
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      3,
      Ee,
      proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getStart = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setStart = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearStart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasStart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setEnd = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearEnd = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasEnd = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.ExtensionRangeOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.ExtensionRangeOptions, 3)
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 3, ye);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DescriptorProto.ReservedRange.prototype.toObject = function(ye) {
    return proto.google.protobuf.DescriptorProto.ReservedRange.toObject(ye, this);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.toObject = function(ye, ve) {
    var Ee, Se = {
      start: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      end: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.DescriptorProto.ReservedRange();
    return proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setStart(Se);
          break;
        case 2:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setEnd(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {number} */
    e.Message.getField(ye, 1), Ee != null && ve.writeInt32(
      1,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 2), Ee != null && ve.writeInt32(
      2,
      Ee
    );
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.getStart = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.setStart = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.clearStart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.hasStart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.setEnd = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.clearEnd = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.hasEnd = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.DescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.DescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.DescriptorProto.prototype.getFieldList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 2)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setFieldList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 2, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addField = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 2, ye, proto.google.protobuf.FieldDescriptorProto, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearFieldList = function() {
    return this.setFieldList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getExtensionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 6)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setExtensionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 6, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addExtension$ = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 6, ye, proto.google.protobuf.FieldDescriptorProto, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearExtensionList = function() {
    return this.setExtensionList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getNestedTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto, 3)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setNestedTypeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 3, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addNestedType = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 3, ye, proto.google.protobuf.DescriptorProto, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearNestedTypeList = function() {
    return this.setNestedTypeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getEnumTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto, 4)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setEnumTypeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 4, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addEnumType = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 4, ye, proto.google.protobuf.EnumDescriptorProto, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearEnumTypeList = function() {
    return this.setEnumTypeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getExtensionRangeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto.ExtensionRange>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto.ExtensionRange, 5)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setExtensionRangeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 5, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addExtensionRange = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 5, ye, proto.google.protobuf.DescriptorProto.ExtensionRange, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearExtensionRangeList = function() {
    return this.setExtensionRangeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getOneofDeclList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.OneofDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.OneofDescriptorProto, 8)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setOneofDeclList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 8, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addOneofDecl = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 8, ye, proto.google.protobuf.OneofDescriptorProto, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearOneofDeclList = function() {
    return this.setOneofDeclList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.MessageOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.MessageOptions, 7)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 7, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.DescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.DescriptorProto.prototype.getReservedRangeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto.ReservedRange>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto.ReservedRange, 9)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setReservedRangeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 9, ye);
  }, proto.google.protobuf.DescriptorProto.prototype.addReservedRange = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 9, ye, proto.google.protobuf.DescriptorProto.ReservedRange, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearReservedRangeList = function() {
    return this.setReservedRangeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getReservedNameList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 10)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setReservedNameList = function(ye) {
    return e.Message.setField(this, 10, ye || []);
  }, proto.google.protobuf.DescriptorProto.prototype.addReservedName = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 10, ye, ve);
  }, proto.google.protobuf.DescriptorProto.prototype.clearReservedNameList = function() {
    return this.setReservedNameList([]);
  }, proto.google.protobuf.ExtensionRangeOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.ExtensionRangeOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.ExtensionRangeOptions.toObject(ye, this);
  }, proto.google.protobuf.ExtensionRangeOptions.toObject = function(ye, ve) {
    var Ee = {
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Ee,
      proto.google.protobuf.ExtensionRangeOptions.extensions,
      proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension,
      ye
    ), ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.ExtensionRangeOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.ExtensionRangeOptions();
    return proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.ExtensionRangeOptions.extensionsBinary,
            proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension,
            proto.google.protobuf.ExtensionRangeOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.ExtensionRangeOptions.extensionsBinary,
      proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension
    );
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FieldDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.FieldDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.FieldDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      number: (Ee = e.Message.getField(ve, 3)) == null ? void 0 : Ee,
      label: (Ee = e.Message.getField(ve, 4)) == null ? void 0 : Ee,
      type: (Ee = e.Message.getField(ve, 5)) == null ? void 0 : Ee,
      typeName: (Ee = e.Message.getField(ve, 6)) == null ? void 0 : Ee,
      extendee: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee,
      defaultValue: (Ee = e.Message.getField(ve, 7)) == null ? void 0 : Ee,
      oneofIndex: (Ee = e.Message.getField(ve, 9)) == null ? void 0 : Ee,
      jsonName: (Ee = e.Message.getField(ve, 10)) == null ? void 0 : Ee,
      options: (Ee = ve.getOptions()) && proto.google.protobuf.FieldOptions.toObject(ye, Ee),
      proto3Optional: (Ee = e.Message.getBooleanField(ve, 17)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.FieldDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.FieldDescriptorProto();
    return proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 3:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setNumber(Se);
          break;
        case 4:
          var Se = (
            /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */
            ve.readEnum()
          );
          ye.setLabel(Se);
          break;
        case 5:
          var Se = (
            /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */
            ve.readEnum()
          );
          ye.setType(Se);
          break;
        case 6:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setTypeName(Se);
          break;
        case 2:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setExtendee(Se);
          break;
        case 7:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setDefaultValue(Se);
          break;
        case 9:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setOneofIndex(Se);
          break;
        case 10:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setJsonName(Se);
          break;
        case 8:
          var Se = new proto.google.protobuf.FieldOptions();
          ve.readMessage(Se, proto.google.protobuf.FieldOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        case 17:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setProto3Optional(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 3), Ee != null && ve.writeInt32(
      3,
      Ee
    ), Ee = /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */
    e.Message.getField(ye, 4), Ee != null && ve.writeEnum(
      4,
      Ee
    ), Ee = /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */
    e.Message.getField(ye, 5), Ee != null && ve.writeEnum(
      5,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 6), Ee != null && ve.writeString(
      6,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 2), Ee != null && ve.writeString(
      2,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 7), Ee != null && ve.writeString(
      7,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 9), Ee != null && ve.writeInt32(
      9,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 10), Ee != null && ve.writeString(
      10,
      Ee
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      8,
      Ee,
      proto.google.protobuf.FieldOptions.serializeBinaryToWriter
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 17), Ee != null && ve.writeBool(
      17,
      Ee
    );
  }, proto.google.protobuf.FieldDescriptorProto.Type = {
    TYPE_DOUBLE: 1,
    TYPE_FLOAT: 2,
    TYPE_INT64: 3,
    TYPE_UINT64: 4,
    TYPE_INT32: 5,
    TYPE_FIXED64: 6,
    TYPE_FIXED32: 7,
    TYPE_BOOL: 8,
    TYPE_STRING: 9,
    TYPE_GROUP: 10,
    TYPE_MESSAGE: 11,
    TYPE_BYTES: 12,
    TYPE_UINT32: 13,
    TYPE_ENUM: 14,
    TYPE_SFIXED32: 15,
    TYPE_SFIXED64: 16,
    TYPE_SINT32: 17,
    TYPE_SINT64: 18
  }, proto.google.protobuf.FieldDescriptorProto.Label = {
    LABEL_OPTIONAL: 1,
    LABEL_REQUIRED: 2,
    LABEL_REPEATED: 3
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getNumber = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 3, 0)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setNumber = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearNumber = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasNumber = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getLabel = function() {
    return (
      /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */
      e.Message.getFieldWithDefault(this, 4, 1)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setLabel = function(ye) {
    return e.Message.setField(this, 4, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearLabel = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasLabel = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getType = function() {
    return (
      /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */
      e.Message.getFieldWithDefault(this, 5, 1)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setType = function(ye) {
    return e.Message.setField(this, 5, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearType = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasType = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getTypeName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 6, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setTypeName = function(ye) {
    return e.Message.setField(this, 6, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearTypeName = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasTypeName = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getExtendee = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setExtendee = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearExtendee = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasExtendee = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getDefaultValue = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 7, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setDefaultValue = function(ye) {
    return e.Message.setField(this, 7, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearDefaultValue = function() {
    return e.Message.setField(this, 7, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasDefaultValue = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getOneofIndex = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 9, 0)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setOneofIndex = function(ye) {
    return e.Message.setField(this, 9, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearOneofIndex = function() {
    return e.Message.setField(this, 9, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasOneofIndex = function() {
    return e.Message.getField(this, 9) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getJsonName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 10, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setJsonName = function(ye) {
    return e.Message.setField(this, 10, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearJsonName = function() {
    return e.Message.setField(this, 10, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasJsonName = function() {
    return e.Message.getField(this, 10) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.FieldOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.FieldOptions, 8)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 8, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getProto3Optional = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 17, !1)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setProto3Optional = function(ye) {
    return e.Message.setField(this, 17, ye);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearProto3Optional = function() {
    return e.Message.setField(this, 17, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasProto3Optional = function() {
    return e.Message.getField(this, 17) != null;
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.OneofDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.OneofDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.OneofDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      options: (Ee = ve.getOptions()) && proto.google.protobuf.OneofOptions.toObject(ye, Ee)
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.OneofDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.OneofDescriptorProto();
    return proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 2:
          var Se = new proto.google.protobuf.OneofOptions();
          ve.readMessage(Se, proto.google.protobuf.OneofOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.OneofDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      2,
      Ee,
      proto.google.protobuf.OneofOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.OneofDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.OneofDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.OneofDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.OneofOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.OneofOptions, 2)
    );
  }, proto.google.protobuf.OneofDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 2, ye);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumDescriptorProto.repeatedFields_ = [2, 4, 5], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.EnumDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.EnumDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      valueList: e.Message.toObjectList(
        ve.getValueList(),
        proto.google.protobuf.EnumValueDescriptorProto.toObject,
        ye
      ),
      options: (Ee = ve.getOptions()) && proto.google.protobuf.EnumOptions.toObject(ye, Ee),
      reservedRangeList: e.Message.toObjectList(
        ve.getReservedRangeList(),
        proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject,
        ye
      ),
      reservedNameList: (Ee = e.Message.getRepeatedField(ve, 5)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.EnumDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.EnumDescriptorProto();
    return proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 2:
          var Se = new proto.google.protobuf.EnumValueDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader), ye.addValue(Se);
          break;
        case 3:
          var Se = new proto.google.protobuf.EnumOptions();
          ve.readMessage(Se, proto.google.protobuf.EnumOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        case 4:
          var Se = new proto.google.protobuf.EnumDescriptorProto.EnumReservedRange();
          ve.readMessage(Se, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader), ye.addReservedRange(Se);
          break;
        case 5:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.addReservedName(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = ye.getValueList(), Ee.length > 0 && ve.writeRepeatedMessage(
      2,
      Ee,
      proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      3,
      Ee,
      proto.google.protobuf.EnumOptions.serializeBinaryToWriter
    ), Ee = ye.getReservedRangeList(), Ee.length > 0 && ve.writeRepeatedMessage(
      4,
      Ee,
      proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter
    ), Ee = ye.getReservedNameList(), Ee.length > 0 && ve.writeRepeatedString(
      5,
      Ee
    );
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.toObject = function(ye) {
    return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(ye, this);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject = function(ye, ve) {
    var Ee, Se = {
      start: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      end: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.EnumDescriptorProto.EnumReservedRange();
    return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setStart(Se);
          break;
        case 2:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setEnd(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {number} */
    e.Message.getField(ye, 1), Ee != null && ve.writeInt32(
      1,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 2), Ee != null && ve.writeInt32(
      2,
      Ee
    );
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.getStart = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.setStart = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.clearStart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.hasStart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.setEnd = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.clearEnd = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.hasEnd = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getValueList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumValueDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumValueDescriptorProto, 2)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setValueList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 2, ye);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.addValue = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 2, ye, proto.google.protobuf.EnumValueDescriptorProto, ve);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearValueList = function() {
    return this.setValueList([]);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.EnumOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.EnumOptions, 3)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 3, ye);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getReservedRangeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, 4)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setReservedRangeList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 4, ye);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.addReservedRange = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 4, ye, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, ve);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearReservedRangeList = function() {
    return this.setReservedRangeList([]);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getReservedNameList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 5)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setReservedNameList = function(ye) {
    return e.Message.setField(this, 5, ye || []);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.addReservedName = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 5, ye, ve);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearReservedNameList = function() {
    return this.setReservedNameList([]);
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumValueDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.EnumValueDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.EnumValueDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      number: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee,
      options: (Ee = ve.getOptions()) && proto.google.protobuf.EnumValueOptions.toObject(ye, Ee)
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.EnumValueDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.EnumValueDescriptorProto();
    return proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 2:
          var Se = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setNumber(Se);
          break;
        case 3:
          var Se = new proto.google.protobuf.EnumValueOptions();
          ve.readMessage(Se, proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 2), Ee != null && ve.writeInt32(
      2,
      Ee
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      3,
      Ee,
      proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.getNumber = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.setNumber = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.clearNumber = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.hasNumber = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.EnumValueOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.EnumValueOptions, 3)
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 3, ye);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.ServiceDescriptorProto.repeatedFields_ = [2], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.ServiceDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.ServiceDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.ServiceDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      methodList: e.Message.toObjectList(
        ve.getMethodList(),
        proto.google.protobuf.MethodDescriptorProto.toObject,
        ye
      ),
      options: (Ee = ve.getOptions()) && proto.google.protobuf.ServiceOptions.toObject(ye, Ee)
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.ServiceDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.ServiceDescriptorProto();
    return proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 2:
          var Se = new proto.google.protobuf.MethodDescriptorProto();
          ve.readMessage(Se, proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader), ye.addMethod(Se);
          break;
        case 3:
          var Se = new proto.google.protobuf.ServiceOptions();
          ve.readMessage(Se, proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = ye.getMethodList(), Ee.length > 0 && ve.writeRepeatedMessage(
      2,
      Ee,
      proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      3,
      Ee,
      proto.google.protobuf.ServiceOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.getMethodList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.MethodDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.MethodDescriptorProto, 2)
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.setMethodList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 2, ye);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.addMethod = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 2, ye, proto.google.protobuf.MethodDescriptorProto, ve);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.clearMethodList = function() {
    return this.setMethodList([]);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.ServiceOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.ServiceOptions, 3)
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 3, ye);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.MethodDescriptorProto.prototype.toObject = function(ye) {
    return proto.google.protobuf.MethodDescriptorProto.toObject(ye, this);
  }, proto.google.protobuf.MethodDescriptorProto.toObject = function(ye, ve) {
    var Ee, Se = {
      name: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      inputType: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee,
      outputType: (Ee = e.Message.getField(ve, 3)) == null ? void 0 : Ee,
      options: (Ee = ve.getOptions()) && proto.google.protobuf.MethodOptions.toObject(ye, Ee),
      clientStreaming: e.Message.getBooleanFieldWithDefault(ve, 5, !1),
      serverStreaming: e.Message.getBooleanFieldWithDefault(ve, 6, !1)
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.MethodDescriptorProto.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.MethodDescriptorProto();
    return proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setName(Se);
          break;
        case 2:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setInputType(Se);
          break;
        case 3:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setOutputType(Se);
          break;
        case 4:
          var Se = new proto.google.protobuf.MethodOptions();
          ve.readMessage(Se, proto.google.protobuf.MethodOptions.deserializeBinaryFromReader), ye.setOptions(Se);
          break;
        case 5:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setClientStreaming(Se);
          break;
        case 6:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setServerStreaming(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 2), Ee != null && ve.writeString(
      2,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 3), Ee != null && ve.writeString(
      3,
      Ee
    ), Ee = ye.getOptions(), Ee != null && ve.writeMessage(
      4,
      Ee,
      proto.google.protobuf.MethodOptions.serializeBinaryToWriter
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 5), Ee != null && ve.writeBool(
      5,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 6), Ee != null && ve.writeBool(
      6,
      Ee
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setName = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getInputType = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setInputType = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearInputType = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasInputType = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getOutputType = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 3, "")
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setOutputType = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearOutputType = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasOutputType = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.MethodOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.MethodOptions, 4)
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setOptions = function(ye) {
    return e.Message.setWrapperField(this, 4, ye);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getClientStreaming = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 5, !1)
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setClientStreaming = function(ye) {
    return e.Message.setField(this, 5, ye);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearClientStreaming = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasClientStreaming = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getServerStreaming = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 6, !1)
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setServerStreaming = function(ye) {
    return e.Message.setField(this, 6, ye);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearServerStreaming = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasServerStreaming = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.FileOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FileOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.FileOptions.toObject(ye, this);
  }, proto.google.protobuf.FileOptions.toObject = function(ye, ve) {
    var Ee, Se = {
      javaPackage: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      javaOuterClassname: (Ee = e.Message.getField(ve, 8)) == null ? void 0 : Ee,
      javaMultipleFiles: e.Message.getBooleanFieldWithDefault(ve, 10, !1),
      javaGenerateEqualsAndHash: (Ee = e.Message.getBooleanField(ve, 20)) == null ? void 0 : Ee,
      javaStringCheckUtf8: e.Message.getBooleanFieldWithDefault(ve, 27, !1),
      optimizeFor: e.Message.getFieldWithDefault(ve, 9, 1),
      goPackage: (Ee = e.Message.getField(ve, 11)) == null ? void 0 : Ee,
      ccGenericServices: e.Message.getBooleanFieldWithDefault(ve, 16, !1),
      javaGenericServices: e.Message.getBooleanFieldWithDefault(ve, 17, !1),
      pyGenericServices: e.Message.getBooleanFieldWithDefault(ve, 18, !1),
      phpGenericServices: e.Message.getBooleanFieldWithDefault(ve, 42, !1),
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 23, !1),
      ccEnableArenas: e.Message.getBooleanFieldWithDefault(ve, 31, !0),
      objcClassPrefix: (Ee = e.Message.getField(ve, 36)) == null ? void 0 : Ee,
      csharpNamespace: (Ee = e.Message.getField(ve, 37)) == null ? void 0 : Ee,
      swiftPrefix: (Ee = e.Message.getField(ve, 39)) == null ? void 0 : Ee,
      phpClassPrefix: (Ee = e.Message.getField(ve, 40)) == null ? void 0 : Ee,
      phpNamespace: (Ee = e.Message.getField(ve, 41)) == null ? void 0 : Ee,
      phpMetadataNamespace: (Ee = e.Message.getField(ve, 44)) == null ? void 0 : Ee,
      rubyPackage: (Ee = e.Message.getField(ve, 45)) == null ? void 0 : Ee,
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Se,
      proto.google.protobuf.FileOptions.extensions,
      proto.google.protobuf.FileOptions.prototype.getExtension,
      ye
    ), ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.FileOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.FileOptions();
    return proto.google.protobuf.FileOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.FileOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setJavaPackage(Se);
          break;
        case 8:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setJavaOuterClassname(Se);
          break;
        case 10:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setJavaMultipleFiles(Se);
          break;
        case 20:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setJavaGenerateEqualsAndHash(Se);
          break;
        case 27:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setJavaStringCheckUtf8(Se);
          break;
        case 9:
          var Se = (
            /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */
            ve.readEnum()
          );
          ye.setOptimizeFor(Se);
          break;
        case 11:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setGoPackage(Se);
          break;
        case 16:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setCcGenericServices(Se);
          break;
        case 17:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setJavaGenericServices(Se);
          break;
        case 18:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setPyGenericServices(Se);
          break;
        case 42:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setPhpGenericServices(Se);
          break;
        case 23:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 31:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setCcEnableArenas(Se);
          break;
        case 36:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setObjcClassPrefix(Se);
          break;
        case 37:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setCsharpNamespace(Se);
          break;
        case 39:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setSwiftPrefix(Se);
          break;
        case 40:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setPhpClassPrefix(Se);
          break;
        case 41:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setPhpNamespace(Se);
          break;
        case 44:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setPhpMetadataNamespace(Se);
          break;
        case 45:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setRubyPackage(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.FileOptions.extensionsBinary,
            proto.google.protobuf.FileOptions.prototype.getExtension,
            proto.google.protobuf.FileOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.FileOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.FileOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.FileOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 8), Ee != null && ve.writeString(
      8,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 10), Ee != null && ve.writeBool(
      10,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 20), Ee != null && ve.writeBool(
      20,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 27), Ee != null && ve.writeBool(
      27,
      Ee
    ), Ee = /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */
    e.Message.getField(ye, 9), Ee != null && ve.writeEnum(
      9,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 11), Ee != null && ve.writeString(
      11,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 16), Ee != null && ve.writeBool(
      16,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 17), Ee != null && ve.writeBool(
      17,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 18), Ee != null && ve.writeBool(
      18,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 42), Ee != null && ve.writeBool(
      42,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 23), Ee != null && ve.writeBool(
      23,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 31), Ee != null && ve.writeBool(
      31,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 36), Ee != null && ve.writeString(
      36,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 37), Ee != null && ve.writeString(
      37,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 39), Ee != null && ve.writeString(
      39,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 40), Ee != null && ve.writeString(
      40,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 41), Ee != null && ve.writeString(
      41,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 44), Ee != null && ve.writeString(
      44,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 45), Ee != null && ve.writeString(
      45,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.FileOptions.extensionsBinary,
      proto.google.protobuf.FileOptions.prototype.getExtension
    );
  }, proto.google.protobuf.FileOptions.OptimizeMode = {
    SPEED: 1,
    CODE_SIZE: 2,
    LITE_RUNTIME: 3
  }, proto.google.protobuf.FileOptions.prototype.getJavaPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaPackage = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaPackage = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaPackage = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaOuterClassname = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 8, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaOuterClassname = function(ye) {
    return e.Message.setField(this, 8, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaOuterClassname = function() {
    return e.Message.setField(this, 8, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaOuterClassname = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaMultipleFiles = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 10, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaMultipleFiles = function(ye) {
    return e.Message.setField(this, 10, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaMultipleFiles = function() {
    return e.Message.setField(this, 10, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaMultipleFiles = function() {
    return e.Message.getField(this, 10) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaGenerateEqualsAndHash = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 20, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaGenerateEqualsAndHash = function(ye) {
    return e.Message.setField(this, 20, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaGenerateEqualsAndHash = function() {
    return e.Message.setField(this, 20, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaGenerateEqualsAndHash = function() {
    return e.Message.getField(this, 20) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaStringCheckUtf8 = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 27, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaStringCheckUtf8 = function(ye) {
    return e.Message.setField(this, 27, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaStringCheckUtf8 = function() {
    return e.Message.setField(this, 27, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaStringCheckUtf8 = function() {
    return e.Message.getField(this, 27) != null;
  }, proto.google.protobuf.FileOptions.prototype.getOptimizeFor = function() {
    return (
      /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */
      e.Message.getFieldWithDefault(this, 9, 1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setOptimizeFor = function(ye) {
    return e.Message.setField(this, 9, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearOptimizeFor = function() {
    return e.Message.setField(this, 9, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasOptimizeFor = function() {
    return e.Message.getField(this, 9) != null;
  }, proto.google.protobuf.FileOptions.prototype.getGoPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 11, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setGoPackage = function(ye) {
    return e.Message.setField(this, 11, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearGoPackage = function() {
    return e.Message.setField(this, 11, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasGoPackage = function() {
    return e.Message.getField(this, 11) != null;
  }, proto.google.protobuf.FileOptions.prototype.getCcGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 16, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setCcGenericServices = function(ye) {
    return e.Message.setField(this, 16, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearCcGenericServices = function() {
    return e.Message.setField(this, 16, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasCcGenericServices = function() {
    return e.Message.getField(this, 16) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 17, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaGenericServices = function(ye) {
    return e.Message.setField(this, 17, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaGenericServices = function() {
    return e.Message.setField(this, 17, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaGenericServices = function() {
    return e.Message.getField(this, 17) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPyGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 18, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setPyGenericServices = function(ye) {
    return e.Message.setField(this, 18, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearPyGenericServices = function() {
    return e.Message.setField(this, 18, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPyGenericServices = function() {
    return e.Message.getField(this, 18) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 42, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpGenericServices = function(ye) {
    return e.Message.setField(this, 42, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpGenericServices = function() {
    return e.Message.setField(this, 42, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpGenericServices = function() {
    return e.Message.getField(this, 42) != null;
  }, proto.google.protobuf.FileOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 23, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 23, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 23, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 23) != null;
  }, proto.google.protobuf.FileOptions.prototype.getCcEnableArenas = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 31, !0)
    );
  }, proto.google.protobuf.FileOptions.prototype.setCcEnableArenas = function(ye) {
    return e.Message.setField(this, 31, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearCcEnableArenas = function() {
    return e.Message.setField(this, 31, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasCcEnableArenas = function() {
    return e.Message.getField(this, 31) != null;
  }, proto.google.protobuf.FileOptions.prototype.getObjcClassPrefix = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 36, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setObjcClassPrefix = function(ye) {
    return e.Message.setField(this, 36, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearObjcClassPrefix = function() {
    return e.Message.setField(this, 36, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasObjcClassPrefix = function() {
    return e.Message.getField(this, 36) != null;
  }, proto.google.protobuf.FileOptions.prototype.getCsharpNamespace = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 37, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setCsharpNamespace = function(ye) {
    return e.Message.setField(this, 37, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearCsharpNamespace = function() {
    return e.Message.setField(this, 37, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasCsharpNamespace = function() {
    return e.Message.getField(this, 37) != null;
  }, proto.google.protobuf.FileOptions.prototype.getSwiftPrefix = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 39, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setSwiftPrefix = function(ye) {
    return e.Message.setField(this, 39, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearSwiftPrefix = function() {
    return e.Message.setField(this, 39, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasSwiftPrefix = function() {
    return e.Message.getField(this, 39) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpClassPrefix = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 40, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpClassPrefix = function(ye) {
    return e.Message.setField(this, 40, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpClassPrefix = function() {
    return e.Message.setField(this, 40, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpClassPrefix = function() {
    return e.Message.getField(this, 40) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpNamespace = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 41, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpNamespace = function(ye) {
    return e.Message.setField(this, 41, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpNamespace = function() {
    return e.Message.setField(this, 41, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpNamespace = function() {
    return e.Message.getField(this, 41) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpMetadataNamespace = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 44, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpMetadataNamespace = function(ye) {
    return e.Message.setField(this, 44, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpMetadataNamespace = function() {
    return e.Message.setField(this, 44, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpMetadataNamespace = function() {
    return e.Message.getField(this, 44) != null;
  }, proto.google.protobuf.FileOptions.prototype.getRubyPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 45, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setRubyPackage = function(ye) {
    return e.Message.setField(this, 45, ye);
  }, proto.google.protobuf.FileOptions.prototype.clearRubyPackage = function() {
    return e.Message.setField(this, 45, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasRubyPackage = function() {
    return e.Message.getField(this, 45) != null;
  }, proto.google.protobuf.FileOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.FileOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.FileOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.FileOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.MessageOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.MessageOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.MessageOptions.toObject(ye, this);
  }, proto.google.protobuf.MessageOptions.toObject = function(ye, ve) {
    var Ee, Se = {
      messageSetWireFormat: e.Message.getBooleanFieldWithDefault(ve, 1, !1),
      noStandardDescriptorAccessor: e.Message.getBooleanFieldWithDefault(ve, 2, !1),
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 3, !1),
      mapEntry: (Ee = e.Message.getBooleanField(ve, 7)) == null ? void 0 : Ee,
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Se,
      proto.google.protobuf.MessageOptions.extensions,
      proto.google.protobuf.MessageOptions.prototype.getExtension,
      ye
    ), ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.MessageOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.MessageOptions();
    return proto.google.protobuf.MessageOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.MessageOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setMessageSetWireFormat(Se);
          break;
        case 2:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setNoStandardDescriptorAccessor(Se);
          break;
        case 3:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 7:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setMapEntry(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.MessageOptions.extensionsBinary,
            proto.google.protobuf.MessageOptions.prototype.getExtension,
            proto.google.protobuf.MessageOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.MessageOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.MessageOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.MessageOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {boolean} */
    e.Message.getField(ye, 1), Ee != null && ve.writeBool(
      1,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 2), Ee != null && ve.writeBool(
      2,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 3), Ee != null && ve.writeBool(
      3,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 7), Ee != null && ve.writeBool(
      7,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.MessageOptions.extensionsBinary,
      proto.google.protobuf.MessageOptions.prototype.getExtension
    );
  }, proto.google.protobuf.MessageOptions.prototype.getMessageSetWireFormat = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 1, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setMessageSetWireFormat = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.MessageOptions.prototype.clearMessageSetWireFormat = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasMessageSetWireFormat = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getNoStandardDescriptorAccessor = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setNoStandardDescriptorAccessor = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.MessageOptions.prototype.clearNoStandardDescriptorAccessor = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasNoStandardDescriptorAccessor = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 3, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.MessageOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getMapEntry = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 7, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setMapEntry = function(ye) {
    return e.Message.setField(this, 7, ye);
  }, proto.google.protobuf.MessageOptions.prototype.clearMapEntry = function() {
    return e.Message.setField(this, 7, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasMapEntry = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.MessageOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.MessageOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.FieldOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FieldOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.FieldOptions.toObject(ye, this);
  }, proto.google.protobuf.FieldOptions.toObject = function(ye, ve) {
    var Ee, Se = {
      ctype: e.Message.getFieldWithDefault(ve, 1, 0),
      packed: (Ee = e.Message.getBooleanField(ve, 2)) == null ? void 0 : Ee,
      jstype: e.Message.getFieldWithDefault(ve, 6, 0),
      lazy: e.Message.getBooleanFieldWithDefault(ve, 5, !1),
      unverifiedLazy: e.Message.getBooleanFieldWithDefault(ve, 15, !1),
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 3, !1),
      weak: e.Message.getBooleanFieldWithDefault(ve, 10, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Se,
      proto.google.protobuf.FieldOptions.extensions,
      proto.google.protobuf.FieldOptions.prototype.getExtension,
      ye
    ), ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.FieldOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.FieldOptions();
    return proto.google.protobuf.FieldOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.FieldOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {!proto.google.protobuf.FieldOptions.CType} */
            ve.readEnum()
          );
          ye.setCtype(Se);
          break;
        case 2:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setPacked(Se);
          break;
        case 6:
          var Se = (
            /** @type {!proto.google.protobuf.FieldOptions.JSType} */
            ve.readEnum()
          );
          ye.setJstype(Se);
          break;
        case 5:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setLazy(Se);
          break;
        case 15:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setUnverifiedLazy(Se);
          break;
        case 3:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 10:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setWeak(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.FieldOptions.extensionsBinary,
            proto.google.protobuf.FieldOptions.prototype.getExtension,
            proto.google.protobuf.FieldOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.FieldOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.FieldOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.FieldOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {!proto.google.protobuf.FieldOptions.CType} */
    e.Message.getField(ye, 1), Ee != null && ve.writeEnum(
      1,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 2), Ee != null && ve.writeBool(
      2,
      Ee
    ), Ee = /** @type {!proto.google.protobuf.FieldOptions.JSType} */
    e.Message.getField(ye, 6), Ee != null && ve.writeEnum(
      6,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 5), Ee != null && ve.writeBool(
      5,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 15), Ee != null && ve.writeBool(
      15,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 3), Ee != null && ve.writeBool(
      3,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 10), Ee != null && ve.writeBool(
      10,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.FieldOptions.extensionsBinary,
      proto.google.protobuf.FieldOptions.prototype.getExtension
    );
  }, proto.google.protobuf.FieldOptions.CType = {
    STRING: 0,
    CORD: 1,
    STRING_PIECE: 2
  }, proto.google.protobuf.FieldOptions.JSType = {
    JS_NORMAL: 0,
    JS_STRING: 1,
    JS_NUMBER: 2
  }, proto.google.protobuf.FieldOptions.prototype.getCtype = function() {
    return (
      /** @type {!proto.google.protobuf.FieldOptions.CType} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setCtype = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearCtype = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasCtype = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getPacked = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setPacked = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearPacked = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasPacked = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getJstype = function() {
    return (
      /** @type {!proto.google.protobuf.FieldOptions.JSType} */
      e.Message.getFieldWithDefault(this, 6, 0)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setJstype = function(ye) {
    return e.Message.setField(this, 6, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearJstype = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasJstype = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getLazy = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 5, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setLazy = function(ye) {
    return e.Message.setField(this, 5, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearLazy = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasLazy = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getUnverifiedLazy = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 15, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setUnverifiedLazy = function(ye) {
    return e.Message.setField(this, 15, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearUnverifiedLazy = function() {
    return e.Message.setField(this, 15, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasUnverifiedLazy = function() {
    return e.Message.getField(this, 15) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 3, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getWeak = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 10, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setWeak = function(ye) {
    return e.Message.setField(this, 10, ye);
  }, proto.google.protobuf.FieldOptions.prototype.clearWeak = function() {
    return e.Message.setField(this, 10, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasWeak = function() {
    return e.Message.getField(this, 10) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.FieldOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.FieldOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.OneofOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.OneofOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.OneofOptions.toObject(ye, this);
  }, proto.google.protobuf.OneofOptions.toObject = function(ye, ve) {
    var Ee = {
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Ee,
      proto.google.protobuf.OneofOptions.extensions,
      proto.google.protobuf.OneofOptions.prototype.getExtension,
      ye
    ), ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.OneofOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.OneofOptions();
    return proto.google.protobuf.OneofOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.OneofOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.OneofOptions.extensionsBinary,
            proto.google.protobuf.OneofOptions.prototype.getExtension,
            proto.google.protobuf.OneofOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.OneofOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.OneofOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.OneofOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.OneofOptions.extensionsBinary,
      proto.google.protobuf.OneofOptions.prototype.getExtension
    );
  }, proto.google.protobuf.OneofOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.OneofOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.OneofOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.OneofOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.EnumOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.EnumOptions.toObject(ye, this);
  }, proto.google.protobuf.EnumOptions.toObject = function(ye, ve) {
    var Ee, Se = {
      allowAlias: (Ee = e.Message.getBooleanField(ve, 2)) == null ? void 0 : Ee,
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 3, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Se,
      proto.google.protobuf.EnumOptions.extensions,
      proto.google.protobuf.EnumOptions.prototype.getExtension,
      ye
    ), ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.EnumOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.EnumOptions();
    return proto.google.protobuf.EnumOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.EnumOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 2:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setAllowAlias(Se);
          break;
        case 3:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.EnumOptions.extensionsBinary,
            proto.google.protobuf.EnumOptions.prototype.getExtension,
            proto.google.protobuf.EnumOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.EnumOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.EnumOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.EnumOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {boolean} */
    e.Message.getField(ye, 2), Ee != null && ve.writeBool(
      2,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 3), Ee != null && ve.writeBool(
      3,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.EnumOptions.extensionsBinary,
      proto.google.protobuf.EnumOptions.prototype.getExtension
    );
  }, proto.google.protobuf.EnumOptions.prototype.getAllowAlias = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.EnumOptions.prototype.setAllowAlias = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.EnumOptions.prototype.clearAllowAlias = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.EnumOptions.prototype.hasAllowAlias = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 3, !1)
    );
  }, proto.google.protobuf.EnumOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.EnumOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.EnumOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.EnumOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.EnumOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.EnumOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.EnumOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.EnumValueOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumValueOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.EnumValueOptions.toObject(ye, this);
  }, proto.google.protobuf.EnumValueOptions.toObject = function(ye, ve) {
    var Ee = {
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 1, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Ee,
      proto.google.protobuf.EnumValueOptions.extensions,
      proto.google.protobuf.EnumValueOptions.prototype.getExtension,
      ye
    ), ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.EnumValueOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.EnumValueOptions();
    return proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.EnumValueOptions.extensionsBinary,
            proto.google.protobuf.EnumValueOptions.prototype.getExtension,
            proto.google.protobuf.EnumValueOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.EnumValueOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {boolean} */
    e.Message.getField(ye, 1), Ee != null && ve.writeBool(
      1,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.EnumValueOptions.extensionsBinary,
      proto.google.protobuf.EnumValueOptions.prototype.getExtension
    );
  }, proto.google.protobuf.EnumValueOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 1, !1)
    );
  }, proto.google.protobuf.EnumValueOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.EnumValueOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumValueOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumValueOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.EnumValueOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.EnumValueOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.EnumValueOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.ServiceOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.ServiceOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.ServiceOptions.toObject(ye, this);
  }, proto.google.protobuf.ServiceOptions.toObject = function(ye, ve) {
    var Ee = {
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 33, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Ee,
      proto.google.protobuf.ServiceOptions.extensions,
      proto.google.protobuf.ServiceOptions.prototype.getExtension,
      ye
    ), ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.ServiceOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.ServiceOptions();
    return proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 33:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.ServiceOptions.extensionsBinary,
            proto.google.protobuf.ServiceOptions.prototype.getExtension,
            proto.google.protobuf.ServiceOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.ServiceOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.ServiceOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.ServiceOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {boolean} */
    e.Message.getField(ye, 33), Ee != null && ve.writeBool(
      33,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.ServiceOptions.extensionsBinary,
      proto.google.protobuf.ServiceOptions.prototype.getExtension
    );
  }, proto.google.protobuf.ServiceOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 33, !1)
    );
  }, proto.google.protobuf.ServiceOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 33, ye);
  }, proto.google.protobuf.ServiceOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 33, void 0);
  }, proto.google.protobuf.ServiceOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 33) != null;
  }, proto.google.protobuf.ServiceOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.ServiceOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.ServiceOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.ServiceOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.MethodOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.MethodOptions.prototype.toObject = function(ye) {
    return proto.google.protobuf.MethodOptions.toObject(ye, this);
  }, proto.google.protobuf.MethodOptions.toObject = function(ye, ve) {
    var Ee = {
      deprecated: e.Message.getBooleanFieldWithDefault(ve, 33, !1),
      idempotencyLevel: e.Message.getFieldWithDefault(ve, 34, 0),
      uninterpretedOptionList: e.Message.toObjectList(
        ve.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        ye
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      ve,
      Ee,
      proto.google.protobuf.MethodOptions.extensions,
      proto.google.protobuf.MethodOptions.prototype.getExtension,
      ye
    ), ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.MethodOptions.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.MethodOptions();
    return proto.google.protobuf.MethodOptions.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.MethodOptions.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 33:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setDeprecated(Se);
          break;
        case 34:
          var Se = (
            /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */
            ve.readEnum()
          );
          ye.setIdempotencyLevel(Se);
          break;
        case 999:
          var Se = new proto.google.protobuf.UninterpretedOption();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), ye.addUninterpretedOption(Se);
          break;
        default:
          e.Message.readBinaryExtension(
            ye,
            ve,
            proto.google.protobuf.MethodOptions.extensionsBinary,
            proto.google.protobuf.MethodOptions.prototype.getExtension,
            proto.google.protobuf.MethodOptions.prototype.setExtension
          );
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.MethodOptions.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.MethodOptions.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.MethodOptions.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {boolean} */
    e.Message.getField(ye, 33), Ee != null && ve.writeBool(
      33,
      Ee
    ), Ee = /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */
    e.Message.getField(ye, 34), Ee != null && ve.writeEnum(
      34,
      Ee
    ), Ee = ye.getUninterpretedOptionList(), Ee.length > 0 && ve.writeRepeatedMessage(
      999,
      Ee,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      ye,
      ve,
      proto.google.protobuf.MethodOptions.extensionsBinary,
      proto.google.protobuf.MethodOptions.prototype.getExtension
    );
  }, proto.google.protobuf.MethodOptions.IdempotencyLevel = {
    IDEMPOTENCY_UNKNOWN: 0,
    NO_SIDE_EFFECTS: 1,
    IDEMPOTENT: 2
  }, proto.google.protobuf.MethodOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 33, !1)
    );
  }, proto.google.protobuf.MethodOptions.prototype.setDeprecated = function(ye) {
    return e.Message.setField(this, 33, ye);
  }, proto.google.protobuf.MethodOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 33, void 0);
  }, proto.google.protobuf.MethodOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 33) != null;
  }, proto.google.protobuf.MethodOptions.prototype.getIdempotencyLevel = function() {
    return (
      /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */
      e.Message.getFieldWithDefault(this, 34, 0)
    );
  }, proto.google.protobuf.MethodOptions.prototype.setIdempotencyLevel = function(ye) {
    return e.Message.setField(this, 34, ye);
  }, proto.google.protobuf.MethodOptions.prototype.clearIdempotencyLevel = function() {
    return e.Message.setField(this, 34, void 0);
  }, proto.google.protobuf.MethodOptions.prototype.hasIdempotencyLevel = function() {
    return e.Message.getField(this, 34) != null;
  }, proto.google.protobuf.MethodOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.MethodOptions.prototype.setUninterpretedOptionList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 999, ye);
  }, proto.google.protobuf.MethodOptions.prototype.addUninterpretedOption = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 999, ye, proto.google.protobuf.UninterpretedOption, ve);
  }, proto.google.protobuf.MethodOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.UninterpretedOption.repeatedFields_ = [2], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.UninterpretedOption.prototype.toObject = function(ye) {
    return proto.google.protobuf.UninterpretedOption.toObject(ye, this);
  }, proto.google.protobuf.UninterpretedOption.toObject = function(ye, ve) {
    var Ee, Se = {
      nameList: e.Message.toObjectList(
        ve.getNameList(),
        proto.google.protobuf.UninterpretedOption.NamePart.toObject,
        ye
      ),
      identifierValue: (Ee = e.Message.getField(ve, 3)) == null ? void 0 : Ee,
      positiveIntValue: (Ee = e.Message.getField(ve, 4)) == null ? void 0 : Ee,
      negativeIntValue: (Ee = e.Message.getField(ve, 5)) == null ? void 0 : Ee,
      doubleValue: (Ee = e.Message.getOptionalFloatingPointField(ve, 6)) == null ? void 0 : Ee,
      stringValue: ve.getStringValue_asB64(),
      aggregateValue: (Ee = e.Message.getField(ve, 8)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.UninterpretedOption.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.UninterpretedOption();
    return proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 2:
          var Se = new proto.google.protobuf.UninterpretedOption.NamePart();
          ve.readMessage(Se, proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader), ye.addName(Se);
          break;
        case 3:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setIdentifierValue(Se);
          break;
        case 4:
          var Se = (
            /** @type {number} */
            ve.readUint64()
          );
          ye.setPositiveIntValue(Se);
          break;
        case 5:
          var Se = (
            /** @type {number} */
            ve.readInt64()
          );
          ye.setNegativeIntValue(Se);
          break;
        case 6:
          var Se = (
            /** @type {number} */
            ve.readDouble()
          );
          ye.setDoubleValue(Se);
          break;
        case 7:
          var Se = (
            /** @type {!Uint8Array} */
            ve.readBytes()
          );
          ye.setStringValue(Se);
          break;
        case 8:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setAggregateValue(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.UninterpretedOption.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getNameList(), Ee.length > 0 && ve.writeRepeatedMessage(
      2,
      Ee,
      proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 3), Ee != null && ve.writeString(
      3,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 4), Ee != null && ve.writeUint64(
      4,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 5), Ee != null && ve.writeInt64(
      5,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 6), Ee != null && ve.writeDouble(
      6,
      Ee
    ), Ee = /** @type {!(string|Uint8Array)} */
    e.Message.getField(ye, 7), Ee != null && ve.writeBytes(
      7,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 8), Ee != null && ve.writeString(
      8,
      Ee
    );
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.UninterpretedOption.NamePart.prototype.toObject = function(ye) {
    return proto.google.protobuf.UninterpretedOption.NamePart.toObject(ye, this);
  }, proto.google.protobuf.UninterpretedOption.NamePart.toObject = function(ye, ve) {
    var Ee, Se = {
      namePart: (Ee = e.Message.getField(ve, 1)) == null ? void 0 : Ee,
      isExtension: (Ee = e.Message.getBooleanField(ve, 2)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.UninterpretedOption.NamePart();
    return proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = (
            /** @type {string} */
            ve.readString()
          );
          ye.setNamePart(Se);
          break;
        case 2:
          var Se = (
            /** @type {boolean} */
            ve.readBool()
          );
          ye.setIsExtension(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = /** @type {string} */
    e.Message.getField(ye, 1), Ee != null && ve.writeString(
      1,
      Ee
    ), Ee = /** @type {boolean} */
    e.Message.getField(ye, 2), Ee != null && ve.writeBool(
      2,
      Ee
    );
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.getNamePart = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.setNamePart = function(ye) {
    return e.Message.setField(this, 1, ye);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.clearNamePart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.hasNamePart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.getIsExtension = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.setIsExtension = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.clearIsExtension = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.hasIsExtension = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getNameList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption.NamePart>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption.NamePart, 2)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setNameList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 2, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.addName = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 2, ye, proto.google.protobuf.UninterpretedOption.NamePart, ve);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearNameList = function() {
    return this.setNameList([]);
  }, proto.google.protobuf.UninterpretedOption.prototype.getIdentifierValue = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 3, "")
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setIdentifierValue = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearIdentifierValue = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasIdentifierValue = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getPositiveIntValue = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 4, 0)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setPositiveIntValue = function(ye) {
    return e.Message.setField(this, 4, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearPositiveIntValue = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasPositiveIntValue = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getNegativeIntValue = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 5, 0)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setNegativeIntValue = function(ye) {
    return e.Message.setField(this, 5, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearNegativeIntValue = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasNegativeIntValue = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getDoubleValue = function() {
    return (
      /** @type {number} */
      e.Message.getFloatingPointFieldWithDefault(this, 6, 0)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setDoubleValue = function(ye) {
    return e.Message.setField(this, 6, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearDoubleValue = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasDoubleValue = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getStringValue = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      e.Message.getFieldWithDefault(this, 7, "")
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.getStringValue_asB64 = function() {
    return (
      /** @type {string} */
      e.Message.bytesAsB64(
        this.getStringValue()
      )
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.getStringValue_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      e.Message.bytesAsU8(
        this.getStringValue()
      )
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setStringValue = function(ye) {
    return e.Message.setField(this, 7, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearStringValue = function() {
    return e.Message.setField(this, 7, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasStringValue = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getAggregateValue = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 8, "")
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setAggregateValue = function(ye) {
    return e.Message.setField(this, 8, ye);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearAggregateValue = function() {
    return e.Message.setField(this, 8, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasAggregateValue = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.SourceCodeInfo.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.SourceCodeInfo.prototype.toObject = function(ye) {
    return proto.google.protobuf.SourceCodeInfo.toObject(ye, this);
  }, proto.google.protobuf.SourceCodeInfo.toObject = function(ye, ve) {
    var Ee = {
      locationList: e.Message.toObjectList(
        ve.getLocationList(),
        proto.google.protobuf.SourceCodeInfo.Location.toObject,
        ye
      )
    };
    return ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.SourceCodeInfo.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.SourceCodeInfo();
    return proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = new proto.google.protobuf.SourceCodeInfo.Location();
          ve.readMessage(Se, proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader), ye.addLocation(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.SourceCodeInfo.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getLocationList(), Ee.length > 0 && ve.writeRepeatedMessage(
      1,
      Ee,
      proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.repeatedFields_ = [1, 2, 6], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.SourceCodeInfo.Location.prototype.toObject = function(ye) {
    return proto.google.protobuf.SourceCodeInfo.Location.toObject(ye, this);
  }, proto.google.protobuf.SourceCodeInfo.Location.toObject = function(ye, ve) {
    var Ee, Se = {
      pathList: (Ee = e.Message.getRepeatedField(ve, 1)) == null ? void 0 : Ee,
      spanList: (Ee = e.Message.getRepeatedField(ve, 2)) == null ? void 0 : Ee,
      leadingComments: (Ee = e.Message.getField(ve, 3)) == null ? void 0 : Ee,
      trailingComments: (Ee = e.Message.getField(ve, 4)) == null ? void 0 : Ee,
      leadingDetachedCommentsList: (Ee = e.Message.getRepeatedField(ve, 6)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.SourceCodeInfo.Location.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.SourceCodeInfo.Location();
    return proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          for (var Oe = (
            /** @type {!Array<number>} */
            ve.isDelimited() ? ve.readPackedInt32() : [ve.readInt32()]
          ), Se = 0; Se < Oe.length; Se++)
            ye.addPath(Oe[Se]);
          break;
        case 2:
          for (var Oe = (
            /** @type {!Array<number>} */
            ve.isDelimited() ? ve.readPackedInt32() : [ve.readInt32()]
          ), Se = 0; Se < Oe.length; Se++)
            ye.addSpan(Oe[Se]);
          break;
        case 3:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.setLeadingComments(xe);
          break;
        case 4:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.setTrailingComments(xe);
          break;
        case 6:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.addLeadingDetachedComments(xe);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getPathList(), Ee.length > 0 && ve.writePackedInt32(
      1,
      Ee
    ), Ee = ye.getSpanList(), Ee.length > 0 && ve.writePackedInt32(
      2,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 3), Ee != null && ve.writeString(
      3,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 4), Ee != null && ve.writeString(
      4,
      Ee
    ), Ee = ye.getLeadingDetachedCommentsList(), Ee.length > 0 && ve.writeRepeatedString(
      6,
      Ee
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getPathList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 1)
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setPathList = function(ye) {
    return e.Message.setField(this, 1, ye || []);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.addPath = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 1, ye, ve);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearPathList = function() {
    return this.setPathList([]);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getSpanList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 2)
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setSpanList = function(ye) {
    return e.Message.setField(this, 2, ye || []);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.addSpan = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 2, ye, ve);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearSpanList = function() {
    return this.setSpanList([]);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getLeadingComments = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 3, "")
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setLeadingComments = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearLeadingComments = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.hasLeadingComments = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getTrailingComments = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 4, "")
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setTrailingComments = function(ye) {
    return e.Message.setField(this, 4, ye);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearTrailingComments = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.hasTrailingComments = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getLeadingDetachedCommentsList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 6)
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setLeadingDetachedCommentsList = function(ye) {
    return e.Message.setField(this, 6, ye || []);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.addLeadingDetachedComments = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 6, ye, ve);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearLeadingDetachedCommentsList = function() {
    return this.setLeadingDetachedCommentsList([]);
  }, proto.google.protobuf.SourceCodeInfo.prototype.getLocationList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.SourceCodeInfo.Location>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.SourceCodeInfo.Location, 1)
    );
  }, proto.google.protobuf.SourceCodeInfo.prototype.setLocationList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 1, ye);
  }, proto.google.protobuf.SourceCodeInfo.prototype.addLocation = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 1, ye, proto.google.protobuf.SourceCodeInfo.Location, ve);
  }, proto.google.protobuf.SourceCodeInfo.prototype.clearLocationList = function() {
    return this.setLocationList([]);
  }, proto.google.protobuf.GeneratedCodeInfo.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.GeneratedCodeInfo.prototype.toObject = function(ye) {
    return proto.google.protobuf.GeneratedCodeInfo.toObject(ye, this);
  }, proto.google.protobuf.GeneratedCodeInfo.toObject = function(ye, ve) {
    var Ee = {
      annotationList: e.Message.toObjectList(
        ve.getAnnotationList(),
        proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject,
        ye
      )
    };
    return ye && (Ee.$jspbMessageInstance = ve), Ee;
  }), proto.google.protobuf.GeneratedCodeInfo.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.GeneratedCodeInfo();
    return proto.google.protobuf.GeneratedCodeInfo.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.GeneratedCodeInfo.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          var Se = new proto.google.protobuf.GeneratedCodeInfo.Annotation();
          ve.readMessage(Se, proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader), ye.addAnnotation(Se);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.GeneratedCodeInfo.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.GeneratedCodeInfo.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getAnnotationList(), Ee.length > 0 && ve.writeRepeatedMessage(
      1,
      Ee,
      proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.toObject = function(ye) {
    return proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject(ye, this);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject = function(ye, ve) {
    var Ee, Se = {
      pathList: (Ee = e.Message.getRepeatedField(ve, 1)) == null ? void 0 : Ee,
      sourceFile: (Ee = e.Message.getField(ve, 2)) == null ? void 0 : Ee,
      begin: (Ee = e.Message.getField(ve, 3)) == null ? void 0 : Ee,
      end: (Ee = e.Message.getField(ve, 4)) == null ? void 0 : Ee
    };
    return ye && (Se.$jspbMessageInstance = ve), Se;
  }), proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinary = function(ye) {
    var ve = new e.BinaryReader(ye), Ee = new proto.google.protobuf.GeneratedCodeInfo.Annotation();
    return proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader(Ee, ve);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader = function(ye, ve) {
    for (; ve.nextField() && !ve.isEndGroup(); ) {
      var Ee = ve.getFieldNumber();
      switch (Ee) {
        case 1:
          for (var Se = (
            /** @type {!Array<number>} */
            ve.isDelimited() ? ve.readPackedInt32() : [ve.readInt32()]
          ), Oe = 0; Oe < Se.length; Oe++)
            ye.addPath(Se[Oe]);
          break;
        case 2:
          var xe = (
            /** @type {string} */
            ve.readString()
          );
          ye.setSourceFile(xe);
          break;
        case 3:
          var xe = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setBegin(xe);
          break;
        case 4:
          var xe = (
            /** @type {number} */
            ve.readInt32()
          );
          ye.setEnd(xe);
          break;
        default:
          ve.skipField();
          break;
      }
    }
    return ye;
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.serializeBinary = function() {
    var ye = new e.BinaryWriter();
    return proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter(this, ye), ye.getResultBuffer();
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter = function(ye, ve) {
    var Ee = void 0;
    Ee = ye.getPathList(), Ee.length > 0 && ve.writePackedInt32(
      1,
      Ee
    ), Ee = /** @type {string} */
    e.Message.getField(ye, 2), Ee != null && ve.writeString(
      2,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 3), Ee != null && ve.writeInt32(
      3,
      Ee
    ), Ee = /** @type {number} */
    e.Message.getField(ye, 4), Ee != null && ve.writeInt32(
      4,
      Ee
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getPathList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 1)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setPathList = function(ye) {
    return e.Message.setField(this, 1, ye || []);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.addPath = function(ye, ve) {
    return e.Message.addToRepeatedField(this, 1, ye, ve);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearPathList = function() {
    return this.setPathList([]);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getSourceFile = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setSourceFile = function(ye) {
    return e.Message.setField(this, 2, ye);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearSourceFile = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasSourceFile = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getBegin = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 3, 0)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setBegin = function(ye) {
    return e.Message.setField(this, 3, ye);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearBegin = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasBegin = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 4, 0)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setEnd = function(ye) {
    return e.Message.setField(this, 4, ye);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearEnd = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasEnd = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.getAnnotationList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.GeneratedCodeInfo.Annotation>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.GeneratedCodeInfo.Annotation, 1)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.setAnnotationList = function(ye) {
    return e.Message.setRepeatedWrapperField(this, 1, ye);
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.addAnnotation = function(ye, ve) {
    return e.Message.addToRepeatedWrapperField(this, 1, ye, proto.google.protobuf.GeneratedCodeInfo.Annotation, ve);
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.clearAnnotationList = function() {
    return this.setAnnotationList([]);
  }, fe.object.extend(v, proto.google.protobuf);
})(descriptor_pb);
var util = {}, options_pb = {};
(function(v) {
  var e = googleProtobuf, fe = e, be = function() {
    return this ? this : typeof window < "u" ? window : typeof be < "u" ? be : typeof self < "u" ? self : Function("return this")();
  }.call(null), ye = descriptor_pb;
  fe.object.extend(proto, ye), fe.exportSymbol("proto.koinos.btype", null, be), fe.exportSymbol("proto.koinos.bytes_type", null, be), proto.koinos.bytes_type = {
    BASE64: 0,
    BASE58: 1,
    HEX: 2,
    BLOCK_ID: 3,
    TRANSACTION_ID: 4,
    CONTRACT_ID: 5,
    ADDRESS: 6
  }, proto.koinos.btype = new e.ExtensionFieldInfo(
    5e4,
    { btype: 0 },
    null,
    /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */
    null,
    0
  ), ye.FieldOptions.extensionsBinary[5e4] = new e.ExtensionFieldBinaryInfo(proto.koinos.btype, e.BinaryReader.prototype.readEnum, e.BinaryWriter.prototype.writeEnum, void 0, void 0, !1), ye.FieldOptions.extensions[5e4] = proto.koinos.btype, fe.object.extend(v, proto.koinos);
})(options_pb);
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(v, e, fe, be) {
  be === void 0 && (be = fe);
  var ye = Object.getOwnPropertyDescriptor(e, fe);
  (!ye || ("get" in ye ? !e.__esModule : ye.writable || ye.configurable)) && (ye = { enumerable: !0, get: function() {
    return e[fe];
  } }), Object.defineProperty(v, be, ye);
} : function(v, e, fe, be) {
  be === void 0 && (be = fe), v[be] = e[fe];
}), __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(v, e) {
  Object.defineProperty(v, "default", { enumerable: !0, value: e });
} : function(v, e) {
  v.default = e;
}), __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(v) {
  if (v && v.__esModule)
    return v;
  var e = {};
  if (v != null)
    for (var fe in v)
      fe !== "default" && Object.prototype.hasOwnProperty.call(v, fe) && __createBinding$2(e, v, fe);
  return __setModuleDefault$2(e, v), e;
};
Object.defineProperty(util, "__esModule", { value: !0 });
util.getMessage = util.getOneofs = util.getField = util.getFieldType = util.getFieldLabel = util.getbType = util.getJSType = util.getExtension = util.getEnum = util.getImport = util.getPackage = util.getSyntax = void 0;
const descriptor_pb_js_1$1 = descriptor_pb, optionspb = __importStar$2(options_pb);
function getSyntax(v) {
  return `syntax = '${v.getSyntax()}';

`;
}
util.getSyntax = getSyntax;
function getPackage(v) {
  return `package ${v.getPackage()};

`;
}
util.getPackage = getPackage;
function getImport(v) {
  return `import "${v}";

`;
}
util.getImport = getImport;
function getEnum(v) {
  const e = [];
  for (const fe of v.getValueList())
    e.push(`${fe.getName()} = ${fe.getNumber()};`);
  return `
enum ${v.getName()} {
  ${e.join(`
  `)} 
}

`;
}
util.getEnum = getEnum;
function getExtension(v) {
  const e = v.hasProto3Optional() ? "optional" : "";
  return `
extend ${v.getExtendee()} {
  ${e} ${v.getTypeName()} ${v.getName()} = ${v.getNumber()};
}

`;
}
util.getExtension = getExtension;
function getJSType(v) {
  if (!v)
    return "";
  switch (v.getJstype()) {
    case descriptor_pb_js_1$1.FieldOptions.JSType.JS_NORMAL:
      return "";
    case descriptor_pb_js_1$1.FieldOptions.JSType.JS_NUMBER:
      return "jstype = JS_NUMBER";
    case descriptor_pb_js_1$1.FieldOptions.JSType.JS_STRING:
      return "jstype = JS_STRING";
    default:
      return "";
  }
}
util.getJSType = getJSType;
function getbType(v) {
  if (!v)
    return "";
  switch (v.getExtension(optionspb.btype)) {
    case optionspb.bytes_type.BASE64:
      return "(koinos.btype) = BASE64";
    case optionspb.bytes_type.BASE58:
      return "(koinos.btype) = BASE58";
    case optionspb.bytes_type.HEX:
      return "(koinos.btype) = HEX";
    case optionspb.bytes_type.BLOCK_ID:
      return "(koinos.btype) = BLOCK_ID";
    case optionspb.bytes_type.TRANSACTION_ID:
      return "(koinos.btype) = TRANSACTION_ID";
    case optionspb.bytes_type.CONTRACT_ID:
      return "(koinos.btype) = CONTRACT_ID";
    case optionspb.bytes_type.ADDRESS:
      return "(koinos.btype) = ADDRESS";
    default:
      return "";
  }
}
util.getbType = getbType;
function getFieldLabel(v) {
  switch (v.getLabel()) {
    case descriptor_pb_js_1$1.FieldDescriptorProto.Label.LABEL_REPEATED:
      return "repeated";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Label.LABEL_REQUIRED:
      return "required";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Label.LABEL_OPTIONAL:
      return "";
    default:
      throw new Error(`Label '${v.getLabel()}' is not supported`);
  }
}
util.getFieldLabel = getFieldLabel;
function getFieldType(v) {
  switch (v.getType()) {
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_INT32:
      return "int32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SINT32:
      return "sint32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_FIXED32:
      return "fixed32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SFIXED32:
      return "sfixed32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_UINT32:
      return "uint32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_INT64:
      return "int64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SINT64:
      return "sint64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_FIXED64:
      return "fixed64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SFIXED64:
      return "sfixed64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_UINT64:
      return "uint64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_FLOAT:
      return "float";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_DOUBLE:
      return "double";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_BOOL:
      return "bool";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_STRING:
      return "string";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_BYTES:
      return "bytes";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_MESSAGE:
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_ENUM:
      return v.getTypeName();
    default:
      throw new Error(`Type '${v.getTypeName()}' is not supported`);
  }
}
util.getFieldType = getFieldType;
function getField(v) {
  const e = v.getOptions(), fe = v.getName(), be = v.getNumber(), ye = v.hasProto3Optional() ? "optional" : "", ve = getJSType(e), Ee = getbType(e), Se = ve ? `[${ve}]` : Ee ? `[${Ee}]` : "";
  return `${ye} ${getFieldLabel(v)} ${getFieldType(v)} ${fe} = ${be} ${Se};`;
}
util.getField = getField;
function getOneofs(v, e) {
  const fe = [];
  for (const [be, ye] of v.getOneofDeclList().entries()) {
    const ve = ye.getName();
    e[be] && fe.push(`
    oneof ${ve} {
      ${e[be].join(`
    `)}
    }

`);
  }
  return fe;
}
util.getOneofs = getOneofs;
function getMessage(v) {
  const e = [], fe = [], be = [];
  for (const ve of v.getNestedTypeList())
    e.push(getMessage(ve));
  for (const ve of v.getFieldList()) {
    const Ee = getField(ve);
    if (ve.hasOneofIndex() && !ve.hasProto3Optional()) {
      const Se = ve.getOneofIndex();
      if (Se === void 0)
        throw new Error("Missing one_of index.");
      let Oe = be[Se];
      Oe === void 0 && (Oe = [], be[Se] = Oe), Oe.push(Ee);
    } else
      fe.push(Ee);
  }
  const ye = getOneofs(v, be);
  return `
  message ${v.getName()} {
    ${e.join(`
  `)}
    ${fe.join(`
  `)}
    ${ye.join(`
  `)}
  }

`;
}
util.getMessage = getMessage;
Object.defineProperty(lib$1, "__esModule", { value: !0 });
lib$1.convert = void 0;
const descriptor_pb_js_1 = descriptor_pb, util_1 = util, convert = (v) => {
  const e = typeof v == "string" ? Buffer.from(v, "base64") : v, fe = descriptor_pb_js_1.FileDescriptorSet.deserializeBinary(e), be = [];
  for (const ye of fe.getFileList()) {
    const ve = ye.getName() || "";
    let Ee = "";
    ye.hasSyntax() && (Ee += (0, util_1.getSyntax)(ye)), ye.hasPackage() && (Ee += (0, util_1.getPackage)(ye)), ye.hasOptions();
    for (const Se of ye.getDependencyList())
      Ee += (0, util_1.getImport)(Se);
    for (const Se of ye.getEnumTypeList())
      Ee += (0, util_1.getEnum)(Se);
    for (const Se of ye.getExtensionList())
      Ee += (0, util_1.getExtension)(Se);
    for (const Se of ye.getMessageTypeList())
      Ee += (0, util_1.getMessage)(Se);
    be.push({ file: ve, definition: Ee });
  }
  return be;
};
lib$1.convert = convert;
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(v, e, fe, be) {
  be === void 0 && (be = fe);
  var ye = Object.getOwnPropertyDescriptor(e, fe);
  (!ye || ("get" in ye ? !e.__esModule : ye.writable || ye.configurable)) && (ye = { enumerable: !0, get: function() {
    return e[fe];
  } }), Object.defineProperty(v, be, ye);
} : function(v, e, fe, be) {
  be === void 0 && (be = fe), v[be] = e[fe];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(v, e) {
  Object.defineProperty(v, "default", { enumerable: !0, value: e });
} : function(v, e) {
  v.default = e;
}), __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(v) {
  if (v && v.__esModule)
    return v;
  var e = {};
  if (v != null)
    for (var fe in v)
      fe !== "default" && Object.prototype.hasOwnProperty.call(v, fe) && __createBinding$1(e, v, fe);
  return __setModuleDefault$1(e, v), e;
};
Object.defineProperty(Serializer$1, "__esModule", { value: !0 });
Serializer$1.Serializer = void 0;
const protobufjs_1 = protobufjs, koinosPbToProto = __importStar$1(lib$1), utils_1$4 = utils$1, OP_BYTES_1 = "(btype)", OP_BYTES_2 = "(koinos.btype)", nativeTypes = [
  "double",
  "float",
  "int32",
  "int64",
  "uint32",
  "uint64",
  "sint32",
  "sint64",
  "fixed32",
  "fixed64",
  "sfixed32",
  "sfixed64",
  "bool",
  "string",
  "bytes"
];
class Serializer {
  constructor(e, fe) {
    if (this.bytesConversion = !0, this.verifyChecksum = {
      serialize: !0,
      deserialize: !1
    }, this.types = e, typeof e == "string") {
      const be = koinosPbToProto.convert((0, utils_1$4.decodeBase64)(e));
      this.root = new protobufjs_1.Root();
      for (const ye of be)
        (0, protobufjs_1.parse)(ye.definition, this.root, { keepCase: !0 });
    } else
      this.root = protobufjs_1.Root.fromJSON(e);
    fe != null && fe.defaultTypeName && (this.defaultType = this.root.lookupType(fe.defaultTypeName)), fe && typeof fe.bytesConversion < "u" && (this.bytesConversion = fe.bytesConversion);
  }
  btypeDecode(e, fe, be) {
    const ye = {};
    return Object.keys(fe.fields).forEach((ve) => {
      const { options: Ee, name: Se, type: Oe, rule: xe } = fe.fields[ve];
      if (!e[Se])
        return;
      const me = { type: Oe };
      if (Ee && (Ee[OP_BYTES_1] ? me.btype = Ee[OP_BYTES_1] : Ee[OP_BYTES_2] && (me.btype = Ee[OP_BYTES_2])), xe === "repeated") {
        ye[Se] = e[Se].map((we) => {
          if (!nativeTypes.includes(Oe)) {
            const ur = this.root.lookupTypeOrEnum(Oe);
            return ur.fields ? this.btypeDecode(we, ur, be) : we;
          }
          return (0, utils_1$4.btypeDecodeValue)(we, me, be);
        });
        return;
      }
      if (!nativeTypes.includes(Oe)) {
        const we = this.root.lookupTypeOrEnum(Oe);
        if (!we.fields) {
          ye[Se] = e[Se];
          return;
        }
        ye[Se] = this.btypeDecode(e[Se], we, be);
        return;
      }
      ye[Se] = (0, utils_1$4.btypeDecodeValue)(e[Se], me, be);
    }), ye;
  }
  btypeEncode(e, fe, be) {
    const ye = {};
    return Object.keys(fe.fields).forEach((ve) => {
      const { options: Ee, name: Se, type: Oe, rule: xe } = fe.fields[ve];
      if (!e[Se])
        return;
      const me = { type: Oe };
      if (Ee && (Ee[OP_BYTES_1] ? me.btype = Ee[OP_BYTES_1] : Ee[OP_BYTES_2] && (me.btype = Ee[OP_BYTES_2])), xe === "repeated") {
        ye[Se] = e[Se].map((we) => {
          if (!nativeTypes.includes(Oe)) {
            const ur = this.root.lookupTypeOrEnum(Oe);
            return ur.fields ? this.btypeEncode(we, ur, be) : we;
          }
          return (0, utils_1$4.btypeEncodeValue)(we, me, be);
        });
        return;
      }
      if (!nativeTypes.includes(Oe)) {
        const we = this.root.lookupTypeOrEnum(Oe);
        if (!we.fields) {
          ye[Se] = e[Se];
          return;
        }
        ye[Se] = this.btypeEncode(e[Se], we, be);
        return;
      }
      ye[Se] = (0, utils_1$4.btypeEncodeValue)(e[Se], me, be);
    }), ye;
  }
  /**
   * Function to encode a type using the protobuffer definitions
   * It also prepares the bytes for special cases (base58, hex string)
   * when bytesConversion param is true.
   */
  async serialize(e, fe, be) {
    let ye;
    if (this.defaultType)
      ye = this.defaultType;
    else if (fe)
      ye = this.root.lookupType(fe);
    else
      throw new Error("no typeName defined");
    let ve = {};
    const Ee = (be == null ? void 0 : be.bytesConversion) === void 0 ? this.bytesConversion : be.bytesConversion, Se = (be == null ? void 0 : be.verifyChecksum) === void 0 ? this.verifyChecksum.serialize : be.verifyChecksum;
    Ee ? ve = this.btypeDecode(e, ye, Se) : ve = e;
    const Oe = ye.create(ve);
    return ye.encode(Oe).finish();
  }
  /**
   * Function to decode bytes using the protobuffer definitions
   * It also encodes the bytes for special cases (base58, hex string)
   * when bytesConversion param is true.
   */
  async deserialize(e, fe, be) {
    const ye = typeof e == "string" ? (0, utils_1$4.decodeBase64url)(e) : e;
    let ve;
    if (this.defaultType)
      ve = this.defaultType;
    else if (fe)
      ve = this.root.lookupType(fe);
    else
      throw new Error("no typeName defined");
    const Ee = ve.decode(ye), Se = ve.toObject(Ee, {
      longs: String,
      defaults: !0
    }), Oe = (be == null ? void 0 : be.bytesConversion) === void 0 ? this.bytesConversion : be.bytesConversion, xe = (be == null ? void 0 : be.verifyChecksum) === void 0 ? this.verifyChecksum.deserialize : be.verifyChecksum;
    return Oe ? this.btypeEncode(Se, ve, xe) : Se;
  }
}
Serializer$1.Serializer = Serializer;
Serializer$1.default = Serializer;
const nested = {
  koinos: {
    options: {
      go_package: "github.com/koinos/koinos-proto-golang/koinos"
    },
    nested: {
      block_topology: {
        fields: {
          id: {
            type: "bytes",
            id: 1,
            options: {
              "(btype)": "BLOCK_ID"
            }
          },
          height: {
            type: "uint64",
            id: 2,
            options: {
              jstype: "JS_STRING"
            }
          },
          previous: {
            type: "bytes",
            id: 3,
            options: {
              "(btype)": "BLOCK_ID"
            }
          }
        }
      },
      protocol: {
        options: {
          go_package: "github.com/koinos/koinos-proto-golang/koinos/protocol"
        },
        nested: {
          event_data: {
            fields: {
              sequence: {
                type: "uint32",
                id: 1
              },
              source: {
                type: "bytes",
                id: 2,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              name: {
                type: "string",
                id: 3
              },
              data: {
                type: "bytes",
                id: 4
              },
              impacted: {
                rule: "repeated",
                type: "bytes",
                id: 5,
                options: {
                  "(btype)": "ADDRESS"
                }
              }
            }
          },
          contract_call_bundle: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              entry_point: {
                type: "uint32",
                id: 2
              }
            }
          },
          system_call_target: {
            oneofs: {
              target: {
                oneof: [
                  "thunk_id",
                  "system_call_bundle"
                ]
              }
            },
            fields: {
              thunk_id: {
                type: "uint32",
                id: 1
              },
              system_call_bundle: {
                type: "contract_call_bundle",
                id: 2
              }
            }
          },
          upload_contract_operation: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              bytecode: {
                type: "bytes",
                id: 2
              },
              abi: {
                type: "string",
                id: 3
              },
              authorizes_call_contract: {
                type: "bool",
                id: 4
              },
              authorizes_transaction_application: {
                type: "bool",
                id: 5
              },
              authorizes_upload_contract: {
                type: "bool",
                id: 6
              }
            }
          },
          call_contract_operation: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              entry_point: {
                type: "uint32",
                id: 2
              },
              args: {
                type: "bytes",
                id: 3
              }
            }
          },
          set_system_call_operation: {
            fields: {
              call_id: {
                type: "uint32",
                id: 1
              },
              target: {
                type: "system_call_target",
                id: 2
              }
            }
          },
          set_system_contract_operation: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              system_contract: {
                type: "bool",
                id: 2
              }
            }
          },
          operation: {
            oneofs: {
              op: {
                oneof: [
                  "upload_contract",
                  "call_contract",
                  "set_system_call",
                  "set_system_contract"
                ]
              }
            },
            fields: {
              upload_contract: {
                type: "upload_contract_operation",
                id: 1
              },
              call_contract: {
                type: "call_contract_operation",
                id: 2
              },
              set_system_call: {
                type: "set_system_call_operation",
                id: 3
              },
              set_system_contract: {
                type: "set_system_contract_operation",
                id: 4
              }
            }
          },
          transaction_header: {
            fields: {
              chain_id: {
                type: "bytes",
                id: 1
              },
              rc_limit: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              nonce: {
                type: "bytes",
                id: 3
              },
              operation_merkle_root: {
                type: "bytes",
                id: 4
              },
              payer: {
                type: "bytes",
                id: 5,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              payee: {
                type: "bytes",
                id: 6,
                options: {
                  "(btype)": "ADDRESS"
                }
              }
            }
          },
          transaction: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "TRANSACTION_ID"
                }
              },
              header: {
                type: "transaction_header",
                id: 2
              },
              operations: {
                rule: "repeated",
                type: "operation",
                id: 3
              },
              signatures: {
                rule: "repeated",
                type: "bytes",
                id: 4
              }
            }
          },
          transaction_receipt: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "TRANSACTION_ID"
                }
              },
              payer: {
                type: "bytes",
                id: 2,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              max_payer_rc: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              rc_limit: {
                type: "uint64",
                id: 4,
                options: {
                  jstype: "JS_STRING"
                }
              },
              rc_used: {
                type: "uint64",
                id: 5,
                options: {
                  jstype: "JS_STRING"
                }
              },
              disk_storage_used: {
                type: "uint64",
                id: 6,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_used: {
                type: "uint64",
                id: 7,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_used: {
                type: "uint64",
                id: 8,
                options: {
                  jstype: "JS_STRING"
                }
              },
              reverted: {
                type: "bool",
                id: 9
              },
              events: {
                rule: "repeated",
                type: "event_data",
                id: 10
              },
              logs: {
                rule: "repeated",
                type: "string",
                id: 11
              }
            }
          },
          block_header: {
            fields: {
              previous: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "BLOCK_ID"
                }
              },
              height: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              timestamp: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              previous_state_merkle_root: {
                type: "bytes",
                id: 4
              },
              transaction_merkle_root: {
                type: "bytes",
                id: 5
              },
              signer: {
                type: "bytes",
                id: 6,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              approved_proposals: {
                rule: "repeated",
                type: "bytes",
                id: 7,
                options: {
                  "(btype)": "TRANSACTION_ID"
                }
              }
            }
          },
          block: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "BLOCK_ID"
                }
              },
              header: {
                type: "block_header",
                id: 2
              },
              transactions: {
                rule: "repeated",
                type: "transaction",
                id: 3
              },
              signature: {
                type: "bytes",
                id: 4
              }
            }
          },
          block_receipt: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "BLOCK_ID"
                }
              },
              height: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              disk_storage_used: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_used: {
                type: "uint64",
                id: 4,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_used: {
                type: "uint64",
                id: 5,
                options: {
                  jstype: "JS_STRING"
                }
              },
              state_merkle_root: {
                type: "bytes",
                id: 6
              },
              events: {
                rule: "repeated",
                type: "event_data",
                id: 7
              },
              transaction_receipts: {
                rule: "repeated",
                type: "transaction_receipt",
                id: 8
              },
              logs: {
                rule: "repeated",
                type: "string",
                id: 9
              }
            }
          }
        }
      },
      chain: {
        options: {
          go_package: "github.com/koinos/koinos-proto-golang/koinos/chain"
        },
        nested: {
          error_data: {
            fields: {
              message: {
                type: "string",
                id: 1
              }
            }
          },
          result: {
            oneofs: {
              value: {
                oneof: [
                  "object",
                  "error"
                ]
              }
            },
            fields: {
              object: {
                type: "bytes",
                id: 1
              },
              error: {
                type: "error_data",
                id: 2
              }
            }
          },
          object_space: {
            fields: {
              system: {
                type: "bool",
                id: 1
              },
              zone: {
                type: "bytes",
                id: 2
              },
              id: {
                type: "uint32",
                id: 3
              }
            }
          },
          database_key: {
            fields: {
              space: {
                type: "object_space",
                id: 1
              },
              key: {
                type: "bytes",
                id: 2
              }
            }
          },
          max_account_resources: {
            fields: {
              value: {
                type: "uint64",
                id: 1,
                options: {
                  jstype: "JS_STRING"
                }
              }
            }
          },
          privilege: {
            values: {
              kernel_mode: 0,
              user_mode: 1
            }
          },
          head_info: {
            fields: {
              head_topology: {
                type: "block_topology",
                id: 1
              },
              head_block_time: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              last_irreversible_block: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              }
            }
          },
          caller_data: {
            fields: {
              caller: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              caller_privilege: {
                type: "privilege",
                id: 2
              }
            }
          },
          argument_data: {
            fields: {
              entry_point: {
                type: "uint32",
                id: 1
              },
              arguments: {
                type: "bytes",
                id: 2
              }
            }
          },
          resource_limit_data: {
            fields: {
              disk_storage_limit: {
                type: "uint64",
                id: 1,
                options: {
                  jstype: "JS_STRING"
                }
              },
              disk_storage_cost: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_limit: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_cost: {
                type: "uint64",
                id: 4,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_limit: {
                type: "uint64",
                id: 5,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_cost: {
                type: "uint64",
                id: 6,
                options: {
                  jstype: "JS_STRING"
                }
              }
            }
          },
          contract_metadata_object: {
            fields: {
              hash: {
                type: "bytes",
                id: 1
              },
              system: {
                type: "bool",
                id: 2
              },
              authorizes_call_contract: {
                type: "bool",
                id: 3
              },
              authorizes_transaction_application: {
                type: "bool",
                id: 4
              },
              authorizes_upload_contract: {
                type: "bool",
                id: 5
              }
            }
          },
          compute_bandwidth_entry: {
            fields: {
              name: {
                type: "string",
                id: 1
              },
              compute: {
                type: "uint64",
                id: 2
              }
            }
          },
          compute_bandwidth_registry: {
            fields: {
              entries: {
                rule: "repeated",
                type: "compute_bandwidth_entry",
                id: 1
              }
            }
          },
          genesis_entry: {
            fields: {
              space: {
                type: "object_space",
                id: 1
              },
              key: {
                type: "bytes",
                id: 2
              },
              value: {
                type: "bytes",
                id: 3
              }
            }
          },
          genesis_data: {
            fields: {
              entries: {
                rule: "repeated",
                type: "genesis_entry",
                id: 1
              }
            }
          },
          dsa: {
            values: {
              ecdsa_secp256k1: 0
            }
          }
        }
      }
    }
  }
}, require$$3 = {
  nested
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(v) {
  return v && v.__esModule ? v : { default: v };
};
Object.defineProperty(utilsNode, "__esModule", { value: !0 });
utilsNode.ChainTypes = utilsNode.decodeGenesisData = utilsNode.encodeGenesisData = void 0;
const sha256_1$1 = sha256, Serializer_1$1 = Serializer$1, utils_1$3 = utils$1, chain_proto_json_1 = __importDefault$1(require$$3), defaultAlias = {
  "object_key::head_block": { typeName: "block" },
  "object_key::chain_id": {},
  "object_key::genesis_key": { isAddress: !0 },
  "object_key::resource_limit_data": { typeName: "resource_limit_data" },
  "object_key::max_account_resources": { typeName: "max_account_resources" },
  "object_key::protocol_descriptor": {},
  "object_key::compute_bandwidth_registry": {
    typeName: "compute_bandwidth_registry"
  },
  "object_key::block_hash_code": {}
};
function prepareDictionary(v) {
  const e = new Serializer_1$1.Serializer(chain_proto_json_1.default, { bytesConversion: !0 }), fe = {};
  return Object.keys(defaultAlias).forEach((ye) => {
    const ve = (0, utils_1$3.encodeBase64)((0, utils_1$3.multihash)((0, sha256_1$1.sha256)(ye)));
    fe[ve] = {
      serializer: e,
      alias: ye,
      ...defaultAlias[ye]
    };
  }), {
    ...fe,
    ...v
  };
}
async function encodeGenesisData(v, e = {}) {
  const fe = {};
  if (!v || !v.entries)
    return fe;
  const be = prepareDictionary(e);
  return fe.entries = await Promise.all(v.entries.map(async (ye) => {
    const ve = Object.keys(be).find((we) => we === ye.key || ye.alias && be[we].alias === ye.alias);
    if (!ve)
      return {
        error: `key ${ye.key} not found in the dictionary`,
        space: ye.space,
        key: ye.key,
        value: (0, utils_1$3.encodeBase64)(new Uint8Array())
      };
    const { isAddress: Ee, serializer: Se, typeName: Oe } = be[ve];
    let xe, me = "";
    return Ee ? xe = (0, utils_1$3.decodeBase58)(ye.value) : Se && Oe ? xe = await Se.serialize(ye.value, Oe) : (xe = new Uint8Array(), me = "no serializer or typeName defined in the dictionary"), {
      ...me && { error: me },
      space: ye.space,
      key: ve,
      value: (0, utils_1$3.encodeBase64)(xe)
    };
  })), fe;
}
utilsNode.encodeGenesisData = encodeGenesisData;
async function decodeGenesisData(v, e = {}) {
  const fe = {};
  if (!v || !v.entries)
    return fe;
  const be = prepareDictionary(e);
  return fe.entries = await Promise.all(v.entries.map(async (ye) => {
    const ve = Object.keys(be).find((lr) => lr === ye.key);
    if (!ve)
      return {
        error: `key ${ye.key} not found in the dictionary`,
        ...ye
      };
    const { isAddress: Ee, serializer: Se, typeName: Oe, alias: xe } = be[ve], me = (0, utils_1$3.encodeBase64url)((0, utils_1$3.decodeBase64)(ye.value));
    let we, ur = "";
    return Ee ? we = (0, utils_1$3.encodeBase58)((0, utils_1$3.decodeBase64url)(me)) : Se && Oe ? we = await Se.deserialize(me, Oe) : (we = me, ur = "no serializer or typeName defined in the dictionary"), {
      ...ur && { error: ur },
      space: ye.space,
      key: ve,
      value: we,
      ...xe && { alias: xe }
    };
  })), fe;
}
utilsNode.decodeGenesisData = decodeGenesisData;
utilsNode.ChainTypes = chain_proto_json_1.default;
(function(v) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(be, ye, ve, Ee) {
    Ee === void 0 && (Ee = ve);
    var Se = Object.getOwnPropertyDescriptor(ye, ve);
    (!Se || ("get" in Se ? !ye.__esModule : Se.writable || Se.configurable)) && (Se = { enumerable: !0, get: function() {
      return ye[ve];
    } }), Object.defineProperty(be, Ee, Se);
  } : function(be, ye, ve, Ee) {
    Ee === void 0 && (Ee = ve), be[Ee] = ye[ve];
  }), fe = commonjsGlobal && commonjsGlobal.__exportStar || function(be, ye) {
    for (var ve in be)
      ve !== "default" && !Object.prototype.hasOwnProperty.call(ye, ve) && e(ye, be, ve);
  };
  Object.defineProperty(v, "__esModule", { value: !0 }), fe(utils$1, v), fe(utilsNode, v);
})(indexUtils);
var _interface = {};
Object.defineProperty(_interface, "__esModule", { value: !0 });
var Contract$1 = {};
Object.defineProperty(Contract$1, "__esModule", { value: !0 });
Contract$1.Contract = void 0;
const Serializer_1 = Serializer$1, utils_1$2 = utils$1;
class Contract {
  constructor(e) {
    var fe;
    if (this.signer = e.signer, e.id)
      this.id = (0, utils_1$2.decodeBase58)(e.id);
    else {
      if (!this.signer)
        throw new Error("at least signer or contract id must be defined");
      this.id = (0, utils_1$2.decodeBase58)(this.signer.getAddress());
    }
    this.provider = e.provider || ((fe = e.signer) === null || fe === void 0 ? void 0 : fe.provider), this.abi = e.abi, this.bytecode = e.bytecode, e.serializer ? this.serializer = e.serializer : e.abi && e.abi.koilib_types ? this.serializer = new Serializer_1.Serializer(e.abi.koilib_types) : e.abi && e.abi.types && (this.serializer = new Serializer_1.Serializer(e.abi.types)), this.options = {
      signTransaction: !0,
      sendTransaction: !0,
      broadcast: !0,
      sendAbis: !0,
      ...e.options
    }, this.functions = {}, this.updateFunctionsFromAbi();
  }
  /**
   * Get contract Id
   */
  getId() {
    return (0, utils_1$2.encodeBase58)(this.id);
  }
  /**
   * Fetch the ABI from the contract meta store and save it in the
   * abi of the contract. The provider must have contract_meta_store
   * microservice enabled.
   * @param opts - options object with 2 boolean: 1) updateFunctions to
   * specify if the contract functions should be regenerated based on
   * the new ABI, and 2) updateSerializer to determine if the serializer
   * should be updated with the types in the new ABI.
   * @returns the new ABI saved in the contract
   */
  async fetchAbi(e = {
    updateFunctions: !0,
    updateSerializer: !0
  }) {
    if (!this.provider)
      throw new Error("provider not found");
    const fe = await this.provider.call("contract_meta_store.get_contract_meta", {
      contract_id: this.getId()
    });
    if (!(!fe.meta || !fe.meta.abi))
      return this.abi = JSON.parse(fe.meta.abi), e.updateFunctions && this.updateFunctionsFromAbi(), e.updateSerializer && (this.abi.koilib_types ? this.serializer = new Serializer_1.Serializer(this.abi.koilib_types) : this.abi.types && (this.serializer = new Serializer_1.Serializer(this.abi.types))), this.abi;
  }
  /**
   * Create the contract functions based on the ABI
   */
  updateFunctionsFromAbi() {
    return !this.abi || !this.abi.methods ? !1 : (Object.keys(this.abi.methods).forEach((e) => {
      this.functions[e] = async (fe = {}, be) => {
        if (!this.provider)
          throw new Error("provider not found");
        if (!this.abi || !this.abi.methods)
          throw new Error("Methods are not defined");
        if (!this.abi.methods[e])
          throw new Error(`Method ${e} not defined in the ABI`);
        const ye = {
          ...this.options,
          ...be
        }, { read_only: ve, return: Ee, default_output: Se, preformat_argument: Oe, preformat_return: xe } = this.abi.methods[e];
        let me;
        typeof Oe == "function" ? me = Oe(fe) : me = fe;
        const we = await this.encodeOperation({ name: e, args: me });
        if (ye.onlyOperation)
          return { operation: we };
        if (ve) {
          if (!Ee)
            throw new Error(`No output defined for ${e}`);
          const { result: Br } = await this.provider.readContract(we.call_contract);
          let Xr = Se;
          return Br && (Xr = await this.serializer.deserialize(Br, Ee)), typeof xe == "function" && (Xr = xe(Xr)), { operation: we, result: Xr };
        }
        if (!this.signer)
          throw new Error("signer not found");
        let ur = await this.signer.prepareTransaction({
          header: {
            ...ye.chainId && { chain_id: ye.chainId },
            ...ye.rcLimit && { rc_limit: ye.rcLimit },
            ...ye.nonce && { nonce: ye.nonce },
            ...ye.payer && { payer: ye.payer },
            ...ye.payee && { payee: ye.payee }
          },
          operations: [
            ...ye.previousOperations ? ye.previousOperations : [],
            we,
            ...ye.nextOperations ? ye.nextOperations : []
          ]
        });
        if (ye.sendAbis) {
          ye.abis || (ye.abis = {});
          const Br = this.getId();
          ye.abis[Br] || (ye.abis[Br] = this.abi);
        }
        if (!ye.sendTransaction) {
          const Br = () => {
            throw new Error("This transaction was not broadcasted");
          };
          return ye.signTransaction && (ur = await this.signer.signTransaction(ur, ye.sendAbis ? ye.abis : void 0)), { operation: we, transaction: { ...ur, wait: Br } };
        }
        const { transaction: lr, receipt: Ar } = await this.signer.sendTransaction(ur, ye);
        return { operation: we, transaction: lr, receipt: Ar };
      };
    }), !0);
  }
  /**
   * Function to deploy a new smart contract.
   * The Bytecode must be defined in the constructor of the class
   * @example
   * ```ts
   * const privateKey = "f186a5de49797bfd52dc42505c33d75a46822ed5b60046e09d7c336242e20200";
   * const provider = new Provider(["http://api.koinos.io:8080"]);
   * const signer = new Signer({ privateKey, provider });
   * const bytecode = new Uint8Array([1, 2, 3, 4]);
   * const contract = new Contract({ signer, provider, bytecode });
   * const { transaction, receipt } = await contract.deploy();
   * console.log(receipt);
   * // wait to be mined
   * const blockNumber = await transaction.wait();
   * console.log(`Contract uploaded in block number ${blockNumber}`);
   * ```
   *
   * @example using options
   * ```ts
   * const { transaction, receipt } = await contract.deploy({
   *   // contract options
   *   abi: "CssCChRrb2lub3Mvb3B0aW9ucy5wc...",
   *   authorizesCallContract: true,
   *   authorizesTransactionApplication: true,
   *   authorizesUploadContract: true,
   *
   *   // transaction options
   *   chainId: "EiB-hw5ABo-EXy6fGDd1Iq3gbAenxQ4Qe60pRbEVMVrR9A==",
   *   rcLimit: "100000000",
   *   nonce: "OAI=",
   *   payer: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   payee: "1Gvqdo9if6v6tFomEuTuMWP1D7H7U9yksb",
   *
   *   // sign and broadcast
   *   signTransaction: true,
   *   sendTransaction: true,
   *   broadcast: true,
   * });
   * console.log(receipt);
   * // wait to be mined
   * const blockNumber = await transaction.wait();
   * console.log(`Contract uploaded in block number ${blockNumber}`);
   * ```
   */
  async deploy(e) {
    if (!this.signer)
      throw new Error("signer not found");
    if (!this.bytecode)
      throw new Error("bytecode not found");
    const fe = {
      ...this.options,
      ...e
    }, ye = {
      upload_contract: {
        contract_id: this.getId(),
        bytecode: (0, utils_1$2.encodeBase64url)(this.bytecode),
        ...fe.abi && { abi: fe.abi },
        ...fe.authorizesCallContract && {
          authorizes_call_contract: fe.authorizesCallContract
        },
        ...fe.authorizesTransactionApplication && {
          authorizes_transaction_application: fe.authorizesTransactionApplication
        },
        ...fe.authorizesUploadContract && {
          authorizes_upload_contract: fe.authorizesUploadContract
        }
      }
    };
    if (fe.onlyOperation)
      return { operation: ye };
    let ve = await this.signer.prepareTransaction({
      header: {
        ...fe.chainId && { chain_id: fe.chainId },
        ...fe.rcLimit && { rc_limit: fe.rcLimit },
        ...fe.nonce && { nonce: fe.nonce },
        ...fe.payer && { payer: fe.payer },
        ...fe.payee && { payee: fe.payee }
      },
      operations: [
        ...fe.previousOperations ? fe.previousOperations : [],
        ye,
        ...fe.nextOperations ? fe.nextOperations : []
      ]
    });
    if (!fe.sendTransaction) {
      const Oe = () => {
        throw new Error("This transaction was not broadcasted");
      };
      return fe.signTransaction && (ve = await this.signer.signTransaction(ve, fe.sendAbis ? fe.abis : void 0)), { operation: ye, transaction: { ...ve, wait: Oe } };
    }
    const { transaction: Ee, receipt: Se } = await this.signer.sendTransaction(ve, fe);
    return { operation: ye, transaction: Ee, receipt: Se };
  }
  /**
   * Encondes a contract operation using Koinos serialization
   * and taking the contract entries as reference to build it
   * @param op - Operation to encode
   * @returns Operation encoded
   * @example
   * ```ts
   * const opEncoded = contract.encodeOperation({
   *   name: "transfer",
   *   args: {
   *     from: "12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD",
   *     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
   *     value: "1000",
   *   }
   * });
   *
   * console.log(opEncoded);
   * // {
   * //   call_contract: {
   * //     contract_id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   * //     entry_point: 670398154,
   * //     args: "ChkAEjl6vrl55V2Oym_rzsnMxIqBoie9PHmMEhkAQgjT1UACatdFY3e5QRkyG7OAzwcCCIylGOgH",
   * //   }
   * // }
   * ```
   */
  async encodeOperation(e) {
    if (!this.abi || !this.abi.methods || !this.abi.methods[e.name])
      throw new Error(`Operation ${e.name} unknown`);
    if (!this.serializer)
      throw new Error("Serializer is not defined");
    const fe = this.abi.methods[e.name];
    let be = new Uint8Array(0);
    if (fe.argument) {
      if (!e.args)
        throw new Error(`No arguments defined for type '${fe.argument}'`);
      be = await this.serializer.serialize(e.args, fe.argument);
    }
    return {
      call_contract: {
        contract_id: this.getId(),
        entry_point: fe.entry_point,
        args: (0, utils_1$2.encodeBase64url)(be)
      }
    };
  }
  /**
   * Decodes a contract operation to be human readable
   * @example
   * ```ts
   * const opDecoded = contract.decodeOperation({
   *   call_contract: {
   *     contract_id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *     entry_point: 0x27f576ca,
   *     args: "ChkAEjl6vrl55V2Oym_rzsnMxIqBoie9PHmMEhkAQgjT1UACatdFY3e5QRkyG7OAzwcCCIylGOgH",
   *   }
   * });
   * console.log(opDecoded);
   * // {
   * //   name: "transfer",
   * //   args: {
   * //     from: "12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD",
   * //     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
   * //     value: "1000",
   * //   },
   * // }
   * ```
   */
  async decodeOperation(e) {
    if (!this.abi || !this.abi.methods)
      throw new Error("Methods are not defined");
    if (!this.serializer)
      throw new Error("Serializer is not defined");
    if (!e.call_contract)
      throw new Error("Operation is not CallContractOperation");
    if (e.call_contract.contract_id !== this.getId())
      throw new Error(`Invalid contract id. Expected: ${this.getId()}. Received: ${e.call_contract.contract_id}`);
    for (let fe = 0; fe < Object.keys(this.abi.methods).length; fe += 1) {
      const be = Object.keys(this.abi.methods)[fe], ye = this.abi.methods[be];
      if (e.call_contract.entry_point === ye.entry_point)
        return ye.argument ? {
          name: be,
          args: await this.serializer.deserialize(e.call_contract.args, ye.argument)
        } : { name: be };
    }
    throw new Error(`Unknown method id ${e.call_contract.entry_point}`);
  }
  /**
   * Decode an event received in a receipt
   *
   * @example
   * ```ts
   * const contract = new Contract({
   *   id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   abi: utils.tokenAbi,
   * });
   * const event = {
   *   sequence: 1,
   *   source: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   name: "koinos.contracts.token.mint_event",
   *   data: "ChkAxjdqxuwS-B50lPQ-lqhRBA3bf2b2ooAHENrw3Ek=",
   *   impacted: ["1K55BRw87nd64a7aiRarp6DLGRzYvoJo8J"],
   * };
   * const eventDecoded = await contract.decodeEvent(event);
   * console.log(eventDecoded);
   * // {
   * //   sequence: 1,
   * //   source: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   * //   name: "koinos.contracts.token.mint_event",
   * //   data: "ChkAxjdqxuwS-B50lPQ-lqhRBA3bf2b2ooAHENrw3Ek=",
   * //   impacted: ["1K55BRw87nd64a7aiRarp6DLGRzYvoJo8J"],
   * //   args: {
   * //     to: "1K55BRw87nd64a7aiRarp6DLGRzYvoJo8J",
   * //     value: "154613850",
   * //   },
   * // }
   * ```
   */
  async decodeEvent(e) {
    if (!this.serializer)
      throw new Error("Serializer is not defined");
    let fe = e.name;
    this.abi && this.abi.events && this.abi.events[e.name] && (fe = this.abi.events[e.name].argument);
    const be = fe ? await this.serializer.deserialize(e.data, fe) : {};
    return { ...e, args: be };
  }
}
Contract$1.Contract = Contract;
Contract$1.default = Contract;
var Signer$1 = {}, lib = {};
(function(v) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(v, "__esModule", { value: !0 }), v.utils = v.schnorr = v.verify = v.signSync = v.sign = v.getSharedSecret = v.recoverPublicKey = v.getPublicKey = v.Signature = v.Point = v.CURVE = void 0;
  const e = require$$0, fe = BigInt(0), be = BigInt(1), ye = BigInt(2), ve = BigInt(3), Ee = BigInt(8), Se = Object.freeze({
    a: fe,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: be,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  v.CURVE = Se;
  const Oe = (Yr, Ur) => (Yr + Ur / ye) / Ur, xe = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Yr) {
      const { n: Ur } = Se, Jr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), to = -be * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), po = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), yo = Jr, mo = BigInt("0x100000000000000000000000000000000"), vo = Oe(yo * Yr, Ur), Ao = Oe(-to * Yr, Ur);
      let wo = io(Yr - vo * Jr - Ao * po, Ur), Do = io(-vo * to - Ao * yo, Ur);
      const Io = wo > mo, No = Do > mo;
      if (Io && (wo = Ur - wo), No && (Do = Ur - Do), wo > mo || Do > mo)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Yr);
      return { k1neg: Io, k1: wo, k2neg: No, k2: Do };
    }
  }, me = 32, we = 32, ur = 32, lr = me + 1, Ar = 2 * me + 1;
  function Br(Yr) {
    const { a: Ur, b: Jr } = Se, to = io(Yr * Yr), po = io(to * Yr);
    return io(po + Ur * Yr + Jr);
  }
  const Xr = Se.a === fe;
  class eo extends Error {
    constructor(Ur) {
      super(Ur);
    }
  }
  function jr(Yr) {
    if (!(Yr instanceof kr))
      throw new TypeError("JacobianPoint expected");
  }
  class kr {
    constructor(Ur, Jr, to) {
      this.x = Ur, this.y = Jr, this.z = to;
    }
    static fromAffine(Ur) {
      if (!(Ur instanceof Mr))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Ur.equals(Mr.ZERO) ? kr.ZERO : new kr(Ur.x, Ur.y, be);
    }
    static toAffineBatch(Ur) {
      const Jr = ao(Ur.map((to) => to.z));
      return Ur.map((to, po) => to.toAffine(Jr[po]));
    }
    static normalizeZ(Ur) {
      return kr.toAffineBatch(Ur).map(kr.fromAffine);
    }
    equals(Ur) {
      jr(Ur);
      const { x: Jr, y: to, z: po } = this, { x: yo, y: mo, z: vo } = Ur, Ao = io(po * po), wo = io(vo * vo), Do = io(Jr * wo), Io = io(yo * Ao), No = io(io(to * vo) * wo), Go = io(io(mo * po) * Ao);
      return Do === Io && No === Go;
    }
    negate() {
      return new kr(this.x, io(-this.y), this.z);
    }
    double() {
      const { x: Ur, y: Jr, z: to } = this, po = io(Ur * Ur), yo = io(Jr * Jr), mo = io(yo * yo), vo = Ur + yo, Ao = io(ye * (io(vo * vo) - po - mo)), wo = io(ve * po), Do = io(wo * wo), Io = io(Do - ye * Ao), No = io(wo * (Ao - Io) - Ee * mo), Go = io(ye * Jr * to);
      return new kr(Io, No, Go);
    }
    add(Ur) {
      jr(Ur);
      const { x: Jr, y: to, z: po } = this, { x: yo, y: mo, z: vo } = Ur;
      if (yo === fe || mo === fe)
        return this;
      if (Jr === fe || to === fe)
        return Ur;
      const Ao = io(po * po), wo = io(vo * vo), Do = io(Jr * wo), Io = io(yo * Ao), No = io(io(to * vo) * wo), Go = io(io(mo * po) * Ao), En = io(Io - Do), Nn = io(Go - No);
      if (En === fe)
        return Nn === fe ? this.double() : kr.ZERO;
      const ti = io(En * En), Rn = io(En * ti), ri = io(Do * ti), pi = io(Nn * Nn - Rn - ye * ri), fi = io(Nn * (ri - pi) - No * Rn), si = io(po * vo * En);
      return new kr(pi, fi, si);
    }
    subtract(Ur) {
      return this.add(Ur.negate());
    }
    multiplyUnsafe(Ur) {
      const Jr = kr.ZERO;
      if (typeof Ur == "bigint" && Ur === fe)
        return Jr;
      let to = So(Ur);
      if (to === be)
        return this;
      if (!Xr) {
        let Io = Jr, No = this;
        for (; to > fe; )
          to & be && (Io = Io.add(No)), No = No.double(), to >>= be;
        return Io;
      }
      let { k1neg: po, k1: yo, k2neg: mo, k2: vo } = xe.splitScalar(to), Ao = Jr, wo = Jr, Do = this;
      for (; yo > fe || vo > fe; )
        yo & be && (Ao = Ao.add(Do)), vo & be && (wo = wo.add(Do)), Do = Do.double(), yo >>= be, vo >>= be;
      return po && (Ao = Ao.negate()), mo && (wo = wo.negate()), wo = new kr(io(wo.x * xe.beta), wo.y, wo.z), Ao.add(wo);
    }
    precomputeWindow(Ur) {
      const Jr = Xr ? 128 / Ur + 1 : 256 / Ur + 1, to = [];
      let po = this, yo = po;
      for (let mo = 0; mo < Jr; mo++) {
        yo = po, to.push(yo);
        for (let vo = 1; vo < 2 ** (Ur - 1); vo++)
          yo = yo.add(po), to.push(yo);
        po = yo.double();
      }
      return to;
    }
    wNAF(Ur, Jr) {
      !Jr && this.equals(kr.BASE) && (Jr = Mr.BASE);
      const to = Jr && Jr._WINDOW_SIZE || 1;
      if (256 % to)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let po = Jr && Vr.get(Jr);
      po || (po = this.precomputeWindow(to), Jr && to !== 1 && (po = kr.normalizeZ(po), Vr.set(Jr, po)));
      let yo = kr.ZERO, mo = kr.BASE;
      const vo = 1 + (Xr ? 128 / to : 256 / to), Ao = 2 ** (to - 1), wo = BigInt(2 ** to - 1), Do = 2 ** to, Io = BigInt(to);
      for (let No = 0; No < vo; No++) {
        const Go = No * Ao;
        let En = Number(Ur & wo);
        Ur >>= Io, En > Ao && (En -= Do, Ur += be);
        const Nn = Go, ti = Go + Math.abs(En) - 1, Rn = No % 2 !== 0, ri = En < 0;
        En === 0 ? mo = mo.add($r(Rn, po[Nn])) : yo = yo.add($r(ri, po[ti]));
      }
      return { p: yo, f: mo };
    }
    multiply(Ur, Jr) {
      let to = So(Ur), po, yo;
      if (Xr) {
        const { k1neg: mo, k1: vo, k2neg: Ao, k2: wo } = xe.splitScalar(to);
        let { p: Do, f: Io } = this.wNAF(vo, Jr), { p: No, f: Go } = this.wNAF(wo, Jr);
        Do = $r(mo, Do), No = $r(Ao, No), No = new kr(io(No.x * xe.beta), No.y, No.z), po = Do.add(No), yo = Io.add(Go);
      } else {
        const { p: mo, f: vo } = this.wNAF(to, Jr);
        po = mo, yo = vo;
      }
      return kr.normalizeZ([po, yo])[0];
    }
    toAffine(Ur) {
      const { x: Jr, y: to, z: po } = this, yo = this.equals(kr.ZERO);
      Ur == null && (Ur = yo ? Ee : Mo(po));
      const mo = Ur, vo = io(mo * mo), Ao = io(vo * mo), wo = io(Jr * vo), Do = io(to * Ao), Io = io(po * mo);
      if (yo)
        return Mr.ZERO;
      if (Io !== be)
        throw new Error("invZ was invalid");
      return new Mr(wo, Do);
    }
  }
  kr.BASE = new kr(Se.Gx, Se.Gy, be), kr.ZERO = new kr(fe, be, fe);
  function $r(Yr, Ur) {
    const Jr = Ur.negate();
    return Yr ? Jr : Ur;
  }
  const Vr = /* @__PURE__ */ new WeakMap();
  class Mr {
    constructor(Ur, Jr) {
      this.x = Ur, this.y = Jr;
    }
    _setWindowSize(Ur) {
      this._WINDOW_SIZE = Ur, Vr.delete(this);
    }
    hasEvenY() {
      return this.y % ye === fe;
    }
    static fromCompressedHex(Ur) {
      const Jr = Ur.length === 32, to = uo(Jr ? Ur : Ur.subarray(1));
      if (!Eo(to))
        throw new Error("Point is not on curve");
      const po = Br(to);
      let yo = Oo(po);
      const mo = (yo & be) === be;
      Jr ? mo && (yo = io(-yo)) : (Ur[0] & 1) === 1 !== mo && (yo = io(-yo));
      const vo = new Mr(to, yo);
      return vo.assertValidity(), vo;
    }
    static fromUncompressedHex(Ur) {
      const Jr = uo(Ur.subarray(1, me + 1)), to = uo(Ur.subarray(me + 1, me * 2 + 1)), po = new Mr(Jr, to);
      return po.assertValidity(), po;
    }
    static fromHex(Ur) {
      const Jr = bo(Ur), to = Jr.length, po = Jr[0];
      if (to === me)
        return this.fromCompressedHex(Jr);
      if (to === lr && (po === 2 || po === 3))
        return this.fromCompressedHex(Jr);
      if (to === Ar && po === 4)
        return this.fromUncompressedHex(Jr);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${lr} compressed bytes or ${Ar} uncompressed bytes, not ${to}`);
    }
    static fromPrivateKey(Ur) {
      return Mr.BASE.multiply(Po(Ur));
    }
    static fromSignature(Ur, Jr, to) {
      const { r: po, s: yo } = Qo(Jr);
      if (![0, 1, 2, 3].includes(to))
        throw new Error("Cannot recover: invalid recovery bit");
      const mo = zr(bo(Ur)), { n: vo } = Se, Ao = to === 2 || to === 3 ? po + vo : po, wo = Mo(Ao, vo), Do = io(-mo * wo, vo), Io = io(yo * wo, vo), No = to & 1 ? "03" : "02", Go = Mr.fromHex(No + Lr(Ao)), En = Mr.BASE.multiplyAndAddUnsafe(Go, Do, Io);
      if (!En)
        throw new Error("Cannot recover signature: point at infinify");
      return En.assertValidity(), En;
    }
    toRawBytes(Ur = !1) {
      return no(this.toHex(Ur));
    }
    toHex(Ur = !1) {
      const Jr = Lr(this.x);
      return Ur ? `${this.hasEvenY() ? "02" : "03"}${Jr}` : `04${Jr}${Lr(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Ur = "Point is not on elliptic curve", { x: Jr, y: to } = this;
      if (!Eo(Jr) || !Eo(to))
        throw new Error(Ur);
      const po = io(to * to), yo = Br(Jr);
      if (io(po - yo) !== fe)
        throw new Error(Ur);
    }
    equals(Ur) {
      return this.x === Ur.x && this.y === Ur.y;
    }
    negate() {
      return new Mr(this.x, io(-this.y));
    }
    double() {
      return kr.fromAffine(this).double().toAffine();
    }
    add(Ur) {
      return kr.fromAffine(this).add(kr.fromAffine(Ur)).toAffine();
    }
    subtract(Ur) {
      return this.add(Ur.negate());
    }
    multiply(Ur) {
      return kr.fromAffine(this).multiply(Ur, this).toAffine();
    }
    multiplyAndAddUnsafe(Ur, Jr, to) {
      const po = kr.fromAffine(this), yo = Jr === fe || Jr === be || this !== Mr.BASE ? po.multiplyUnsafe(Jr) : po.multiply(Jr), mo = kr.fromAffine(Ur).multiplyUnsafe(to), vo = yo.add(mo);
      return vo.equals(kr.ZERO) ? void 0 : vo.toAffine();
    }
  }
  v.Point = Mr, Mr.BASE = new Mr(Se.Gx, Se.Gy), Mr.ZERO = new Mr(fe, fe);
  function gr(Yr) {
    return Number.parseInt(Yr[0], 16) >= 8 ? "00" + Yr : Yr;
  }
  function Fr(Yr) {
    if (Yr.length < 2 || Yr[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${lo(Yr)}`);
    const Ur = Yr[1], Jr = Yr.subarray(2, Ur + 2);
    if (!Ur || Jr.length !== Ur)
      throw new Error("Invalid signature integer: wrong length");
    if (Jr[0] === 0 && Jr[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: uo(Jr), left: Yr.subarray(Ur + 2) };
  }
  function Zr(Yr) {
    if (Yr.length < 2 || Yr[0] != 48)
      throw new Error(`Invalid signature tag: ${lo(Yr)}`);
    if (Yr[1] !== Yr.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Ur, left: Jr } = Fr(Yr.subarray(2)), { data: to, left: po } = Fr(Jr);
    if (po.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${lo(po)}`);
    return { r: Ur, s: to };
  }
  class Wr {
    constructor(Ur, Jr) {
      this.r = Ur, this.s = Jr, this.assertValidity();
    }
    static fromCompact(Ur) {
      const Jr = Ur instanceof Uint8Array, to = "Signature.fromCompact";
      if (typeof Ur != "string" && !Jr)
        throw new TypeError(`${to}: Expected string or Uint8Array`);
      const po = Jr ? lo(Ur) : Ur;
      if (po.length !== 128)
        throw new Error(`${to}: Expected 64-byte hex`);
      return new Wr(co(po.slice(0, 64)), co(po.slice(64, 128)));
    }
    static fromDER(Ur) {
      const Jr = Ur instanceof Uint8Array;
      if (typeof Ur != "string" && !Jr)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: to, s: po } = Zr(Jr ? Ur : no(Ur));
      return new Wr(to, po);
    }
    static fromHex(Ur) {
      return this.fromDER(Ur);
    }
    assertValidity() {
      const { r: Ur, s: Jr } = this;
      if (!ho(Ur))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!ho(Jr))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Ur = Se.n >> be;
      return this.s > Ur;
    }
    normalizeS() {
      return this.hasHighS() ? new Wr(this.r, io(-this.s, Se.n)) : this;
    }
    toDERRawBytes() {
      return no(this.toDERHex());
    }
    toDERHex() {
      const Ur = gr(fo(this.s)), Jr = gr(fo(this.r)), to = Ur.length / 2, po = Jr.length / 2, yo = fo(to), mo = fo(po);
      return `30${fo(po + to + 4)}02${mo}${Jr}02${yo}${Ur}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return no(this.toCompactHex());
    }
    toCompactHex() {
      return Lr(this.r) + Lr(this.s);
    }
  }
  v.Signature = Wr;
  function qr(...Yr) {
    if (!Yr.every((to) => to instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Yr.length === 1)
      return Yr[0];
    const Ur = Yr.reduce((to, po) => to + po.length, 0), Jr = new Uint8Array(Ur);
    for (let to = 0, po = 0; to < Yr.length; to++) {
      const yo = Yr[to];
      Jr.set(yo, po), po += yo.length;
    }
    return Jr;
  }
  const Qr = Array.from({ length: 256 }, (Yr, Ur) => Ur.toString(16).padStart(2, "0"));
  function lo(Yr) {
    if (!(Yr instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Ur = "";
    for (let Jr = 0; Jr < Yr.length; Jr++)
      Ur += Qr[Yr[Jr]];
    return Ur;
  }
  const Nr = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Lr(Yr) {
    if (typeof Yr != "bigint")
      throw new Error("Expected bigint");
    if (!(fe <= Yr && Yr < Nr))
      throw new Error("Expected number 0 <= n < 2^256");
    return Yr.toString(16).padStart(64, "0");
  }
  function so(Yr) {
    const Ur = no(Lr(Yr));
    if (Ur.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Ur;
  }
  function fo(Yr) {
    const Ur = Yr.toString(16);
    return Ur.length & 1 ? `0${Ur}` : Ur;
  }
  function co(Yr) {
    if (typeof Yr != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Yr);
    return BigInt(`0x${Yr}`);
  }
  function no(Yr) {
    if (typeof Yr != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Yr);
    if (Yr.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Yr.length);
    const Ur = new Uint8Array(Yr.length / 2);
    for (let Jr = 0; Jr < Ur.length; Jr++) {
      const to = Jr * 2, po = Yr.slice(to, to + 2), yo = Number.parseInt(po, 16);
      if (Number.isNaN(yo) || yo < 0)
        throw new Error("Invalid byte sequence");
      Ur[Jr] = yo;
    }
    return Ur;
  }
  function uo(Yr) {
    return co(lo(Yr));
  }
  function bo(Yr) {
    return Yr instanceof Uint8Array ? Uint8Array.from(Yr) : no(Yr);
  }
  function So(Yr) {
    if (typeof Yr == "number" && Number.isSafeInteger(Yr) && Yr > 0)
      return BigInt(Yr);
    if (typeof Yr == "bigint" && ho(Yr))
      return Yr;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function io(Yr, Ur = Se.P) {
    const Jr = Yr % Ur;
    return Jr >= fe ? Jr : Ur + Jr;
  }
  function To(Yr, Ur) {
    const { P: Jr } = Se;
    let to = Yr;
    for (; Ur-- > fe; )
      to *= to, to %= Jr;
    return to;
  }
  function Oo(Yr) {
    const { P: Ur } = Se, Jr = BigInt(6), to = BigInt(11), po = BigInt(22), yo = BigInt(23), mo = BigInt(44), vo = BigInt(88), Ao = Yr * Yr * Yr % Ur, wo = Ao * Ao * Yr % Ur, Do = To(wo, ve) * wo % Ur, Io = To(Do, ve) * wo % Ur, No = To(Io, ye) * Ao % Ur, Go = To(No, to) * No % Ur, En = To(Go, po) * Go % Ur, Nn = To(En, mo) * En % Ur, ti = To(Nn, vo) * Nn % Ur, Rn = To(ti, mo) * En % Ur, ri = To(Rn, ve) * wo % Ur, pi = To(ri, yo) * Go % Ur, fi = To(pi, Jr) * Ao % Ur, si = To(fi, ye);
    if (si * si % Ur !== Yr)
      throw new Error("Cannot find square root");
    return si;
  }
  function Mo(Yr, Ur = Se.P) {
    if (Yr === fe || Ur <= fe)
      throw new Error(`invert: expected positive integers, got n=${Yr} mod=${Ur}`);
    let Jr = io(Yr, Ur), to = Ur, po = fe, yo = be;
    for (; Jr !== fe; ) {
      const vo = to / Jr, Ao = to % Jr, wo = po - yo * vo;
      to = Jr, Jr = Ao, po = yo, yo = wo;
    }
    if (to !== be)
      throw new Error("invert: does not exist");
    return io(po, Ur);
  }
  function ao(Yr, Ur = Se.P) {
    const Jr = new Array(Yr.length), to = Yr.reduce((yo, mo, vo) => mo === fe ? yo : (Jr[vo] = yo, io(yo * mo, Ur)), be), po = Mo(to, Ur);
    return Yr.reduceRight((yo, mo, vo) => mo === fe ? yo : (Jr[vo] = io(yo * Jr[vo], Ur), io(yo * mo, Ur)), po), Jr;
  }
  function oo(Yr) {
    const Ur = Yr.length * 8 - we * 8, Jr = uo(Yr);
    return Ur > 0 ? Jr >> BigInt(Ur) : Jr;
  }
  function zr(Yr, Ur = !1) {
    const Jr = oo(Yr);
    if (Ur)
      return Jr;
    const { n: to } = Se;
    return Jr >= to ? Jr - to : Jr;
  }
  let dr, Hr;
  class go {
    constructor(Ur, Jr) {
      if (this.hashLen = Ur, this.qByteLen = Jr, typeof Ur != "number" || Ur < 2)
        throw new Error("hashLen must be a number");
      if (typeof Jr != "number" || Jr < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Ur).fill(1), this.k = new Uint8Array(Ur).fill(0), this.counter = 0;
    }
    hmac(...Ur) {
      return v.utils.hmacSha256(this.k, ...Ur);
    }
    hmacSync(...Ur) {
      return Hr(this.k, ...Ur);
    }
    checkSync() {
      if (typeof Hr != "function")
        throw new eo("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Ur = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Ur), this.v = await this.hmac(this.v), Ur.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Ur), this.v = await this.hmac(this.v));
    }
    reseedSync(Ur = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Ur), this.v = this.hmacSync(this.v), Ur.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Ur), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Ur = 0;
      const Jr = [];
      for (; Ur < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const to = this.v.slice();
        Jr.push(to), Ur += this.v.length;
      }
      return qr(...Jr);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Ur = 0;
      const Jr = [];
      for (; Ur < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const to = this.v.slice();
        Jr.push(to), Ur += this.v.length;
      }
      return qr(...Jr);
    }
  }
  function ho(Yr) {
    return fe < Yr && Yr < Se.n;
  }
  function Eo(Yr) {
    return fe < Yr && Yr < Se.P;
  }
  function Fo(Yr, Ur, Jr, to = !0) {
    const { n: po } = Se, yo = zr(Yr, !0);
    if (!ho(yo))
      return;
    const mo = Mo(yo, po), vo = Mr.BASE.multiply(yo), Ao = io(vo.x, po);
    if (Ao === fe)
      return;
    const wo = io(mo * io(Ur + Jr * Ao, po), po);
    if (wo === fe)
      return;
    let Do = new Wr(Ao, wo), Io = (vo.x === Do.r ? 0 : 2) | Number(vo.y & be);
    return to && Do.hasHighS() && (Do = Do.normalizeS(), Io ^= 1), { sig: Do, recovery: Io };
  }
  function Po(Yr) {
    let Ur;
    if (typeof Yr == "bigint")
      Ur = Yr;
    else if (typeof Yr == "number" && Number.isSafeInteger(Yr) && Yr > 0)
      Ur = BigInt(Yr);
    else if (typeof Yr == "string") {
      if (Yr.length !== 2 * we)
        throw new Error("Expected 32 bytes of private key");
      Ur = co(Yr);
    } else if (Yr instanceof Uint8Array) {
      if (Yr.length !== we)
        throw new Error("Expected 32 bytes of private key");
      Ur = uo(Yr);
    } else
      throw new TypeError("Expected valid private key");
    if (!ho(Ur))
      throw new Error("Expected private key: 0 < key < n");
    return Ur;
  }
  function jo(Yr) {
    return Yr instanceof Mr ? (Yr.assertValidity(), Yr) : Mr.fromHex(Yr);
  }
  function Qo(Yr) {
    if (Yr instanceof Wr)
      return Yr.assertValidity(), Yr;
    try {
      return Wr.fromDER(Yr);
    } catch {
      return Wr.fromCompact(Yr);
    }
  }
  function bn(Yr, Ur = !1) {
    return Mr.fromPrivateKey(Yr).toRawBytes(Ur);
  }
  v.getPublicKey = bn;
  function Lo(Yr, Ur, Jr, to = !1) {
    return Mr.fromSignature(Yr, Ur, Jr).toRawBytes(to);
  }
  v.recoverPublicKey = Lo;
  function Vo(Yr) {
    const Ur = Yr instanceof Uint8Array, Jr = typeof Yr == "string", to = (Ur || Jr) && Yr.length;
    return Ur ? to === lr || to === Ar : Jr ? to === lr * 2 || to === Ar * 2 : Yr instanceof Mr;
  }
  function zo(Yr, Ur, Jr = !1) {
    if (Vo(Yr))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Vo(Ur))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const to = jo(Ur);
    return to.assertValidity(), to.multiply(Po(Yr)).toRawBytes(Jr);
  }
  v.getSharedSecret = zo;
  function ko(Yr) {
    const Ur = Yr.length > me ? Yr.slice(0, me) : Yr;
    return uo(Ur);
  }
  function Wo(Yr) {
    const Ur = ko(Yr), Jr = io(Ur, Se.n);
    return Co(Jr < fe ? Ur : Jr);
  }
  function Co(Yr) {
    return so(Yr);
  }
  function $o(Yr, Ur, Jr) {
    if (Yr == null)
      throw new Error(`sign: expected valid message hash, not "${Yr}"`);
    const to = bo(Yr), po = Po(Ur), yo = [Co(po), Wo(to)];
    if (Jr != null) {
      Jr === !0 && (Jr = v.utils.randomBytes(me));
      const Ao = bo(Jr);
      if (Ao.length !== me)
        throw new Error(`sign: Expected ${me} bytes of extra data`);
      yo.push(Ao);
    }
    const mo = qr(...yo), vo = ko(to);
    return { seed: mo, m: vo, d: po };
  }
  function xo(Yr, Ur) {
    const { sig: Jr, recovery: to } = Yr, { der: po, recovered: yo } = Object.assign({ canonical: !0, der: !0 }, Ur), mo = po ? Jr.toDERRawBytes() : Jr.toCompactRawBytes();
    return yo ? [mo, to] : mo;
  }
  async function Ho(Yr, Ur, Jr = {}) {
    const { seed: to, m: po, d: yo } = $o(Yr, Ur, Jr.extraEntropy), mo = new go(ur, we);
    await mo.reseed(to);
    let vo;
    for (; !(vo = Fo(await mo.generate(), po, yo, Jr.canonical)); )
      await mo.reseed();
    return xo(vo, Jr);
  }
  v.sign = Ho;
  function qo(Yr, Ur, Jr = {}) {
    const { seed: to, m: po, d: yo } = $o(Yr, Ur, Jr.extraEntropy), mo = new go(ur, we);
    mo.reseedSync(to);
    let vo;
    for (; !(vo = Fo(mo.generateSync(), po, yo, Jr.canonical)); )
      mo.reseedSync();
    return xo(vo, Jr);
  }
  v.signSync = qo;
  const Bo = { strict: !0 };
  function Yo(Yr, Ur, Jr, to = Bo) {
    let po;
    try {
      po = Qo(Yr), Ur = bo(Ur);
    } catch {
      return !1;
    }
    const { r: yo, s: mo } = po;
    if (to.strict && po.hasHighS())
      return !1;
    const vo = zr(Ur);
    let Ao;
    try {
      Ao = jo(Jr);
    } catch {
      return !1;
    }
    const { n: wo } = Se, Do = Mo(mo, wo), Io = io(vo * Do, wo), No = io(yo * Do, wo), Go = Mr.BASE.multiplyAndAddUnsafe(Ao, Io, No);
    return Go ? io(Go.x, wo) === yo : !1;
  }
  v.verify = Yo;
  function Ko(Yr) {
    return io(uo(Yr), Se.n);
  }
  class Jo {
    constructor(Ur, Jr) {
      this.r = Ur, this.s = Jr, this.assertValidity();
    }
    static fromHex(Ur) {
      const Jr = bo(Ur);
      if (Jr.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Jr.length}`);
      const to = uo(Jr.subarray(0, 32)), po = uo(Jr.subarray(32, 64));
      return new Jo(to, po);
    }
    assertValidity() {
      const { r: Ur, s: Jr } = this;
      if (!Eo(Ur) || !ho(Jr))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Lr(this.r) + Lr(this.s);
    }
    toRawBytes() {
      return no(this.toHex());
    }
  }
  function Zo(Yr) {
    return Mr.fromPrivateKey(Yr).toRawX();
  }
  class Xo {
    constructor(Ur, Jr, to = v.utils.randomBytes()) {
      if (Ur == null)
        throw new TypeError(`sign: Expected valid message, not "${Ur}"`);
      this.m = bo(Ur);
      const { x: po, scalar: yo } = this.getScalar(Po(Jr));
      if (this.px = po, this.d = yo, this.rand = bo(to), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Ur) {
      const Jr = Mr.fromPrivateKey(Ur), to = Jr.hasEvenY() ? Ur : Se.n - Ur;
      return { point: Jr, scalar: to, x: Jr.toRawX() };
    }
    initNonce(Ur, Jr) {
      return so(Ur ^ uo(Jr));
    }
    finalizeNonce(Ur) {
      const Jr = io(uo(Ur), Se.n);
      if (Jr === fe)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: to, x: po, scalar: yo } = this.getScalar(Jr);
      return { R: to, rx: po, k: yo };
    }
    finalizeSig(Ur, Jr, to, po) {
      return new Jo(Ur.x, io(Jr + to * po, Se.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Ur, d: Jr, px: to, rand: po } = this, yo = v.utils.taggedHash, mo = this.initNonce(Jr, await yo(gn.aux, po)), { R: vo, rx: Ao, k: wo } = this.finalizeNonce(await yo(gn.nonce, mo, to, Ur)), Do = Ko(await yo(gn.challenge, Ao, to, Ur)), Io = this.finalizeSig(vo, wo, Do, Jr);
      return await Zn(Io, Ur, to) || this.error(), Io;
    }
    calcSync() {
      const { m: Ur, d: Jr, px: to, rand: po } = this, yo = v.utils.taggedHashSync, mo = this.initNonce(Jr, yo(gn.aux, po)), { R: vo, rx: Ao, k: wo } = this.finalizeNonce(yo(gn.nonce, mo, to, Ur)), Do = Ko(yo(gn.challenge, Ao, to, Ur)), Io = this.finalizeSig(vo, wo, Do, Jr);
      return ei(Io, Ur, to) || this.error(), Io;
    }
  }
  async function Pn(Yr, Ur, Jr) {
    return new Xo(Yr, Ur, Jr).calc();
  }
  function Un(Yr, Ur, Jr) {
    return new Xo(Yr, Ur, Jr).calcSync();
  }
  function Yn(Yr, Ur, Jr) {
    const to = Yr instanceof Jo, po = to ? Yr : Jo.fromHex(Yr);
    return to && po.assertValidity(), {
      ...po,
      m: bo(Ur),
      P: jo(Jr)
    };
  }
  function An(Yr, Ur, Jr, to) {
    const po = Mr.BASE.multiplyAndAddUnsafe(Ur, Po(Jr), io(-to, Se.n));
    return !(!po || !po.hasEvenY() || po.x !== Yr);
  }
  async function Zn(Yr, Ur, Jr) {
    try {
      const { r: to, s: po, m: yo, P: mo } = Yn(Yr, Ur, Jr), vo = Ko(await v.utils.taggedHash(gn.challenge, so(to), mo.toRawX(), yo));
      return An(to, mo, po, vo);
    } catch {
      return !1;
    }
  }
  function ei(Yr, Ur, Jr) {
    try {
      const { r: to, s: po, m: yo, P: mo } = Yn(Yr, Ur, Jr), vo = Ko(v.utils.taggedHashSync(gn.challenge, so(to), mo.toRawX(), yo));
      return An(to, mo, po, vo);
    } catch (to) {
      if (to instanceof eo)
        throw to;
      return !1;
    }
  }
  v.schnorr = {
    Signature: Jo,
    getPublicKey: Zo,
    sign: Pn,
    verify: Zn,
    signSync: Un,
    verifySync: ei
  }, Mr.BASE._setWindowSize(8);
  const Sn = {
    node: e,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, gn = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, hn = {};
  v.utils = {
    bytesToHex: lo,
    hexToBytes: no,
    concatBytes: qr,
    mod: io,
    invert: Mo,
    isValidPrivateKey(Yr) {
      try {
        return Po(Yr), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: so,
    _normalizePrivateKey: Po,
    hashToPrivateKey: (Yr) => {
      Yr = bo(Yr);
      const Ur = we + 8;
      if (Yr.length < Ur || Yr.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Jr = io(uo(Yr), Se.n - be) + be;
      return so(Jr);
    },
    randomBytes: (Yr = 32) => {
      if (Sn.web)
        return Sn.web.getRandomValues(new Uint8Array(Yr));
      if (Sn.node) {
        const { randomBytes: Ur } = Sn.node;
        return Uint8Array.from(Ur(Yr));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => v.utils.hashToPrivateKey(v.utils.randomBytes(we + 8)),
    precompute(Yr = 8, Ur = Mr.BASE) {
      const Jr = Ur === Mr.BASE ? Ur : new Mr(Ur.x, Ur.y);
      return Jr._setWindowSize(Yr), Jr.multiply(ve), Jr;
    },
    sha256: async (...Yr) => {
      if (Sn.web) {
        const Ur = await Sn.web.subtle.digest("SHA-256", qr(...Yr));
        return new Uint8Array(Ur);
      } else if (Sn.node) {
        const { createHash: Ur } = Sn.node, Jr = Ur("sha256");
        return Yr.forEach((to) => Jr.update(to)), Uint8Array.from(Jr.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Yr, ...Ur) => {
      if (Sn.web) {
        const Jr = await Sn.web.subtle.importKey("raw", Yr, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), to = qr(...Ur), po = await Sn.web.subtle.sign("HMAC", Jr, to);
        return new Uint8Array(po);
      } else if (Sn.node) {
        const { createHmac: Jr } = Sn.node, to = Jr("sha256", Yr);
        return Ur.forEach((po) => to.update(po)), Uint8Array.from(to.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Yr, ...Ur) => {
      let Jr = hn[Yr];
      if (Jr === void 0) {
        const to = await v.utils.sha256(Uint8Array.from(Yr, (po) => po.charCodeAt(0)));
        Jr = qr(to, to), hn[Yr] = Jr;
      }
      return v.utils.sha256(Jr, ...Ur);
    },
    taggedHashSync: (Yr, ...Ur) => {
      if (typeof dr != "function")
        throw new eo("sha256Sync is undefined, you need to set it");
      let Jr = hn[Yr];
      if (Jr === void 0) {
        const to = dr(Uint8Array.from(Yr, (po) => po.charCodeAt(0)));
        Jr = qr(to, to), hn[Yr] = Jr;
      }
      return dr(Jr, ...Ur);
    },
    _JacobianPoint: kr
  }, Object.defineProperties(v.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return dr;
      },
      set(Yr) {
        dr || (dr = Yr);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Hr;
      },
      set(Yr) {
        Hr || (Hr = Yr);
      }
    }
  });
})(lib);
var protocolProto = { exports: {} }, minimal, hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, minimal = indexMinimal), minimal;
}
(function(v) {
  (function(e, fe) {
    typeof commonjsRequire == "function" && v && v.exports && (v.exports = fe(requireMinimal()));
  })(commonjsGlobal, function(e) {
    var fe = e.Reader, be = e.Writer, ye = e.util, ve = e.roots.default || (e.roots.default = {});
    return ve.koinos = function() {
      var Ee = {};
      return Ee.protocol = function() {
        var Se = {};
        return Se.event_data = function() {
          function Oe(xe) {
            if (this.impacted = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.sequence = 0, Oe.prototype.source = ye.newBuffer([]), Oe.prototype.name = "", Oe.prototype.data = ye.newBuffer([]), Oe.prototype.impacted = ye.emptyArray, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.sequence != null && Object.hasOwnProperty.call(me, "sequence") && we.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(me.sequence), me.source != null && Object.hasOwnProperty.call(me, "source") && we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(me.source), me.name != null && Object.hasOwnProperty.call(me, "name") && we.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(me.name), me.data != null && Object.hasOwnProperty.call(me, "data") && we.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(me.data), me.impacted != null && me.impacted.length)
              for (var ur = 0; ur < me.impacted.length; ++ur)
                we.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).bytes(me.impacted[ur]);
            return we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.event_data(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.sequence = me.uint32();
                  break;
                }
                case 2: {
                  lr.source = me.bytes();
                  break;
                }
                case 3: {
                  lr.name = me.string();
                  break;
                }
                case 4: {
                  lr.data = me.bytes();
                  break;
                }
                case 5: {
                  lr.impacted && lr.impacted.length || (lr.impacted = []), lr.impacted.push(me.bytes());
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.sequence != null && me.hasOwnProperty("sequence") && !ye.isInteger(me.sequence))
              return "sequence: integer expected";
            if (me.source != null && me.hasOwnProperty("source") && !(me.source && typeof me.source.length == "number" || ye.isString(me.source)))
              return "source: buffer expected";
            if (me.name != null && me.hasOwnProperty("name") && !ye.isString(me.name))
              return "name: string expected";
            if (me.data != null && me.hasOwnProperty("data") && !(me.data && typeof me.data.length == "number" || ye.isString(me.data)))
              return "data: buffer expected";
            if (me.impacted != null && me.hasOwnProperty("impacted")) {
              if (!Array.isArray(me.impacted))
                return "impacted: array expected";
              for (var we = 0; we < me.impacted.length; ++we)
                if (!(me.impacted[we] && typeof me.impacted[we].length == "number" || ye.isString(me.impacted[we])))
                  return "impacted: buffer[] expected";
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.event_data)
              return me;
            var we = new ve.koinos.protocol.event_data();
            if (me.sequence != null && (we.sequence = me.sequence >>> 0), me.source != null && (typeof me.source == "string" ? ye.base64.decode(me.source, we.source = ye.newBuffer(ye.base64.length(me.source)), 0) : me.source.length >= 0 && (we.source = me.source)), me.name != null && (we.name = String(me.name)), me.data != null && (typeof me.data == "string" ? ye.base64.decode(me.data, we.data = ye.newBuffer(ye.base64.length(me.data)), 0) : me.data.length >= 0 && (we.data = me.data)), me.impacted) {
              if (!Array.isArray(me.impacted))
                throw TypeError(".koinos.protocol.event_data.impacted: array expected");
              we.impacted = [];
              for (var ur = 0; ur < me.impacted.length; ++ur)
                typeof me.impacted[ur] == "string" ? ye.base64.decode(me.impacted[ur], we.impacted[ur] = ye.newBuffer(ye.base64.length(me.impacted[ur])), 0) : me.impacted[ur].length >= 0 && (we.impacted[ur] = me.impacted[ur]);
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.impacted = []), we.defaults && (ur.sequence = 0, we.bytes === String ? ur.source = "" : (ur.source = [], we.bytes !== Array && (ur.source = ye.newBuffer(ur.source))), ur.name = "", we.bytes === String ? ur.data = "" : (ur.data = [], we.bytes !== Array && (ur.data = ye.newBuffer(ur.data)))), me.sequence != null && me.hasOwnProperty("sequence") && (ur.sequence = me.sequence), me.source != null && me.hasOwnProperty("source") && (ur.source = we.bytes === String ? ye.base64.encode(me.source, 0, me.source.length) : we.bytes === Array ? Array.prototype.slice.call(me.source) : me.source), me.name != null && me.hasOwnProperty("name") && (ur.name = me.name), me.data != null && me.hasOwnProperty("data") && (ur.data = we.bytes === String ? ye.base64.encode(me.data, 0, me.data.length) : we.bytes === Array ? Array.prototype.slice.call(me.data) : me.data), me.impacted && me.impacted.length) {
              ur.impacted = [];
              for (var lr = 0; lr < me.impacted.length; ++lr)
                ur.impacted[lr] = we.bytes === String ? ye.base64.encode(me.impacted[lr], 0, me.impacted[lr].length) : we.bytes === Array ? Array.prototype.slice.call(me.impacted[lr]) : me.impacted[lr];
            }
            return ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.event_data";
          }, Oe;
        }(), Se.contract_call_bundle = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.contract_id = ye.newBuffer([]), Oe.prototype.entry_point = 0, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.contract_id != null && Object.hasOwnProperty.call(me, "contract_id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.contract_id), me.entry_point != null && Object.hasOwnProperty.call(me, "entry_point") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(me.entry_point), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.contract_call_bundle(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.contract_id = me.bytes();
                  break;
                }
                case 2: {
                  lr.entry_point = me.uint32();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.contract_id != null && me.hasOwnProperty("contract_id") && !(me.contract_id && typeof me.contract_id.length == "number" || ye.isString(me.contract_id)) ? "contract_id: buffer expected" : me.entry_point != null && me.hasOwnProperty("entry_point") && !ye.isInteger(me.entry_point) ? "entry_point: integer expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.contract_call_bundle)
              return me;
            var we = new ve.koinos.protocol.contract_call_bundle();
            return me.contract_id != null && (typeof me.contract_id == "string" ? ye.base64.decode(me.contract_id, we.contract_id = ye.newBuffer(ye.base64.length(me.contract_id)), 0) : me.contract_id.length >= 0 && (we.contract_id = me.contract_id)), me.entry_point != null && (we.entry_point = me.entry_point >>> 0), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (we.bytes === String ? ur.contract_id = "" : (ur.contract_id = [], we.bytes !== Array && (ur.contract_id = ye.newBuffer(ur.contract_id))), ur.entry_point = 0), me.contract_id != null && me.hasOwnProperty("contract_id") && (ur.contract_id = we.bytes === String ? ye.base64.encode(me.contract_id, 0, me.contract_id.length) : we.bytes === Array ? Array.prototype.slice.call(me.contract_id) : me.contract_id), me.entry_point != null && me.hasOwnProperty("entry_point") && (ur.entry_point = me.entry_point), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.contract_call_bundle";
          }, Oe;
        }(), Se.system_call_target = function() {
          function Oe(me) {
            if (me)
              for (var we = Object.keys(me), ur = 0; ur < we.length; ++ur)
                me[we[ur]] != null && (this[we[ur]] = me[we[ur]]);
          }
          Oe.prototype.thunk_id = null, Oe.prototype.system_call_bundle = null;
          var xe;
          return Object.defineProperty(Oe.prototype, "target", {
            get: ye.oneOfGetter(xe = ["thunk_id", "system_call_bundle"]),
            set: ye.oneOfSetter(xe)
          }), Oe.create = function(we) {
            return new Oe(we);
          }, Oe.encode = function(we, ur) {
            return ur || (ur = be.create()), we.thunk_id != null && Object.hasOwnProperty.call(we, "thunk_id") && ur.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(we.thunk_id), we.system_call_bundle != null && Object.hasOwnProperty.call(we, "system_call_bundle") && ve.koinos.protocol.contract_call_bundle.encode(we.system_call_bundle, ur.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), ur;
          }, Oe.encodeDelimited = function(we, ur) {
            return this.encode(we, ur).ldelim();
          }, Oe.decode = function(we, ur) {
            we instanceof fe || (we = fe.create(we));
            for (var lr = ur === void 0 ? we.len : we.pos + ur, Ar = new ve.koinos.protocol.system_call_target(); we.pos < lr; ) {
              var Br = we.uint32();
              switch (Br >>> 3) {
                case 1: {
                  Ar.thunk_id = we.uint32();
                  break;
                }
                case 2: {
                  Ar.system_call_bundle = ve.koinos.protocol.contract_call_bundle.decode(we, we.uint32());
                  break;
                }
                default:
                  we.skipType(Br & 7);
                  break;
              }
            }
            return Ar;
          }, Oe.decodeDelimited = function(we) {
            return we instanceof fe || (we = new fe(we)), this.decode(we, we.uint32());
          }, Oe.verify = function(we) {
            if (typeof we != "object" || we === null)
              return "object expected";
            var ur = {};
            if (we.thunk_id != null && we.hasOwnProperty("thunk_id") && (ur.target = 1, !ye.isInteger(we.thunk_id)))
              return "thunk_id: integer expected";
            if (we.system_call_bundle != null && we.hasOwnProperty("system_call_bundle")) {
              if (ur.target === 1)
                return "target: multiple values";
              ur.target = 1;
              {
                var lr = ve.koinos.protocol.contract_call_bundle.verify(we.system_call_bundle);
                if (lr)
                  return "system_call_bundle." + lr;
              }
            }
            return null;
          }, Oe.fromObject = function(we) {
            if (we instanceof ve.koinos.protocol.system_call_target)
              return we;
            var ur = new ve.koinos.protocol.system_call_target();
            if (we.thunk_id != null && (ur.thunk_id = we.thunk_id >>> 0), we.system_call_bundle != null) {
              if (typeof we.system_call_bundle != "object")
                throw TypeError(".koinos.protocol.system_call_target.system_call_bundle: object expected");
              ur.system_call_bundle = ve.koinos.protocol.contract_call_bundle.fromObject(we.system_call_bundle);
            }
            return ur;
          }, Oe.toObject = function(we, ur) {
            ur || (ur = {});
            var lr = {};
            return we.thunk_id != null && we.hasOwnProperty("thunk_id") && (lr.thunk_id = we.thunk_id, ur.oneofs && (lr.target = "thunk_id")), we.system_call_bundle != null && we.hasOwnProperty("system_call_bundle") && (lr.system_call_bundle = ve.koinos.protocol.contract_call_bundle.toObject(we.system_call_bundle, ur), ur.oneofs && (lr.target = "system_call_bundle")), lr;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(we) {
            return we === void 0 && (we = "type.googleapis.com"), we + "/koinos.protocol.system_call_target";
          }, Oe;
        }(), Se.upload_contract_operation = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.contract_id = ye.newBuffer([]), Oe.prototype.bytecode = ye.newBuffer([]), Oe.prototype.abi = "", Oe.prototype.authorizes_call_contract = !1, Oe.prototype.authorizes_transaction_application = !1, Oe.prototype.authorizes_upload_contract = !1, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.contract_id != null && Object.hasOwnProperty.call(me, "contract_id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.contract_id), me.bytecode != null && Object.hasOwnProperty.call(me, "bytecode") && we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(me.bytecode), me.abi != null && Object.hasOwnProperty.call(me, "abi") && we.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(me.abi), me.authorizes_call_contract != null && Object.hasOwnProperty.call(me, "authorizes_call_contract") && we.uint32(
              /* id 4, wireType 0 =*/
              32
            ).bool(me.authorizes_call_contract), me.authorizes_transaction_application != null && Object.hasOwnProperty.call(me, "authorizes_transaction_application") && we.uint32(
              /* id 5, wireType 0 =*/
              40
            ).bool(me.authorizes_transaction_application), me.authorizes_upload_contract != null && Object.hasOwnProperty.call(me, "authorizes_upload_contract") && we.uint32(
              /* id 6, wireType 0 =*/
              48
            ).bool(me.authorizes_upload_contract), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.upload_contract_operation(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.contract_id = me.bytes();
                  break;
                }
                case 2: {
                  lr.bytecode = me.bytes();
                  break;
                }
                case 3: {
                  lr.abi = me.string();
                  break;
                }
                case 4: {
                  lr.authorizes_call_contract = me.bool();
                  break;
                }
                case 5: {
                  lr.authorizes_transaction_application = me.bool();
                  break;
                }
                case 6: {
                  lr.authorizes_upload_contract = me.bool();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.contract_id != null && me.hasOwnProperty("contract_id") && !(me.contract_id && typeof me.contract_id.length == "number" || ye.isString(me.contract_id)) ? "contract_id: buffer expected" : me.bytecode != null && me.hasOwnProperty("bytecode") && !(me.bytecode && typeof me.bytecode.length == "number" || ye.isString(me.bytecode)) ? "bytecode: buffer expected" : me.abi != null && me.hasOwnProperty("abi") && !ye.isString(me.abi) ? "abi: string expected" : me.authorizes_call_contract != null && me.hasOwnProperty("authorizes_call_contract") && typeof me.authorizes_call_contract != "boolean" ? "authorizes_call_contract: boolean expected" : me.authorizes_transaction_application != null && me.hasOwnProperty("authorizes_transaction_application") && typeof me.authorizes_transaction_application != "boolean" ? "authorizes_transaction_application: boolean expected" : me.authorizes_upload_contract != null && me.hasOwnProperty("authorizes_upload_contract") && typeof me.authorizes_upload_contract != "boolean" ? "authorizes_upload_contract: boolean expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.upload_contract_operation)
              return me;
            var we = new ve.koinos.protocol.upload_contract_operation();
            return me.contract_id != null && (typeof me.contract_id == "string" ? ye.base64.decode(me.contract_id, we.contract_id = ye.newBuffer(ye.base64.length(me.contract_id)), 0) : me.contract_id.length >= 0 && (we.contract_id = me.contract_id)), me.bytecode != null && (typeof me.bytecode == "string" ? ye.base64.decode(me.bytecode, we.bytecode = ye.newBuffer(ye.base64.length(me.bytecode)), 0) : me.bytecode.length >= 0 && (we.bytecode = me.bytecode)), me.abi != null && (we.abi = String(me.abi)), me.authorizes_call_contract != null && (we.authorizes_call_contract = !!me.authorizes_call_contract), me.authorizes_transaction_application != null && (we.authorizes_transaction_application = !!me.authorizes_transaction_application), me.authorizes_upload_contract != null && (we.authorizes_upload_contract = !!me.authorizes_upload_contract), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (we.bytes === String ? ur.contract_id = "" : (ur.contract_id = [], we.bytes !== Array && (ur.contract_id = ye.newBuffer(ur.contract_id))), we.bytes === String ? ur.bytecode = "" : (ur.bytecode = [], we.bytes !== Array && (ur.bytecode = ye.newBuffer(ur.bytecode))), ur.abi = "", ur.authorizes_call_contract = !1, ur.authorizes_transaction_application = !1, ur.authorizes_upload_contract = !1), me.contract_id != null && me.hasOwnProperty("contract_id") && (ur.contract_id = we.bytes === String ? ye.base64.encode(me.contract_id, 0, me.contract_id.length) : we.bytes === Array ? Array.prototype.slice.call(me.contract_id) : me.contract_id), me.bytecode != null && me.hasOwnProperty("bytecode") && (ur.bytecode = we.bytes === String ? ye.base64.encode(me.bytecode, 0, me.bytecode.length) : we.bytes === Array ? Array.prototype.slice.call(me.bytecode) : me.bytecode), me.abi != null && me.hasOwnProperty("abi") && (ur.abi = me.abi), me.authorizes_call_contract != null && me.hasOwnProperty("authorizes_call_contract") && (ur.authorizes_call_contract = me.authorizes_call_contract), me.authorizes_transaction_application != null && me.hasOwnProperty("authorizes_transaction_application") && (ur.authorizes_transaction_application = me.authorizes_transaction_application), me.authorizes_upload_contract != null && me.hasOwnProperty("authorizes_upload_contract") && (ur.authorizes_upload_contract = me.authorizes_upload_contract), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.upload_contract_operation";
          }, Oe;
        }(), Se.call_contract_operation = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.contract_id = ye.newBuffer([]), Oe.prototype.entry_point = 0, Oe.prototype.args = ye.newBuffer([]), Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.contract_id != null && Object.hasOwnProperty.call(me, "contract_id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.contract_id), me.entry_point != null && Object.hasOwnProperty.call(me, "entry_point") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(me.entry_point), me.args != null && Object.hasOwnProperty.call(me, "args") && we.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(me.args), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.call_contract_operation(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.contract_id = me.bytes();
                  break;
                }
                case 2: {
                  lr.entry_point = me.uint32();
                  break;
                }
                case 3: {
                  lr.args = me.bytes();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.contract_id != null && me.hasOwnProperty("contract_id") && !(me.contract_id && typeof me.contract_id.length == "number" || ye.isString(me.contract_id)) ? "contract_id: buffer expected" : me.entry_point != null && me.hasOwnProperty("entry_point") && !ye.isInteger(me.entry_point) ? "entry_point: integer expected" : me.args != null && me.hasOwnProperty("args") && !(me.args && typeof me.args.length == "number" || ye.isString(me.args)) ? "args: buffer expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.call_contract_operation)
              return me;
            var we = new ve.koinos.protocol.call_contract_operation();
            return me.contract_id != null && (typeof me.contract_id == "string" ? ye.base64.decode(me.contract_id, we.contract_id = ye.newBuffer(ye.base64.length(me.contract_id)), 0) : me.contract_id.length >= 0 && (we.contract_id = me.contract_id)), me.entry_point != null && (we.entry_point = me.entry_point >>> 0), me.args != null && (typeof me.args == "string" ? ye.base64.decode(me.args, we.args = ye.newBuffer(ye.base64.length(me.args)), 0) : me.args.length >= 0 && (we.args = me.args)), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (we.bytes === String ? ur.contract_id = "" : (ur.contract_id = [], we.bytes !== Array && (ur.contract_id = ye.newBuffer(ur.contract_id))), ur.entry_point = 0, we.bytes === String ? ur.args = "" : (ur.args = [], we.bytes !== Array && (ur.args = ye.newBuffer(ur.args)))), me.contract_id != null && me.hasOwnProperty("contract_id") && (ur.contract_id = we.bytes === String ? ye.base64.encode(me.contract_id, 0, me.contract_id.length) : we.bytes === Array ? Array.prototype.slice.call(me.contract_id) : me.contract_id), me.entry_point != null && me.hasOwnProperty("entry_point") && (ur.entry_point = me.entry_point), me.args != null && me.hasOwnProperty("args") && (ur.args = we.bytes === String ? ye.base64.encode(me.args, 0, me.args.length) : we.bytes === Array ? Array.prototype.slice.call(me.args) : me.args), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.call_contract_operation";
          }, Oe;
        }(), Se.set_system_call_operation = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.call_id = 0, Oe.prototype.target = null, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.call_id != null && Object.hasOwnProperty.call(me, "call_id") && we.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(me.call_id), me.target != null && Object.hasOwnProperty.call(me, "target") && ve.koinos.protocol.system_call_target.encode(me.target, we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.set_system_call_operation(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.call_id = me.uint32();
                  break;
                }
                case 2: {
                  lr.target = ve.koinos.protocol.system_call_target.decode(me, me.uint32());
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.call_id != null && me.hasOwnProperty("call_id") && !ye.isInteger(me.call_id))
              return "call_id: integer expected";
            if (me.target != null && me.hasOwnProperty("target")) {
              var we = ve.koinos.protocol.system_call_target.verify(me.target);
              if (we)
                return "target." + we;
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.set_system_call_operation)
              return me;
            var we = new ve.koinos.protocol.set_system_call_operation();
            if (me.call_id != null && (we.call_id = me.call_id >>> 0), me.target != null) {
              if (typeof me.target != "object")
                throw TypeError(".koinos.protocol.set_system_call_operation.target: object expected");
              we.target = ve.koinos.protocol.system_call_target.fromObject(me.target);
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (ur.call_id = 0, ur.target = null), me.call_id != null && me.hasOwnProperty("call_id") && (ur.call_id = me.call_id), me.target != null && me.hasOwnProperty("target") && (ur.target = ve.koinos.protocol.system_call_target.toObject(me.target, we)), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.set_system_call_operation";
          }, Oe;
        }(), Se.set_system_contract_operation = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.contract_id = ye.newBuffer([]), Oe.prototype.system_contract = !1, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.contract_id != null && Object.hasOwnProperty.call(me, "contract_id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.contract_id), me.system_contract != null && Object.hasOwnProperty.call(me, "system_contract") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).bool(me.system_contract), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.set_system_contract_operation(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.contract_id = me.bytes();
                  break;
                }
                case 2: {
                  lr.system_contract = me.bool();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.contract_id != null && me.hasOwnProperty("contract_id") && !(me.contract_id && typeof me.contract_id.length == "number" || ye.isString(me.contract_id)) ? "contract_id: buffer expected" : me.system_contract != null && me.hasOwnProperty("system_contract") && typeof me.system_contract != "boolean" ? "system_contract: boolean expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.set_system_contract_operation)
              return me;
            var we = new ve.koinos.protocol.set_system_contract_operation();
            return me.contract_id != null && (typeof me.contract_id == "string" ? ye.base64.decode(me.contract_id, we.contract_id = ye.newBuffer(ye.base64.length(me.contract_id)), 0) : me.contract_id.length >= 0 && (we.contract_id = me.contract_id)), me.system_contract != null && (we.system_contract = !!me.system_contract), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (we.bytes === String ? ur.contract_id = "" : (ur.contract_id = [], we.bytes !== Array && (ur.contract_id = ye.newBuffer(ur.contract_id))), ur.system_contract = !1), me.contract_id != null && me.hasOwnProperty("contract_id") && (ur.contract_id = we.bytes === String ? ye.base64.encode(me.contract_id, 0, me.contract_id.length) : we.bytes === Array ? Array.prototype.slice.call(me.contract_id) : me.contract_id), me.system_contract != null && me.hasOwnProperty("system_contract") && (ur.system_contract = me.system_contract), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.set_system_contract_operation";
          }, Oe;
        }(), Se.operation = function() {
          function Oe(me) {
            if (me)
              for (var we = Object.keys(me), ur = 0; ur < we.length; ++ur)
                me[we[ur]] != null && (this[we[ur]] = me[we[ur]]);
          }
          Oe.prototype.upload_contract = null, Oe.prototype.call_contract = null, Oe.prototype.set_system_call = null, Oe.prototype.set_system_contract = null;
          var xe;
          return Object.defineProperty(Oe.prototype, "op", {
            get: ye.oneOfGetter(xe = [
              "upload_contract",
              "call_contract",
              "set_system_call",
              "set_system_contract"
            ]),
            set: ye.oneOfSetter(xe)
          }), Oe.create = function(we) {
            return new Oe(we);
          }, Oe.encode = function(we, ur) {
            return ur || (ur = be.create()), we.upload_contract != null && Object.hasOwnProperty.call(we, "upload_contract") && ve.koinos.protocol.upload_contract_operation.encode(we.upload_contract, ur.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim(), we.call_contract != null && Object.hasOwnProperty.call(we, "call_contract") && ve.koinos.protocol.call_contract_operation.encode(we.call_contract, ur.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), we.set_system_call != null && Object.hasOwnProperty.call(we, "set_system_call") && ve.koinos.protocol.set_system_call_operation.encode(we.set_system_call, ur.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim(), we.set_system_contract != null && Object.hasOwnProperty.call(we, "set_system_contract") && ve.koinos.protocol.set_system_contract_operation.encode(we.set_system_contract, ur.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim(), ur;
          }, Oe.encodeDelimited = function(we, ur) {
            return this.encode(we, ur).ldelim();
          }, Oe.decode = function(we, ur) {
            we instanceof fe || (we = fe.create(we));
            for (var lr = ur === void 0 ? we.len : we.pos + ur, Ar = new ve.koinos.protocol.operation(); we.pos < lr; ) {
              var Br = we.uint32();
              switch (Br >>> 3) {
                case 1: {
                  Ar.upload_contract = ve.koinos.protocol.upload_contract_operation.decode(we, we.uint32());
                  break;
                }
                case 2: {
                  Ar.call_contract = ve.koinos.protocol.call_contract_operation.decode(we, we.uint32());
                  break;
                }
                case 3: {
                  Ar.set_system_call = ve.koinos.protocol.set_system_call_operation.decode(we, we.uint32());
                  break;
                }
                case 4: {
                  Ar.set_system_contract = ve.koinos.protocol.set_system_contract_operation.decode(we, we.uint32());
                  break;
                }
                default:
                  we.skipType(Br & 7);
                  break;
              }
            }
            return Ar;
          }, Oe.decodeDelimited = function(we) {
            return we instanceof fe || (we = new fe(we)), this.decode(we, we.uint32());
          }, Oe.verify = function(we) {
            if (typeof we != "object" || we === null)
              return "object expected";
            var ur = {};
            if (we.upload_contract != null && we.hasOwnProperty("upload_contract")) {
              ur.op = 1;
              {
                var lr = ve.koinos.protocol.upload_contract_operation.verify(we.upload_contract);
                if (lr)
                  return "upload_contract." + lr;
              }
            }
            if (we.call_contract != null && we.hasOwnProperty("call_contract")) {
              if (ur.op === 1)
                return "op: multiple values";
              ur.op = 1;
              {
                var lr = ve.koinos.protocol.call_contract_operation.verify(we.call_contract);
                if (lr)
                  return "call_contract." + lr;
              }
            }
            if (we.set_system_call != null && we.hasOwnProperty("set_system_call")) {
              if (ur.op === 1)
                return "op: multiple values";
              ur.op = 1;
              {
                var lr = ve.koinos.protocol.set_system_call_operation.verify(we.set_system_call);
                if (lr)
                  return "set_system_call." + lr;
              }
            }
            if (we.set_system_contract != null && we.hasOwnProperty("set_system_contract")) {
              if (ur.op === 1)
                return "op: multiple values";
              ur.op = 1;
              {
                var lr = ve.koinos.protocol.set_system_contract_operation.verify(we.set_system_contract);
                if (lr)
                  return "set_system_contract." + lr;
              }
            }
            return null;
          }, Oe.fromObject = function(we) {
            if (we instanceof ve.koinos.protocol.operation)
              return we;
            var ur = new ve.koinos.protocol.operation();
            if (we.upload_contract != null) {
              if (typeof we.upload_contract != "object")
                throw TypeError(".koinos.protocol.operation.upload_contract: object expected");
              ur.upload_contract = ve.koinos.protocol.upload_contract_operation.fromObject(we.upload_contract);
            }
            if (we.call_contract != null) {
              if (typeof we.call_contract != "object")
                throw TypeError(".koinos.protocol.operation.call_contract: object expected");
              ur.call_contract = ve.koinos.protocol.call_contract_operation.fromObject(we.call_contract);
            }
            if (we.set_system_call != null) {
              if (typeof we.set_system_call != "object")
                throw TypeError(".koinos.protocol.operation.set_system_call: object expected");
              ur.set_system_call = ve.koinos.protocol.set_system_call_operation.fromObject(we.set_system_call);
            }
            if (we.set_system_contract != null) {
              if (typeof we.set_system_contract != "object")
                throw TypeError(".koinos.protocol.operation.set_system_contract: object expected");
              ur.set_system_contract = ve.koinos.protocol.set_system_contract_operation.fromObject(we.set_system_contract);
            }
            return ur;
          }, Oe.toObject = function(we, ur) {
            ur || (ur = {});
            var lr = {};
            return we.upload_contract != null && we.hasOwnProperty("upload_contract") && (lr.upload_contract = ve.koinos.protocol.upload_contract_operation.toObject(we.upload_contract, ur), ur.oneofs && (lr.op = "upload_contract")), we.call_contract != null && we.hasOwnProperty("call_contract") && (lr.call_contract = ve.koinos.protocol.call_contract_operation.toObject(we.call_contract, ur), ur.oneofs && (lr.op = "call_contract")), we.set_system_call != null && we.hasOwnProperty("set_system_call") && (lr.set_system_call = ve.koinos.protocol.set_system_call_operation.toObject(we.set_system_call, ur), ur.oneofs && (lr.op = "set_system_call")), we.set_system_contract != null && we.hasOwnProperty("set_system_contract") && (lr.set_system_contract = ve.koinos.protocol.set_system_contract_operation.toObject(we.set_system_contract, ur), ur.oneofs && (lr.op = "set_system_contract")), lr;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(we) {
            return we === void 0 && (we = "type.googleapis.com"), we + "/koinos.protocol.operation";
          }, Oe;
        }(), Se.transaction_header = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.chain_id = ye.newBuffer([]), Oe.prototype.rc_limit = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.nonce = ye.newBuffer([]), Oe.prototype.operation_merkle_root = ye.newBuffer([]), Oe.prototype.payer = ye.newBuffer([]), Oe.prototype.payee = ye.newBuffer([]), Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.chain_id != null && Object.hasOwnProperty.call(me, "chain_id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.chain_id), me.rc_limit != null && Object.hasOwnProperty.call(me, "rc_limit") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(me.rc_limit), me.nonce != null && Object.hasOwnProperty.call(me, "nonce") && we.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(me.nonce), me.operation_merkle_root != null && Object.hasOwnProperty.call(me, "operation_merkle_root") && we.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(me.operation_merkle_root), me.payer != null && Object.hasOwnProperty.call(me, "payer") && we.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(me.payer), me.payee != null && Object.hasOwnProperty.call(me, "payee") && we.uint32(
              /* id 6, wireType 2 =*/
              50
            ).bytes(me.payee), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.transaction_header(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.chain_id = me.bytes();
                  break;
                }
                case 2: {
                  lr.rc_limit = me.uint64();
                  break;
                }
                case 3: {
                  lr.nonce = me.bytes();
                  break;
                }
                case 4: {
                  lr.operation_merkle_root = me.bytes();
                  break;
                }
                case 5: {
                  lr.payer = me.bytes();
                  break;
                }
                case 6: {
                  lr.payee = me.bytes();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.chain_id != null && me.hasOwnProperty("chain_id") && !(me.chain_id && typeof me.chain_id.length == "number" || ye.isString(me.chain_id)) ? "chain_id: buffer expected" : me.rc_limit != null && me.hasOwnProperty("rc_limit") && !ye.isInteger(me.rc_limit) && !(me.rc_limit && ye.isInteger(me.rc_limit.low) && ye.isInteger(me.rc_limit.high)) ? "rc_limit: integer|Long expected" : me.nonce != null && me.hasOwnProperty("nonce") && !(me.nonce && typeof me.nonce.length == "number" || ye.isString(me.nonce)) ? "nonce: buffer expected" : me.operation_merkle_root != null && me.hasOwnProperty("operation_merkle_root") && !(me.operation_merkle_root && typeof me.operation_merkle_root.length == "number" || ye.isString(me.operation_merkle_root)) ? "operation_merkle_root: buffer expected" : me.payer != null && me.hasOwnProperty("payer") && !(me.payer && typeof me.payer.length == "number" || ye.isString(me.payer)) ? "payer: buffer expected" : me.payee != null && me.hasOwnProperty("payee") && !(me.payee && typeof me.payee.length == "number" || ye.isString(me.payee)) ? "payee: buffer expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.transaction_header)
              return me;
            var we = new ve.koinos.protocol.transaction_header();
            return me.chain_id != null && (typeof me.chain_id == "string" ? ye.base64.decode(me.chain_id, we.chain_id = ye.newBuffer(ye.base64.length(me.chain_id)), 0) : me.chain_id.length >= 0 && (we.chain_id = me.chain_id)), me.rc_limit != null && (ye.Long ? (we.rc_limit = ye.Long.fromValue(me.rc_limit)).unsigned = !0 : typeof me.rc_limit == "string" ? we.rc_limit = parseInt(me.rc_limit, 10) : typeof me.rc_limit == "number" ? we.rc_limit = me.rc_limit : typeof me.rc_limit == "object" && (we.rc_limit = new ye.LongBits(me.rc_limit.low >>> 0, me.rc_limit.high >>> 0).toNumber(!0))), me.nonce != null && (typeof me.nonce == "string" ? ye.base64.decode(me.nonce, we.nonce = ye.newBuffer(ye.base64.length(me.nonce)), 0) : me.nonce.length >= 0 && (we.nonce = me.nonce)), me.operation_merkle_root != null && (typeof me.operation_merkle_root == "string" ? ye.base64.decode(me.operation_merkle_root, we.operation_merkle_root = ye.newBuffer(ye.base64.length(me.operation_merkle_root)), 0) : me.operation_merkle_root.length >= 0 && (we.operation_merkle_root = me.operation_merkle_root)), me.payer != null && (typeof me.payer == "string" ? ye.base64.decode(me.payer, we.payer = ye.newBuffer(ye.base64.length(me.payer)), 0) : me.payer.length >= 0 && (we.payer = me.payer)), me.payee != null && (typeof me.payee == "string" ? ye.base64.decode(me.payee, we.payee = ye.newBuffer(ye.base64.length(me.payee)), 0) : me.payee.length >= 0 && (we.payee = me.payee)), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if (we.defaults) {
              if (we.bytes === String ? ur.chain_id = "" : (ur.chain_id = [], we.bytes !== Array && (ur.chain_id = ye.newBuffer(ur.chain_id))), ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.rc_limit = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.rc_limit = we.longs === String ? "0" : 0;
              we.bytes === String ? ur.nonce = "" : (ur.nonce = [], we.bytes !== Array && (ur.nonce = ye.newBuffer(ur.nonce))), we.bytes === String ? ur.operation_merkle_root = "" : (ur.operation_merkle_root = [], we.bytes !== Array && (ur.operation_merkle_root = ye.newBuffer(ur.operation_merkle_root))), we.bytes === String ? ur.payer = "" : (ur.payer = [], we.bytes !== Array && (ur.payer = ye.newBuffer(ur.payer))), we.bytes === String ? ur.payee = "" : (ur.payee = [], we.bytes !== Array && (ur.payee = ye.newBuffer(ur.payee)));
            }
            return me.chain_id != null && me.hasOwnProperty("chain_id") && (ur.chain_id = we.bytes === String ? ye.base64.encode(me.chain_id, 0, me.chain_id.length) : we.bytes === Array ? Array.prototype.slice.call(me.chain_id) : me.chain_id), me.rc_limit != null && me.hasOwnProperty("rc_limit") && (typeof me.rc_limit == "number" ? ur.rc_limit = we.longs === String ? String(me.rc_limit) : me.rc_limit : ur.rc_limit = we.longs === String ? ye.Long.prototype.toString.call(me.rc_limit) : we.longs === Number ? new ye.LongBits(me.rc_limit.low >>> 0, me.rc_limit.high >>> 0).toNumber(!0) : me.rc_limit), me.nonce != null && me.hasOwnProperty("nonce") && (ur.nonce = we.bytes === String ? ye.base64.encode(me.nonce, 0, me.nonce.length) : we.bytes === Array ? Array.prototype.slice.call(me.nonce) : me.nonce), me.operation_merkle_root != null && me.hasOwnProperty("operation_merkle_root") && (ur.operation_merkle_root = we.bytes === String ? ye.base64.encode(me.operation_merkle_root, 0, me.operation_merkle_root.length) : we.bytes === Array ? Array.prototype.slice.call(me.operation_merkle_root) : me.operation_merkle_root), me.payer != null && me.hasOwnProperty("payer") && (ur.payer = we.bytes === String ? ye.base64.encode(me.payer, 0, me.payer.length) : we.bytes === Array ? Array.prototype.slice.call(me.payer) : me.payer), me.payee != null && me.hasOwnProperty("payee") && (ur.payee = we.bytes === String ? ye.base64.encode(me.payee, 0, me.payee.length) : we.bytes === Array ? Array.prototype.slice.call(me.payee) : me.payee), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.transaction_header";
          }, Oe;
        }(), Se.transaction = function() {
          function Oe(xe) {
            if (this.operations = [], this.signatures = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.id = ye.newBuffer([]), Oe.prototype.header = null, Oe.prototype.operations = ye.emptyArray, Oe.prototype.signatures = ye.emptyArray, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.id != null && Object.hasOwnProperty.call(me, "id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.id), me.header != null && Object.hasOwnProperty.call(me, "header") && ve.koinos.protocol.transaction_header.encode(me.header, we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), me.operations != null && me.operations.length)
              for (var ur = 0; ur < me.operations.length; ++ur)
                ve.koinos.protocol.operation.encode(me.operations[ur], we.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (me.signatures != null && me.signatures.length)
              for (var ur = 0; ur < me.signatures.length; ++ur)
                we.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).bytes(me.signatures[ur]);
            return we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.transaction(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.id = me.bytes();
                  break;
                }
                case 2: {
                  lr.header = ve.koinos.protocol.transaction_header.decode(me, me.uint32());
                  break;
                }
                case 3: {
                  lr.operations && lr.operations.length || (lr.operations = []), lr.operations.push(ve.koinos.protocol.operation.decode(me, me.uint32()));
                  break;
                }
                case 4: {
                  lr.signatures && lr.signatures.length || (lr.signatures = []), lr.signatures.push(me.bytes());
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.id != null && me.hasOwnProperty("id") && !(me.id && typeof me.id.length == "number" || ye.isString(me.id)))
              return "id: buffer expected";
            if (me.header != null && me.hasOwnProperty("header")) {
              var we = ve.koinos.protocol.transaction_header.verify(me.header);
              if (we)
                return "header." + we;
            }
            if (me.operations != null && me.hasOwnProperty("operations")) {
              if (!Array.isArray(me.operations))
                return "operations: array expected";
              for (var ur = 0; ur < me.operations.length; ++ur) {
                var we = ve.koinos.protocol.operation.verify(me.operations[ur]);
                if (we)
                  return "operations." + we;
              }
            }
            if (me.signatures != null && me.hasOwnProperty("signatures")) {
              if (!Array.isArray(me.signatures))
                return "signatures: array expected";
              for (var ur = 0; ur < me.signatures.length; ++ur)
                if (!(me.signatures[ur] && typeof me.signatures[ur].length == "number" || ye.isString(me.signatures[ur])))
                  return "signatures: buffer[] expected";
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.transaction)
              return me;
            var we = new ve.koinos.protocol.transaction();
            if (me.id != null && (typeof me.id == "string" ? ye.base64.decode(me.id, we.id = ye.newBuffer(ye.base64.length(me.id)), 0) : me.id.length >= 0 && (we.id = me.id)), me.header != null) {
              if (typeof me.header != "object")
                throw TypeError(".koinos.protocol.transaction.header: object expected");
              we.header = ve.koinos.protocol.transaction_header.fromObject(me.header);
            }
            if (me.operations) {
              if (!Array.isArray(me.operations))
                throw TypeError(".koinos.protocol.transaction.operations: array expected");
              we.operations = [];
              for (var ur = 0; ur < me.operations.length; ++ur) {
                if (typeof me.operations[ur] != "object")
                  throw TypeError(".koinos.protocol.transaction.operations: object expected");
                we.operations[ur] = ve.koinos.protocol.operation.fromObject(me.operations[ur]);
              }
            }
            if (me.signatures) {
              if (!Array.isArray(me.signatures))
                throw TypeError(".koinos.protocol.transaction.signatures: array expected");
              we.signatures = [];
              for (var ur = 0; ur < me.signatures.length; ++ur)
                typeof me.signatures[ur] == "string" ? ye.base64.decode(me.signatures[ur], we.signatures[ur] = ye.newBuffer(ye.base64.length(me.signatures[ur])), 0) : me.signatures[ur].length >= 0 && (we.signatures[ur] = me.signatures[ur]);
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.operations = [], ur.signatures = []), we.defaults && (we.bytes === String ? ur.id = "" : (ur.id = [], we.bytes !== Array && (ur.id = ye.newBuffer(ur.id))), ur.header = null), me.id != null && me.hasOwnProperty("id") && (ur.id = we.bytes === String ? ye.base64.encode(me.id, 0, me.id.length) : we.bytes === Array ? Array.prototype.slice.call(me.id) : me.id), me.header != null && me.hasOwnProperty("header") && (ur.header = ve.koinos.protocol.transaction_header.toObject(me.header, we)), me.operations && me.operations.length) {
              ur.operations = [];
              for (var lr = 0; lr < me.operations.length; ++lr)
                ur.operations[lr] = ve.koinos.protocol.operation.toObject(me.operations[lr], we);
            }
            if (me.signatures && me.signatures.length) {
              ur.signatures = [];
              for (var lr = 0; lr < me.signatures.length; ++lr)
                ur.signatures[lr] = we.bytes === String ? ye.base64.encode(me.signatures[lr], 0, me.signatures[lr].length) : we.bytes === Array ? Array.prototype.slice.call(me.signatures[lr]) : me.signatures[lr];
            }
            return ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.transaction";
          }, Oe;
        }(), Se.transaction_receipt = function() {
          function Oe(xe) {
            if (this.events = [], this.logs = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.id = ye.newBuffer([]), Oe.prototype.payer = ye.newBuffer([]), Oe.prototype.max_payer_rc = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.rc_limit = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.rc_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.disk_storage_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.network_bandwidth_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.compute_bandwidth_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.reverted = !1, Oe.prototype.events = ye.emptyArray, Oe.prototype.logs = ye.emptyArray, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.id != null && Object.hasOwnProperty.call(me, "id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.id), me.payer != null && Object.hasOwnProperty.call(me, "payer") && we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(me.payer), me.max_payer_rc != null && Object.hasOwnProperty.call(me, "max_payer_rc") && we.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(me.max_payer_rc), me.rc_limit != null && Object.hasOwnProperty.call(me, "rc_limit") && we.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(me.rc_limit), me.rc_used != null && Object.hasOwnProperty.call(me, "rc_used") && we.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(me.rc_used), me.disk_storage_used != null && Object.hasOwnProperty.call(me, "disk_storage_used") && we.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint64(me.disk_storage_used), me.network_bandwidth_used != null && Object.hasOwnProperty.call(me, "network_bandwidth_used") && we.uint32(
              /* id 7, wireType 0 =*/
              56
            ).uint64(me.network_bandwidth_used), me.compute_bandwidth_used != null && Object.hasOwnProperty.call(me, "compute_bandwidth_used") && we.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(me.compute_bandwidth_used), me.reverted != null && Object.hasOwnProperty.call(me, "reverted") && we.uint32(
              /* id 9, wireType 0 =*/
              72
            ).bool(me.reverted), me.events != null && me.events.length)
              for (var ur = 0; ur < me.events.length; ++ur)
                ve.koinos.protocol.event_data.encode(me.events[ur], we.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).fork()).ldelim();
            if (me.logs != null && me.logs.length)
              for (var ur = 0; ur < me.logs.length; ++ur)
                we.uint32(
                  /* id 11, wireType 2 =*/
                  90
                ).string(me.logs[ur]);
            return we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.transaction_receipt(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.id = me.bytes();
                  break;
                }
                case 2: {
                  lr.payer = me.bytes();
                  break;
                }
                case 3: {
                  lr.max_payer_rc = me.uint64();
                  break;
                }
                case 4: {
                  lr.rc_limit = me.uint64();
                  break;
                }
                case 5: {
                  lr.rc_used = me.uint64();
                  break;
                }
                case 6: {
                  lr.disk_storage_used = me.uint64();
                  break;
                }
                case 7: {
                  lr.network_bandwidth_used = me.uint64();
                  break;
                }
                case 8: {
                  lr.compute_bandwidth_used = me.uint64();
                  break;
                }
                case 9: {
                  lr.reverted = me.bool();
                  break;
                }
                case 10: {
                  lr.events && lr.events.length || (lr.events = []), lr.events.push(ve.koinos.protocol.event_data.decode(me, me.uint32()));
                  break;
                }
                case 11: {
                  lr.logs && lr.logs.length || (lr.logs = []), lr.logs.push(me.string());
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.id != null && me.hasOwnProperty("id") && !(me.id && typeof me.id.length == "number" || ye.isString(me.id)))
              return "id: buffer expected";
            if (me.payer != null && me.hasOwnProperty("payer") && !(me.payer && typeof me.payer.length == "number" || ye.isString(me.payer)))
              return "payer: buffer expected";
            if (me.max_payer_rc != null && me.hasOwnProperty("max_payer_rc") && !ye.isInteger(me.max_payer_rc) && !(me.max_payer_rc && ye.isInteger(me.max_payer_rc.low) && ye.isInteger(me.max_payer_rc.high)))
              return "max_payer_rc: integer|Long expected";
            if (me.rc_limit != null && me.hasOwnProperty("rc_limit") && !ye.isInteger(me.rc_limit) && !(me.rc_limit && ye.isInteger(me.rc_limit.low) && ye.isInteger(me.rc_limit.high)))
              return "rc_limit: integer|Long expected";
            if (me.rc_used != null && me.hasOwnProperty("rc_used") && !ye.isInteger(me.rc_used) && !(me.rc_used && ye.isInteger(me.rc_used.low) && ye.isInteger(me.rc_used.high)))
              return "rc_used: integer|Long expected";
            if (me.disk_storage_used != null && me.hasOwnProperty("disk_storage_used") && !ye.isInteger(me.disk_storage_used) && !(me.disk_storage_used && ye.isInteger(me.disk_storage_used.low) && ye.isInteger(me.disk_storage_used.high)))
              return "disk_storage_used: integer|Long expected";
            if (me.network_bandwidth_used != null && me.hasOwnProperty("network_bandwidth_used") && !ye.isInteger(me.network_bandwidth_used) && !(me.network_bandwidth_used && ye.isInteger(me.network_bandwidth_used.low) && ye.isInteger(me.network_bandwidth_used.high)))
              return "network_bandwidth_used: integer|Long expected";
            if (me.compute_bandwidth_used != null && me.hasOwnProperty("compute_bandwidth_used") && !ye.isInteger(me.compute_bandwidth_used) && !(me.compute_bandwidth_used && ye.isInteger(me.compute_bandwidth_used.low) && ye.isInteger(me.compute_bandwidth_used.high)))
              return "compute_bandwidth_used: integer|Long expected";
            if (me.reverted != null && me.hasOwnProperty("reverted") && typeof me.reverted != "boolean")
              return "reverted: boolean expected";
            if (me.events != null && me.hasOwnProperty("events")) {
              if (!Array.isArray(me.events))
                return "events: array expected";
              for (var we = 0; we < me.events.length; ++we) {
                var ur = ve.koinos.protocol.event_data.verify(me.events[we]);
                if (ur)
                  return "events." + ur;
              }
            }
            if (me.logs != null && me.hasOwnProperty("logs")) {
              if (!Array.isArray(me.logs))
                return "logs: array expected";
              for (var we = 0; we < me.logs.length; ++we)
                if (!ye.isString(me.logs[we]))
                  return "logs: string[] expected";
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.transaction_receipt)
              return me;
            var we = new ve.koinos.protocol.transaction_receipt();
            if (me.id != null && (typeof me.id == "string" ? ye.base64.decode(me.id, we.id = ye.newBuffer(ye.base64.length(me.id)), 0) : me.id.length >= 0 && (we.id = me.id)), me.payer != null && (typeof me.payer == "string" ? ye.base64.decode(me.payer, we.payer = ye.newBuffer(ye.base64.length(me.payer)), 0) : me.payer.length >= 0 && (we.payer = me.payer)), me.max_payer_rc != null && (ye.Long ? (we.max_payer_rc = ye.Long.fromValue(me.max_payer_rc)).unsigned = !0 : typeof me.max_payer_rc == "string" ? we.max_payer_rc = parseInt(me.max_payer_rc, 10) : typeof me.max_payer_rc == "number" ? we.max_payer_rc = me.max_payer_rc : typeof me.max_payer_rc == "object" && (we.max_payer_rc = new ye.LongBits(me.max_payer_rc.low >>> 0, me.max_payer_rc.high >>> 0).toNumber(!0))), me.rc_limit != null && (ye.Long ? (we.rc_limit = ye.Long.fromValue(me.rc_limit)).unsigned = !0 : typeof me.rc_limit == "string" ? we.rc_limit = parseInt(me.rc_limit, 10) : typeof me.rc_limit == "number" ? we.rc_limit = me.rc_limit : typeof me.rc_limit == "object" && (we.rc_limit = new ye.LongBits(me.rc_limit.low >>> 0, me.rc_limit.high >>> 0).toNumber(!0))), me.rc_used != null && (ye.Long ? (we.rc_used = ye.Long.fromValue(me.rc_used)).unsigned = !0 : typeof me.rc_used == "string" ? we.rc_used = parseInt(me.rc_used, 10) : typeof me.rc_used == "number" ? we.rc_used = me.rc_used : typeof me.rc_used == "object" && (we.rc_used = new ye.LongBits(me.rc_used.low >>> 0, me.rc_used.high >>> 0).toNumber(!0))), me.disk_storage_used != null && (ye.Long ? (we.disk_storage_used = ye.Long.fromValue(me.disk_storage_used)).unsigned = !0 : typeof me.disk_storage_used == "string" ? we.disk_storage_used = parseInt(me.disk_storage_used, 10) : typeof me.disk_storage_used == "number" ? we.disk_storage_used = me.disk_storage_used : typeof me.disk_storage_used == "object" && (we.disk_storage_used = new ye.LongBits(me.disk_storage_used.low >>> 0, me.disk_storage_used.high >>> 0).toNumber(!0))), me.network_bandwidth_used != null && (ye.Long ? (we.network_bandwidth_used = ye.Long.fromValue(me.network_bandwidth_used)).unsigned = !0 : typeof me.network_bandwidth_used == "string" ? we.network_bandwidth_used = parseInt(me.network_bandwidth_used, 10) : typeof me.network_bandwidth_used == "number" ? we.network_bandwidth_used = me.network_bandwidth_used : typeof me.network_bandwidth_used == "object" && (we.network_bandwidth_used = new ye.LongBits(me.network_bandwidth_used.low >>> 0, me.network_bandwidth_used.high >>> 0).toNumber(!0))), me.compute_bandwidth_used != null && (ye.Long ? (we.compute_bandwidth_used = ye.Long.fromValue(me.compute_bandwidth_used)).unsigned = !0 : typeof me.compute_bandwidth_used == "string" ? we.compute_bandwidth_used = parseInt(me.compute_bandwidth_used, 10) : typeof me.compute_bandwidth_used == "number" ? we.compute_bandwidth_used = me.compute_bandwidth_used : typeof me.compute_bandwidth_used == "object" && (we.compute_bandwidth_used = new ye.LongBits(me.compute_bandwidth_used.low >>> 0, me.compute_bandwidth_used.high >>> 0).toNumber(!0))), me.reverted != null && (we.reverted = !!me.reverted), me.events) {
              if (!Array.isArray(me.events))
                throw TypeError(".koinos.protocol.transaction_receipt.events: array expected");
              we.events = [];
              for (var ur = 0; ur < me.events.length; ++ur) {
                if (typeof me.events[ur] != "object")
                  throw TypeError(".koinos.protocol.transaction_receipt.events: object expected");
                we.events[ur] = ve.koinos.protocol.event_data.fromObject(me.events[ur]);
              }
            }
            if (me.logs) {
              if (!Array.isArray(me.logs))
                throw TypeError(".koinos.protocol.transaction_receipt.logs: array expected");
              we.logs = [];
              for (var ur = 0; ur < me.logs.length; ++ur)
                we.logs[ur] = String(me.logs[ur]);
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.events = [], ur.logs = []), we.defaults) {
              if (we.bytes === String ? ur.id = "" : (ur.id = [], we.bytes !== Array && (ur.id = ye.newBuffer(ur.id))), we.bytes === String ? ur.payer = "" : (ur.payer = [], we.bytes !== Array && (ur.payer = ye.newBuffer(ur.payer))), ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.max_payer_rc = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.max_payer_rc = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.rc_limit = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.rc_limit = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.rc_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.rc_used = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.disk_storage_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.disk_storage_used = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.network_bandwidth_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.network_bandwidth_used = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.compute_bandwidth_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.compute_bandwidth_used = we.longs === String ? "0" : 0;
              ur.reverted = !1;
            }
            if (me.id != null && me.hasOwnProperty("id") && (ur.id = we.bytes === String ? ye.base64.encode(me.id, 0, me.id.length) : we.bytes === Array ? Array.prototype.slice.call(me.id) : me.id), me.payer != null && me.hasOwnProperty("payer") && (ur.payer = we.bytes === String ? ye.base64.encode(me.payer, 0, me.payer.length) : we.bytes === Array ? Array.prototype.slice.call(me.payer) : me.payer), me.max_payer_rc != null && me.hasOwnProperty("max_payer_rc") && (typeof me.max_payer_rc == "number" ? ur.max_payer_rc = we.longs === String ? String(me.max_payer_rc) : me.max_payer_rc : ur.max_payer_rc = we.longs === String ? ye.Long.prototype.toString.call(me.max_payer_rc) : we.longs === Number ? new ye.LongBits(me.max_payer_rc.low >>> 0, me.max_payer_rc.high >>> 0).toNumber(!0) : me.max_payer_rc), me.rc_limit != null && me.hasOwnProperty("rc_limit") && (typeof me.rc_limit == "number" ? ur.rc_limit = we.longs === String ? String(me.rc_limit) : me.rc_limit : ur.rc_limit = we.longs === String ? ye.Long.prototype.toString.call(me.rc_limit) : we.longs === Number ? new ye.LongBits(me.rc_limit.low >>> 0, me.rc_limit.high >>> 0).toNumber(!0) : me.rc_limit), me.rc_used != null && me.hasOwnProperty("rc_used") && (typeof me.rc_used == "number" ? ur.rc_used = we.longs === String ? String(me.rc_used) : me.rc_used : ur.rc_used = we.longs === String ? ye.Long.prototype.toString.call(me.rc_used) : we.longs === Number ? new ye.LongBits(me.rc_used.low >>> 0, me.rc_used.high >>> 0).toNumber(!0) : me.rc_used), me.disk_storage_used != null && me.hasOwnProperty("disk_storage_used") && (typeof me.disk_storage_used == "number" ? ur.disk_storage_used = we.longs === String ? String(me.disk_storage_used) : me.disk_storage_used : ur.disk_storage_used = we.longs === String ? ye.Long.prototype.toString.call(me.disk_storage_used) : we.longs === Number ? new ye.LongBits(me.disk_storage_used.low >>> 0, me.disk_storage_used.high >>> 0).toNumber(!0) : me.disk_storage_used), me.network_bandwidth_used != null && me.hasOwnProperty("network_bandwidth_used") && (typeof me.network_bandwidth_used == "number" ? ur.network_bandwidth_used = we.longs === String ? String(me.network_bandwidth_used) : me.network_bandwidth_used : ur.network_bandwidth_used = we.longs === String ? ye.Long.prototype.toString.call(me.network_bandwidth_used) : we.longs === Number ? new ye.LongBits(me.network_bandwidth_used.low >>> 0, me.network_bandwidth_used.high >>> 0).toNumber(!0) : me.network_bandwidth_used), me.compute_bandwidth_used != null && me.hasOwnProperty("compute_bandwidth_used") && (typeof me.compute_bandwidth_used == "number" ? ur.compute_bandwidth_used = we.longs === String ? String(me.compute_bandwidth_used) : me.compute_bandwidth_used : ur.compute_bandwidth_used = we.longs === String ? ye.Long.prototype.toString.call(me.compute_bandwidth_used) : we.longs === Number ? new ye.LongBits(me.compute_bandwidth_used.low >>> 0, me.compute_bandwidth_used.high >>> 0).toNumber(!0) : me.compute_bandwidth_used), me.reverted != null && me.hasOwnProperty("reverted") && (ur.reverted = me.reverted), me.events && me.events.length) {
              ur.events = [];
              for (var Ar = 0; Ar < me.events.length; ++Ar)
                ur.events[Ar] = ve.koinos.protocol.event_data.toObject(me.events[Ar], we);
            }
            if (me.logs && me.logs.length) {
              ur.logs = [];
              for (var Ar = 0; Ar < me.logs.length; ++Ar)
                ur.logs[Ar] = me.logs[Ar];
            }
            return ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.transaction_receipt";
          }, Oe;
        }(), Se.block_header = function() {
          function Oe(xe) {
            if (this.approved_proposals = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.previous = ye.newBuffer([]), Oe.prototype.height = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.timestamp = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.previous_state_merkle_root = ye.newBuffer([]), Oe.prototype.transaction_merkle_root = ye.newBuffer([]), Oe.prototype.signer = ye.newBuffer([]), Oe.prototype.approved_proposals = ye.emptyArray, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.previous != null && Object.hasOwnProperty.call(me, "previous") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.previous), me.height != null && Object.hasOwnProperty.call(me, "height") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(me.height), me.timestamp != null && Object.hasOwnProperty.call(me, "timestamp") && we.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(me.timestamp), me.previous_state_merkle_root != null && Object.hasOwnProperty.call(me, "previous_state_merkle_root") && we.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(me.previous_state_merkle_root), me.transaction_merkle_root != null && Object.hasOwnProperty.call(me, "transaction_merkle_root") && we.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(me.transaction_merkle_root), me.signer != null && Object.hasOwnProperty.call(me, "signer") && we.uint32(
              /* id 6, wireType 2 =*/
              50
            ).bytes(me.signer), me.approved_proposals != null && me.approved_proposals.length)
              for (var ur = 0; ur < me.approved_proposals.length; ++ur)
                we.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).bytes(me.approved_proposals[ur]);
            return we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.block_header(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.previous = me.bytes();
                  break;
                }
                case 2: {
                  lr.height = me.uint64();
                  break;
                }
                case 3: {
                  lr.timestamp = me.uint64();
                  break;
                }
                case 4: {
                  lr.previous_state_merkle_root = me.bytes();
                  break;
                }
                case 5: {
                  lr.transaction_merkle_root = me.bytes();
                  break;
                }
                case 6: {
                  lr.signer = me.bytes();
                  break;
                }
                case 7: {
                  lr.approved_proposals && lr.approved_proposals.length || (lr.approved_proposals = []), lr.approved_proposals.push(me.bytes());
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.previous != null && me.hasOwnProperty("previous") && !(me.previous && typeof me.previous.length == "number" || ye.isString(me.previous)))
              return "previous: buffer expected";
            if (me.height != null && me.hasOwnProperty("height") && !ye.isInteger(me.height) && !(me.height && ye.isInteger(me.height.low) && ye.isInteger(me.height.high)))
              return "height: integer|Long expected";
            if (me.timestamp != null && me.hasOwnProperty("timestamp") && !ye.isInteger(me.timestamp) && !(me.timestamp && ye.isInteger(me.timestamp.low) && ye.isInteger(me.timestamp.high)))
              return "timestamp: integer|Long expected";
            if (me.previous_state_merkle_root != null && me.hasOwnProperty("previous_state_merkle_root") && !(me.previous_state_merkle_root && typeof me.previous_state_merkle_root.length == "number" || ye.isString(me.previous_state_merkle_root)))
              return "previous_state_merkle_root: buffer expected";
            if (me.transaction_merkle_root != null && me.hasOwnProperty("transaction_merkle_root") && !(me.transaction_merkle_root && typeof me.transaction_merkle_root.length == "number" || ye.isString(me.transaction_merkle_root)))
              return "transaction_merkle_root: buffer expected";
            if (me.signer != null && me.hasOwnProperty("signer") && !(me.signer && typeof me.signer.length == "number" || ye.isString(me.signer)))
              return "signer: buffer expected";
            if (me.approved_proposals != null && me.hasOwnProperty("approved_proposals")) {
              if (!Array.isArray(me.approved_proposals))
                return "approved_proposals: array expected";
              for (var we = 0; we < me.approved_proposals.length; ++we)
                if (!(me.approved_proposals[we] && typeof me.approved_proposals[we].length == "number" || ye.isString(me.approved_proposals[we])))
                  return "approved_proposals: buffer[] expected";
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.block_header)
              return me;
            var we = new ve.koinos.protocol.block_header();
            if (me.previous != null && (typeof me.previous == "string" ? ye.base64.decode(me.previous, we.previous = ye.newBuffer(ye.base64.length(me.previous)), 0) : me.previous.length >= 0 && (we.previous = me.previous)), me.height != null && (ye.Long ? (we.height = ye.Long.fromValue(me.height)).unsigned = !0 : typeof me.height == "string" ? we.height = parseInt(me.height, 10) : typeof me.height == "number" ? we.height = me.height : typeof me.height == "object" && (we.height = new ye.LongBits(me.height.low >>> 0, me.height.high >>> 0).toNumber(!0))), me.timestamp != null && (ye.Long ? (we.timestamp = ye.Long.fromValue(me.timestamp)).unsigned = !0 : typeof me.timestamp == "string" ? we.timestamp = parseInt(me.timestamp, 10) : typeof me.timestamp == "number" ? we.timestamp = me.timestamp : typeof me.timestamp == "object" && (we.timestamp = new ye.LongBits(me.timestamp.low >>> 0, me.timestamp.high >>> 0).toNumber(!0))), me.previous_state_merkle_root != null && (typeof me.previous_state_merkle_root == "string" ? ye.base64.decode(me.previous_state_merkle_root, we.previous_state_merkle_root = ye.newBuffer(ye.base64.length(me.previous_state_merkle_root)), 0) : me.previous_state_merkle_root.length >= 0 && (we.previous_state_merkle_root = me.previous_state_merkle_root)), me.transaction_merkle_root != null && (typeof me.transaction_merkle_root == "string" ? ye.base64.decode(me.transaction_merkle_root, we.transaction_merkle_root = ye.newBuffer(ye.base64.length(me.transaction_merkle_root)), 0) : me.transaction_merkle_root.length >= 0 && (we.transaction_merkle_root = me.transaction_merkle_root)), me.signer != null && (typeof me.signer == "string" ? ye.base64.decode(me.signer, we.signer = ye.newBuffer(ye.base64.length(me.signer)), 0) : me.signer.length >= 0 && (we.signer = me.signer)), me.approved_proposals) {
              if (!Array.isArray(me.approved_proposals))
                throw TypeError(".koinos.protocol.block_header.approved_proposals: array expected");
              we.approved_proposals = [];
              for (var ur = 0; ur < me.approved_proposals.length; ++ur)
                typeof me.approved_proposals[ur] == "string" ? ye.base64.decode(me.approved_proposals[ur], we.approved_proposals[ur] = ye.newBuffer(ye.base64.length(me.approved_proposals[ur])), 0) : me.approved_proposals[ur].length >= 0 && (we.approved_proposals[ur] = me.approved_proposals[ur]);
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.approved_proposals = []), we.defaults) {
              if (we.bytes === String ? ur.previous = "" : (ur.previous = [], we.bytes !== Array && (ur.previous = ye.newBuffer(ur.previous))), ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.height = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.height = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.timestamp = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.timestamp = we.longs === String ? "0" : 0;
              we.bytes === String ? ur.previous_state_merkle_root = "" : (ur.previous_state_merkle_root = [], we.bytes !== Array && (ur.previous_state_merkle_root = ye.newBuffer(ur.previous_state_merkle_root))), we.bytes === String ? ur.transaction_merkle_root = "" : (ur.transaction_merkle_root = [], we.bytes !== Array && (ur.transaction_merkle_root = ye.newBuffer(ur.transaction_merkle_root))), we.bytes === String ? ur.signer = "" : (ur.signer = [], we.bytes !== Array && (ur.signer = ye.newBuffer(ur.signer)));
            }
            if (me.previous != null && me.hasOwnProperty("previous") && (ur.previous = we.bytes === String ? ye.base64.encode(me.previous, 0, me.previous.length) : we.bytes === Array ? Array.prototype.slice.call(me.previous) : me.previous), me.height != null && me.hasOwnProperty("height") && (typeof me.height == "number" ? ur.height = we.longs === String ? String(me.height) : me.height : ur.height = we.longs === String ? ye.Long.prototype.toString.call(me.height) : we.longs === Number ? new ye.LongBits(me.height.low >>> 0, me.height.high >>> 0).toNumber(!0) : me.height), me.timestamp != null && me.hasOwnProperty("timestamp") && (typeof me.timestamp == "number" ? ur.timestamp = we.longs === String ? String(me.timestamp) : me.timestamp : ur.timestamp = we.longs === String ? ye.Long.prototype.toString.call(me.timestamp) : we.longs === Number ? new ye.LongBits(me.timestamp.low >>> 0, me.timestamp.high >>> 0).toNumber(!0) : me.timestamp), me.previous_state_merkle_root != null && me.hasOwnProperty("previous_state_merkle_root") && (ur.previous_state_merkle_root = we.bytes === String ? ye.base64.encode(me.previous_state_merkle_root, 0, me.previous_state_merkle_root.length) : we.bytes === Array ? Array.prototype.slice.call(me.previous_state_merkle_root) : me.previous_state_merkle_root), me.transaction_merkle_root != null && me.hasOwnProperty("transaction_merkle_root") && (ur.transaction_merkle_root = we.bytes === String ? ye.base64.encode(me.transaction_merkle_root, 0, me.transaction_merkle_root.length) : we.bytes === Array ? Array.prototype.slice.call(me.transaction_merkle_root) : me.transaction_merkle_root), me.signer != null && me.hasOwnProperty("signer") && (ur.signer = we.bytes === String ? ye.base64.encode(me.signer, 0, me.signer.length) : we.bytes === Array ? Array.prototype.slice.call(me.signer) : me.signer), me.approved_proposals && me.approved_proposals.length) {
              ur.approved_proposals = [];
              for (var Ar = 0; Ar < me.approved_proposals.length; ++Ar)
                ur.approved_proposals[Ar] = we.bytes === String ? ye.base64.encode(me.approved_proposals[Ar], 0, me.approved_proposals[Ar].length) : we.bytes === Array ? Array.prototype.slice.call(me.approved_proposals[Ar]) : me.approved_proposals[Ar];
            }
            return ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.block_header";
          }, Oe;
        }(), Se.block = function() {
          function Oe(xe) {
            if (this.transactions = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.id = ye.newBuffer([]), Oe.prototype.header = null, Oe.prototype.transactions = ye.emptyArray, Oe.prototype.signature = ye.newBuffer([]), Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.id != null && Object.hasOwnProperty.call(me, "id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.id), me.header != null && Object.hasOwnProperty.call(me, "header") && ve.koinos.protocol.block_header.encode(me.header, we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), me.transactions != null && me.transactions.length)
              for (var ur = 0; ur < me.transactions.length; ++ur)
                ve.koinos.protocol.transaction.encode(me.transactions[ur], we.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            return me.signature != null && Object.hasOwnProperty.call(me, "signature") && we.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(me.signature), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.block(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.id = me.bytes();
                  break;
                }
                case 2: {
                  lr.header = ve.koinos.protocol.block_header.decode(me, me.uint32());
                  break;
                }
                case 3: {
                  lr.transactions && lr.transactions.length || (lr.transactions = []), lr.transactions.push(ve.koinos.protocol.transaction.decode(me, me.uint32()));
                  break;
                }
                case 4: {
                  lr.signature = me.bytes();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.id != null && me.hasOwnProperty("id") && !(me.id && typeof me.id.length == "number" || ye.isString(me.id)))
              return "id: buffer expected";
            if (me.header != null && me.hasOwnProperty("header")) {
              var we = ve.koinos.protocol.block_header.verify(me.header);
              if (we)
                return "header." + we;
            }
            if (me.transactions != null && me.hasOwnProperty("transactions")) {
              if (!Array.isArray(me.transactions))
                return "transactions: array expected";
              for (var ur = 0; ur < me.transactions.length; ++ur) {
                var we = ve.koinos.protocol.transaction.verify(me.transactions[ur]);
                if (we)
                  return "transactions." + we;
              }
            }
            return me.signature != null && me.hasOwnProperty("signature") && !(me.signature && typeof me.signature.length == "number" || ye.isString(me.signature)) ? "signature: buffer expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.block)
              return me;
            var we = new ve.koinos.protocol.block();
            if (me.id != null && (typeof me.id == "string" ? ye.base64.decode(me.id, we.id = ye.newBuffer(ye.base64.length(me.id)), 0) : me.id.length >= 0 && (we.id = me.id)), me.header != null) {
              if (typeof me.header != "object")
                throw TypeError(".koinos.protocol.block.header: object expected");
              we.header = ve.koinos.protocol.block_header.fromObject(me.header);
            }
            if (me.transactions) {
              if (!Array.isArray(me.transactions))
                throw TypeError(".koinos.protocol.block.transactions: array expected");
              we.transactions = [];
              for (var ur = 0; ur < me.transactions.length; ++ur) {
                if (typeof me.transactions[ur] != "object")
                  throw TypeError(".koinos.protocol.block.transactions: object expected");
                we.transactions[ur] = ve.koinos.protocol.transaction.fromObject(me.transactions[ur]);
              }
            }
            return me.signature != null && (typeof me.signature == "string" ? ye.base64.decode(me.signature, we.signature = ye.newBuffer(ye.base64.length(me.signature)), 0) : me.signature.length >= 0 && (we.signature = me.signature)), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.transactions = []), we.defaults && (we.bytes === String ? ur.id = "" : (ur.id = [], we.bytes !== Array && (ur.id = ye.newBuffer(ur.id))), ur.header = null, we.bytes === String ? ur.signature = "" : (ur.signature = [], we.bytes !== Array && (ur.signature = ye.newBuffer(ur.signature)))), me.id != null && me.hasOwnProperty("id") && (ur.id = we.bytes === String ? ye.base64.encode(me.id, 0, me.id.length) : we.bytes === Array ? Array.prototype.slice.call(me.id) : me.id), me.header != null && me.hasOwnProperty("header") && (ur.header = ve.koinos.protocol.block_header.toObject(me.header, we)), me.transactions && me.transactions.length) {
              ur.transactions = [];
              for (var lr = 0; lr < me.transactions.length; ++lr)
                ur.transactions[lr] = ve.koinos.protocol.transaction.toObject(me.transactions[lr], we);
            }
            return me.signature != null && me.hasOwnProperty("signature") && (ur.signature = we.bytes === String ? ye.base64.encode(me.signature, 0, me.signature.length) : we.bytes === Array ? Array.prototype.slice.call(me.signature) : me.signature), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.block";
          }, Oe;
        }(), Se.block_receipt = function() {
          function Oe(xe) {
            if (this.events = [], this.transaction_receipts = [], this.logs = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.id = ye.newBuffer([]), Oe.prototype.height = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.disk_storage_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.network_bandwidth_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.compute_bandwidth_used = ye.Long ? ye.Long.fromBits(0, 0, !0) : 0, Oe.prototype.state_merkle_root = ye.newBuffer([]), Oe.prototype.events = ye.emptyArray, Oe.prototype.transaction_receipts = ye.emptyArray, Oe.prototype.logs = ye.emptyArray, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.id != null && Object.hasOwnProperty.call(me, "id") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(me.id), me.height != null && Object.hasOwnProperty.call(me, "height") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(me.height), me.disk_storage_used != null && Object.hasOwnProperty.call(me, "disk_storage_used") && we.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(me.disk_storage_used), me.network_bandwidth_used != null && Object.hasOwnProperty.call(me, "network_bandwidth_used") && we.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(me.network_bandwidth_used), me.compute_bandwidth_used != null && Object.hasOwnProperty.call(me, "compute_bandwidth_used") && we.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(me.compute_bandwidth_used), me.state_merkle_root != null && Object.hasOwnProperty.call(me, "state_merkle_root") && we.uint32(
              /* id 6, wireType 2 =*/
              50
            ).bytes(me.state_merkle_root), me.events != null && me.events.length)
              for (var ur = 0; ur < me.events.length; ++ur)
                ve.koinos.protocol.event_data.encode(me.events[ur], we.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).fork()).ldelim();
            if (me.transaction_receipts != null && me.transaction_receipts.length)
              for (var ur = 0; ur < me.transaction_receipts.length; ++ur)
                ve.koinos.protocol.transaction_receipt.encode(me.transaction_receipts[ur], we.uint32(
                  /* id 8, wireType 2 =*/
                  66
                ).fork()).ldelim();
            if (me.logs != null && me.logs.length)
              for (var ur = 0; ur < me.logs.length; ++ur)
                we.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).string(me.logs[ur]);
            return we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.protocol.block_receipt(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.id = me.bytes();
                  break;
                }
                case 2: {
                  lr.height = me.uint64();
                  break;
                }
                case 3: {
                  lr.disk_storage_used = me.uint64();
                  break;
                }
                case 4: {
                  lr.network_bandwidth_used = me.uint64();
                  break;
                }
                case 5: {
                  lr.compute_bandwidth_used = me.uint64();
                  break;
                }
                case 6: {
                  lr.state_merkle_root = me.bytes();
                  break;
                }
                case 7: {
                  lr.events && lr.events.length || (lr.events = []), lr.events.push(ve.koinos.protocol.event_data.decode(me, me.uint32()));
                  break;
                }
                case 8: {
                  lr.transaction_receipts && lr.transaction_receipts.length || (lr.transaction_receipts = []), lr.transaction_receipts.push(ve.koinos.protocol.transaction_receipt.decode(me, me.uint32()));
                  break;
                }
                case 9: {
                  lr.logs && lr.logs.length || (lr.logs = []), lr.logs.push(me.string());
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.id != null && me.hasOwnProperty("id") && !(me.id && typeof me.id.length == "number" || ye.isString(me.id)))
              return "id: buffer expected";
            if (me.height != null && me.hasOwnProperty("height") && !ye.isInteger(me.height) && !(me.height && ye.isInteger(me.height.low) && ye.isInteger(me.height.high)))
              return "height: integer|Long expected";
            if (me.disk_storage_used != null && me.hasOwnProperty("disk_storage_used") && !ye.isInteger(me.disk_storage_used) && !(me.disk_storage_used && ye.isInteger(me.disk_storage_used.low) && ye.isInteger(me.disk_storage_used.high)))
              return "disk_storage_used: integer|Long expected";
            if (me.network_bandwidth_used != null && me.hasOwnProperty("network_bandwidth_used") && !ye.isInteger(me.network_bandwidth_used) && !(me.network_bandwidth_used && ye.isInteger(me.network_bandwidth_used.low) && ye.isInteger(me.network_bandwidth_used.high)))
              return "network_bandwidth_used: integer|Long expected";
            if (me.compute_bandwidth_used != null && me.hasOwnProperty("compute_bandwidth_used") && !ye.isInteger(me.compute_bandwidth_used) && !(me.compute_bandwidth_used && ye.isInteger(me.compute_bandwidth_used.low) && ye.isInteger(me.compute_bandwidth_used.high)))
              return "compute_bandwidth_used: integer|Long expected";
            if (me.state_merkle_root != null && me.hasOwnProperty("state_merkle_root") && !(me.state_merkle_root && typeof me.state_merkle_root.length == "number" || ye.isString(me.state_merkle_root)))
              return "state_merkle_root: buffer expected";
            if (me.events != null && me.hasOwnProperty("events")) {
              if (!Array.isArray(me.events))
                return "events: array expected";
              for (var we = 0; we < me.events.length; ++we) {
                var ur = ve.koinos.protocol.event_data.verify(me.events[we]);
                if (ur)
                  return "events." + ur;
              }
            }
            if (me.transaction_receipts != null && me.hasOwnProperty("transaction_receipts")) {
              if (!Array.isArray(me.transaction_receipts))
                return "transaction_receipts: array expected";
              for (var we = 0; we < me.transaction_receipts.length; ++we) {
                var ur = ve.koinos.protocol.transaction_receipt.verify(me.transaction_receipts[we]);
                if (ur)
                  return "transaction_receipts." + ur;
              }
            }
            if (me.logs != null && me.hasOwnProperty("logs")) {
              if (!Array.isArray(me.logs))
                return "logs: array expected";
              for (var we = 0; we < me.logs.length; ++we)
                if (!ye.isString(me.logs[we]))
                  return "logs: string[] expected";
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.protocol.block_receipt)
              return me;
            var we = new ve.koinos.protocol.block_receipt();
            if (me.id != null && (typeof me.id == "string" ? ye.base64.decode(me.id, we.id = ye.newBuffer(ye.base64.length(me.id)), 0) : me.id.length >= 0 && (we.id = me.id)), me.height != null && (ye.Long ? (we.height = ye.Long.fromValue(me.height)).unsigned = !0 : typeof me.height == "string" ? we.height = parseInt(me.height, 10) : typeof me.height == "number" ? we.height = me.height : typeof me.height == "object" && (we.height = new ye.LongBits(me.height.low >>> 0, me.height.high >>> 0).toNumber(!0))), me.disk_storage_used != null && (ye.Long ? (we.disk_storage_used = ye.Long.fromValue(me.disk_storage_used)).unsigned = !0 : typeof me.disk_storage_used == "string" ? we.disk_storage_used = parseInt(me.disk_storage_used, 10) : typeof me.disk_storage_used == "number" ? we.disk_storage_used = me.disk_storage_used : typeof me.disk_storage_used == "object" && (we.disk_storage_used = new ye.LongBits(me.disk_storage_used.low >>> 0, me.disk_storage_used.high >>> 0).toNumber(!0))), me.network_bandwidth_used != null && (ye.Long ? (we.network_bandwidth_used = ye.Long.fromValue(me.network_bandwidth_used)).unsigned = !0 : typeof me.network_bandwidth_used == "string" ? we.network_bandwidth_used = parseInt(me.network_bandwidth_used, 10) : typeof me.network_bandwidth_used == "number" ? we.network_bandwidth_used = me.network_bandwidth_used : typeof me.network_bandwidth_used == "object" && (we.network_bandwidth_used = new ye.LongBits(me.network_bandwidth_used.low >>> 0, me.network_bandwidth_used.high >>> 0).toNumber(!0))), me.compute_bandwidth_used != null && (ye.Long ? (we.compute_bandwidth_used = ye.Long.fromValue(me.compute_bandwidth_used)).unsigned = !0 : typeof me.compute_bandwidth_used == "string" ? we.compute_bandwidth_used = parseInt(me.compute_bandwidth_used, 10) : typeof me.compute_bandwidth_used == "number" ? we.compute_bandwidth_used = me.compute_bandwidth_used : typeof me.compute_bandwidth_used == "object" && (we.compute_bandwidth_used = new ye.LongBits(me.compute_bandwidth_used.low >>> 0, me.compute_bandwidth_used.high >>> 0).toNumber(!0))), me.state_merkle_root != null && (typeof me.state_merkle_root == "string" ? ye.base64.decode(me.state_merkle_root, we.state_merkle_root = ye.newBuffer(ye.base64.length(me.state_merkle_root)), 0) : me.state_merkle_root.length >= 0 && (we.state_merkle_root = me.state_merkle_root)), me.events) {
              if (!Array.isArray(me.events))
                throw TypeError(".koinos.protocol.block_receipt.events: array expected");
              we.events = [];
              for (var ur = 0; ur < me.events.length; ++ur) {
                if (typeof me.events[ur] != "object")
                  throw TypeError(".koinos.protocol.block_receipt.events: object expected");
                we.events[ur] = ve.koinos.protocol.event_data.fromObject(me.events[ur]);
              }
            }
            if (me.transaction_receipts) {
              if (!Array.isArray(me.transaction_receipts))
                throw TypeError(".koinos.protocol.block_receipt.transaction_receipts: array expected");
              we.transaction_receipts = [];
              for (var ur = 0; ur < me.transaction_receipts.length; ++ur) {
                if (typeof me.transaction_receipts[ur] != "object")
                  throw TypeError(".koinos.protocol.block_receipt.transaction_receipts: object expected");
                we.transaction_receipts[ur] = ve.koinos.protocol.transaction_receipt.fromObject(me.transaction_receipts[ur]);
              }
            }
            if (me.logs) {
              if (!Array.isArray(me.logs))
                throw TypeError(".koinos.protocol.block_receipt.logs: array expected");
              we.logs = [];
              for (var ur = 0; ur < me.logs.length; ++ur)
                we.logs[ur] = String(me.logs[ur]);
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.events = [], ur.transaction_receipts = [], ur.logs = []), we.defaults) {
              if (we.bytes === String ? ur.id = "" : (ur.id = [], we.bytes !== Array && (ur.id = ye.newBuffer(ur.id))), ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.height = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.height = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.disk_storage_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.disk_storage_used = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.network_bandwidth_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.network_bandwidth_used = we.longs === String ? "0" : 0;
              if (ye.Long) {
                var lr = new ye.Long(0, 0, !0);
                ur.compute_bandwidth_used = we.longs === String ? lr.toString() : we.longs === Number ? lr.toNumber() : lr;
              } else
                ur.compute_bandwidth_used = we.longs === String ? "0" : 0;
              we.bytes === String ? ur.state_merkle_root = "" : (ur.state_merkle_root = [], we.bytes !== Array && (ur.state_merkle_root = ye.newBuffer(ur.state_merkle_root)));
            }
            if (me.id != null && me.hasOwnProperty("id") && (ur.id = we.bytes === String ? ye.base64.encode(me.id, 0, me.id.length) : we.bytes === Array ? Array.prototype.slice.call(me.id) : me.id), me.height != null && me.hasOwnProperty("height") && (typeof me.height == "number" ? ur.height = we.longs === String ? String(me.height) : me.height : ur.height = we.longs === String ? ye.Long.prototype.toString.call(me.height) : we.longs === Number ? new ye.LongBits(me.height.low >>> 0, me.height.high >>> 0).toNumber(!0) : me.height), me.disk_storage_used != null && me.hasOwnProperty("disk_storage_used") && (typeof me.disk_storage_used == "number" ? ur.disk_storage_used = we.longs === String ? String(me.disk_storage_used) : me.disk_storage_used : ur.disk_storage_used = we.longs === String ? ye.Long.prototype.toString.call(me.disk_storage_used) : we.longs === Number ? new ye.LongBits(me.disk_storage_used.low >>> 0, me.disk_storage_used.high >>> 0).toNumber(!0) : me.disk_storage_used), me.network_bandwidth_used != null && me.hasOwnProperty("network_bandwidth_used") && (typeof me.network_bandwidth_used == "number" ? ur.network_bandwidth_used = we.longs === String ? String(me.network_bandwidth_used) : me.network_bandwidth_used : ur.network_bandwidth_used = we.longs === String ? ye.Long.prototype.toString.call(me.network_bandwidth_used) : we.longs === Number ? new ye.LongBits(me.network_bandwidth_used.low >>> 0, me.network_bandwidth_used.high >>> 0).toNumber(!0) : me.network_bandwidth_used), me.compute_bandwidth_used != null && me.hasOwnProperty("compute_bandwidth_used") && (typeof me.compute_bandwidth_used == "number" ? ur.compute_bandwidth_used = we.longs === String ? String(me.compute_bandwidth_used) : me.compute_bandwidth_used : ur.compute_bandwidth_used = we.longs === String ? ye.Long.prototype.toString.call(me.compute_bandwidth_used) : we.longs === Number ? new ye.LongBits(me.compute_bandwidth_used.low >>> 0, me.compute_bandwidth_used.high >>> 0).toNumber(!0) : me.compute_bandwidth_used), me.state_merkle_root != null && me.hasOwnProperty("state_merkle_root") && (ur.state_merkle_root = we.bytes === String ? ye.base64.encode(me.state_merkle_root, 0, me.state_merkle_root.length) : we.bytes === Array ? Array.prototype.slice.call(me.state_merkle_root) : me.state_merkle_root), me.events && me.events.length) {
              ur.events = [];
              for (var Ar = 0; Ar < me.events.length; ++Ar)
                ur.events[Ar] = ve.koinos.protocol.event_data.toObject(me.events[Ar], we);
            }
            if (me.transaction_receipts && me.transaction_receipts.length) {
              ur.transaction_receipts = [];
              for (var Ar = 0; Ar < me.transaction_receipts.length; ++Ar)
                ur.transaction_receipts[Ar] = ve.koinos.protocol.transaction_receipt.toObject(me.transaction_receipts[Ar], we);
            }
            if (me.logs && me.logs.length) {
              ur.logs = [];
              for (var Ar = 0; Ar < me.logs.length; ++Ar)
                ur.logs[Ar] = me.logs[Ar];
            }
            return ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.protocol.block_receipt";
          }, Oe;
        }(), Se;
      }(), Ee.chain = function() {
        var Se = {};
        return Se.value_type = function() {
          function Oe(me) {
            if (me)
              for (var we = Object.keys(me), ur = 0; ur < we.length; ++ur)
                me[we[ur]] != null && (this[we[ur]] = me[we[ur]]);
          }
          Oe.prototype.message_value = null, Oe.prototype.int32_value = null, Oe.prototype.int64_value = null, Oe.prototype.uint32_value = null, Oe.prototype.uint64_value = null, Oe.prototype.sint32_value = null, Oe.prototype.sint64_value = null, Oe.prototype.fixed32_value = null, Oe.prototype.fixed64_value = null, Oe.prototype.sfixed32_value = null, Oe.prototype.sfixed64_value = null, Oe.prototype.bool_value = null, Oe.prototype.string_value = null, Oe.prototype.bytes_value = null;
          var xe;
          return Object.defineProperty(Oe.prototype, "kind", {
            get: ye.oneOfGetter(xe = [
              "message_value",
              "int32_value",
              "int64_value",
              "uint32_value",
              "uint64_value",
              "sint32_value",
              "sint64_value",
              "fixed32_value",
              "fixed64_value",
              "sfixed32_value",
              "sfixed64_value",
              "bool_value",
              "string_value",
              "bytes_value"
            ]),
            set: ye.oneOfSetter(xe)
          }), Oe.create = function(we) {
            return new Oe(we);
          }, Oe.encode = function(we, ur) {
            return ur || (ur = be.create()), we.message_value != null && Object.hasOwnProperty.call(we, "message_value") && ve.google.protobuf.Any.encode(we.message_value, ur.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim(), we.int32_value != null && Object.hasOwnProperty.call(we, "int32_value") && ur.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(we.int32_value), we.int64_value != null && Object.hasOwnProperty.call(we, "int64_value") && ur.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int64(we.int64_value), we.uint32_value != null && Object.hasOwnProperty.call(we, "uint32_value") && ur.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint32(we.uint32_value), we.uint64_value != null && Object.hasOwnProperty.call(we, "uint64_value") && ur.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(we.uint64_value), we.sint32_value != null && Object.hasOwnProperty.call(we, "sint32_value") && ur.uint32(
              /* id 6, wireType 0 =*/
              48
            ).sint32(we.sint32_value), we.sint64_value != null && Object.hasOwnProperty.call(we, "sint64_value") && ur.uint32(
              /* id 7, wireType 0 =*/
              56
            ).sint64(we.sint64_value), we.fixed32_value != null && Object.hasOwnProperty.call(we, "fixed32_value") && ur.uint32(
              /* id 8, wireType 5 =*/
              69
            ).fixed32(we.fixed32_value), we.fixed64_value != null && Object.hasOwnProperty.call(we, "fixed64_value") && ur.uint32(
              /* id 9, wireType 1 =*/
              73
            ).fixed64(we.fixed64_value), we.sfixed32_value != null && Object.hasOwnProperty.call(we, "sfixed32_value") && ur.uint32(
              /* id 10, wireType 5 =*/
              85
            ).sfixed32(we.sfixed32_value), we.sfixed64_value != null && Object.hasOwnProperty.call(we, "sfixed64_value") && ur.uint32(
              /* id 11, wireType 1 =*/
              89
            ).sfixed64(we.sfixed64_value), we.bool_value != null && Object.hasOwnProperty.call(we, "bool_value") && ur.uint32(
              /* id 12, wireType 0 =*/
              96
            ).bool(we.bool_value), we.string_value != null && Object.hasOwnProperty.call(we, "string_value") && ur.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(we.string_value), we.bytes_value != null && Object.hasOwnProperty.call(we, "bytes_value") && ur.uint32(
              /* id 14, wireType 2 =*/
              114
            ).bytes(we.bytes_value), ur;
          }, Oe.encodeDelimited = function(we, ur) {
            return this.encode(we, ur).ldelim();
          }, Oe.decode = function(we, ur) {
            we instanceof fe || (we = fe.create(we));
            for (var lr = ur === void 0 ? we.len : we.pos + ur, Ar = new ve.koinos.chain.value_type(); we.pos < lr; ) {
              var Br = we.uint32();
              switch (Br >>> 3) {
                case 1: {
                  Ar.message_value = ve.google.protobuf.Any.decode(we, we.uint32());
                  break;
                }
                case 2: {
                  Ar.int32_value = we.int32();
                  break;
                }
                case 3: {
                  Ar.int64_value = we.int64();
                  break;
                }
                case 4: {
                  Ar.uint32_value = we.uint32();
                  break;
                }
                case 5: {
                  Ar.uint64_value = we.uint64();
                  break;
                }
                case 6: {
                  Ar.sint32_value = we.sint32();
                  break;
                }
                case 7: {
                  Ar.sint64_value = we.sint64();
                  break;
                }
                case 8: {
                  Ar.fixed32_value = we.fixed32();
                  break;
                }
                case 9: {
                  Ar.fixed64_value = we.fixed64();
                  break;
                }
                case 10: {
                  Ar.sfixed32_value = we.sfixed32();
                  break;
                }
                case 11: {
                  Ar.sfixed64_value = we.sfixed64();
                  break;
                }
                case 12: {
                  Ar.bool_value = we.bool();
                  break;
                }
                case 13: {
                  Ar.string_value = we.string();
                  break;
                }
                case 14: {
                  Ar.bytes_value = we.bytes();
                  break;
                }
                default:
                  we.skipType(Br & 7);
                  break;
              }
            }
            return Ar;
          }, Oe.decodeDelimited = function(we) {
            return we instanceof fe || (we = new fe(we)), this.decode(we, we.uint32());
          }, Oe.verify = function(we) {
            if (typeof we != "object" || we === null)
              return "object expected";
            var ur = {};
            if (we.message_value != null && we.hasOwnProperty("message_value")) {
              ur.kind = 1;
              {
                var lr = ve.google.protobuf.Any.verify(we.message_value);
                if (lr)
                  return "message_value." + lr;
              }
            }
            if (we.int32_value != null && we.hasOwnProperty("int32_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.int32_value))
                return "int32_value: integer expected";
            }
            if (we.int64_value != null && we.hasOwnProperty("int64_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.int64_value) && !(we.int64_value && ye.isInteger(we.int64_value.low) && ye.isInteger(we.int64_value.high)))
                return "int64_value: integer|Long expected";
            }
            if (we.uint32_value != null && we.hasOwnProperty("uint32_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.uint32_value))
                return "uint32_value: integer expected";
            }
            if (we.uint64_value != null && we.hasOwnProperty("uint64_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.uint64_value) && !(we.uint64_value && ye.isInteger(we.uint64_value.low) && ye.isInteger(we.uint64_value.high)))
                return "uint64_value: integer|Long expected";
            }
            if (we.sint32_value != null && we.hasOwnProperty("sint32_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.sint32_value))
                return "sint32_value: integer expected";
            }
            if (we.sint64_value != null && we.hasOwnProperty("sint64_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.sint64_value) && !(we.sint64_value && ye.isInteger(we.sint64_value.low) && ye.isInteger(we.sint64_value.high)))
                return "sint64_value: integer|Long expected";
            }
            if (we.fixed32_value != null && we.hasOwnProperty("fixed32_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.fixed32_value))
                return "fixed32_value: integer expected";
            }
            if (we.fixed64_value != null && we.hasOwnProperty("fixed64_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.fixed64_value) && !(we.fixed64_value && ye.isInteger(we.fixed64_value.low) && ye.isInteger(we.fixed64_value.high)))
                return "fixed64_value: integer|Long expected";
            }
            if (we.sfixed32_value != null && we.hasOwnProperty("sfixed32_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.sfixed32_value))
                return "sfixed32_value: integer expected";
            }
            if (we.sfixed64_value != null && we.hasOwnProperty("sfixed64_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isInteger(we.sfixed64_value) && !(we.sfixed64_value && ye.isInteger(we.sfixed64_value.low) && ye.isInteger(we.sfixed64_value.high)))
                return "sfixed64_value: integer|Long expected";
            }
            if (we.bool_value != null && we.hasOwnProperty("bool_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, typeof we.bool_value != "boolean")
                return "bool_value: boolean expected";
            }
            if (we.string_value != null && we.hasOwnProperty("string_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !ye.isString(we.string_value))
                return "string_value: string expected";
            }
            if (we.bytes_value != null && we.hasOwnProperty("bytes_value")) {
              if (ur.kind === 1)
                return "kind: multiple values";
              if (ur.kind = 1, !(we.bytes_value && typeof we.bytes_value.length == "number" || ye.isString(we.bytes_value)))
                return "bytes_value: buffer expected";
            }
            return null;
          }, Oe.fromObject = function(we) {
            if (we instanceof ve.koinos.chain.value_type)
              return we;
            var ur = new ve.koinos.chain.value_type();
            if (we.message_value != null) {
              if (typeof we.message_value != "object")
                throw TypeError(".koinos.chain.value_type.message_value: object expected");
              ur.message_value = ve.google.protobuf.Any.fromObject(we.message_value);
            }
            return we.int32_value != null && (ur.int32_value = we.int32_value | 0), we.int64_value != null && (ye.Long ? (ur.int64_value = ye.Long.fromValue(we.int64_value)).unsigned = !1 : typeof we.int64_value == "string" ? ur.int64_value = parseInt(we.int64_value, 10) : typeof we.int64_value == "number" ? ur.int64_value = we.int64_value : typeof we.int64_value == "object" && (ur.int64_value = new ye.LongBits(we.int64_value.low >>> 0, we.int64_value.high >>> 0).toNumber())), we.uint32_value != null && (ur.uint32_value = we.uint32_value >>> 0), we.uint64_value != null && (ye.Long ? (ur.uint64_value = ye.Long.fromValue(we.uint64_value)).unsigned = !0 : typeof we.uint64_value == "string" ? ur.uint64_value = parseInt(we.uint64_value, 10) : typeof we.uint64_value == "number" ? ur.uint64_value = we.uint64_value : typeof we.uint64_value == "object" && (ur.uint64_value = new ye.LongBits(we.uint64_value.low >>> 0, we.uint64_value.high >>> 0).toNumber(!0))), we.sint32_value != null && (ur.sint32_value = we.sint32_value | 0), we.sint64_value != null && (ye.Long ? (ur.sint64_value = ye.Long.fromValue(we.sint64_value)).unsigned = !1 : typeof we.sint64_value == "string" ? ur.sint64_value = parseInt(we.sint64_value, 10) : typeof we.sint64_value == "number" ? ur.sint64_value = we.sint64_value : typeof we.sint64_value == "object" && (ur.sint64_value = new ye.LongBits(we.sint64_value.low >>> 0, we.sint64_value.high >>> 0).toNumber())), we.fixed32_value != null && (ur.fixed32_value = we.fixed32_value >>> 0), we.fixed64_value != null && (ye.Long ? (ur.fixed64_value = ye.Long.fromValue(we.fixed64_value)).unsigned = !1 : typeof we.fixed64_value == "string" ? ur.fixed64_value = parseInt(we.fixed64_value, 10) : typeof we.fixed64_value == "number" ? ur.fixed64_value = we.fixed64_value : typeof we.fixed64_value == "object" && (ur.fixed64_value = new ye.LongBits(we.fixed64_value.low >>> 0, we.fixed64_value.high >>> 0).toNumber())), we.sfixed32_value != null && (ur.sfixed32_value = we.sfixed32_value | 0), we.sfixed64_value != null && (ye.Long ? (ur.sfixed64_value = ye.Long.fromValue(we.sfixed64_value)).unsigned = !1 : typeof we.sfixed64_value == "string" ? ur.sfixed64_value = parseInt(we.sfixed64_value, 10) : typeof we.sfixed64_value == "number" ? ur.sfixed64_value = we.sfixed64_value : typeof we.sfixed64_value == "object" && (ur.sfixed64_value = new ye.LongBits(we.sfixed64_value.low >>> 0, we.sfixed64_value.high >>> 0).toNumber())), we.bool_value != null && (ur.bool_value = !!we.bool_value), we.string_value != null && (ur.string_value = String(we.string_value)), we.bytes_value != null && (typeof we.bytes_value == "string" ? ye.base64.decode(we.bytes_value, ur.bytes_value = ye.newBuffer(ye.base64.length(we.bytes_value)), 0) : we.bytes_value.length >= 0 && (ur.bytes_value = we.bytes_value)), ur;
          }, Oe.toObject = function(we, ur) {
            ur || (ur = {});
            var lr = {};
            return we.message_value != null && we.hasOwnProperty("message_value") && (lr.message_value = ve.google.protobuf.Any.toObject(we.message_value, ur), ur.oneofs && (lr.kind = "message_value")), we.int32_value != null && we.hasOwnProperty("int32_value") && (lr.int32_value = we.int32_value, ur.oneofs && (lr.kind = "int32_value")), we.int64_value != null && we.hasOwnProperty("int64_value") && (typeof we.int64_value == "number" ? lr.int64_value = ur.longs === String ? String(we.int64_value) : we.int64_value : lr.int64_value = ur.longs === String ? ye.Long.prototype.toString.call(we.int64_value) : ur.longs === Number ? new ye.LongBits(we.int64_value.low >>> 0, we.int64_value.high >>> 0).toNumber() : we.int64_value, ur.oneofs && (lr.kind = "int64_value")), we.uint32_value != null && we.hasOwnProperty("uint32_value") && (lr.uint32_value = we.uint32_value, ur.oneofs && (lr.kind = "uint32_value")), we.uint64_value != null && we.hasOwnProperty("uint64_value") && (typeof we.uint64_value == "number" ? lr.uint64_value = ur.longs === String ? String(we.uint64_value) : we.uint64_value : lr.uint64_value = ur.longs === String ? ye.Long.prototype.toString.call(we.uint64_value) : ur.longs === Number ? new ye.LongBits(we.uint64_value.low >>> 0, we.uint64_value.high >>> 0).toNumber(!0) : we.uint64_value, ur.oneofs && (lr.kind = "uint64_value")), we.sint32_value != null && we.hasOwnProperty("sint32_value") && (lr.sint32_value = we.sint32_value, ur.oneofs && (lr.kind = "sint32_value")), we.sint64_value != null && we.hasOwnProperty("sint64_value") && (typeof we.sint64_value == "number" ? lr.sint64_value = ur.longs === String ? String(we.sint64_value) : we.sint64_value : lr.sint64_value = ur.longs === String ? ye.Long.prototype.toString.call(we.sint64_value) : ur.longs === Number ? new ye.LongBits(we.sint64_value.low >>> 0, we.sint64_value.high >>> 0).toNumber() : we.sint64_value, ur.oneofs && (lr.kind = "sint64_value")), we.fixed32_value != null && we.hasOwnProperty("fixed32_value") && (lr.fixed32_value = we.fixed32_value, ur.oneofs && (lr.kind = "fixed32_value")), we.fixed64_value != null && we.hasOwnProperty("fixed64_value") && (typeof we.fixed64_value == "number" ? lr.fixed64_value = ur.longs === String ? String(we.fixed64_value) : we.fixed64_value : lr.fixed64_value = ur.longs === String ? ye.Long.prototype.toString.call(we.fixed64_value) : ur.longs === Number ? new ye.LongBits(we.fixed64_value.low >>> 0, we.fixed64_value.high >>> 0).toNumber() : we.fixed64_value, ur.oneofs && (lr.kind = "fixed64_value")), we.sfixed32_value != null && we.hasOwnProperty("sfixed32_value") && (lr.sfixed32_value = we.sfixed32_value, ur.oneofs && (lr.kind = "sfixed32_value")), we.sfixed64_value != null && we.hasOwnProperty("sfixed64_value") && (typeof we.sfixed64_value == "number" ? lr.sfixed64_value = ur.longs === String ? String(we.sfixed64_value) : we.sfixed64_value : lr.sfixed64_value = ur.longs === String ? ye.Long.prototype.toString.call(we.sfixed64_value) : ur.longs === Number ? new ye.LongBits(we.sfixed64_value.low >>> 0, we.sfixed64_value.high >>> 0).toNumber() : we.sfixed64_value, ur.oneofs && (lr.kind = "sfixed64_value")), we.bool_value != null && we.hasOwnProperty("bool_value") && (lr.bool_value = we.bool_value, ur.oneofs && (lr.kind = "bool_value")), we.string_value != null && we.hasOwnProperty("string_value") && (lr.string_value = we.string_value, ur.oneofs && (lr.kind = "string_value")), we.bytes_value != null && we.hasOwnProperty("bytes_value") && (lr.bytes_value = ur.bytes === String ? ye.base64.encode(we.bytes_value, 0, we.bytes_value.length) : ur.bytes === Array ? Array.prototype.slice.call(we.bytes_value) : we.bytes_value, ur.oneofs && (lr.kind = "bytes_value")), lr;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(we) {
            return we === void 0 && (we = "type.googleapis.com"), we + "/koinos.chain.value_type";
          }, Oe;
        }(), Se.enum_type = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.name = "", Oe.prototype.number = 0, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.name != null && Object.hasOwnProperty.call(me, "name") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(me.name), me.number != null && Object.hasOwnProperty.call(me, "number") && we.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(me.number), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.chain.enum_type(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.name = me.string();
                  break;
                }
                case 2: {
                  lr.number = me.int32();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.name != null && me.hasOwnProperty("name") && !ye.isString(me.name) ? "name: string expected" : me.number != null && me.hasOwnProperty("number") && !ye.isInteger(me.number) ? "number: integer expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.chain.enum_type)
              return me;
            var we = new ve.koinos.chain.enum_type();
            return me.name != null && (we.name = String(me.name)), me.number != null && (we.number = me.number | 0), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (ur.name = "", ur.number = 0), me.name != null && me.hasOwnProperty("name") && (ur.name = me.name), me.number != null && me.hasOwnProperty("number") && (ur.number = me.number), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.chain.enum_type";
          }, Oe;
        }(), Se.list_type = function() {
          function Oe(xe) {
            if (this.values = [], xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.values = ye.emptyArray, Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            if (we || (we = be.create()), me.values != null && me.values.length)
              for (var ur = 0; ur < me.values.length; ++ur)
                ve.koinos.chain.value_type.encode(me.values[ur], we.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.koinos.chain.list_type(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.values && lr.values.length || (lr.values = []), lr.values.push(ve.koinos.chain.value_type.decode(me, me.uint32()));
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            if (typeof me != "object" || me === null)
              return "object expected";
            if (me.values != null && me.hasOwnProperty("values")) {
              if (!Array.isArray(me.values))
                return "values: array expected";
              for (var we = 0; we < me.values.length; ++we) {
                var ur = ve.koinos.chain.value_type.verify(me.values[we]);
                if (ur)
                  return "values." + ur;
              }
            }
            return null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.koinos.chain.list_type)
              return me;
            var we = new ve.koinos.chain.list_type();
            if (me.values) {
              if (!Array.isArray(me.values))
                throw TypeError(".koinos.chain.list_type.values: array expected");
              we.values = [];
              for (var ur = 0; ur < me.values.length; ++ur) {
                if (typeof me.values[ur] != "object")
                  throw TypeError(".koinos.chain.list_type.values: object expected");
                we.values[ur] = ve.koinos.chain.value_type.fromObject(me.values[ur]);
              }
            }
            return we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            if ((we.arrays || we.defaults) && (ur.values = []), me.values && me.values.length) {
              ur.values = [];
              for (var lr = 0; lr < me.values.length; ++lr)
                ur.values[lr] = ve.koinos.chain.value_type.toObject(me.values[lr], we);
            }
            return ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/koinos.chain.list_type";
          }, Oe;
        }(), Se;
      }(), Ee;
    }(), ve.google = function() {
      var Ee = {};
      return Ee.protobuf = function() {
        var Se = {};
        return Se.Any = function() {
          function Oe(xe) {
            if (xe)
              for (var me = Object.keys(xe), we = 0; we < me.length; ++we)
                xe[me[we]] != null && (this[me[we]] = xe[me[we]]);
          }
          return Oe.prototype.type_url = "", Oe.prototype.value = ye.newBuffer([]), Oe.create = function(me) {
            return new Oe(me);
          }, Oe.encode = function(me, we) {
            return we || (we = be.create()), me.type_url != null && Object.hasOwnProperty.call(me, "type_url") && we.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(me.type_url), me.value != null && Object.hasOwnProperty.call(me, "value") && we.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(me.value), we;
          }, Oe.encodeDelimited = function(me, we) {
            return this.encode(me, we).ldelim();
          }, Oe.decode = function(me, we) {
            me instanceof fe || (me = fe.create(me));
            for (var ur = we === void 0 ? me.len : me.pos + we, lr = new ve.google.protobuf.Any(); me.pos < ur; ) {
              var Ar = me.uint32();
              switch (Ar >>> 3) {
                case 1: {
                  lr.type_url = me.string();
                  break;
                }
                case 2: {
                  lr.value = me.bytes();
                  break;
                }
                default:
                  me.skipType(Ar & 7);
                  break;
              }
            }
            return lr;
          }, Oe.decodeDelimited = function(me) {
            return me instanceof fe || (me = new fe(me)), this.decode(me, me.uint32());
          }, Oe.verify = function(me) {
            return typeof me != "object" || me === null ? "object expected" : me.type_url != null && me.hasOwnProperty("type_url") && !ye.isString(me.type_url) ? "type_url: string expected" : me.value != null && me.hasOwnProperty("value") && !(me.value && typeof me.value.length == "number" || ye.isString(me.value)) ? "value: buffer expected" : null;
          }, Oe.fromObject = function(me) {
            if (me instanceof ve.google.protobuf.Any)
              return me;
            var we = new ve.google.protobuf.Any();
            return me.type_url != null && (we.type_url = String(me.type_url)), me.value != null && (typeof me.value == "string" ? ye.base64.decode(me.value, we.value = ye.newBuffer(ye.base64.length(me.value)), 0) : me.value.length >= 0 && (we.value = me.value)), we;
          }, Oe.toObject = function(me, we) {
            we || (we = {});
            var ur = {};
            return we.defaults && (ur.type_url = "", we.bytes === String ? ur.value = "" : (ur.value = [], we.bytes !== Array && (ur.value = ye.newBuffer(ur.value)))), me.type_url != null && me.hasOwnProperty("type_url") && (ur.type_url = me.type_url), me.value != null && me.hasOwnProperty("value") && (ur.value = we.bytes === String ? ye.base64.encode(me.value, 0, me.value.length) : we.bytes === Array ? Array.prototype.slice.call(me.value) : me.value), ur;
          }, Oe.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Oe.getTypeUrl = function(me) {
            return me === void 0 && (me = "type.googleapis.com"), me + "/google.protobuf.Any";
          }, Oe;
        }(), Se;
      }(), Ee;
    }(), ve;
  });
})(protocolProto);
var protocolProtoExports = protocolProto.exports, __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(v, e, fe, be) {
  be === void 0 && (be = fe);
  var ye = Object.getOwnPropertyDescriptor(e, fe);
  (!ye || ("get" in ye ? !e.__esModule : ye.writable || ye.configurable)) && (ye = { enumerable: !0, get: function() {
    return e[fe];
  } }), Object.defineProperty(v, be, ye);
} : function(v, e, fe, be) {
  be === void 0 && (be = fe), v[be] = e[fe];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(v, e) {
  Object.defineProperty(v, "default", { enumerable: !0, value: e });
} : function(v, e) {
  v.default = e;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(v) {
  if (v && v.__esModule)
    return v;
  var e = {};
  if (v != null)
    for (var fe in v)
      fe !== "default" && Object.prototype.hasOwnProperty.call(v, fe) && __createBinding(e, v, fe);
  return __setModuleDefault(e, v), e;
};
Object.defineProperty(Signer$1, "__esModule", { value: !0 });
Signer$1.Signer = void 0;
const sha256_1 = sha256, secp = __importStar(lib), utils_1$1 = utils$1, protocol_proto_js_1$1 = protocolProtoExports, btypeBlockHeader = {
  previous: { type: "bytes", btype: "BLOCK_ID" },
  height: { type: "uint64" },
  timestamp: { type: "uint64" },
  previous_state_merkle_root: { type: "bytes" },
  transaction_merkle_root: { type: "bytes" },
  signer: { type: "bytes", btype: "ADDRESS" }
}, btypeTransactionHeader = {
  chain_id: { type: "bytes" },
  rc_limit: { type: "uint64" },
  nonce: { type: "bytes" },
  operation_merkle_root: { type: "bytes" },
  payer: { type: "bytes", btype: "ADDRESS" },
  payee: { type: "bytes", btype: "ADDRESS" }
}, btypesOperation = {
  upload_contract: {
    type: "object",
    subtypes: {
      contract_id: { type: "bytes", btype: "CONTRACT_ID" },
      bytecode: { type: "bytes" },
      abi: { type: "string" },
      authorizes_call_contract: { type: "bool" },
      authorizes_transaction_application: { type: "bool" },
      authorizes_upload_contract: { type: "bool" }
    }
  },
  call_contract: {
    type: "object",
    subtypes: {
      contract_id: { type: "bytes", btype: "CONTRACT_ID" },
      entry_point: { type: "uint32" },
      args: { type: "bytes" }
    }
  },
  set_system_call: {
    type: "object",
    subtypes: {
      call_id: { type: "uint32" },
      target: {
        type: "object",
        subtypes: {
          thunk_id: { type: "uint32" },
          system_call_bundle: {
            type: "object",
            subtypes: {
              contract_id: { type: "bytes", btype: "CONTRACT_ID" },
              entry_point: { type: "uint32" }
            }
          }
        }
      }
    }
  },
  set_system_contract: {
    type: "object",
    subtypes: {
      contract_id: { type: "bytes", btype: "CONTRACT_ID" },
      system_contract: { type: "bool" }
    }
  }
};
class Signer {
  /**
   * The constructor receives de private key as hexstring, bigint or Uint8Array.
   * See also the functions [[Signer.fromWif]] and [[Signer.fromSeed]]
   * to create the signer from the WIF or Seed respectively.
   *
   * @param privateKey - Private key as hexstring, bigint or Uint8Array
   * @param compressed - compressed format is true by default
   * @param provider - provider to connect with the blockchain
   * @example
   * ```ts
   * const privateKey = "ec8601a24f81decd57f4b611b5ac6eb801cb3780bb02c0f9cdfe9d09daaddf9c";
   * cons signer = new Signer({ privateKey });
   * console.log(signer.getAddress());
   * // 1MbL6mG8ASAvSYdoMnGUfG3ZXkmQ2dpL5b
   * ```
   */
  constructor(e) {
    this.chainId = "", this.compressed = typeof e.compressed > "u" ? !0 : e.compressed, this.privateKey = e.privateKey, this.provider = e.provider, typeof e.privateKey == "string" ? (this.publicKey = secp.getPublicKey(e.privateKey, this.compressed), this.address = (0, utils_1$1.bitcoinAddress)(this.publicKey)) : (this.publicKey = secp.getPublicKey(e.privateKey, this.compressed), this.address = (0, utils_1$1.bitcoinAddress)(this.publicKey)), e.chainId && (this.chainId = e.chainId), this.sendOptions = {
      broadcast: !0,
      ...e.sendOptions
    };
  }
  /**
   * Function to import a private key from the WIF
   * @param wif  - Private key in WIF format
   * @example
   * ```ts
   * const signer = Signer.fromWif("L59UtJcTdNBnrH2QSBA5beSUhRufRu3g6tScDTite6Msuj7U93tM")
   * console.log(signer.getAddress());
   * // 1MbL6mG8ASAvSYdoMnGUfG3ZXkmQ2dpL5b
   * ```
   * @returns Signer object
   */
  static fromWif(e, fe = !0) {
    const be = fe === void 0 ? e[0] !== "5" : fe, ye = (0, utils_1$1.bitcoinDecode)(e);
    return new Signer({
      privateKey: (0, utils_1$1.toHexString)(ye),
      compressed: be
    });
  }
  /**
   * Function to import a private key from the seed
   * @param seed - Seed words
   * @param compressed -
   * @example
   * ```ts
   * const signer = Signer.fromSeed("my seed");
   * console.log(signer.getAddress());
   * // 1BqtgWBcqm9cSZ97avLGZGJdgso7wx6pCA
   * ```
   * @returns Signer object
   */
  static fromSeed(e, fe = !0) {
    const be = (0, sha256_1.sha256)(e);
    return new Signer({ privateKey: be, compressed: fe });
  }
  /**
   * @param compressed - determines if the address should be
   * derived from the compressed public key (default) or the public key
   * @returns Signer address
   */
  getAddress(e = !0) {
    if (typeof this.privateKey == "string") {
      const be = secp.getPublicKey(this.privateKey, e);
      return (0, utils_1$1.bitcoinAddress)(be);
    }
    const fe = secp.getPublicKey(this.privateKey, e);
    return (0, utils_1$1.bitcoinAddress)(fe);
  }
  /**
   * Function to get the private key in hex format or wif format
   * @param format - The format must be "hex" (default) or "wif"
   * @param compressed - Optional arg when using WIF format. By default it
   * uses the compressed value defined in the signer
   * @example
   * ```ts
   * const signer = Signer.fromSeed("one two three four five six");
   * console.log(signer.getPrivateKey());
   * // bab7fd6e5bd624f4ea0c33f7e7219262a6fa93a945a8964d9f110148286b7b37
   *
   * console.log(signer.getPrivateKey("wif"));
   * // L3UfgFJWmbVziGB1uZBjkG1UjKkF7hhpXWY7mbTUdmycmvXCVtiL
   *
   * console.log(signer.getPrivateKey("wif", false));
   * // 5KEX4TMHG66fT7cM9HMZLmdp4hVq4LC4X2Fkg6zeypM5UteWmtd
   * ```
   */
  getPrivateKey(e = "hex", fe = !1) {
    let be;
    this.privateKey instanceof Uint8Array ? be = (0, utils_1$1.toHexString)(this.privateKey) : typeof this.privateKey == "string" ? be = this.privateKey : be = BigInt(this.privateKey).toString(16).padStart(64, "0");
    const ye = fe === void 0 ? this.compressed : fe;
    switch (e) {
      case "hex":
        return be;
      case "wif":
        return (0, utils_1$1.bitcoinEncode)((0, utils_1$1.toUint8Array)(be), "private", ye);
      default:
        throw new Error(`Invalid format ${e}`);
    }
  }
  /**
   * Function to sign a hash value. It returns the bytes signature.
   * The signature is in compact format with the recovery byte
   * @param hash - Hash value. Also known as digest
   */
  async signHash(e) {
    const [fe, be] = await secp.sign(e, this.privateKey, {
      recovered: !0,
      canonical: !0,
      der: !1
      // compact signature
    }), ye = new Uint8Array(65);
    return ye.set([be + 31], 0), ye.set(fe, 1), ye;
  }
  /**
   * Function to sign a message, which could be a string or a Uint8Array
   */
  async signMessage(e) {
    return this.signHash((0, sha256_1.sha256)(e));
  }
  /**
   * Function to sign a transaction. It's important to remark that
   * the transaction parameter is modified inside this function.
   * @param tx - Unsigned transaction
   */
  async signTransaction(e, fe) {
    if (!e.id)
      throw new Error("Missing transaction id");
    const be = (0, utils_1$1.toUint8Array)(e.id.slice(6)), ye = await this.signHash(be);
    return e.signatures || (e.signatures = []), e.signatures.push((0, utils_1$1.encodeBase64url)(ye)), e;
  }
  /**
   * Function to sign a block for federated consensus. That is,
   * just the ecdsa signature. For other algorithms, like PoW,
   * you have to sign the block and then process the signature
   * to add the extra data (nonce in the case of PoW).
   * @param block - Unsigned block
   */
  async signBlock(e) {
    if (!e.id)
      throw new Error("Missing block id");
    const fe = (0, utils_1$1.toUint8Array)(e.id.slice(6)), be = await this.signHash(fe);
    return e.signature = (0, utils_1$1.encodeBase64url)(be), e;
  }
  /**
   * Function to sign and send a transaction. It internally uses
   * [[Provider.sendTransaction]]
   * @param transaction - Transaction to send. It will be signed inside this
   * function if it is not signed yet
   * @param options - Options for sending the transaction
   */
  async sendTransaction(e, fe) {
    var be;
    if ((!e.signatures || !(!((be = e.signatures) === null || be === void 0) && be.length)) && (e = await this.signTransaction(e, fe != null && fe.sendAbis ? fe.abis : void 0)), !this.provider)
      throw new Error("provider is undefined");
    const ye = {
      ...this.sendOptions,
      ...fe
    };
    return ye.beforeSend && await ye.beforeSend(e, fe), this.provider.sendTransaction(e, ye.broadcast);
  }
  /**
   * Function to recover the public key from hash and signature
   * @param hash - hash sha256
   * @param signature - compact signature
   * @param compressed - default true
   */
  static recoverPublicKey(e, fe, be = !0) {
    const ye = (0, utils_1$1.toHexString)(fe), ve = +`0x${ye.slice(0, 2)}` - 31, Ee = ye.slice(2, 66), Se = ye.slice(66), Oe = BigInt(`0x${Ee}`), xe = BigInt(`0x${Se}`), me = new secp.Signature(Oe, xe), we = secp.recoverPublicKey((0, utils_1$1.toHexString)(e), me.toHex(), ve);
    if (!we)
      throw new Error("Public key cannot be recovered");
    return be ? secp.Point.fromHex(we).toHex(!0) : (0, utils_1$1.toHexString)(we);
  }
  static recoverAddress(e, fe, be = !0) {
    return (0, utils_1$1.bitcoinAddress)((0, utils_1$1.toUint8Array)(Signer.recoverPublicKey(e, fe, be)));
  }
  /**
   * Function to recover the publics keys from a signed
   * transaction or block.
   * The output format can be compressed (default) or uncompressed.
   *
   * @example
   * ```ts
   * const publicKeys = await Signer.recoverPublicKeys(tx);
   * ```
   *
   * If the signature data contains more data, like in the
   * blocks for PoW consensus, use the "transformSignature"
   * function to extract the signature.
   *
   * @example
   * ```ts
   *  const powDescriptorJson = {
   *    nested: {
   *      mypackage: {
   *        nested: {
   *          pow_signature_data: {
   *            fields: {
   *              nonce: {
   *                type: "bytes",
   *                id: 1,
   *              },
   *              recoverable_signature: {
   *                type: "bytes",
   *                id: 2,
   *              },
   *            },
   *          },
   *        },
   *      },
   *    },
   *  };
   *
   *  const serializer = new Serializer(powDescriptorJson, {
   *   defaultTypeName: "pow_signature_data",
   *  });
   *
   *  const publicKeys = await signer.recoverPublicKeys(block, {
   *    transformSignature: async (signatureData) => {
   *      const powSignatureData = await serializer.deserialize(signatureData);
   *      return powSignatureData.recoverable_signature;
   *    },
   *  });
   * ```
   */
  async recoverPublicKeys(e, fe) {
    let be = !0;
    fe && fe.compressed !== void 0 && (be = fe.compressed);
    let ye = [], ve;
    const Ee = e;
    if (Ee.signature) {
      if (!Ee.header)
        throw new Error("Missing block header");
      if (!Ee.signature)
        throw new Error("Missing block signature");
      ye = [Ee.signature];
      const Oe = (0, utils_1$1.btypeDecode)(Ee.header, btypeBlockHeader, !1), xe = protocol_proto_js_1$1.koinos.protocol.block_header.create(Oe);
      ve = protocol_proto_js_1$1.koinos.protocol.block_header.encode(xe).finish();
    } else {
      const Oe = e;
      if (!Oe.header)
        throw new Error("Missing transaction header");
      if (!Oe.signatures)
        throw new Error("Missing transaction signatures");
      ye = Oe.signatures;
      const xe = (0, utils_1$1.btypeDecode)(Oe.header, btypeTransactionHeader, !1), me = protocol_proto_js_1$1.koinos.protocol.transaction_header.create(xe);
      ve = protocol_proto_js_1$1.koinos.protocol.transaction_header.encode(me).finish();
    }
    const Se = (0, sha256_1.sha256)(ve);
    return Promise.all(ye.map(async (Oe) => (fe && typeof fe.transformSignature == "function" && (Oe = await fe.transformSignature(Oe)), Signer.recoverPublicKey(Se, (0, utils_1$1.decodeBase64url)(Oe), be))));
  }
  /**
   * Function to recover the signer addresses from a signed
   * transaction or block.
   * The output format can be compressed (default) or uncompressed.
   * @example
   * ```ts
   * const addresses = await signer.recoverAddress(tx);
   * ```
   *
   * If the signature data contains more data, like in the
   * blocks for PoW consensus, use the "transformSignature"
   * function to extract the signature.
   *
   * @example
   * ```ts
   *  const powDescriptorJson = {
   *    nested: {
   *      mypackage: {
   *        nested: {
   *          pow_signature_data: {
   *            fields: {
   *              nonce: {
   *                type: "bytes",
   *                id: 1,
   *              },
   *              recoverable_signature: {
   *                type: "bytes",
   *                id: 2,
   *              },
   *            },
   *          },
   *        },
   *      },
   *    },
   *  };
   *
   *  const serializer = new Serializer(powDescriptorJson, {
   *   defaultTypeName: "pow_signature_data",
   *  });
   *
   *  const addresses = await signer.recoverAddress(block, {
   *    transformSignature: async (signatureData) => {
   *      const powSignatureData = await serializer.deserialize(signatureData);
   *      return powSignatureData.recoverable_signature;
   *    },
   *  });
   * ```
   */
  async recoverAddresses(e, fe) {
    return (await this.recoverPublicKeys(e, fe)).map((ye) => (0, utils_1$1.bitcoinAddress)((0, utils_1$1.toUint8Array)(ye)));
  }
  /**
   * Function to prepare a transaction
   * @param tx - Do not set the nonce to get it from the blockchain
   * using the provider. The rc_limit is 1e8 by default.
   * @returns A prepared transaction. ()
   */
  async prepareTransaction(e) {
    var fe, be;
    e.header || (e.header = {});
    const ye = (fe = e.header.payer) !== null && fe !== void 0 ? fe : this.address, { payee: ve } = e.header;
    let Ee;
    if (e.header.nonce === void 0) {
      if (!this.provider)
        throw new Error("Cannot get the nonce because provider is undefined. To skip this call set a nonce in the transaction header");
      Ee = await this.provider.getNextNonce(ve || ye);
    } else
      Ee = e.header.nonce;
    let Se;
    if (e.header.rc_limit === void 0) {
      if (!this.provider)
        throw new Error("Cannot get the rc_limit because provider is undefined. To skip this call set a rc_limit in the transaction header");
      Se = await this.provider.getAccountRc(ye);
    } else
      Se = e.header.rc_limit;
    let Oe = e.header.chain_id || this.chainId;
    if (!Oe) {
      if (!this.provider)
        throw new Error("Cannot get the chain_id because provider is undefined. To skip this call set a chain_id in the Signer");
      Oe = await this.provider.getChainId(), this.chainId = Oe;
    }
    const xe = [];
    if (e.operations)
      for (let Br = 0; Br < ((be = e.operations) === null || be === void 0 ? void 0 : be.length); Br += 1) {
        const Xr = (0, utils_1$1.btypeDecode)(e.operations[Br], btypesOperation, !1), eo = protocol_proto_js_1$1.koinos.protocol.operation.create(Xr), jr = protocol_proto_js_1$1.koinos.protocol.operation.encode(eo).finish();
        xe.push((0, sha256_1.sha256)(jr));
      }
    const me = (0, utils_1$1.encodeBase64url)(new Uint8Array([
      // multihash sha256: 18, 32
      18,
      32,
      ...(0, utils_1$1.calculateMerkleRoot)(xe)
    ]));
    e.header = {
      chain_id: Oe,
      rc_limit: Se,
      nonce: Ee,
      operation_merkle_root: me,
      payer: ye,
      ...ve && { payee: ve }
      // TODO: Option to resolve names (payer, payee)
    };
    const we = (0, utils_1$1.btypeDecode)(e.header, btypeTransactionHeader, !1), ur = protocol_proto_js_1$1.koinos.protocol.transaction_header.create(we), lr = protocol_proto_js_1$1.koinos.protocol.transaction_header.encode(ur).finish(), Ar = (0, sha256_1.sha256)(lr);
    return e.id = `0x1220${(0, utils_1$1.toHexString)(Ar)}`, e;
  }
  /**
   * Function to prepare a block
   * @param block -
   * @returns A prepared block. ()
   */
  async prepareBlock(e) {
    var fe;
    e.header || (e.header = {});
    const be = [];
    if (e.transactions)
      for (let we = 0; we < e.transactions.length; we++) {
        const ur = e.transactions[we], lr = (0, utils_1$1.btypeDecode)(ur.header, btypeTransactionHeader, !1), Ar = protocol_proto_js_1$1.koinos.protocol.transaction_header.create(lr), Br = protocol_proto_js_1$1.koinos.protocol.transaction_header.encode(Ar).finish();
        be.push((0, sha256_1.sha256)(Br));
        let Xr = new Uint8Array();
        (fe = ur.signatures) === null || fe === void 0 || fe.forEach((eo) => {
          Xr = new Uint8Array([
            ...Xr,
            ...(0, utils_1$1.decodeBase64url)(eo)
          ]);
        }), be.push((0, sha256_1.sha256)(Xr));
      }
    let { height: ye, previous: ve, previous_state_merkle_root: Ee } = e.header;
    if (!ye || !ve || !Ee) {
      if (!this.provider)
        throw new Error("Cannot get the head info because provider is undefined.");
      const we = await this.provider.getHeadInfo();
      ye = ye || `${Number(we.head_topology.height) + 1}`, ve = ve || we.head_topology.id, Ee = Ee || we.head_state_merkle_root;
    }
    e.header = {
      height: ye,
      previous: ve,
      previous_state_merkle_root: Ee,
      timestamp: e.header.timestamp || `${Date.now()}`,
      transaction_merkle_root: (0, utils_1$1.encodeBase64url)(new Uint8Array([
        // multihash sha256: 18, 32
        18,
        32,
        ...(0, utils_1$1.calculateMerkleRoot)(be)
      ])),
      signer: this.address
    };
    const Se = (0, utils_1$1.btypeDecode)(e.header, btypeBlockHeader, !1), Oe = protocol_proto_js_1$1.koinos.protocol.block_header.create(Se), xe = protocol_proto_js_1$1.koinos.protocol.block_header.encode(Oe).finish(), me = (0, sha256_1.sha256)(xe);
    return e.id = `0x1220${(0, utils_1$1.toHexString)(me)}`, e;
  }
}
Signer$1.Signer = Signer;
Signer$1.default = Signer;
var Provider$1 = {}, browserPonyfill = { exports: {} };
(function(v, e) {
  var fe = typeof self < "u" ? self : commonjsGlobal, be = function() {
    function ve() {
      this.fetch = !1, this.DOMException = fe.DOMException;
    }
    return ve.prototype = fe, new ve();
  }();
  (function(ve) {
    (function(Ee) {
      var Se = {
        searchParams: "URLSearchParams" in ve,
        iterable: "Symbol" in ve && "iterator" in Symbol,
        blob: "FileReader" in ve && "Blob" in ve && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in ve,
        arrayBuffer: "ArrayBuffer" in ve
      };
      function Oe(Nr) {
        return Nr && DataView.prototype.isPrototypeOf(Nr);
      }
      if (Se.arrayBuffer)
        var xe = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], me = ArrayBuffer.isView || function(Nr) {
          return Nr && xe.indexOf(Object.prototype.toString.call(Nr)) > -1;
        };
      function we(Nr) {
        if (typeof Nr != "string" && (Nr = String(Nr)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(Nr))
          throw new TypeError("Invalid character in header field name");
        return Nr.toLowerCase();
      }
      function ur(Nr) {
        return typeof Nr != "string" && (Nr = String(Nr)), Nr;
      }
      function lr(Nr) {
        var Lr = {
          next: function() {
            var so = Nr.shift();
            return { done: so === void 0, value: so };
          }
        };
        return Se.iterable && (Lr[Symbol.iterator] = function() {
          return Lr;
        }), Lr;
      }
      function Ar(Nr) {
        this.map = {}, Nr instanceof Ar ? Nr.forEach(function(Lr, so) {
          this.append(so, Lr);
        }, this) : Array.isArray(Nr) ? Nr.forEach(function(Lr) {
          this.append(Lr[0], Lr[1]);
        }, this) : Nr && Object.getOwnPropertyNames(Nr).forEach(function(Lr) {
          this.append(Lr, Nr[Lr]);
        }, this);
      }
      Ar.prototype.append = function(Nr, Lr) {
        Nr = we(Nr), Lr = ur(Lr);
        var so = this.map[Nr];
        this.map[Nr] = so ? so + ", " + Lr : Lr;
      }, Ar.prototype.delete = function(Nr) {
        delete this.map[we(Nr)];
      }, Ar.prototype.get = function(Nr) {
        return Nr = we(Nr), this.has(Nr) ? this.map[Nr] : null;
      }, Ar.prototype.has = function(Nr) {
        return this.map.hasOwnProperty(we(Nr));
      }, Ar.prototype.set = function(Nr, Lr) {
        this.map[we(Nr)] = ur(Lr);
      }, Ar.prototype.forEach = function(Nr, Lr) {
        for (var so in this.map)
          this.map.hasOwnProperty(so) && Nr.call(Lr, this.map[so], so, this);
      }, Ar.prototype.keys = function() {
        var Nr = [];
        return this.forEach(function(Lr, so) {
          Nr.push(so);
        }), lr(Nr);
      }, Ar.prototype.values = function() {
        var Nr = [];
        return this.forEach(function(Lr) {
          Nr.push(Lr);
        }), lr(Nr);
      }, Ar.prototype.entries = function() {
        var Nr = [];
        return this.forEach(function(Lr, so) {
          Nr.push([so, Lr]);
        }), lr(Nr);
      }, Se.iterable && (Ar.prototype[Symbol.iterator] = Ar.prototype.entries);
      function Br(Nr) {
        if (Nr.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        Nr.bodyUsed = !0;
      }
      function Xr(Nr) {
        return new Promise(function(Lr, so) {
          Nr.onload = function() {
            Lr(Nr.result);
          }, Nr.onerror = function() {
            so(Nr.error);
          };
        });
      }
      function eo(Nr) {
        var Lr = new FileReader(), so = Xr(Lr);
        return Lr.readAsArrayBuffer(Nr), so;
      }
      function jr(Nr) {
        var Lr = new FileReader(), so = Xr(Lr);
        return Lr.readAsText(Nr), so;
      }
      function kr(Nr) {
        for (var Lr = new Uint8Array(Nr), so = new Array(Lr.length), fo = 0; fo < Lr.length; fo++)
          so[fo] = String.fromCharCode(Lr[fo]);
        return so.join("");
      }
      function $r(Nr) {
        if (Nr.slice)
          return Nr.slice(0);
        var Lr = new Uint8Array(Nr.byteLength);
        return Lr.set(new Uint8Array(Nr)), Lr.buffer;
      }
      function Vr() {
        return this.bodyUsed = !1, this._initBody = function(Nr) {
          this._bodyInit = Nr, Nr ? typeof Nr == "string" ? this._bodyText = Nr : Se.blob && Blob.prototype.isPrototypeOf(Nr) ? this._bodyBlob = Nr : Se.formData && FormData.prototype.isPrototypeOf(Nr) ? this._bodyFormData = Nr : Se.searchParams && URLSearchParams.prototype.isPrototypeOf(Nr) ? this._bodyText = Nr.toString() : Se.arrayBuffer && Se.blob && Oe(Nr) ? (this._bodyArrayBuffer = $r(Nr.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Se.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(Nr) || me(Nr)) ? this._bodyArrayBuffer = $r(Nr) : this._bodyText = Nr = Object.prototype.toString.call(Nr) : this._bodyText = "", this.headers.get("content-type") || (typeof Nr == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Se.searchParams && URLSearchParams.prototype.isPrototypeOf(Nr) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, Se.blob && (this.blob = function() {
          var Nr = Br(this);
          if (Nr)
            return Nr;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? Br(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(eo);
        }), this.text = function() {
          var Nr = Br(this);
          if (Nr)
            return Nr;
          if (this._bodyBlob)
            return jr(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(kr(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, Se.formData && (this.formData = function() {
          return this.text().then(Zr);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var Mr = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function gr(Nr) {
        var Lr = Nr.toUpperCase();
        return Mr.indexOf(Lr) > -1 ? Lr : Nr;
      }
      function Fr(Nr, Lr) {
        Lr = Lr || {};
        var so = Lr.body;
        if (Nr instanceof Fr) {
          if (Nr.bodyUsed)
            throw new TypeError("Already read");
          this.url = Nr.url, this.credentials = Nr.credentials, Lr.headers || (this.headers = new Ar(Nr.headers)), this.method = Nr.method, this.mode = Nr.mode, this.signal = Nr.signal, !so && Nr._bodyInit != null && (so = Nr._bodyInit, Nr.bodyUsed = !0);
        } else
          this.url = String(Nr);
        if (this.credentials = Lr.credentials || this.credentials || "same-origin", (Lr.headers || !this.headers) && (this.headers = new Ar(Lr.headers)), this.method = gr(Lr.method || this.method || "GET"), this.mode = Lr.mode || this.mode || null, this.signal = Lr.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && so)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(so);
      }
      Fr.prototype.clone = function() {
        return new Fr(this, { body: this._bodyInit });
      };
      function Zr(Nr) {
        var Lr = new FormData();
        return Nr.trim().split("&").forEach(function(so) {
          if (so) {
            var fo = so.split("="), co = fo.shift().replace(/\+/g, " "), no = fo.join("=").replace(/\+/g, " ");
            Lr.append(decodeURIComponent(co), decodeURIComponent(no));
          }
        }), Lr;
      }
      function Wr(Nr) {
        var Lr = new Ar(), so = Nr.replace(/\r?\n[\t ]+/g, " ");
        return so.split(/\r?\n/).forEach(function(fo) {
          var co = fo.split(":"), no = co.shift().trim();
          if (no) {
            var uo = co.join(":").trim();
            Lr.append(no, uo);
          }
        }), Lr;
      }
      Vr.call(Fr.prototype);
      function qr(Nr, Lr) {
        Lr || (Lr = {}), this.type = "default", this.status = Lr.status === void 0 ? 200 : Lr.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Lr ? Lr.statusText : "OK", this.headers = new Ar(Lr.headers), this.url = Lr.url || "", this._initBody(Nr);
      }
      Vr.call(qr.prototype), qr.prototype.clone = function() {
        return new qr(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Ar(this.headers),
          url: this.url
        });
      }, qr.error = function() {
        var Nr = new qr(null, { status: 0, statusText: "" });
        return Nr.type = "error", Nr;
      };
      var Qr = [301, 302, 303, 307, 308];
      qr.redirect = function(Nr, Lr) {
        if (Qr.indexOf(Lr) === -1)
          throw new RangeError("Invalid status code");
        return new qr(null, { status: Lr, headers: { location: Nr } });
      }, Ee.DOMException = ve.DOMException;
      try {
        new Ee.DOMException();
      } catch {
        Ee.DOMException = function(Lr, so) {
          this.message = Lr, this.name = so;
          var fo = Error(Lr);
          this.stack = fo.stack;
        }, Ee.DOMException.prototype = Object.create(Error.prototype), Ee.DOMException.prototype.constructor = Ee.DOMException;
      }
      function lo(Nr, Lr) {
        return new Promise(function(so, fo) {
          var co = new Fr(Nr, Lr);
          if (co.signal && co.signal.aborted)
            return fo(new Ee.DOMException("Aborted", "AbortError"));
          var no = new XMLHttpRequest();
          function uo() {
            no.abort();
          }
          no.onload = function() {
            var bo = {
              status: no.status,
              statusText: no.statusText,
              headers: Wr(no.getAllResponseHeaders() || "")
            };
            bo.url = "responseURL" in no ? no.responseURL : bo.headers.get("X-Request-URL");
            var So = "response" in no ? no.response : no.responseText;
            so(new qr(So, bo));
          }, no.onerror = function() {
            fo(new TypeError("Network request failed"));
          }, no.ontimeout = function() {
            fo(new TypeError("Network request failed"));
          }, no.onabort = function() {
            fo(new Ee.DOMException("Aborted", "AbortError"));
          }, no.open(co.method, co.url, !0), co.credentials === "include" ? no.withCredentials = !0 : co.credentials === "omit" && (no.withCredentials = !1), "responseType" in no && Se.blob && (no.responseType = "blob"), co.headers.forEach(function(bo, So) {
            no.setRequestHeader(So, bo);
          }), co.signal && (co.signal.addEventListener("abort", uo), no.onreadystatechange = function() {
            no.readyState === 4 && co.signal.removeEventListener("abort", uo);
          }), no.send(typeof co._bodyInit > "u" ? null : co._bodyInit);
        });
      }
      return lo.polyfill = !0, ve.fetch || (ve.fetch = lo, ve.Headers = Ar, ve.Request = Fr, ve.Response = qr), Ee.Headers = Ar, Ee.Request = Fr, Ee.Response = qr, Ee.fetch = lo, Object.defineProperty(Ee, "__esModule", { value: !0 }), Ee;
    })({});
  })(be), be.fetch.ponyfill = !0, delete be.fetch.polyfill;
  var ye = be;
  e = ye.fetch, e.default = ye.fetch, e.fetch = ye.fetch, e.Headers = ye.Headers, e.Request = ye.Request, e.Response = ye.Response, v.exports = e;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(v) {
  return v && v.__esModule ? v : { default: v };
};
Object.defineProperty(Provider$1, "__esModule", { value: !0 });
Provider$1.Provider = void 0;
const cross_fetch_1 = __importDefault(browserPonyfillExports), protocol_proto_js_1 = protocolProtoExports, utils_1 = utils$1;
async function sleep(v) {
  return new Promise((e) => setTimeout(e, v));
}
class Provider {
  /**
   *
   * @param rpcNodes - URL of the rpc node, or array of urls
   * to switch between them when someone is down
   * @example
   * ```ts
   * const provider = new Provider([
   *   "http://45.56.104.152:8080",
   *   "http://159.203.119.0:8080"
   * ]);
   * ```
   */
  constructor(e) {
    Array.isArray(e) ? this.rpcNodes = e : this.rpcNodes = [e], this.currentNodeId = 0, this.onError = () => !0;
  }
  /**
   * Function to make jsonrpc requests to the RPC node
   * @param method - jsonrpc method
   * @param params - jsonrpc params
   * @returns Result of jsonrpc response
   */
  async call(e, fe) {
    for (; ; )
      try {
        const be = {
          id: Math.round(Math.random() * 1e3),
          jsonrpc: "2.0",
          method: e,
          params: fe
        }, ye = this.rpcNodes[this.currentNodeId], Ee = await (await (0, cross_fetch_1.default)(ye, {
          method: "POST",
          body: JSON.stringify(be)
        })).json();
        if (Ee.result !== void 0)
          return Ee.result;
        if (!Ee.error)
          throw new Error("undefined error");
        const { message: Se, data: Oe } = Ee.error;
        if (!Oe)
          throw new Error(Se);
        let xe;
        try {
          xe = JSON.parse(Oe);
        } catch {
          xe = { data: Oe };
        }
        throw new Error(JSON.stringify({
          ...Se && { error: Se },
          ...xe
        }));
      } catch (be) {
        const ye = this.rpcNodes[this.currentNodeId];
        this.currentNodeId = (this.currentNodeId + 1) % this.rpcNodes.length;
        const ve = this.rpcNodes[this.currentNodeId];
        if (this.onError(be, ye, ve))
          throw be;
      }
  }
  /**
   * Function to call "chain.get_account_nonce" to return the number of
   * transactions for a particular account. If you are creating a new
   * transaction consider using [[Provider.getNextNonce]].
   * @param account - account address
   * @param deserialize - If set true it will deserialize the nonce
   * and return it as number (default). If set false it will return
   * the nonce encoded as received from the RPC.
   * @returns Nonce
   */
  async getNonce(e, fe = !0) {
    const { nonce: be } = await this.call("chain.get_account_nonce", { account: e });
    if (!fe)
      return be;
    const ye = (0, utils_1.decodeBase64url)(be), ve = protocol_proto_js_1.koinos.chain.value_type.decode(ye), Ee = protocol_proto_js_1.koinos.chain.value_type.toObject(ve, {
      longs: String,
      defaults: !0
    });
    return Number(Ee.uint64_value);
  }
  /**
   * Function to call "chain.get_account_nonce" (number of
   * transactions for a particular account) and return the next nonce.
   * This call is used when creating new transactions. The result is
   * encoded in base64url
   * @param account - account address
   * @returns Nonce
   */
  async getNextNonce(e) {
    const fe = await this.getNonce(e), be = protocol_proto_js_1.koinos.chain.value_type.create({
      // todo: consider using bigint for big nonces
      uint64_value: String(fe + 1)
    }), ye = protocol_proto_js_1.koinos.chain.value_type.encode(be).finish();
    return (0, utils_1.encodeBase64url)(ye);
  }
  async getAccountRc(e) {
    const { rc: fe } = await this.call("chain.get_account_rc", {
      account: e
    });
    return fe || "0";
  }
  /**
   * Get transactions by id and their corresponding block ids
   */
  async getTransactionsById(e) {
    return this.call("transaction_store.get_transactions_by_id", {
      transaction_ids: e
    });
  }
  async getBlocksById(e) {
    return this.call("block_store.get_blocks_by_id", {
      block_ids: e,
      return_block: !0,
      return_receipt: !1
    });
  }
  /**
   * Function to get info from the head block in the blockchain
   */
  async getHeadInfo() {
    return this.call("chain.get_head_info", {});
  }
  /**
   * Function to get the chain
   */
  async getChainId() {
    const { chain_id: e } = await this.call("chain.get_chain_id", {});
    return e;
  }
  /**
   * Function to get consecutive blocks in descending order
   * @param height - Starting block height
   * @param numBlocks - Number of blocks to fetch
   * @param idRef - Block ID reference to speed up searching blocks.
   * This ID must be from a greater block height. By default it
   * gets the ID from the block head.
   */
  async getBlocks(e, fe = 1, be) {
    let ye = be;
    return ye || (ye = (await this.getHeadInfo()).head_topology.id), (await this.call("block_store.get_blocks_by_height", {
      head_block_id: ye,
      ancestor_start_height: e,
      num_blocks: fe,
      return_block: !0,
      return_receipt: !1
    })).block_items;
  }
  /**
   * Function to get a block by its height
   */
  async getBlock(e) {
    return (await this.getBlocks(e, 1))[0];
  }
  /**
   * Function to wait for a transaction to be mined.
   * @param txId - transaction id
   * @param type - Type must be "byBlock" (default) or "byTransactionId".
   * _byBlock_ will query the blockchain to get blocks and search for the
   * transaction there. _byTransactionId_ will query the "transaction store"
   * microservice to search the transaction by its id. If non of them is
   * specified the function will use "byBlock" (as "byTransactionId"
   * requires the transaction store, which is an optional microservice).
   *
   * When _byBlock_ is used it returns the block number.
   *
   * When _byTransactionId_ is used it returns the block id.
   *
   * @param timeout - Timeout in milliseconds. By default it is 15000
   * @example
   * ```ts
   * const blockNumber = await provider.wait(txId);
   * // const blockNumber = await provider.wait(txId, "byBlock", 15000);
   * // const blockId = await provider.wait(txId, "byTransactionId", 15000);
   * console.log("Transaction mined")
   * ```
   */
  async wait(e, fe = "byBlock", be = 15e3) {
    const ye = Date.now();
    if (fe === "byTransactionId") {
      for (; Date.now() < ye + be; ) {
        await sleep(1e3);
        const { transactions: xe } = await this.getTransactionsById([e]);
        if (xe && xe[0] && xe[0].containing_blocks)
          return {
            blockId: xe[0].containing_blocks[0]
          };
      }
      throw new Error(`Transaction not mined after ${be} ms`);
    }
    const ve = async (xe, me, we) => {
      const ur = await this.getBlocks(xe, me, we);
      let lr = 0, Ar = "";
      ur.forEach((Xr) => {
        if (!Xr || !Xr.block || !Xr.block_id || !Xr.block.transactions)
          return;
        Xr.block.transactions.find((jr) => jr.id === e) && (lr = Number(Xr.block_height), Ar = Xr.block_id);
      });
      const Br = ur[ur.length - 1].block_id;
      return [lr, Ar, Br];
    };
    let Ee = 0, Se = 0, Oe = "";
    for (; Date.now() < ye + be; ) {
      await sleep(1e3);
      const { head_topology: xe } = await this.getHeadInfo();
      if (Ee === 0 && (Ee = Number(xe.height), Se = Ee), Number(xe.height) === Ee - 1 && Oe && Oe !== xe.id) {
        const [lr, Ar, Br] = await ve(Se, Number(xe.height) - Se + 1, xe.id);
        if (lr)
          return {
            blockId: Ar,
            blockNumber: lr
          };
        Oe = Br, Ee = Number(xe.height) + 1;
      }
      if (Ee > Number(xe.height))
        continue;
      const [me, we, ur] = await ve(Ee, 1, xe.id);
      if (me)
        return {
          blockId: we,
          blockNumber: me
        };
      Oe || (Oe = ur), Ee += 1;
    }
    throw new Error(`Transaction not mined after ${be} ms. Blocks checked from ${Se} to ${Ee}`);
  }
  /**
   * Function to call "chain.submit_transaction" to send a signed
   * transaction to the blockchain.
   *
   * It also has the option to not broadcast the transaction (to not
   * include the transaction the mempool), which is useful if you
   * want to test the interaction with a contract and check the
   * possible events triggered.
   * @param transaction - Transaction
   * @param broadcast - Option to broadcast the transaction to the
   * whole network. By default it is true.
   * @returns It returns the receipt received from the RPC node
   * and the transaction with the arrow function "wait" (see [[wait]])
   */
  async sendTransaction(e, fe = !0) {
    const be = await this.call("chain.submit_transaction", { transaction: e, broadcast: fe });
    return e.wait = async (ye = "byBlock", ve = 15e3) => this.wait(e.id, ye, ve), { ...be, transaction: e };
  }
  /**
   * Function to call "chain.submit_block" to send a signed
   * block to the blockchain.
   */
  async submitBlock(e) {
    return this.call("chain.submit_block", { block: e });
  }
  /**
   * Function to call "chain.read_contract" to read a contract.
   * This function is used by [[Contract]] class when read methods
   * are invoked.
   */
  async readContract(e) {
    return this.call("chain.read_contract", e);
  }
}
Provider$1.Provider = Provider;
Provider$1.default = Provider;
var Transaction$1 = {};
Object.defineProperty(Transaction$1, "__esModule", { value: !0 });
Transaction$1.Transaction = void 0;
const Signer_1 = Signer$1;
class Transaction {
  constructor(e) {
    var fe, be, ye, ve, Ee;
    this.signer = e == null ? void 0 : e.signer, this.provider = e == null ? void 0 : e.provider, this.options = {
      broadcast: !0,
      sendAbis: !0,
      ...e == null ? void 0 : e.options
    }, this.transaction = {
      header: {
        ...((fe = e == null ? void 0 : e.options) === null || fe === void 0 ? void 0 : fe.chainId) && { chain_id: e.options.chainId },
        ...((be = e == null ? void 0 : e.options) === null || be === void 0 ? void 0 : be.rcLimit) && { rc_limit: e.options.rcLimit },
        ...((ye = e == null ? void 0 : e.options) === null || ye === void 0 ? void 0 : ye.nonce) && { nonce: e.options.nonce },
        ...((ve = e == null ? void 0 : e.options) === null || ve === void 0 ? void 0 : ve.payer) && { payer: e.options.payer },
        ...((Ee = e == null ? void 0 : e.options) === null || Ee === void 0 ? void 0 : Ee.payee) && { payee: e.options.payee }
      },
      operations: []
    };
  }
  /**
   * Function to push an operation to the transaction. It can be created
   * in several ways. Example:
   *
   * @example
   * ```ts
   * const koin = new Contract({
   *   id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   abi: utils.tokenAbi,
   * }).functions;
   * const signer = Signer.fromSeed("my seed");
   * const provider = new Provider(["https://api.koinos.io"]);
   * signer.provider = provider;
   * const tx = new Transaction({ signer });
   *
   * // method 1
   * await tx.pushOperation(koin.transfer, {
   *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *   value: "1000",
   * });
   *
   * // method 2
   * await tx.pushOperation(
   *   koin.transfer({
   *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *     value: "1000",
   *   },{
   *    onlyOperation: true,
   *   })
   * );
   *
   * // method 3
   * await tx.pushOperation(
   *   await koin.transfer({
   *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *     value: "1000",
   *   },{
   *    onlyOperation: true,
   *   })
   * );
   *
   * // method 4
   * const { operation } = await koin.transfer({
   *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *   value: "1000",
   * },{
   *  onlyOperation: true,
   * });
   * await tx.pushOperation(operation)
   * ```
   *
   */
  async pushOperation(e, fe) {
    let be;
    if (typeof e == "function")
      be = (await e(fe, { onlyOperation: !0 })).operation;
    else {
      let ye;
      e instanceof Promise ? ye = await e : ye = e, ye.operation ? be = ye.operation : be = e;
    }
    this.transaction.operations || (this.transaction.operations = []), this.transaction.operations.push(be);
  }
  /**
   * Functon to prepare the transaction (set headers, merkle
   * root, etc)
   */
  async prepare(e) {
    if (e) {
      const fe = {
        ...(e == null ? void 0 : e.chainId) && { chain_id: e.chainId },
        ...(e == null ? void 0 : e.rcLimit) && { rc_limit: e.rcLimit },
        ...(e == null ? void 0 : e.nonce) && { nonce: e.nonce },
        ...(e == null ? void 0 : e.payer) && { payer: e.payer },
        ...(e == null ? void 0 : e.payee) && { payee: e.payee }
      };
      this.transaction.header = {
        ...this.transaction.header,
        ...fe
      };
    }
    if (this.signer)
      this.transaction = await this.signer.prepareTransaction(this.transaction);
    else {
      if (!this.transaction.header || !this.transaction.header.payer)
        throw new Error("no payer defined");
      const fe = Signer_1.Signer.fromSeed("0");
      fe.provider = this.provider, this.transaction = await fe.prepareTransaction(this.transaction);
    }
    return this.transaction;
  }
  /**
   * Function to sign the transaction
   */
  async sign(e) {
    if (!this.signer)
      throw new Error("no signer defined");
    return this.transaction.id || await this.prepare(), this.signer.signTransaction(this.transaction, this.options.sendAbis ? e : void 0);
  }
  /**
   * Function to broadcast the transaction
   */
  async send(e) {
    const fe = {
      ...this.options,
      ...e
    };
    if (this.transaction.id || await this.prepare(), this.signer && this.signer.provider) {
      const { transaction: ve, receipt: Ee } = await this.signer.sendTransaction(this.transaction, fe);
      return this.transaction = ve, this.waitFunction = ve.wait, Ee;
    }
    if (!this.provider)
      throw new Error("provider not defined");
    if (!this.transaction.signatures || !this.transaction.signatures.length)
      throw new Error("transaction without signatures and no signer defined");
    fe.beforeSend && await fe.beforeSend(this.transaction, fe);
    const { transaction: be, receipt: ye } = await this.provider.sendTransaction(this.transaction, fe.broadcast);
    return this.transaction = be, this.waitFunction = be.wait, ye;
  }
  async wait(e, fe) {
    if (!this.waitFunction)
      throw new Error("no wait function defined");
    return this.waitFunction(e, fe);
  }
}
Transaction$1.Transaction = Transaction;
(function(v) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ve, Ee, Se, Oe) {
    Oe === void 0 && (Oe = Se);
    var xe = Object.getOwnPropertyDescriptor(Ee, Se);
    (!xe || ("get" in xe ? !Ee.__esModule : xe.writable || xe.configurable)) && (xe = { enumerable: !0, get: function() {
      return Ee[Se];
    } }), Object.defineProperty(ve, Oe, xe);
  } : function(ve, Ee, Se, Oe) {
    Oe === void 0 && (Oe = Se), ve[Oe] = Ee[Se];
  }), fe = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(ve, Ee) {
    Object.defineProperty(ve, "default", { enumerable: !0, value: Ee });
  } : function(ve, Ee) {
    ve.default = Ee;
  }), be = commonjsGlobal && commonjsGlobal.__importStar || function(ve) {
    if (ve && ve.__esModule)
      return ve;
    var Ee = {};
    if (ve != null)
      for (var Se in ve)
        Se !== "default" && Object.prototype.hasOwnProperty.call(ve, Se) && e(Ee, ve, Se);
    return fe(Ee, ve), Ee;
  }, ye = commonjsGlobal && commonjsGlobal.__exportStar || function(ve, Ee) {
    for (var Se in ve)
      Se !== "default" && !Object.prototype.hasOwnProperty.call(Ee, Se) && e(Ee, ve, Se);
  };
  Object.defineProperty(v, "__esModule", { value: !0 }), v.interfaces = v.utils = void 0;
  /*! koilib - MIT License (c) Julian Gonzalez (joticajulian@gmail.com) */
  v.utils = be(indexUtils), v.interfaces = be(_interface), ye(Contract$1, v), ye(Signer$1, v), ye(Provider$1, v), ye(Transaction$1, v), ye(Serializer$1, v);
})(lib$2);
function generateProvider(v, e, fe) {
  return {
    async call(be, ye) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.JsonRpcCall,
          params: {
            method: be,
            params: ye
          }
        }
      });
    },
    async getNonce(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetNonce,
          params: {
            address: be
          }
        }
      });
    },
    async getNextNonce(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetNextNonce,
          params: {
            address: be
          }
        }
      });
    },
    async getAccountRc(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetAccountRc,
          params: {
            address: be
          }
        }
      });
    },
    async getTransactionsById(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetTransactionsById,
          params: {
            transactionIds: be
          }
        }
      });
    },
    async getBlocksById(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetBlocksById,
          params: {
            blockIds: be
          }
        }
      });
    },
    async getHeadInfo() {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetHeadInfo,
          params: {}
        }
      });
    },
    async getChainId() {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetChainId,
          params: {}
        }
      });
    },
    async getBlocks(be, ye = 1, ve) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetBlocks,
          params: {
            height: be,
            numBlocks: ye,
            idRef: ve
          }
        }
      });
    },
    async getBlock(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.GetBlock,
          params: {
            height: be
          }
        }
      });
    },
    async wait(be, ye = "byBlock", ve = 3e4) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.WaitForTransaction,
          params: {
            transactionId: be,
            type: ye,
            timeout: ve
          }
        }
      });
    },
    async sendTransaction(be, ye = !0) {
      const ve = await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.SendTransaction,
          params: {
            transaction: be,
            broadcast: ye
          }
        }
      });
      return ve.wait = async (Ee = "byBlock", Se = 6e4) => await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.WaitForTransaction,
          params: {
            transactionId: ve.id,
            type: Ee,
            timeout: Se
          }
        }
      }), ve;
    },
    async readContract(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.ReadContract,
          params: {
            operation: be
          }
        }
      });
    },
    async submitBlock(be) {
      return await fe.request({
        chainId: v,
        topic: e,
        request: {
          method: Methods.SubmitBlock,
          params: {
            block: be
          }
        }
      });
    }
  };
}
function generateSigner(v, e, fe, be, ye) {
  return {
    provider: ye || generateProvider(e, fe, be),
    getAddress: () => v,
    getPrivateKey: () => {
      throw new Error("not implemented");
    },
    signHash: async (Ee) => {
      const Se = await be.request({
        chainId: e,
        topic: fe,
        request: {
          method: Methods.SignHash,
          params: {
            address: v,
            hash: lib$2.utils.encodeBase64(Ee)
          }
        }
      });
      return lib$2.utils.decodeBase64(Se);
    },
    signMessage: async (Ee) => {
      const Se = await be.request({
        chainId: e,
        topic: fe,
        request: {
          method: Methods.SignMessage,
          params: {
            address: v,
            message: Ee
          }
        }
      });
      return lib$2.utils.decodeBase64(Se);
    },
    prepareTransaction: async (Ee) => {
      var Se;
      if (ye) {
        const Oe = lib$2.Signer.fromSeed("dummy_signer");
        return Oe.provider = ye, (Se = Ee.header) != null && Se.payer || (Ee.header = {
          ...Ee.header,
          payer: v
        }), Oe.prepareTransaction(Ee);
      } else
        return await be.request({
          chainId: e,
          topic: fe,
          request: {
            method: Methods.PrepareTransaction,
            params: {
              address: v,
              transaction: Ee
            }
          }
        });
    },
    signTransaction: async (Ee, Se) => await be.request({
      chainId: e,
      topic: fe,
      request: {
        method: Methods.SignTransaction,
        params: {
          address: v,
          transaction: Ee,
          options: {
            abis: Se
          }
        }
      }
    }),
    sendTransaction: async (Ee, Se) => {
      const Oe = await be.request({
        chainId: e,
        topic: fe,
        request: {
          method: Methods.SignAndSendTransaction,
          params: {
            address: v,
            transaction: Ee,
            options: Se
          }
        }
      });
      return Oe.transaction.wait = async (xe = "byBlock", me = 6e4) => await be.request({
        chainId: e,
        topic: fe,
        request: {
          method: Methods.WaitForTransaction,
          params: {
            transactionId: Oe.transaction.id,
            type: xe,
            timeout: me
          }
        }
      }), Oe;
    },
    prepareBlock: () => {
      throw new Error("not implemented");
    },
    signBlock: () => {
      throw new Error("not implemented");
    }
  };
}
var ChainIds = /* @__PURE__ */ ((v) => (v.Mainnet = "koinos:EiBZK_GGVP0H_fXVAM3j6EAuz3-B-l3e", v.Harbinger = "koinos:EiBncD4pKRIQWco_WRqo5Q-xnXR7JuO3", v))(ChainIds || {}), Methods = /* @__PURE__ */ ((v) => (v.SignMessage = "koinos_signMessage", v.SignHash = "koinos_signHash", v.SignTransaction = "koinos_signTransaction", v.SignAndSendTransaction = "koinos_signAndSendTransaction", v.PrepareTransaction = "koinos_prepareTransaction", v.WaitForTransaction = "koinos_waitForTransaction", v.JsonRpcCall = "koinos_JsonRpcCall", v.GetNonce = "koinos_getNonce", v.GetNextNonce = "koinos_getNextNonce", v.GetAccountRc = "koinos_getAccountRc", v.GetTransactionsById = "koinos_getTransactionsById", v.GetBlocksById = "koinos_getBlocksById", v.GetHeadInfo = "koinos_getHeadInfo", v.GetChainId = "koinos_getChainId", v.GetBlocks = "koinos_getBlocks", v.GetBlock = "koinos_getBlock", v.SendTransaction = "koinos_sendTransaction", v.ReadContract = "koinos_readContract", v.SubmitBlock = "koinos_submitBlock", v))(Methods || {}), LogLevel = /* @__PURE__ */ ((v) => (v[v.none = 0] = "none", v[v.debug = 1] = "debug", v))(LogLevel || {});
class WalletConnectKoinos {
  constructor(e, fe) {
    gi(this, "web3Modal");
    gi(this, "topic", "");
    gi(this, "chainId");
    gi(this, "accounts", []);
    gi(this, "options", {
      logLevel: 0
      /* none */
    });
    fe && (this.options = fe), this.web3Modal = new z(e), this.web3Modal.onSessionDelete((be) => this.onSessionDelete(be));
  }
  close() {
    this.web3Modal.offSessionDelete((e) => this.onSessionDelete(e));
  }
  async onSessionDelete(e) {
    this.options.logLevel === 1 && console.log("onSessionDelete", e), this.accounts = [], this.topic = "", this.chainId = void 0;
  }
  async connect(e, fe) {
    var Ee;
    this.accounts = [];
    const be = await this.web3Modal.getSessions();
    let ye = be.length ? be[0] : void 0;
    if (ye || (ye = await this.web3Modal.connect({
      requiredNamespaces: {
        koinos: {
          methods: fe,
          chains: e,
          events: []
        }
      }
    })), !ye)
      return [];
    this.topic = ye.topic, ((Ee = ye.namespaces.koinos.chains) == null ? void 0 : Ee.length) === 1 && (this.chainId = ye.namespaces.koinos.chains[0]);
    const ve = ye.namespaces.koinos.accounts.reduce((Se, Oe) => {
      const [xe, me, we] = Oe.split(":");
      return Se.includes(we) || Se.push(we), Se;
    }, []);
    return this.accounts = ve, ve;
  }
  async disconnect() {
    const e = await this.web3Modal.getSessions();
    for (const fe of e) {
      try {
        this.web3Modal.disconnect({
          topic: fe.topic,
          reason: U("USER_DISCONNECTED")
        });
      } catch (be) {
        console.error(be);
      }
      if (fe.pairingTopic)
        try {
          this.web3Modal.disconnect({
            topic: fe.pairingTopic,
            reason: U("USER_DISCONNECTED")
          });
        } catch (be) {
          console.error(be);
        }
    }
    this.accounts = [];
  }
  getAccounts() {
    return this.accounts;
  }
  getSigner(e, fe, be) {
    const ye = be || this.chainId;
    if (!ye)
      throw new Error(
        "You must provide a chain id because none or several are present in this session."
      );
    return generateSigner(e, ye, this.topic, this.web3Modal, fe);
  }
  getProvider(e) {
    const fe = e || this.chainId;
    if (!fe)
      throw new Error(
        "You must provide a chain id because none or several are present in this session."
      );
    return generateProvider(fe, this.topic, this.web3Modal);
  }
}
export {
  ChainIds as C,
  LogLevel as L,
  Methods as M,
  R$4 as R,
  T$1 as T,
  WalletConnectKoinos as W,
  a$2 as a,
  ne$1 as n,
  oe$2 as o,
  p$4 as p,
  se as s,
  te$2 as t,
  y$3 as y
};
