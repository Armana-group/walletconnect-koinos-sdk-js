var Su = Object.defineProperty;
var Eu = (se, e, Oe) => e in se ? Su(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe;
var El = (se, e, Oe) => (Eu(se, typeof e != "symbol" ? e + "" : e, Oe), Oe);
import c$5, { EventEmitter } from "events";
import require$$1 from "crypto";
const t = Symbol(), s$2 = Object.getPrototypeOf, c$4 = /* @__PURE__ */ new WeakMap(), l$3 = (se) => se && (c$4.has(se) ? c$4.get(se) : s$2(se) === Object.prototype || s$2(se) === Array.prototype), y$7 = (se) => l$3(se) && se[t] || null, h$6 = (se, e = !0) => {
  c$4.set(se, e);
}, isObject = (se) => typeof se == "object" && se !== null, proxyStateMap = /* @__PURE__ */ new WeakMap(), refSet = /* @__PURE__ */ new WeakSet(), buildProxyFunction = (se = Object.is, e = (Ti, Oi) => new Proxy(Ti, Oi), Oe = (Ti) => isObject(Ti) && !refSet.has(Ti) && (Array.isArray(Ti) || !(Symbol.iterator in Ti)) && !(Ti instanceof WeakMap) && !(Ti instanceof WeakSet) && !(Ti instanceof Error) && !(Ti instanceof Number) && !(Ti instanceof Date) && !(Ti instanceof String) && !(Ti instanceof RegExp) && !(Ti instanceof ArrayBuffer), Si = (Ti) => {
  switch (Ti.status) {
    case "fulfilled":
      return Ti.value;
    case "rejected":
      throw Ti.reason;
    default:
      throw Ti;
  }
}, wi = /* @__PURE__ */ new WeakMap(), Ei = (Ti, Oi, Mi = Si) => {
  const Ii = wi.get(Ti);
  if ((Ii == null ? void 0 : Ii[0]) === Oi)
    return Ii[1];
  const Ci = Array.isArray(Ti) ? [] : Object.create(Object.getPrototypeOf(Ti));
  return h$6(Ci, !0), wi.set(Ti, [Oi, Ci]), Reflect.ownKeys(Ti).forEach((Oo) => {
    if (Object.getOwnPropertyDescriptor(Ci, Oo))
      return;
    const Ro = Reflect.get(Ti, Oo), Bo = {
      value: Ro,
      enumerable: !0,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (refSet.has(Ro))
      h$6(Ro, !1);
    else if (Ro instanceof Promise)
      delete Bo.value, Bo.get = () => Mi(Ro);
    else if (proxyStateMap.has(Ro)) {
      const [Fo, Io] = proxyStateMap.get(
        Ro
      );
      Bo.value = Ei(
        Fo,
        Io(),
        Mi
      );
    }
    Object.defineProperty(Ci, Oo, Bo);
  }), Object.preventExtensions(Ci);
}, $i = /* @__PURE__ */ new WeakMap(), xi = [1, 1], Ri = (Ti) => {
  if (!isObject(Ti))
    throw new Error("object required");
  const Oi = $i.get(Ti);
  if (Oi)
    return Oi;
  let Mi = xi[0];
  const Ii = /* @__PURE__ */ new Set(), Ci = (Jo, zo = ++xi[0]) => {
    Mi !== zo && (Mi = zo, Ii.forEach((Do) => Do(Jo, zo)));
  };
  let Oo = xi[1];
  const Ro = (Jo = ++xi[1]) => (Oo !== Jo && !Ii.size && (Oo = Jo, Fo.forEach(([zo]) => {
    const Do = zo[1](Jo);
    Do > Mi && (Mi = Do);
  })), Mi), Bo = (Jo) => (zo, Do) => {
    const wo = [...zo];
    wo[1] = [Jo, ...wo[1]], Ci(wo, Do);
  }, Fo = /* @__PURE__ */ new Map(), Io = (Jo, zo) => {
    if (Ii.size) {
      const Do = zo[3](Bo(Jo));
      Fo.set(Jo, [zo, Do]);
    } else
      Fo.set(Jo, [zo]);
  }, Uo = (Jo) => {
    var zo;
    const Do = Fo.get(Jo);
    Do && (Fo.delete(Jo), (zo = Do[1]) == null || zo.call(Do));
  }, Co = (Jo) => (Ii.add(Jo), Ii.size === 1 && Fo.forEach(([Do, wo], Li) => {
    const Ai = Do[3](Bo(Li));
    Fo.set(Li, [Do, Ai]);
  }), () => {
    Ii.delete(Jo), Ii.size === 0 && Fo.forEach(([Do, wo], Li) => {
      wo && (wo(), Fo.set(Li, [Do]));
    });
  }), ko = Array.isArray(Ti) ? [] : Object.create(Object.getPrototypeOf(Ti)), Mo = e(ko, {
    deleteProperty(Jo, zo) {
      const Do = Reflect.get(Jo, zo);
      Uo(zo);
      const wo = Reflect.deleteProperty(Jo, zo);
      return wo && Ci(["delete", [zo], Do]), wo;
    },
    set(Jo, zo, Do, wo) {
      const Li = Reflect.has(Jo, zo), Ai = Reflect.get(Jo, zo, wo);
      if (Li && (se(Ai, Do) || $i.has(Do) && se(Ai, $i.get(Do))))
        return !0;
      Uo(zo), isObject(Do) && (Do = y$7(Do) || Do);
      let Ni = Do;
      if (Do instanceof Promise)
        Do.then((Ui) => {
          Do.status = "fulfilled", Do.value = Ui, Ci(["resolve", [zo], Ui]);
        }).catch((Ui) => {
          Do.status = "rejected", Do.reason = Ui, Ci(["reject", [zo], Ui]);
        });
      else {
        !proxyStateMap.has(Do) && Oe(Do) && (Ni = Ri(Do));
        const Ui = !refSet.has(Ni) && proxyStateMap.get(Ni);
        Ui && Io(zo, Ui);
      }
      return Reflect.set(Jo, zo, Ni, wo), Ci(["set", [zo], Do, Ai]), !0;
    }
  });
  $i.set(Ti, Mo);
  const No = [
    ko,
    Ro,
    Ei,
    Co
  ];
  return proxyStateMap.set(Mo, No), Reflect.ownKeys(Ti).forEach((Jo) => {
    const zo = Object.getOwnPropertyDescriptor(
      Ti,
      Jo
    );
    "value" in zo && (Mo[Jo] = Ti[Jo], delete zo.value, delete zo.writable), Object.defineProperty(ko, Jo, zo);
  }), Mo;
}) => [
  // public functions
  Ri,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  se,
  e,
  Oe,
  Si,
  wi,
  Ei,
  $i,
  xi
], [defaultProxyFunction] = buildProxyFunction();
function proxy(se = {}) {
  return defaultProxyFunction(se);
}
function subscribe(se, e, Oe) {
  const Si = proxyStateMap.get(se);
  let wi;
  const Ei = [], $i = Si[3];
  let xi = !1;
  const Ti = $i((Oi) => {
    if (Ei.push(Oi), Oe) {
      e(Ei.splice(0));
      return;
    }
    wi || (wi = Promise.resolve().then(() => {
      wi = void 0, xi && e(Ei.splice(0));
    }));
  });
  return xi = !0, () => {
    xi = !1, Ti();
  };
}
function snapshot(se, e) {
  const Oe = proxyStateMap.get(se), [Si, wi, Ei] = Oe;
  return Ei(Si, wi(), e);
}
const state$7 = proxy({
  history: ["ConnectWallet"],
  view: "ConnectWallet",
  data: void 0
}), RouterCtrl = {
  state: state$7,
  subscribe(se) {
    return subscribe(state$7, () => se(state$7));
  },
  push(se, e) {
    se !== state$7.view && (state$7.view = se, e && (state$7.data = e), state$7.history.push(se));
  },
  reset(se) {
    state$7.view = se, state$7.history = [se];
  },
  replace(se) {
    state$7.history.length > 1 && (state$7.history[state$7.history.length - 1] = se, state$7.view = se);
  },
  goBack() {
    if (state$7.history.length > 1) {
      state$7.history.pop();
      const [se] = state$7.history.slice(-1);
      state$7.view = se;
    }
  },
  setData(se) {
    state$7.data = se;
  }
}, CoreUtil = {
  WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
  WCM_VERSION: "WCM_VERSION",
  RECOMMENDED_WALLET_AMOUNT: 9,
  isMobile() {
    return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
  },
  isAndroid() {
    return CoreUtil.isMobile() && navigator.userAgent.toLowerCase().includes("android");
  },
  isIos() {
    const se = navigator.userAgent.toLowerCase();
    return CoreUtil.isMobile() && (se.includes("iphone") || se.includes("ipad"));
  },
  isHttpUrl(se) {
    return se.startsWith("http://") || se.startsWith("https://");
  },
  isArray(se) {
    return Array.isArray(se) && se.length > 0;
  },
  isTelegram() {
    return typeof window < "u" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (!!window.TelegramWebviewProxy || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!window.Telegram || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!window.TelegramWebviewProxyProto);
  },
  formatNativeUrl(se, e, Oe) {
    if (CoreUtil.isHttpUrl(se))
      return this.formatUniversalUrl(se, e, Oe);
    let Si = se;
    Si.includes("://") || (Si = se.replaceAll("/", "").replaceAll(":", ""), Si = `${Si}://`), Si.endsWith("/") || (Si = `${Si}/`), this.setWalletConnectDeepLink(Si, Oe);
    const wi = encodeURIComponent(e);
    return `${Si}wc?uri=${wi}`;
  },
  formatUniversalUrl(se, e, Oe) {
    if (!CoreUtil.isHttpUrl(se))
      return this.formatNativeUrl(se, e, Oe);
    let Si = se;
    if (Si.startsWith("https://t.me")) {
      const Ei = Buffer.from(e).toString("base64").replace(/[=]/g, "");
      Si.endsWith("/") && (Si = Si.slice(0, -1)), this.setWalletConnectDeepLink(Si, Oe);
      const $i = new URL(Si);
      return $i.searchParams.set("startapp", Ei), $i.toString();
    }
    Si.endsWith("/") || (Si = `${Si}/`), this.setWalletConnectDeepLink(Si, Oe);
    const wi = encodeURIComponent(e);
    return `${Si}wc?uri=${wi}`;
  },
  async wait(se) {
    return new Promise((e) => {
      setTimeout(e, se);
    });
  },
  openHref(se, e) {
    const Oe = this.isTelegram() ? "_blank" : e;
    window.open(se, Oe, "noreferrer noopener");
  },
  setWalletConnectDeepLink(se, e) {
    try {
      localStorage.setItem(CoreUtil.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: se, name: e }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  setWalletConnectAndroidDeepLink(se) {
    try {
      const [e] = se.split("?");
      localStorage.setItem(
        CoreUtil.WALLETCONNECT_DEEPLINK_CHOICE,
        JSON.stringify({ href: e, name: "Android" })
      );
    } catch {
      console.info("Unable to set WalletConnect android deep link");
    }
  },
  removeWalletConnectDeepLink() {
    try {
      localStorage.removeItem(CoreUtil.WALLETCONNECT_DEEPLINK_CHOICE);
    } catch {
      console.info("Unable to remove WalletConnect deep link");
    }
  },
  setModalVersionInStorage() {
    try {
      typeof localStorage < "u" && localStorage.setItem(CoreUtil.WCM_VERSION, "2.7.0");
    } catch {
      console.info("Unable to set Web3Modal version in storage");
    }
  },
  getWalletRouterData() {
    var se;
    const e = (se = RouterCtrl.state.data) == null ? void 0 : se.Wallet;
    if (!e)
      throw new Error('Missing "Wallet" view data');
    return e;
  }
}, isEnabled = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), state$6 = proxy({
  enabled: isEnabled,
  userSessionId: "",
  events: [],
  connectedWalletId: void 0
}), EventsCtrl = {
  state: state$6,
  subscribe(se) {
    return subscribe(state$6.events, () => se(snapshot(state$6.events[state$6.events.length - 1])));
  },
  initialize() {
    state$6.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (state$6.userSessionId = crypto.randomUUID());
  },
  setConnectedWalletId(se) {
    state$6.connectedWalletId = se;
  },
  click(se) {
    if (state$6.enabled) {
      const e = {
        type: "CLICK",
        name: se.name,
        userSessionId: state$6.userSessionId,
        timestamp: Date.now(),
        data: se
      };
      state$6.events.push(e);
    }
  },
  track(se) {
    if (state$6.enabled) {
      const e = {
        type: "TRACK",
        name: se.name,
        userSessionId: state$6.userSessionId,
        timestamp: Date.now(),
        data: se
      };
      state$6.events.push(e);
    }
  },
  view(se) {
    if (state$6.enabled) {
      const e = {
        type: "VIEW",
        name: se.name,
        userSessionId: state$6.userSessionId,
        timestamp: Date.now(),
        data: se
      };
      state$6.events.push(e);
    }
  }
}, state$5 = proxy({
  chains: void 0,
  walletConnectUri: void 0,
  isAuth: !1,
  isCustomDesktop: !1,
  isCustomMobile: !1,
  isDataLoaded: !1,
  isUiLoaded: !1
}), OptionsCtrl = {
  state: state$5,
  subscribe(se) {
    return subscribe(state$5, () => se(state$5));
  },
  setChains(se) {
    state$5.chains = se;
  },
  setWalletConnectUri(se) {
    state$5.walletConnectUri = se;
  },
  setIsCustomDesktop(se) {
    state$5.isCustomDesktop = se;
  },
  setIsCustomMobile(se) {
    state$5.isCustomMobile = se;
  },
  setIsDataLoaded(se) {
    state$5.isDataLoaded = se;
  },
  setIsUiLoaded(se) {
    state$5.isUiLoaded = se;
  },
  setIsAuth(se) {
    state$5.isAuth = se;
  }
}, state$4 = proxy({
  projectId: "",
  mobileWallets: void 0,
  desktopWallets: void 0,
  walletImages: void 0,
  chains: void 0,
  enableAuthMode: !1,
  enableExplorer: !0,
  explorerExcludedWalletIds: void 0,
  explorerRecommendedWalletIds: void 0,
  termsOfServiceUrl: void 0,
  privacyPolicyUrl: void 0
}), ConfigCtrl = {
  state: state$4,
  subscribe(se) {
    return subscribe(state$4, () => se(state$4));
  },
  setConfig(se) {
    var e, Oe;
    EventsCtrl.initialize(), OptionsCtrl.setChains(se.chains), OptionsCtrl.setIsAuth(!!se.enableAuthMode), OptionsCtrl.setIsCustomMobile(!!((e = se.mobileWallets) != null && e.length)), OptionsCtrl.setIsCustomDesktop(!!((Oe = se.desktopWallets) != null && Oe.length)), CoreUtil.setModalVersionInStorage(), Object.assign(state$4, se);
  }
};
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (se, e, Oe) => e in se ? __defProp$2(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, __spreadValues$2 = (se, e) => {
  for (var Oe in e || (e = {}))
    __hasOwnProp$2.call(e, Oe) && __defNormalProp$2(se, Oe, e[Oe]);
  if (__getOwnPropSymbols$2)
    for (var Oe of __getOwnPropSymbols$2(e))
      __propIsEnum$2.call(e, Oe) && __defNormalProp$2(se, Oe, e[Oe]);
  return se;
};
const W3M_API = "https://explorer-api.walletconnect.com", SDK_TYPE = "wcm", SDK_VERSION = "js-2.7.0";
async function fetchListings(se, e) {
  const Oe = __spreadValues$2({ sdkType: SDK_TYPE, sdkVersion: SDK_VERSION }, e), Si = new URL(se, W3M_API);
  return Si.searchParams.append("projectId", ConfigCtrl.state.projectId), Object.entries(Oe).forEach(([Ei, $i]) => {
    $i && Si.searchParams.append(Ei, String($i));
  }), (await fetch(Si)).json();
}
const ExplorerUtil = {
  async getDesktopListings(se) {
    return fetchListings("/w3m/v1/getDesktopListings", se);
  },
  async getMobileListings(se) {
    return fetchListings("/w3m/v1/getMobileListings", se);
  },
  async getInjectedListings(se) {
    return fetchListings("/w3m/v1/getInjectedListings", se);
  },
  async getAllListings(se) {
    return fetchListings("/w3m/v1/getAllListings", se);
  },
  getWalletImageUrl(se) {
    return `${W3M_API}/w3m/v1/getWalletImage/${se}?projectId=${ConfigCtrl.state.projectId}&sdkType=${SDK_TYPE}&sdkVersion=${SDK_VERSION}`;
  },
  getAssetImageUrl(se) {
    return `${W3M_API}/w3m/v1/getAssetImage/${se}?projectId=${ConfigCtrl.state.projectId}&sdkType=${SDK_TYPE}&sdkVersion=${SDK_VERSION}`;
  }
};
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (se, e, Oe) => e in se ? __defProp$1(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, __spreadValues$1 = (se, e) => {
  for (var Oe in e || (e = {}))
    __hasOwnProp$1.call(e, Oe) && __defNormalProp$1(se, Oe, e[Oe]);
  if (__getOwnPropSymbols$1)
    for (var Oe of __getOwnPropSymbols$1(e))
      __propIsEnum$1.call(e, Oe) && __defNormalProp$1(se, Oe, e[Oe]);
  return se;
};
const isMobile = CoreUtil.isMobile(), state$3 = proxy({
  wallets: { listings: [], total: 0, page: 1 },
  search: { listings: [], total: 0, page: 1 },
  recomendedWallets: []
}), ExplorerCtrl = {
  state: state$3,
  async getRecomendedWallets() {
    const { explorerRecommendedWalletIds: se, explorerExcludedWalletIds: e } = ConfigCtrl.state;
    if (se === "NONE" || e === "ALL" && !se)
      return state$3.recomendedWallets;
    if (CoreUtil.isArray(se)) {
      const Si = { recommendedIds: se.join(",") }, { listings: wi } = await ExplorerUtil.getAllListings(Si), Ei = Object.values(wi);
      Ei.sort(($i, xi) => {
        const Ri = se.indexOf($i.id), Ti = se.indexOf(xi.id);
        return Ri - Ti;
      }), state$3.recomendedWallets = Ei;
    } else {
      const { chains: Oe, isAuth: Si } = OptionsCtrl.state, wi = Oe == null ? void 0 : Oe.join(","), Ei = CoreUtil.isArray(e), $i = {
        page: 1,
        sdks: Si ? "auth_v1" : void 0,
        entries: CoreUtil.RECOMMENDED_WALLET_AMOUNT,
        chains: wi,
        version: 2,
        excludedIds: Ei ? e.join(",") : void 0
      }, { listings: xi } = isMobile ? await ExplorerUtil.getMobileListings($i) : await ExplorerUtil.getDesktopListings($i);
      state$3.recomendedWallets = Object.values(xi);
    }
    return state$3.recomendedWallets;
  },
  async getWallets(se) {
    const e = __spreadValues$1({}, se), { explorerRecommendedWalletIds: Oe, explorerExcludedWalletIds: Si } = ConfigCtrl.state, { recomendedWallets: wi } = state$3;
    if (Si === "ALL")
      return state$3.wallets;
    wi.length ? e.excludedIds = wi.map((Mi) => Mi.id).join(",") : CoreUtil.isArray(Oe) && (e.excludedIds = Oe.join(",")), CoreUtil.isArray(Si) && (e.excludedIds = [e.excludedIds, Si].filter(Boolean).join(",")), OptionsCtrl.state.isAuth && (e.sdks = "auth_v1");
    const { page: Ei, search: $i } = se, { listings: xi, total: Ri } = isMobile ? await ExplorerUtil.getMobileListings(e) : await ExplorerUtil.getDesktopListings(e), Ti = Object.values(xi), Oi = $i ? "search" : "wallets";
    return state$3[Oi] = {
      listings: [...state$3[Oi].listings, ...Ti],
      total: Ri,
      page: Ei ?? 1
    }, { listings: Ti, total: Ri };
  },
  getWalletImageUrl(se) {
    return ExplorerUtil.getWalletImageUrl(se);
  },
  getAssetImageUrl(se) {
    return ExplorerUtil.getAssetImageUrl(se);
  },
  resetSearch() {
    state$3.search = { listings: [], total: 0, page: 1 };
  }
}, state$2 = proxy({
  open: !1
}), ModalCtrl = {
  state: state$2,
  subscribe(se) {
    return subscribe(state$2, () => se(state$2));
  },
  async open(se) {
    return new Promise((e) => {
      const { isUiLoaded: Oe, isDataLoaded: Si } = OptionsCtrl.state;
      if (CoreUtil.removeWalletConnectDeepLink(), OptionsCtrl.setWalletConnectUri(se == null ? void 0 : se.uri), OptionsCtrl.setChains(se == null ? void 0 : se.chains), RouterCtrl.reset("ConnectWallet"), Oe && Si)
        state$2.open = !0, e();
      else {
        const wi = setInterval(() => {
          const Ei = OptionsCtrl.state;
          Ei.isUiLoaded && Ei.isDataLoaded && (clearInterval(wi), state$2.open = !0, e());
        }, 200);
      }
    });
  },
  close() {
    state$2.open = !1;
  }
};
var __defProp$3 = Object.defineProperty, __getOwnPropSymbols$3 = Object.getOwnPropertySymbols, __hasOwnProp$3 = Object.prototype.hasOwnProperty, __propIsEnum$3 = Object.prototype.propertyIsEnumerable, __defNormalProp$3 = (se, e, Oe) => e in se ? __defProp$3(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, __spreadValues$3 = (se, e) => {
  for (var Oe in e || (e = {}))
    __hasOwnProp$3.call(e, Oe) && __defNormalProp$3(se, Oe, e[Oe]);
  if (__getOwnPropSymbols$3)
    for (var Oe of __getOwnPropSymbols$3(e))
      __propIsEnum$3.call(e, Oe) && __defNormalProp$3(se, Oe, e[Oe]);
  return se;
};
function isDarkMode() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const state$1 = proxy({
  themeMode: isDarkMode() ? "dark" : "light"
}), ThemeCtrl = {
  state: state$1,
  subscribe(se) {
    return subscribe(state$1, () => se(state$1));
  },
  setThemeConfig(se) {
    const { themeMode: e, themeVariables: Oe } = se;
    e && (state$1.themeMode = e), Oe && (state$1.themeVariables = __spreadValues$3({}, Oe));
  }
}, state = proxy({
  open: !1,
  message: "",
  variant: "success"
}), ToastCtrl = {
  state,
  subscribe(se) {
    return subscribe(state, () => se(state));
  },
  openToast(se, e) {
    state.open = !0, state.message = se, state.variant = e;
  },
  closeToast() {
    state.open = !1;
  }
};
class WalletConnectModal {
  constructor(e) {
    this.openModal = ModalCtrl.open, this.closeModal = ModalCtrl.close, this.subscribeModal = ModalCtrl.subscribe, this.setTheme = ThemeCtrl.setThemeConfig, ThemeCtrl.setThemeConfig(e), ConfigCtrl.setConfig(e), this.initUi();
  }
  async initUi() {
    if (typeof window < "u") {
      await import("./index-ca4d1ce8.mjs");
      const e = document.createElement("wcm-modal");
      document.body.insertAdjacentElement("beforeend", e), OptionsCtrl.setIsUiLoaded(!0);
    }
  }
}
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(se, e) {
  if (se === "__proto__" || se === "constructor" && e && typeof e == "object" && "prototype" in e) {
    warnKeyDropped(se);
    return;
  }
  return e;
}
function warnKeyDropped(se) {
  console.warn(`[destr] Dropping "${se}" key to prevent prototype pollution.`);
}
function destr(se, e = {}) {
  if (typeof se != "string")
    return se;
  const Oe = se.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    se[0] === '"' && se.at(-1) === '"' && !se.includes("\\")
  )
    return Oe.slice(1, -1);
  if (Oe.length <= 9) {
    const Si = Oe.toLowerCase();
    if (Si === "true")
      return !0;
    if (Si === "false")
      return !1;
    if (Si === "undefined")
      return;
    if (Si === "null")
      return null;
    if (Si === "nan")
      return Number.NaN;
    if (Si === "infinity")
      return Number.POSITIVE_INFINITY;
    if (Si === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!JsonSigRx.test(se)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return se;
  }
  try {
    if (suspectProtoRx.test(se) || suspectConstructorRx.test(se)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(se, jsonParseTransform);
    }
    return JSON.parse(se);
  } catch (Si) {
    if (e.strict)
      throw Si;
    return se;
  }
}
function wrapToPromise(se) {
  return !se || typeof se.then != "function" ? Promise.resolve(se) : se;
}
function asyncCall(se, ...e) {
  try {
    return wrapToPromise(se(...e));
  } catch (Oe) {
    return Promise.reject(Oe);
  }
}
function isPrimitive(se) {
  const e = typeof se;
  return se === null || e !== "object" && e !== "function";
}
function isPureObject(se) {
  const e = Object.getPrototypeOf(se);
  return !e || e.isPrototypeOf(Object);
}
function stringify(se) {
  if (isPrimitive(se))
    return String(se);
  if (isPureObject(se) || Array.isArray(se))
    return JSON.stringify(se);
  if (typeof se.toJSON == "function")
    return stringify(se.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(se) {
  if (typeof se == "string")
    return se;
  checkBufferSupport();
  const e = Buffer.from(se).toString("base64");
  return BASE64_PREFIX + e;
}
function deserializeRaw(se) {
  return typeof se != "string" || !se.startsWith(BASE64_PREFIX) ? se : (checkBufferSupport(), Buffer.from(se.slice(BASE64_PREFIX.length), "base64"));
}
function normalizeKey(se) {
  return se ? se.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function joinKeys(...se) {
  return normalizeKey(se.join(":"));
}
function normalizeBaseKey(se) {
  return se = normalizeKey(se), se ? se + ":" : "";
}
function defineDriver(se) {
  return se;
}
const DRIVER_NAME = "memory", memory = () => {
  const se = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    options: {},
    hasItem(e) {
      return se.has(e);
    },
    getItem(e) {
      return se.get(e) || null;
    },
    getItemRaw(e) {
      return se.get(e) || null;
    },
    setItem(e, Oe) {
      se.set(e, Oe);
    },
    setItemRaw(e, Oe) {
      se.set(e, Oe);
    },
    removeItem(e) {
      se.delete(e);
    },
    getKeys() {
      return Array.from(se.keys());
    },
    clear() {
      se.clear();
    },
    dispose() {
      se.clear();
    }
  };
};
function createStorage(se = {}) {
  const e = {
    mounts: { "": se.driver || memory() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, Oe = (Ti) => {
    for (const Oi of e.mountpoints)
      if (Ti.startsWith(Oi))
        return {
          base: Oi,
          relativeKey: Ti.slice(Oi.length),
          driver: e.mounts[Oi]
        };
    return {
      base: "",
      relativeKey: Ti,
      driver: e.mounts[""]
    };
  }, Si = (Ti, Oi) => e.mountpoints.filter(
    (Mi) => Mi.startsWith(Ti) || Oi && Ti.startsWith(Mi)
  ).map((Mi) => ({
    relativeBase: Ti.length > Mi.length ? Ti.slice(Mi.length) : void 0,
    mountpoint: Mi,
    driver: e.mounts[Mi]
  })), wi = (Ti, Oi) => {
    if (e.watching) {
      Oi = normalizeKey(Oi);
      for (const Mi of e.watchListeners)
        Mi(Ti, Oi);
    }
  }, Ei = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const Ti in e.mounts)
        e.unwatch[Ti] = await watch$2(
          e.mounts[Ti],
          wi,
          Ti
        );
    }
  }, $i = async () => {
    if (e.watching) {
      for (const Ti in e.unwatch)
        await e.unwatch[Ti]();
      e.unwatch = {}, e.watching = !1;
    }
  }, xi = (Ti, Oi, Mi) => {
    const Ii = /* @__PURE__ */ new Map(), Ci = (Oo) => {
      let Ro = Ii.get(Oo.base);
      return Ro || (Ro = {
        driver: Oo.driver,
        base: Oo.base,
        items: []
      }, Ii.set(Oo.base, Ro)), Ro;
    };
    for (const Oo of Ti) {
      const Ro = typeof Oo == "string", Bo = normalizeKey(Ro ? Oo : Oo.key), Fo = Ro ? void 0 : Oo.value, Io = Ro || !Oo.options ? Oi : { ...Oi, ...Oo.options }, Uo = Oe(Bo);
      Ci(Uo).items.push({
        key: Bo,
        value: Fo,
        relativeKey: Uo.relativeKey,
        options: Io
      });
    }
    return Promise.all([...Ii.values()].map((Oo) => Mi(Oo))).then(
      (Oo) => Oo.flat()
    );
  }, Ri = {
    // Item
    hasItem(Ti, Oi = {}) {
      Ti = normalizeKey(Ti);
      const { relativeKey: Mi, driver: Ii } = Oe(Ti);
      return asyncCall(Ii.hasItem, Mi, Oi);
    },
    getItem(Ti, Oi = {}) {
      Ti = normalizeKey(Ti);
      const { relativeKey: Mi, driver: Ii } = Oe(Ti);
      return asyncCall(Ii.getItem, Mi, Oi).then(
        (Ci) => destr(Ci)
      );
    },
    getItems(Ti, Oi) {
      return xi(Ti, Oi, (Mi) => Mi.driver.getItems ? asyncCall(
        Mi.driver.getItems,
        Mi.items.map((Ii) => ({
          key: Ii.relativeKey,
          options: Ii.options
        })),
        Oi
      ).then(
        (Ii) => Ii.map((Ci) => ({
          key: joinKeys(Mi.base, Ci.key),
          value: destr(Ci.value)
        }))
      ) : Promise.all(
        Mi.items.map((Ii) => asyncCall(
          Mi.driver.getItem,
          Ii.relativeKey,
          Ii.options
        ).then((Ci) => ({
          key: Ii.key,
          value: destr(Ci)
        })))
      ));
    },
    getItemRaw(Ti, Oi = {}) {
      Ti = normalizeKey(Ti);
      const { relativeKey: Mi, driver: Ii } = Oe(Ti);
      return Ii.getItemRaw ? asyncCall(Ii.getItemRaw, Mi, Oi) : asyncCall(Ii.getItem, Mi, Oi).then(
        (Ci) => deserializeRaw(Ci)
      );
    },
    async setItem(Ti, Oi, Mi = {}) {
      if (Oi === void 0)
        return Ri.removeItem(Ti);
      Ti = normalizeKey(Ti);
      const { relativeKey: Ii, driver: Ci } = Oe(Ti);
      Ci.setItem && (await asyncCall(Ci.setItem, Ii, stringify(Oi), Mi), Ci.watch || wi("update", Ti));
    },
    async setItems(Ti, Oi) {
      await xi(Ti, Oi, async (Mi) => {
        Mi.driver.setItems && await asyncCall(
          Mi.driver.setItems,
          Mi.items.map((Ii) => ({
            key: Ii.relativeKey,
            value: stringify(Ii.value),
            options: Ii.options
          })),
          Oi
        ), Mi.driver.setItem && await Promise.all(
          Mi.items.map((Ii) => asyncCall(
            Mi.driver.setItem,
            Ii.relativeKey,
            stringify(Ii.value),
            Ii.options
          ))
        );
      });
    },
    async setItemRaw(Ti, Oi, Mi = {}) {
      if (Oi === void 0)
        return Ri.removeItem(Ti, Mi);
      Ti = normalizeKey(Ti);
      const { relativeKey: Ii, driver: Ci } = Oe(Ti);
      if (Ci.setItemRaw)
        await asyncCall(Ci.setItemRaw, Ii, Oi, Mi);
      else if (Ci.setItem)
        await asyncCall(Ci.setItem, Ii, serializeRaw(Oi), Mi);
      else
        return;
      Ci.watch || wi("update", Ti);
    },
    async removeItem(Ti, Oi = {}) {
      typeof Oi == "boolean" && (Oi = { removeMeta: Oi }), Ti = normalizeKey(Ti);
      const { relativeKey: Mi, driver: Ii } = Oe(Ti);
      Ii.removeItem && (await asyncCall(Ii.removeItem, Mi, Oi), (Oi.removeMeta || Oi.removeMata) && await asyncCall(Ii.removeItem, Mi + "$", Oi), Ii.watch || wi("remove", Ti));
    },
    // Meta
    async getMeta(Ti, Oi = {}) {
      typeof Oi == "boolean" && (Oi = { nativeOnly: Oi }), Ti = normalizeKey(Ti);
      const { relativeKey: Mi, driver: Ii } = Oe(Ti), Ci = /* @__PURE__ */ Object.create(null);
      if (Ii.getMeta && Object.assign(Ci, await asyncCall(Ii.getMeta, Mi, Oi)), !Oi.nativeOnly) {
        const Oo = await asyncCall(
          Ii.getItem,
          Mi + "$",
          Oi
        ).then((Ro) => destr(Ro));
        Oo && typeof Oo == "object" && (typeof Oo.atime == "string" && (Oo.atime = new Date(Oo.atime)), typeof Oo.mtime == "string" && (Oo.mtime = new Date(Oo.mtime)), Object.assign(Ci, Oo));
      }
      return Ci;
    },
    setMeta(Ti, Oi, Mi = {}) {
      return this.setItem(Ti + "$", Oi, Mi);
    },
    removeMeta(Ti, Oi = {}) {
      return this.removeItem(Ti + "$", Oi);
    },
    // Keys
    async getKeys(Ti, Oi = {}) {
      Ti = normalizeBaseKey(Ti);
      const Mi = Si(Ti, !0);
      let Ii = [];
      const Ci = [];
      for (const Oo of Mi) {
        const Bo = (await asyncCall(
          Oo.driver.getKeys,
          Oo.relativeBase,
          Oi
        )).map((Fo) => Oo.mountpoint + normalizeKey(Fo)).filter((Fo) => !Ii.some((Io) => Fo.startsWith(Io)));
        Ci.push(...Bo), Ii = [
          Oo.mountpoint,
          ...Ii.filter((Fo) => !Fo.startsWith(Oo.mountpoint))
        ];
      }
      return Ti ? Ci.filter((Oo) => Oo.startsWith(Ti) && !Oo.endsWith("$")) : Ci.filter((Oo) => !Oo.endsWith("$"));
    },
    // Utils
    async clear(Ti, Oi = {}) {
      Ti = normalizeBaseKey(Ti), await Promise.all(
        Si(Ti, !1).map(async (Mi) => {
          if (Mi.driver.clear)
            return asyncCall(Mi.driver.clear, Mi.relativeBase, Oi);
          if (Mi.driver.removeItem) {
            const Ii = await Mi.driver.getKeys(Mi.relativeBase || "", Oi);
            return Promise.all(
              Ii.map((Ci) => Mi.driver.removeItem(Ci, Oi))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((Ti) => dispose(Ti))
      );
    },
    async watch(Ti) {
      return await Ei(), e.watchListeners.push(Ti), async () => {
        e.watchListeners = e.watchListeners.filter(
          (Oi) => Oi !== Ti
        ), e.watchListeners.length === 0 && await $i();
      };
    },
    async unwatch() {
      e.watchListeners = [], await $i();
    },
    // Mount
    mount(Ti, Oi) {
      if (Ti = normalizeBaseKey(Ti), Ti && e.mounts[Ti])
        throw new Error(`already mounted at ${Ti}`);
      return Ti && (e.mountpoints.push(Ti), e.mountpoints.sort((Mi, Ii) => Ii.length - Mi.length)), e.mounts[Ti] = Oi, e.watching && Promise.resolve(watch$2(Oi, wi, Ti)).then((Mi) => {
        e.unwatch[Ti] = Mi;
      }).catch(console.error), Ri;
    },
    async unmount(Ti, Oi = !0) {
      Ti = normalizeBaseKey(Ti), !(!Ti || !e.mounts[Ti]) && (e.watching && Ti in e.unwatch && (e.unwatch[Ti](), delete e.unwatch[Ti]), Oi && await dispose(e.mounts[Ti]), e.mountpoints = e.mountpoints.filter((Mi) => Mi !== Ti), delete e.mounts[Ti]);
    },
    getMount(Ti = "") {
      Ti = normalizeKey(Ti) + ":";
      const Oi = Oe(Ti);
      return {
        driver: Oi.driver,
        base: Oi.base
      };
    },
    getMounts(Ti = "", Oi = {}) {
      return Ti = normalizeKey(Ti), Si(Ti, Oi.parents).map((Ii) => ({
        driver: Ii.driver,
        base: Ii.mountpoint
      }));
    }
  };
  return Ri;
}
function watch$2(se, e, Oe) {
  return se.watch ? se.watch((Si, wi) => e(Si, Oe + wi)) : () => {
  };
}
async function dispose(se) {
  typeof se.dispose == "function" && await asyncCall(se.dispose);
}
function promisifyRequest(se) {
  return new Promise((e, Oe) => {
    se.oncomplete = se.onsuccess = () => e(se.result), se.onabort = se.onerror = () => Oe(se.error);
  });
}
function createStore(se, e) {
  const Oe = indexedDB.open(se);
  Oe.onupgradeneeded = () => Oe.result.createObjectStore(e);
  const Si = promisifyRequest(Oe);
  return (wi, Ei) => Si.then(($i) => Ei($i.transaction(e, wi).objectStore(e)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  return defaultGetStoreFunc || (defaultGetStoreFunc = createStore("keyval-store", "keyval")), defaultGetStoreFunc;
}
function get(se, e = defaultGetStore()) {
  return e("readonly", (Oe) => promisifyRequest(Oe.get(se)));
}
function set(se, e, Oe = defaultGetStore()) {
  return Oe("readwrite", (Si) => (Si.put(e, se), promisifyRequest(Si.transaction)));
}
function del(se, e = defaultGetStore()) {
  return e("readwrite", (Oe) => (Oe.delete(se), promisifyRequest(Oe.transaction)));
}
function clear(se = defaultGetStore()) {
  return se("readwrite", (e) => (e.clear(), promisifyRequest(e.transaction)));
}
function eachCursor(se, e) {
  return se.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, promisifyRequest(se.transaction);
}
function keys(se = defaultGetStore()) {
  return se("readonly", (e) => {
    if (e.getAllKeys)
      return promisifyRequest(e.getAllKeys());
    const Oe = [];
    return eachCursor(e, (Si) => Oe.push(Si.key)).then(() => Oe);
  });
}
const JSONStringify = (se) => JSON.stringify(se, (e, Oe) => typeof Oe == "bigint" ? Oe.toString() + "n" : Oe), JSONParse = (se) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, Oe = se.replace(e, '$1"$2n"$3');
  return JSON.parse(Oe, (Si, wi) => typeof wi == "string" && wi.match(/^\d+n$/) ? BigInt(wi.substring(0, wi.length - 1)) : wi);
};
function safeJsonParse(se) {
  if (typeof se != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof se}`);
  try {
    return JSONParse(se);
  } catch {
    return se;
  }
}
function safeJsonStringify(se) {
  return typeof se == "string" ? se : JSONStringify(se) || "";
}
const x$8 = "idb-keyval";
var z$5 = (se = {}) => {
  const e = se.base && se.base.length > 0 ? `${se.base}:` : "", Oe = (wi) => e + wi;
  let Si;
  return se.dbName && se.storeName && (Si = createStore(se.dbName, se.storeName)), { name: x$8, options: se, async hasItem(wi) {
    return !(typeof await get(Oe(wi), Si) > "u");
  }, async getItem(wi) {
    return await get(Oe(wi), Si) ?? null;
  }, setItem(wi, Ei) {
    return set(Oe(wi), Ei, Si);
  }, removeItem(wi) {
    return del(Oe(wi), Si);
  }, getKeys() {
    return keys(Si);
  }, clear() {
    return clear(Si);
  } };
};
const D$5 = "WALLET_CONNECT_V2_INDEXED_DB", E$5 = "keyvaluestorage";
let _$6 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z$5({ dbName: D$5, storeName: E$5 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const Oe = await this.indexedDb.getItem(e);
    if (Oe !== null)
      return Oe;
  }
  async setItem(e, Oe) {
    await this.indexedDb.setItem(e, safeJsonStringify(Oe));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var l$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c$3 = { exports: {} };
(function() {
  let se;
  function e() {
  }
  se = e, se.prototype.getItem = function(Oe) {
    return this.hasOwnProperty(Oe) ? String(this[Oe]) : null;
  }, se.prototype.setItem = function(Oe, Si) {
    this[Oe] = String(Si);
  }, se.prototype.removeItem = function(Oe) {
    delete this[Oe];
  }, se.prototype.clear = function() {
    const Oe = this;
    Object.keys(Oe).forEach(function(Si) {
      Oe[Si] = void 0, delete Oe[Si];
    });
  }, se.prototype.key = function(Oe) {
    return Oe = Oe || 0, Object.keys(this)[Oe];
  }, se.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$2 < "u" && l$2.localStorage ? c$3.exports = l$2.localStorage : typeof window < "u" && window.localStorage ? c$3.exports = window.localStorage : c$3.exports = new e();
})();
function k$4(se) {
  var e;
  return [se[0], safeJsonParse((e = se[1]) != null ? e : "")];
}
let K$4 = class {
  constructor() {
    this.localStorage = c$3.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$4);
  }
  async getItem(e) {
    const Oe = this.localStorage.getItem(e);
    if (Oe !== null)
      return safeJsonParse(Oe);
  }
  async setItem(e, Oe) {
    this.localStorage.setItem(e, safeJsonStringify(Oe));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const N$3 = "wc_storage_version", y$6 = 1, O$4 = async (se, e, Oe) => {
  const Si = N$3, wi = await e.getItem(Si);
  if (wi && wi >= y$6) {
    Oe(e);
    return;
  }
  const Ei = await se.getKeys();
  if (!Ei.length) {
    Oe(e);
    return;
  }
  const $i = [];
  for (; Ei.length; ) {
    const xi = Ei.shift();
    if (!xi)
      continue;
    const Ri = xi.toLowerCase();
    if (Ri.includes("wc@") || Ri.includes("walletconnect") || Ri.includes("wc_") || Ri.includes("wallet_connect")) {
      const Ti = await se.getItem(xi);
      await e.setItem(xi, Ti), $i.push(xi);
    }
  }
  await e.setItem(Si, y$6), Oe(e), j$3(se, $i);
}, j$3 = async (se, e) => {
  e.length && e.forEach(async (Oe) => {
    await se.removeItem(Oe);
  });
};
let h$5 = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (Oe) => {
      this.storage = Oe, this.initialized = !0;
    };
    const e = new K$4();
    this.storage = e;
    try {
      const Oe = new _$6();
      O$4(e, Oe, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, Oe) {
    return await this.initialize(), this.storage.setItem(e, Oe);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const Oe = setInterval(() => {
        this.initialized && (clearInterval(Oe), e());
      }, 20);
    });
  }
};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(se) {
  return se && se.__esModule && Object.prototype.hasOwnProperty.call(se, "default") ? se.default : se;
}
function getAugmentedNamespace(se) {
  if (se.__esModule)
    return se;
  var e = se.default;
  if (typeof e == "function") {
    var Oe = function Si() {
      if (this instanceof Si) {
        var wi = [null];
        wi.push.apply(wi, arguments);
        var Ei = Function.bind.apply(e, wi);
        return new Ei();
      }
      return e.apply(this, arguments);
    };
    Oe.prototype = e.prototype;
  } else
    Oe = {};
  return Object.defineProperty(Oe, "__esModule", { value: !0 }), Object.keys(se).forEach(function(Si) {
    var wi = Object.getOwnPropertyDescriptor(se, Si);
    Object.defineProperty(Oe, Si, wi.get ? wi : {
      enumerable: !0,
      get: function() {
        return se[Si];
      }
    });
  }), Oe;
}
var cjs$5 = {}, tslib = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(se) {
  var e, Oe, Si, wi, Ei, $i, xi, Ri, Ti, Oi, Mi, Ii, Ci, Oo, Ro, Bo, Fo, Io, Uo, Co, ko, Po, Mo;
  (function(No) {
    var Jo = typeof commonjsGlobal == "object" ? commonjsGlobal : typeof self == "object" ? self : typeof this == "object" ? this : {};
    No(zo(Jo, zo(se.exports)));
    function zo(Do, wo) {
      return Do !== Jo && (typeof Object.create == "function" ? Object.defineProperty(Do, "__esModule", { value: !0 }) : Do.__esModule = !0), function(Li, Ai) {
        return Do[Li] = wo ? wo(Li, Ai) : Ai;
      };
    }
  })(function(No) {
    var Jo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(zo, Do) {
      zo.__proto__ = Do;
    } || function(zo, Do) {
      for (var wo in Do)
        Do.hasOwnProperty(wo) && (zo[wo] = Do[wo]);
    };
    e = function(zo, Do) {
      Jo(zo, Do);
      function wo() {
        this.constructor = zo;
      }
      zo.prototype = Do === null ? Object.create(Do) : (wo.prototype = Do.prototype, new wo());
    }, Oe = Object.assign || function(zo) {
      for (var Do, wo = 1, Li = arguments.length; wo < Li; wo++) {
        Do = arguments[wo];
        for (var Ai in Do)
          Object.prototype.hasOwnProperty.call(Do, Ai) && (zo[Ai] = Do[Ai]);
      }
      return zo;
    }, Si = function(zo, Do) {
      var wo = {};
      for (var Li in zo)
        Object.prototype.hasOwnProperty.call(zo, Li) && Do.indexOf(Li) < 0 && (wo[Li] = zo[Li]);
      if (zo != null && typeof Object.getOwnPropertySymbols == "function")
        for (var Ai = 0, Li = Object.getOwnPropertySymbols(zo); Ai < Li.length; Ai++)
          Do.indexOf(Li[Ai]) < 0 && Object.prototype.propertyIsEnumerable.call(zo, Li[Ai]) && (wo[Li[Ai]] = zo[Li[Ai]]);
      return wo;
    }, wi = function(zo, Do, wo, Li) {
      var Ai = arguments.length, Ni = Ai < 3 ? Do : Li === null ? Li = Object.getOwnPropertyDescriptor(Do, wo) : Li, Ui;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        Ni = Reflect.decorate(zo, Do, wo, Li);
      else
        for (var So = zo.length - 1; So >= 0; So--)
          (Ui = zo[So]) && (Ni = (Ai < 3 ? Ui(Ni) : Ai > 3 ? Ui(Do, wo, Ni) : Ui(Do, wo)) || Ni);
      return Ai > 3 && Ni && Object.defineProperty(Do, wo, Ni), Ni;
    }, Ei = function(zo, Do) {
      return function(wo, Li) {
        Do(wo, Li, zo);
      };
    }, $i = function(zo, Do) {
      if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(zo, Do);
    }, xi = function(zo, Do, wo, Li) {
      function Ai(Ni) {
        return Ni instanceof wo ? Ni : new wo(function(Ui) {
          Ui(Ni);
        });
      }
      return new (wo || (wo = Promise))(function(Ni, Ui) {
        function So(zi) {
          try {
            Eo(Li.next(zi));
          } catch (_o) {
            Ui(_o);
          }
        }
        function $o(zi) {
          try {
            Eo(Li.throw(zi));
          } catch (_o) {
            Ui(_o);
          }
        }
        function Eo(zi) {
          zi.done ? Ni(zi.value) : Ai(zi.value).then(So, $o);
        }
        Eo((Li = Li.apply(zo, Do || [])).next());
      });
    }, Ri = function(zo, Do) {
      var wo = { label: 0, sent: function() {
        if (Ni[0] & 1)
          throw Ni[1];
        return Ni[1];
      }, trys: [], ops: [] }, Li, Ai, Ni, Ui;
      return Ui = { next: So(0), throw: So(1), return: So(2) }, typeof Symbol == "function" && (Ui[Symbol.iterator] = function() {
        return this;
      }), Ui;
      function So(Eo) {
        return function(zi) {
          return $o([Eo, zi]);
        };
      }
      function $o(Eo) {
        if (Li)
          throw new TypeError("Generator is already executing.");
        for (; wo; )
          try {
            if (Li = 1, Ai && (Ni = Eo[0] & 2 ? Ai.return : Eo[0] ? Ai.throw || ((Ni = Ai.return) && Ni.call(Ai), 0) : Ai.next) && !(Ni = Ni.call(Ai, Eo[1])).done)
              return Ni;
            switch (Ai = 0, Ni && (Eo = [Eo[0] & 2, Ni.value]), Eo[0]) {
              case 0:
              case 1:
                Ni = Eo;
                break;
              case 4:
                return wo.label++, { value: Eo[1], done: !1 };
              case 5:
                wo.label++, Ai = Eo[1], Eo = [0];
                continue;
              case 7:
                Eo = wo.ops.pop(), wo.trys.pop();
                continue;
              default:
                if (Ni = wo.trys, !(Ni = Ni.length > 0 && Ni[Ni.length - 1]) && (Eo[0] === 6 || Eo[0] === 2)) {
                  wo = 0;
                  continue;
                }
                if (Eo[0] === 3 && (!Ni || Eo[1] > Ni[0] && Eo[1] < Ni[3])) {
                  wo.label = Eo[1];
                  break;
                }
                if (Eo[0] === 6 && wo.label < Ni[1]) {
                  wo.label = Ni[1], Ni = Eo;
                  break;
                }
                if (Ni && wo.label < Ni[2]) {
                  wo.label = Ni[2], wo.ops.push(Eo);
                  break;
                }
                Ni[2] && wo.ops.pop(), wo.trys.pop();
                continue;
            }
            Eo = Do.call(zo, wo);
          } catch (zi) {
            Eo = [6, zi], Ai = 0;
          } finally {
            Li = Ni = 0;
          }
        if (Eo[0] & 5)
          throw Eo[1];
        return { value: Eo[0] ? Eo[1] : void 0, done: !0 };
      }
    }, Mo = function(zo, Do, wo, Li) {
      Li === void 0 && (Li = wo), zo[Li] = Do[wo];
    }, Ti = function(zo, Do) {
      for (var wo in zo)
        wo !== "default" && !Do.hasOwnProperty(wo) && (Do[wo] = zo[wo]);
    }, Oi = function(zo) {
      var Do = typeof Symbol == "function" && Symbol.iterator, wo = Do && zo[Do], Li = 0;
      if (wo)
        return wo.call(zo);
      if (zo && typeof zo.length == "number")
        return {
          next: function() {
            return zo && Li >= zo.length && (zo = void 0), { value: zo && zo[Li++], done: !zo };
          }
        };
      throw new TypeError(Do ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, Mi = function(zo, Do) {
      var wo = typeof Symbol == "function" && zo[Symbol.iterator];
      if (!wo)
        return zo;
      var Li = wo.call(zo), Ai, Ni = [], Ui;
      try {
        for (; (Do === void 0 || Do-- > 0) && !(Ai = Li.next()).done; )
          Ni.push(Ai.value);
      } catch (So) {
        Ui = { error: So };
      } finally {
        try {
          Ai && !Ai.done && (wo = Li.return) && wo.call(Li);
        } finally {
          if (Ui)
            throw Ui.error;
        }
      }
      return Ni;
    }, Ii = function() {
      for (var zo = [], Do = 0; Do < arguments.length; Do++)
        zo = zo.concat(Mi(arguments[Do]));
      return zo;
    }, Ci = function() {
      for (var zo = 0, Do = 0, wo = arguments.length; Do < wo; Do++)
        zo += arguments[Do].length;
      for (var Li = Array(zo), Ai = 0, Do = 0; Do < wo; Do++)
        for (var Ni = arguments[Do], Ui = 0, So = Ni.length; Ui < So; Ui++, Ai++)
          Li[Ai] = Ni[Ui];
      return Li;
    }, Oo = function(zo) {
      return this instanceof Oo ? (this.v = zo, this) : new Oo(zo);
    }, Ro = function(zo, Do, wo) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var Li = wo.apply(zo, Do || []), Ai, Ni = [];
      return Ai = {}, Ui("next"), Ui("throw"), Ui("return"), Ai[Symbol.asyncIterator] = function() {
        return this;
      }, Ai;
      function Ui(Fi) {
        Li[Fi] && (Ai[Fi] = function(xo) {
          return new Promise(function(Qo, To) {
            Ni.push([Fi, xo, Qo, To]) > 1 || So(Fi, xo);
          });
        });
      }
      function So(Fi, xo) {
        try {
          $o(Li[Fi](xo));
        } catch (Qo) {
          _o(Ni[0][3], Qo);
        }
      }
      function $o(Fi) {
        Fi.value instanceof Oo ? Promise.resolve(Fi.value.v).then(Eo, zi) : _o(Ni[0][2], Fi);
      }
      function Eo(Fi) {
        So("next", Fi);
      }
      function zi(Fi) {
        So("throw", Fi);
      }
      function _o(Fi, xo) {
        Fi(xo), Ni.shift(), Ni.length && So(Ni[0][0], Ni[0][1]);
      }
    }, Bo = function(zo) {
      var Do, wo;
      return Do = {}, Li("next"), Li("throw", function(Ai) {
        throw Ai;
      }), Li("return"), Do[Symbol.iterator] = function() {
        return this;
      }, Do;
      function Li(Ai, Ni) {
        Do[Ai] = zo[Ai] ? function(Ui) {
          return (wo = !wo) ? { value: Oo(zo[Ai](Ui)), done: Ai === "return" } : Ni ? Ni(Ui) : Ui;
        } : Ni;
      }
    }, Fo = function(zo) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var Do = zo[Symbol.asyncIterator], wo;
      return Do ? Do.call(zo) : (zo = typeof Oi == "function" ? Oi(zo) : zo[Symbol.iterator](), wo = {}, Li("next"), Li("throw"), Li("return"), wo[Symbol.asyncIterator] = function() {
        return this;
      }, wo);
      function Li(Ni) {
        wo[Ni] = zo[Ni] && function(Ui) {
          return new Promise(function(So, $o) {
            Ui = zo[Ni](Ui), Ai(So, $o, Ui.done, Ui.value);
          });
        };
      }
      function Ai(Ni, Ui, So, $o) {
        Promise.resolve($o).then(function(Eo) {
          Ni({ value: Eo, done: So });
        }, Ui);
      }
    }, Io = function(zo, Do) {
      return Object.defineProperty ? Object.defineProperty(zo, "raw", { value: Do }) : zo.raw = Do, zo;
    }, Uo = function(zo) {
      if (zo && zo.__esModule)
        return zo;
      var Do = {};
      if (zo != null)
        for (var wo in zo)
          Object.hasOwnProperty.call(zo, wo) && (Do[wo] = zo[wo]);
      return Do.default = zo, Do;
    }, Co = function(zo) {
      return zo && zo.__esModule ? zo : { default: zo };
    }, ko = function(zo, Do) {
      if (!Do.has(zo))
        throw new TypeError("attempted to get private field on non-instance");
      return Do.get(zo);
    }, Po = function(zo, Do, wo) {
      if (!Do.has(zo))
        throw new TypeError("attempted to set private field on non-instance");
      return Do.set(zo, wo), wo;
    }, No("__extends", e), No("__assign", Oe), No("__rest", Si), No("__decorate", wi), No("__param", Ei), No("__metadata", $i), No("__awaiter", xi), No("__generator", Ri), No("__exportStar", Ti), No("__createBinding", Mo), No("__values", Oi), No("__read", Mi), No("__spread", Ii), No("__spreadArrays", Ci), No("__await", Oo), No("__asyncGenerator", Ro), No("__asyncDelegator", Bo), No("__asyncValues", Fo), No("__makeTemplateObject", Io), No("__importStar", Uo), No("__importDefault", Co), No("__classPrivateFieldGet", ko), No("__classPrivateFieldSet", Po);
  });
})(tslib);
var tslibExports = tslib.exports, heartbeat$2 = {}, cjs$4 = {}, utils$q = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function se(e) {
    return new Promise((Oe) => {
      setTimeout(() => {
        Oe(!0);
      }, e);
    });
  }
  return delay.delay = se, delay;
}
var convert$1 = {}, constants$3 = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(se) {
    Object.defineProperty(se, "__esModule", { value: !0 }), se.ONE_YEAR = se.FOUR_WEEKS = se.THREE_WEEKS = se.TWO_WEEKS = se.ONE_WEEK = se.THIRTY_DAYS = se.SEVEN_DAYS = se.FIVE_DAYS = se.THREE_DAYS = se.ONE_DAY = se.TWENTY_FOUR_HOURS = se.TWELVE_HOURS = se.SIX_HOURS = se.THREE_HOURS = se.ONE_HOUR = se.SIXTY_MINUTES = se.THIRTY_MINUTES = se.TEN_MINUTES = se.FIVE_MINUTES = se.ONE_MINUTE = se.SIXTY_SECONDS = se.THIRTY_SECONDS = se.TEN_SECONDS = se.FIVE_SECONDS = se.ONE_SECOND = void 0, se.ONE_SECOND = 1, se.FIVE_SECONDS = 5, se.TEN_SECONDS = 10, se.THIRTY_SECONDS = 30, se.SIXTY_SECONDS = 60, se.ONE_MINUTE = se.SIXTY_SECONDS, se.FIVE_MINUTES = se.ONE_MINUTE * 5, se.TEN_MINUTES = se.ONE_MINUTE * 10, se.THIRTY_MINUTES = se.ONE_MINUTE * 30, se.SIXTY_MINUTES = se.ONE_MINUTE * 60, se.ONE_HOUR = se.SIXTY_MINUTES, se.THREE_HOURS = se.ONE_HOUR * 3, se.SIX_HOURS = se.ONE_HOUR * 6, se.TWELVE_HOURS = se.ONE_HOUR * 12, se.TWENTY_FOUR_HOURS = se.ONE_HOUR * 24, se.ONE_DAY = se.TWENTY_FOUR_HOURS, se.THREE_DAYS = se.ONE_DAY * 3, se.FIVE_DAYS = se.ONE_DAY * 5, se.SEVEN_DAYS = se.ONE_DAY * 7, se.THIRTY_DAYS = se.ONE_DAY * 30, se.ONE_WEEK = se.SEVEN_DAYS, se.TWO_WEEKS = se.ONE_WEEK * 2, se.THREE_WEEKS = se.ONE_WEEK * 3, se.FOUR_WEEKS = se.ONE_WEEK * 4, se.ONE_YEAR = se.ONE_DAY * 365;
  }(time)), time;
}
var hasRequiredConstants$2;
function requireConstants$2() {
  return hasRequiredConstants$2 || (hasRequiredConstants$2 = 1, function(se) {
    Object.defineProperty(se, "__esModule", { value: !0 });
    const e = tslibExports;
    e.__exportStar(requireMisc(), se), e.__exportStar(requireTime(), se);
  }(constants$3)), constants$3;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert$1;
  hasRequiredConvert = 1, Object.defineProperty(convert$1, "__esModule", { value: !0 }), convert$1.fromMiliseconds = convert$1.toMiliseconds = void 0;
  const se = requireConstants$2();
  function e(Si) {
    return Si * se.ONE_THOUSAND;
  }
  convert$1.toMiliseconds = e;
  function Oe(Si) {
    return Math.floor(Si / se.ONE_THOUSAND);
  }
  return convert$1.fromMiliseconds = Oe, convert$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(se) {
    Object.defineProperty(se, "__esModule", { value: !0 });
    const e = tslibExports;
    e.__exportStar(requireDelay(), se), e.__exportStar(requireConvert(), se);
  }(utils$q)), utils$q;
}
var watch$1 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.Watch = void 0;
  class se {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(Oe) {
      if (this.timestamps.has(Oe))
        throw new Error(`Watch already started for label: ${Oe}`);
      this.timestamps.set(Oe, { started: Date.now() });
    }
    stop(Oe) {
      const Si = this.get(Oe);
      if (typeof Si.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${Oe}`);
      const wi = Date.now() - Si.started;
      this.timestamps.set(Oe, { started: Si.started, elapsed: wi });
    }
    get(Oe) {
      const Si = this.timestamps.get(Oe);
      if (typeof Si > "u")
        throw new Error(`No timestamp found for label: ${Oe}`);
      return Si;
    }
    elapsed(Oe) {
      const Si = this.get(Oe);
      return Si.elapsed || Date.now() - Si.started;
    }
  }
  return watch$1.Watch = se, watch$1.default = se, watch$1;
}
var types$3 = {}, watch = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1, Object.defineProperty(watch, "__esModule", { value: !0 }), watch.IWatch = void 0;
  class se {
  }
  return watch.IWatch = se, watch;
}
var hasRequiredTypes$2;
function requireTypes$2() {
  return hasRequiredTypes$2 || (hasRequiredTypes$2 = 1, function(se) {
    Object.defineProperty(se, "__esModule", { value: !0 }), tslibExports.__exportStar(requireWatch(), se);
  }(types$3)), types$3;
}
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  const e = tslibExports;
  e.__exportStar(requireUtils$1(), se), e.__exportStar(requireWatch$1(), se), e.__exportStar(requireTypes$2(), se), e.__exportStar(requireConstants$2(), se);
})(cjs$4);
var types$2 = {}, heartbeat$1 = {};
let IEvents$1 = class {
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: IEvents$1
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(esm);
var hasRequiredHeartbeat$2;
function requireHeartbeat$2() {
  if (hasRequiredHeartbeat$2)
    return heartbeat$1;
  hasRequiredHeartbeat$2 = 1, Object.defineProperty(heartbeat$1, "__esModule", { value: !0 }), heartbeat$1.IHeartBeat = void 0;
  const se = require$$0$1;
  class e extends se.IEvents {
    constructor(Si) {
      super();
    }
  }
  return heartbeat$1.IHeartBeat = e, heartbeat$1;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(se) {
    Object.defineProperty(se, "__esModule", { value: !0 }), tslibExports.__exportStar(requireHeartbeat$2(), se);
  }(types$2)), types$2;
}
var constants$2 = {}, heartbeat = {}, hasRequiredHeartbeat$1;
function requireHeartbeat$1() {
  if (hasRequiredHeartbeat$1)
    return heartbeat;
  hasRequiredHeartbeat$1 = 1, Object.defineProperty(heartbeat, "__esModule", { value: !0 }), heartbeat.HEARTBEAT_EVENTS = heartbeat.HEARTBEAT_INTERVAL = void 0;
  const se = cjs$4;
  return heartbeat.HEARTBEAT_INTERVAL = se.FIVE_SECONDS, heartbeat.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, heartbeat;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, function(se) {
    Object.defineProperty(se, "__esModule", { value: !0 }), tslibExports.__exportStar(requireHeartbeat$1(), se);
  }(constants$2)), constants$2;
}
var hasRequiredHeartbeat;
function requireHeartbeat() {
  if (hasRequiredHeartbeat)
    return heartbeat$2;
  hasRequiredHeartbeat = 1, Object.defineProperty(heartbeat$2, "__esModule", { value: !0 }), heartbeat$2.HeartBeat = void 0;
  const se = tslibExports, e = c$5, Oe = cjs$4, Si = requireTypes$1(), wi = requireConstants$1();
  class Ei extends Si.IHeartBeat {
    constructor(xi) {
      super(xi), this.events = new e.EventEmitter(), this.interval = wi.HEARTBEAT_INTERVAL, this.interval = (xi == null ? void 0 : xi.interval) || wi.HEARTBEAT_INTERVAL;
    }
    static init(xi) {
      return se.__awaiter(this, void 0, void 0, function* () {
        const Ri = new Ei(xi);
        return yield Ri.init(), Ri;
      });
    }
    init() {
      return se.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(xi, Ri) {
      this.events.on(xi, Ri);
    }
    once(xi, Ri) {
      this.events.once(xi, Ri);
    }
    off(xi, Ri) {
      this.events.off(xi, Ri);
    }
    removeListener(xi, Ri) {
      this.events.removeListener(xi, Ri);
    }
    initialize() {
      return se.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), Oe.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(wi.HEARTBEAT_EVENTS.pulse);
    }
  }
  return heartbeat$2.HeartBeat = Ei, heartbeat$2;
}
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  const e = tslibExports;
  e.__exportStar(requireHeartbeat(), se), e.__exportStar(requireTypes$1(), se), e.__exportStar(requireConstants$1(), se);
})(cjs$5);
var cjs$3 = {}, quickFormatUnescaped, hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped)
    return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function se(Oe) {
    try {
      return JSON.stringify(Oe);
    } catch {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = e;
  function e(Oe, Si, wi) {
    var Ei = wi && wi.stringify || se, $i = 1;
    if (typeof Oe == "object" && Oe !== null) {
      var xi = Si.length + $i;
      if (xi === 1)
        return Oe;
      var Ri = new Array(xi);
      Ri[0] = Ei(Oe);
      for (var Ti = 1; Ti < xi; Ti++)
        Ri[Ti] = Ei(Si[Ti]);
      return Ri.join(" ");
    }
    if (typeof Oe != "string")
      return Oe;
    var Oi = Si.length;
    if (Oi === 0)
      return Oe;
    for (var Mi = "", Ii = 1 - $i, Ci = -1, Oo = Oe && Oe.length || 0, Ro = 0; Ro < Oo; ) {
      if (Oe.charCodeAt(Ro) === 37 && Ro + 1 < Oo) {
        switch (Ci = Ci > -1 ? Ci : 0, Oe.charCodeAt(Ro + 1)) {
          case 100:
          case 102:
            if (Ii >= Oi || Si[Ii] == null)
              break;
            Ci < Ro && (Mi += Oe.slice(Ci, Ro)), Mi += Number(Si[Ii]), Ci = Ro + 2, Ro++;
            break;
          case 105:
            if (Ii >= Oi || Si[Ii] == null)
              break;
            Ci < Ro && (Mi += Oe.slice(Ci, Ro)), Mi += Math.floor(Number(Si[Ii])), Ci = Ro + 2, Ro++;
            break;
          case 79:
          case 111:
          case 106:
            if (Ii >= Oi || Si[Ii] === void 0)
              break;
            Ci < Ro && (Mi += Oe.slice(Ci, Ro));
            var Bo = typeof Si[Ii];
            if (Bo === "string") {
              Mi += "'" + Si[Ii] + "'", Ci = Ro + 2, Ro++;
              break;
            }
            if (Bo === "function") {
              Mi += Si[Ii].name || "<anonymous>", Ci = Ro + 2, Ro++;
              break;
            }
            Mi += Ei(Si[Ii]), Ci = Ro + 2, Ro++;
            break;
          case 115:
            if (Ii >= Oi)
              break;
            Ci < Ro && (Mi += Oe.slice(Ci, Ro)), Mi += String(Si[Ii]), Ci = Ro + 2, Ro++;
            break;
          case 37:
            Ci < Ro && (Mi += Oe.slice(Ci, Ro)), Mi += "%", Ci = Ro + 2, Ro++, Ii--;
            break;
        }
        ++Ii;
      }
      ++Ro;
    }
    return Ci === -1 ? Oe : (Ci < Oo && (Mi += Oe.slice(Ci)), Mi);
  }
  return quickFormatUnescaped;
}
var browser$1, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$1;
  hasRequiredBrowser = 1;
  const se = requireQuickFormatUnescaped();
  browser$1 = wi;
  const e = ko().console || {}, Oe = {
    mapHttpRequest: Oo,
    mapHttpResponse: Oo,
    wrapRequestSerializer: Ro,
    wrapResponseSerializer: Ro,
    wrapErrorSerializer: Ro,
    req: Oo,
    res: Oo,
    err: Ii
  };
  function Si(Po, Mo) {
    return Array.isArray(Po) ? Po.filter(function(Jo) {
      return Jo !== "!stdSerializers.err";
    }) : Po === !0 ? Object.keys(Mo) : !1;
  }
  function wi(Po) {
    Po = Po || {}, Po.browser = Po.browser || {};
    const Mo = Po.browser.transmit;
    if (Mo && typeof Mo.send != "function")
      throw Error("pino: transmit option must have a send function");
    const No = Po.browser.write || e;
    Po.browser.write && (Po.browser.asObject = !0);
    const Jo = Po.serializers || {}, zo = Si(Po.browser.serialize, Jo);
    let Do = Po.browser.serialize;
    Array.isArray(Po.browser.serialize) && Po.browser.serialize.indexOf("!stdSerializers.err") > -1 && (Do = !1);
    const wo = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof No == "function" && (No.error = No.fatal = No.warn = No.info = No.debug = No.trace = No), Po.enabled === !1 && (Po.level = "silent");
    const Li = Po.level || "info", Ai = Object.create(No);
    Ai.log || (Ai.log = Bo), Object.defineProperty(Ai, "levelVal", {
      get: Ui
    }), Object.defineProperty(Ai, "level", {
      get: So,
      set: $o
    });
    const Ni = {
      transmit: Mo,
      serialize: zo,
      asObject: Po.browser.asObject,
      levels: wo,
      timestamp: Ci(Po)
    };
    Ai.levels = wi.levels, Ai.level = Li, Ai.setMaxListeners = Ai.getMaxListeners = Ai.emit = Ai.addListener = Ai.on = Ai.prependListener = Ai.once = Ai.prependOnceListener = Ai.removeListener = Ai.removeAllListeners = Ai.listeners = Ai.listenerCount = Ai.eventNames = Ai.write = Ai.flush = Bo, Ai.serializers = Jo, Ai._serialize = zo, Ai._stdErrSerialize = Do, Ai.child = Eo, Mo && (Ai._logEvent = Mi());
    function Ui() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function So() {
      return this._level;
    }
    function $o(zi) {
      if (zi !== "silent" && !this.levels.values[zi])
        throw Error("unknown level " + zi);
      this._level = zi, Ei(Ni, Ai, "error", "log"), Ei(Ni, Ai, "fatal", "error"), Ei(Ni, Ai, "warn", "error"), Ei(Ni, Ai, "info", "log"), Ei(Ni, Ai, "debug", "log"), Ei(Ni, Ai, "trace", "log");
    }
    function Eo(zi, _o) {
      if (!zi)
        throw new Error("missing bindings for child Pino");
      _o = _o || {}, zo && zi.serializers && (_o.serializers = zi.serializers);
      const Fi = _o.serializers;
      if (zo && Fi) {
        var xo = Object.assign({}, Jo, Fi), Qo = Po.browser.serialize === !0 ? Object.keys(xo) : zo;
        delete zi.serializers, Ri([zi], Qo, xo, this._stdErrSerialize);
      }
      function To(Ko) {
        this._childLevel = (Ko._childLevel | 0) + 1, this.error = Ti(Ko, zi, "error"), this.fatal = Ti(Ko, zi, "fatal"), this.warn = Ti(Ko, zi, "warn"), this.info = Ti(Ko, zi, "info"), this.debug = Ti(Ko, zi, "debug"), this.trace = Ti(Ko, zi, "trace"), xo && (this.serializers = xo, this._serialize = Qo), Mo && (this._logEvent = Mi(
          [].concat(Ko._logEvent.bindings, zi)
        ));
      }
      return To.prototype = this, new To(this);
    }
    return Ai;
  }
  wi.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, wi.stdSerializers = Oe, wi.stdTimeFunctions = Object.assign({}, { nullTime: Fo, epochTime: Io, unixTime: Uo, isoTime: Co });
  function Ei(Po, Mo, No, Jo) {
    const zo = Object.getPrototypeOf(Mo);
    Mo[No] = Mo.levelVal > Mo.levels.values[No] ? Bo : zo[No] ? zo[No] : e[No] || e[Jo] || Bo, $i(Po, Mo, No);
  }
  function $i(Po, Mo, No) {
    !Po.transmit && Mo[No] === Bo || (Mo[No] = function(Jo) {
      return function() {
        const Do = Po.timestamp(), wo = new Array(arguments.length), Li = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var Ai = 0; Ai < wo.length; Ai++)
          wo[Ai] = arguments[Ai];
        if (Po.serialize && !Po.asObject && Ri(wo, this._serialize, this.serializers, this._stdErrSerialize), Po.asObject ? Jo.call(Li, xi(this, No, wo, Do)) : Jo.apply(Li, wo), Po.transmit) {
          const Ni = Po.transmit.level || Mo.level, Ui = wi.levels.values[Ni], So = wi.levels.values[No];
          if (So < Ui)
            return;
          Oi(this, {
            ts: Do,
            methodLevel: No,
            methodValue: So,
            transmitLevel: Ni,
            transmitValue: wi.levels.values[Po.transmit.level || Mo.level],
            send: Po.transmit.send,
            val: Mo.levelVal
          }, wo);
        }
      };
    }(Mo[No]));
  }
  function xi(Po, Mo, No, Jo) {
    Po._serialize && Ri(No, Po._serialize, Po.serializers, Po._stdErrSerialize);
    const zo = No.slice();
    let Do = zo[0];
    const wo = {};
    Jo && (wo.time = Jo), wo.level = wi.levels.values[Mo];
    let Li = (Po._childLevel | 0) + 1;
    if (Li < 1 && (Li = 1), Do !== null && typeof Do == "object") {
      for (; Li-- && typeof zo[0] == "object"; )
        Object.assign(wo, zo.shift());
      Do = zo.length ? se(zo.shift(), zo) : void 0;
    } else
      typeof Do == "string" && (Do = se(zo.shift(), zo));
    return Do !== void 0 && (wo.msg = Do), wo;
  }
  function Ri(Po, Mo, No, Jo) {
    for (const zo in Po)
      if (Jo && Po[zo] instanceof Error)
        Po[zo] = wi.stdSerializers.err(Po[zo]);
      else if (typeof Po[zo] == "object" && !Array.isArray(Po[zo]))
        for (const Do in Po[zo])
          Mo && Mo.indexOf(Do) > -1 && Do in No && (Po[zo][Do] = No[Do](Po[zo][Do]));
  }
  function Ti(Po, Mo, No) {
    return function() {
      const Jo = new Array(1 + arguments.length);
      Jo[0] = Mo;
      for (var zo = 1; zo < Jo.length; zo++)
        Jo[zo] = arguments[zo - 1];
      return Po[No].apply(this, Jo);
    };
  }
  function Oi(Po, Mo, No) {
    const Jo = Mo.send, zo = Mo.ts, Do = Mo.methodLevel, wo = Mo.methodValue, Li = Mo.val, Ai = Po._logEvent.bindings;
    Ri(
      No,
      Po._serialize || Object.keys(Po.serializers),
      Po.serializers,
      Po._stdErrSerialize === void 0 ? !0 : Po._stdErrSerialize
    ), Po._logEvent.ts = zo, Po._logEvent.messages = No.filter(function(Ni) {
      return Ai.indexOf(Ni) === -1;
    }), Po._logEvent.level.label = Do, Po._logEvent.level.value = wo, Jo(Do, Po._logEvent, Li), Po._logEvent = Mi(Ai);
  }
  function Mi(Po) {
    return {
      ts: 0,
      messages: [],
      bindings: Po || [],
      level: { label: "", value: 0 }
    };
  }
  function Ii(Po) {
    const Mo = {
      type: Po.constructor.name,
      msg: Po.message,
      stack: Po.stack
    };
    for (const No in Po)
      Mo[No] === void 0 && (Mo[No] = Po[No]);
    return Mo;
  }
  function Ci(Po) {
    return typeof Po.timestamp == "function" ? Po.timestamp : Po.timestamp === !1 ? Fo : Io;
  }
  function Oo() {
    return {};
  }
  function Ro(Po) {
    return Po;
  }
  function Bo() {
  }
  function Fo() {
    return !1;
  }
  function Io() {
    return Date.now();
  }
  function Uo() {
    return Math.round(Date.now() / 1e3);
  }
  function Co() {
    return new Date(Date.now()).toISOString();
  }
  function ko() {
    function Po(Mo) {
      return typeof Mo < "u" && Mo;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return Po(self) || Po(window) || Po(this) || {};
    }
  }
  return browser$1;
}
var constants$1 = {}, hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, Object.defineProperty(constants$1, "__esModule", { value: !0 }), constants$1.PINO_CUSTOM_CONTEXT_KEY = constants$1.PINO_LOGGER_DEFAULTS = void 0, constants$1.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, constants$1.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), constants$1;
}
var utils$p = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$p;
  hasRequiredUtils = 1, Object.defineProperty(utils$p, "__esModule", { value: !0 }), utils$p.generateChildLogger = utils$p.formatChildLoggerContext = utils$p.getLoggerContext = utils$p.setBrowserLoggerContext = utils$p.getBrowserLoggerContext = utils$p.getDefaultLoggerOptions = void 0;
  const se = requireConstants();
  function e(xi) {
    return Object.assign(Object.assign({}, xi), { level: (xi == null ? void 0 : xi.level) || se.PINO_LOGGER_DEFAULTS.level });
  }
  utils$p.getDefaultLoggerOptions = e;
  function Oe(xi, Ri = se.PINO_CUSTOM_CONTEXT_KEY) {
    return xi[Ri] || "";
  }
  utils$p.getBrowserLoggerContext = Oe;
  function Si(xi, Ri, Ti = se.PINO_CUSTOM_CONTEXT_KEY) {
    return xi[Ti] = Ri, xi;
  }
  utils$p.setBrowserLoggerContext = Si;
  function wi(xi, Ri = se.PINO_CUSTOM_CONTEXT_KEY) {
    let Ti = "";
    return typeof xi.bindings > "u" ? Ti = Oe(xi, Ri) : Ti = xi.bindings().context || "", Ti;
  }
  utils$p.getLoggerContext = wi;
  function Ei(xi, Ri, Ti = se.PINO_CUSTOM_CONTEXT_KEY) {
    const Oi = wi(xi, Ti);
    return Oi.trim() ? `${Oi}/${Ri}` : Ri;
  }
  utils$p.formatChildLoggerContext = Ei;
  function $i(xi, Ri, Ti = se.PINO_CUSTOM_CONTEXT_KEY) {
    const Oi = Ei(xi, Ri, Ti), Mi = xi.child({ context: Oi });
    return Si(Mi, Oi, Ti);
  }
  return utils$p.generateChildLogger = $i, utils$p;
}
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 }), se.pino = void 0;
  const e = tslibExports, Oe = e.__importDefault(requireBrowser());
  Object.defineProperty(se, "pino", { enumerable: !0, get: function() {
    return Oe.default;
  } }), e.__exportStar(requireConstants(), se), e.__exportStar(requireUtils(), se);
})(cjs$3);
let n$4 = class extends IEvents$1 {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, h$4 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.core = e, this.logger = Oe, this.records = /* @__PURE__ */ new Map();
  }
}, a$1 = class {
  constructor(e, Oe) {
    this.logger = e, this.core = Oe;
  }
}, u$1 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.relayer = e, this.logger = Oe;
  }
}, g$6 = class extends IEvents$1 {
  constructor(e) {
    super();
  }
}, p$4 = class {
  constructor(e, Oe, Si, wi) {
    this.core = e, this.logger = Oe, this.name = Si;
  }
}, d$3 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.relayer = e, this.logger = Oe;
  }
}, E$4 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.core = e, this.logger = Oe;
  }
}, y$5 = class {
  constructor(e, Oe) {
    this.projectId = e, this.logger = Oe;
  }
}, b$5 = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, S$4 = class {
  constructor(e) {
    this.client = e;
  }
};
var ed25519 = {}, random = {}, system = {}, browser = {};
Object.defineProperty(browser, "__esModule", { value: !0 });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const Oe = new Uint8Array(e);
    for (let Si = 0; Si < Oe.length; Si += QUOTA)
      this._crypto.getRandomValues(Oe.subarray(Si, Si + Math.min(Oe.length - Si, QUOTA)));
    return Oe;
  }
}
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire$1(se) {
  throw new Error('Could not dynamically require "' + se + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {}, wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(se) {
  for (var e = 0; e < se.length; e++)
    se[e] = 0;
  return se;
}
wipe$1.wipe = wipe;
Object.defineProperty(node, "__esModule", { value: !0 });
node.NodeRandomSource = void 0;
const wipe_1$3 = wipe$1;
class NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire$1 < "u") {
      const e = require$$1;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let Oe = this._crypto.randomBytes(e);
    if (Oe.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const Si = new Uint8Array(e);
    for (let wi = 0; wi < Si.length; wi++)
      Si[wi] = Oe[wi];
    return (0, wipe_1$3.wipe)(Oe), Si;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser, node_1 = node;
class SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {}, int = {};
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  function e(xi, Ri) {
    var Ti = xi >>> 16 & 65535, Oi = xi & 65535, Mi = Ri >>> 16 & 65535, Ii = Ri & 65535;
    return Oi * Ii + (Ti * Ii + Oi * Mi << 16 >>> 0) | 0;
  }
  se.mul = Math.imul || e;
  function Oe(xi, Ri) {
    return xi + Ri | 0;
  }
  se.add = Oe;
  function Si(xi, Ri) {
    return xi - Ri | 0;
  }
  se.sub = Si;
  function wi(xi, Ri) {
    return xi << Ri | xi >>> 32 - Ri;
  }
  se.rotl = wi;
  function Ei(xi, Ri) {
    return xi << 32 - Ri | xi >>> Ri;
  }
  se.rotr = Ei;
  function $i(xi) {
    return typeof xi == "number" && isFinite(xi) && Math.floor(xi) === xi;
  }
  se.isInteger = Number.isInteger || $i, se.MAX_SAFE_INTEGER = 9007199254740991, se.isSafeInteger = function(xi) {
    return se.isInteger(xi) && xi >= -se.MAX_SAFE_INTEGER && xi <= se.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(se, e) {
  return e === void 0 && (e = 0), (se[e + 0] << 8 | se[e + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(se, e) {
  return e === void 0 && (e = 0), (se[e + 0] << 8 | se[e + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(se, e) {
  return e === void 0 && (e = 0), (se[e + 1] << 8 | se[e]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(se, e) {
  return e === void 0 && (e = 0), (se[e + 1] << 8 | se[e]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(se, e, Oe) {
  return e === void 0 && (e = new Uint8Array(2)), Oe === void 0 && (Oe = 0), e[Oe + 0] = se >>> 8, e[Oe + 1] = se >>> 0, e;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(se, e, Oe) {
  return e === void 0 && (e = new Uint8Array(2)), Oe === void 0 && (Oe = 0), e[Oe + 0] = se >>> 0, e[Oe + 1] = se >>> 8, e;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(se, e) {
  return e === void 0 && (e = 0), se[e] << 24 | se[e + 1] << 16 | se[e + 2] << 8 | se[e + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(se, e) {
  return e === void 0 && (e = 0), (se[e] << 24 | se[e + 1] << 16 | se[e + 2] << 8 | se[e + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(se, e) {
  return e === void 0 && (e = 0), se[e + 3] << 24 | se[e + 2] << 16 | se[e + 1] << 8 | se[e];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(se, e) {
  return e === void 0 && (e = 0), (se[e + 3] << 24 | se[e + 2] << 16 | se[e + 1] << 8 | se[e]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(se, e, Oe) {
  return e === void 0 && (e = new Uint8Array(4)), Oe === void 0 && (Oe = 0), e[Oe + 0] = se >>> 24, e[Oe + 1] = se >>> 16, e[Oe + 2] = se >>> 8, e[Oe + 3] = se >>> 0, e;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(se, e, Oe) {
  return e === void 0 && (e = new Uint8Array(4)), Oe === void 0 && (Oe = 0), e[Oe + 0] = se >>> 0, e[Oe + 1] = se >>> 8, e[Oe + 2] = se >>> 16, e[Oe + 3] = se >>> 24, e;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(se, e) {
  e === void 0 && (e = 0);
  var Oe = readInt32BE(se, e), Si = readInt32BE(se, e + 4);
  return Oe * 4294967296 + Si - (Si >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(se, e) {
  e === void 0 && (e = 0);
  var Oe = readUint32BE(se, e), Si = readUint32BE(se, e + 4);
  return Oe * 4294967296 + Si;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(se, e) {
  e === void 0 && (e = 0);
  var Oe = readInt32LE(se, e), Si = readInt32LE(se, e + 4);
  return Si * 4294967296 + Oe - (Oe >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(se, e) {
  e === void 0 && (e = 0);
  var Oe = readUint32LE(se, e), Si = readUint32LE(se, e + 4);
  return Si * 4294967296 + Oe;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(se, e, Oe) {
  return e === void 0 && (e = new Uint8Array(8)), Oe === void 0 && (Oe = 0), writeUint32BE(se / 4294967296 >>> 0, e, Oe), writeUint32BE(se >>> 0, e, Oe + 4), e;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(se, e, Oe) {
  return e === void 0 && (e = new Uint8Array(8)), Oe === void 0 && (Oe = 0), writeUint32LE(se >>> 0, e, Oe), writeUint32LE(se / 4294967296 >>> 0, e, Oe + 4), e;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(se, e, Oe) {
  if (Oe === void 0 && (Oe = 0), se % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (se / 8 > e.length - Oe)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var Si = 0, wi = 1, Ei = se / 8 + Oe - 1; Ei >= Oe; Ei--)
    Si += e[Ei] * wi, wi *= 256;
  return Si;
}
binary.readUintBE = readUintBE;
function readUintLE(se, e, Oe) {
  if (Oe === void 0 && (Oe = 0), se % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (se / 8 > e.length - Oe)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var Si = 0, wi = 1, Ei = Oe; Ei < Oe + se / 8; Ei++)
    Si += e[Ei] * wi, wi *= 256;
  return Si;
}
binary.readUintLE = readUintLE;
function writeUintBE(se, e, Oe, Si) {
  if (Oe === void 0 && (Oe = new Uint8Array(se / 8)), Si === void 0 && (Si = 0), se % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var wi = 1, Ei = se / 8 + Si - 1; Ei >= Si; Ei--)
    Oe[Ei] = e / wi & 255, wi *= 256;
  return Oe;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(se, e, Oe, Si) {
  if (Oe === void 0 && (Oe = new Uint8Array(se / 8)), Si === void 0 && (Si = 0), se % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var wi = 1, Ei = Si; Ei < Si + se / 8; Ei++)
    Oe[Ei] = e / wi & 255, wi *= 256;
  return Oe;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(se, e) {
  e === void 0 && (e = 0);
  var Oe = new DataView(se.buffer, se.byteOffset, se.byteLength);
  return Oe.getFloat32(e);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(se, e) {
  e === void 0 && (e = 0);
  var Oe = new DataView(se.buffer, se.byteOffset, se.byteLength);
  return Oe.getFloat32(e, !0);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(se, e) {
  e === void 0 && (e = 0);
  var Oe = new DataView(se.buffer, se.byteOffset, se.byteLength);
  return Oe.getFloat64(e);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(se, e) {
  e === void 0 && (e = 0);
  var Oe = new DataView(se.buffer, se.byteOffset, se.byteLength);
  return Oe.getFloat64(e, !0);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(se, e, Oe) {
  e === void 0 && (e = new Uint8Array(4)), Oe === void 0 && (Oe = 0);
  var Si = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return Si.setFloat32(Oe, se), e;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(se, e, Oe) {
  e === void 0 && (e = new Uint8Array(4)), Oe === void 0 && (Oe = 0);
  var Si = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return Si.setFloat32(Oe, se, !0), e;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(se, e, Oe) {
  e === void 0 && (e = new Uint8Array(8)), Oe === void 0 && (Oe = 0);
  var Si = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return Si.setFloat64(Oe, se), e;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(se, e, Oe) {
  e === void 0 && (e = new Uint8Array(8)), Oe === void 0 && (Oe = 0);
  var Si = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return Si.setFloat64(Oe, se, !0), e;
}
binary.writeFloat64LE = writeFloat64LE;
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 }), se.randomStringForEntropy = se.randomString = se.randomUint32 = se.randomBytes = se.defaultRandomSource = void 0;
  const e = system, Oe = binary, Si = wipe$1;
  se.defaultRandomSource = new e.SystemRandomSource();
  function wi(Ti, Oi = se.defaultRandomSource) {
    return Oi.randomBytes(Ti);
  }
  se.randomBytes = wi;
  function Ei(Ti = se.defaultRandomSource) {
    const Oi = wi(4, Ti), Mi = (0, Oe.readUint32LE)(Oi);
    return (0, Si.wipe)(Oi), Mi;
  }
  se.randomUint32 = Ei;
  const $i = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function xi(Ti, Oi = $i, Mi = se.defaultRandomSource) {
    if (Oi.length < 2)
      throw new Error("randomString charset is too short");
    if (Oi.length > 256)
      throw new Error("randomString charset is too long");
    let Ii = "";
    const Ci = Oi.length, Oo = 256 - 256 % Ci;
    for (; Ti > 0; ) {
      const Ro = wi(Math.ceil(Ti * 256 / Oo), Mi);
      for (let Bo = 0; Bo < Ro.length && Ti > 0; Bo++) {
        const Fo = Ro[Bo];
        Fo < Oo && (Ii += Oi.charAt(Fo % Ci), Ti--);
      }
      (0, Si.wipe)(Ro);
    }
    return Ii;
  }
  se.randomString = xi;
  function Ri(Ti, Oi = $i, Mi = se.defaultRandomSource) {
    const Ii = Math.ceil(Ti / (Math.log(Oi.length) / Math.LN2));
    return xi(Ii, Oi, Mi);
  }
  se.randomStringForEntropy = Ri;
})(random);
var sha512 = {};
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  var e = binary, Oe = wipe$1;
  se.DIGEST_LENGTH = 64, se.BLOCK_SIZE = 128;
  var Si = (
    /** @class */
    function() {
      function xi() {
        this.digestLength = se.DIGEST_LENGTH, this.blockSize = se.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return xi.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, xi.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, xi.prototype.clean = function() {
        Oe.wipe(this._buffer), Oe.wipe(this._tempHi), Oe.wipe(this._tempLo), this.reset();
      }, xi.prototype.update = function(Ri, Ti) {
        if (Ti === void 0 && (Ti = Ri.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var Oi = 0;
        if (this._bytesHashed += Ti, this._bufferLength > 0) {
          for (; this._bufferLength < se.BLOCK_SIZE && Ti > 0; )
            this._buffer[this._bufferLength++] = Ri[Oi++], Ti--;
          this._bufferLength === this.blockSize && (Ei(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (Ti >= this.blockSize && (Oi = Ei(this._tempHi, this._tempLo, this._stateHi, this._stateLo, Ri, Oi, Ti), Ti %= this.blockSize); Ti > 0; )
          this._buffer[this._bufferLength++] = Ri[Oi++], Ti--;
        return this;
      }, xi.prototype.finish = function(Ri) {
        if (!this._finished) {
          var Ti = this._bytesHashed, Oi = this._bufferLength, Mi = Ti / 536870912 | 0, Ii = Ti << 3, Ci = Ti % 128 < 112 ? 128 : 256;
          this._buffer[Oi] = 128;
          for (var Oo = Oi + 1; Oo < Ci - 8; Oo++)
            this._buffer[Oo] = 0;
          e.writeUint32BE(Mi, this._buffer, Ci - 8), e.writeUint32BE(Ii, this._buffer, Ci - 4), Ei(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, Ci), this._finished = !0;
        }
        for (var Oo = 0; Oo < this.digestLength / 8; Oo++)
          e.writeUint32BE(this._stateHi[Oo], Ri, Oo * 8), e.writeUint32BE(this._stateLo[Oo], Ri, Oo * 8 + 4);
        return this;
      }, xi.prototype.digest = function() {
        var Ri = new Uint8Array(this.digestLength);
        return this.finish(Ri), Ri;
      }, xi.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, xi.prototype.restoreState = function(Ri) {
        return this._stateHi.set(Ri.stateHi), this._stateLo.set(Ri.stateLo), this._bufferLength = Ri.bufferLength, Ri.buffer && this._buffer.set(Ri.buffer), this._bytesHashed = Ri.bytesHashed, this._finished = !1, this;
      }, xi.prototype.cleanSavedState = function(Ri) {
        Oe.wipe(Ri.stateHi), Oe.wipe(Ri.stateLo), Ri.buffer && Oe.wipe(Ri.buffer), Ri.bufferLength = 0, Ri.bytesHashed = 0;
      }, xi;
    }()
  );
  se.SHA512 = Si;
  var wi = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function Ei(xi, Ri, Ti, Oi, Mi, Ii, Ci) {
    for (var Oo = Ti[0], Ro = Ti[1], Bo = Ti[2], Fo = Ti[3], Io = Ti[4], Uo = Ti[5], Co = Ti[6], ko = Ti[7], Po = Oi[0], Mo = Oi[1], No = Oi[2], Jo = Oi[3], zo = Oi[4], Do = Oi[5], wo = Oi[6], Li = Oi[7], Ai, Ni, Ui, So, $o, Eo, zi, _o; Ci >= 128; ) {
      for (var Fi = 0; Fi < 16; Fi++) {
        var xo = 8 * Fi + Ii;
        xi[Fi] = e.readUint32BE(Mi, xo), Ri[Fi] = e.readUint32BE(Mi, xo + 4);
      }
      for (var Fi = 0; Fi < 80; Fi++) {
        var Qo = Oo, To = Ro, Ko = Bo, Vo = Fo, Wo = Io, jo = Uo, Ao = Co, Lo = ko, Zo = Po, An = Mo, ra = No, sa = Jo, Ma = zo, ba = Do, ma = wo, Va = Li;
        if (Ai = ko, Ni = Li, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = (Io >>> 14 | zo << 32 - 14) ^ (Io >>> 18 | zo << 32 - 18) ^ (zo >>> 41 - 32 | Io << 32 - (41 - 32)), Ni = (zo >>> 14 | Io << 32 - 14) ^ (zo >>> 18 | Io << 32 - 18) ^ (Io >>> 41 - 32 | zo << 32 - (41 - 32)), $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Ai = Io & Uo ^ ~Io & Co, Ni = zo & Do ^ ~zo & wo, $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Ai = wi[Fi * 2], Ni = wi[Fi * 2 + 1], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Ai = xi[Fi % 16], Ni = Ri[Fi % 16], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ui = zi & 65535 | _o << 16, So = $o & 65535 | Eo << 16, Ai = Ui, Ni = So, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = (Oo >>> 28 | Po << 32 - 28) ^ (Po >>> 34 - 32 | Oo << 32 - (34 - 32)) ^ (Po >>> 39 - 32 | Oo << 32 - (39 - 32)), Ni = (Po >>> 28 | Oo << 32 - 28) ^ (Oo >>> 34 - 32 | Po << 32 - (34 - 32)) ^ (Oo >>> 39 - 32 | Po << 32 - (39 - 32)), $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Ai = Oo & Ro ^ Oo & Bo ^ Ro & Bo, Ni = Po & Mo ^ Po & No ^ Mo & No, $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Lo = zi & 65535 | _o << 16, Va = $o & 65535 | Eo << 16, Ai = Vo, Ni = sa, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ui, Ni = So, $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Vo = zi & 65535 | _o << 16, sa = $o & 65535 | Eo << 16, Ro = Qo, Bo = To, Fo = Ko, Io = Vo, Uo = Wo, Co = jo, ko = Ao, Oo = Lo, Mo = Zo, No = An, Jo = ra, zo = sa, Do = Ma, wo = ba, Li = ma, Po = Va, Fi % 16 === 15)
          for (var xo = 0; xo < 16; xo++)
            Ai = xi[xo], Ni = Ri[xo], $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = xi[(xo + 9) % 16], Ni = Ri[(xo + 9) % 16], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Ui = xi[(xo + 1) % 16], So = Ri[(xo + 1) % 16], Ai = (Ui >>> 1 | So << 32 - 1) ^ (Ui >>> 8 | So << 32 - 8) ^ Ui >>> 7, Ni = (So >>> 1 | Ui << 32 - 1) ^ (So >>> 8 | Ui << 32 - 8) ^ (So >>> 7 | Ui << 32 - 7), $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Ui = xi[(xo + 14) % 16], So = Ri[(xo + 14) % 16], Ai = (Ui >>> 19 | So << 32 - 19) ^ (So >>> 61 - 32 | Ui << 32 - (61 - 32)) ^ Ui >>> 6, Ni = (So >>> 19 | Ui << 32 - 19) ^ (Ui >>> 61 - 32 | So << 32 - (61 - 32)) ^ (So >>> 6 | Ui << 32 - 6), $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, xi[xo] = zi & 65535 | _o << 16, Ri[xo] = $o & 65535 | Eo << 16;
      }
      Ai = Oo, Ni = Po, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[0], Ni = Oi[0], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[0] = Oo = zi & 65535 | _o << 16, Oi[0] = Po = $o & 65535 | Eo << 16, Ai = Ro, Ni = Mo, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[1], Ni = Oi[1], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[1] = Ro = zi & 65535 | _o << 16, Oi[1] = Mo = $o & 65535 | Eo << 16, Ai = Bo, Ni = No, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[2], Ni = Oi[2], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[2] = Bo = zi & 65535 | _o << 16, Oi[2] = No = $o & 65535 | Eo << 16, Ai = Fo, Ni = Jo, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[3], Ni = Oi[3], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[3] = Fo = zi & 65535 | _o << 16, Oi[3] = Jo = $o & 65535 | Eo << 16, Ai = Io, Ni = zo, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[4], Ni = Oi[4], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[4] = Io = zi & 65535 | _o << 16, Oi[4] = zo = $o & 65535 | Eo << 16, Ai = Uo, Ni = Do, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[5], Ni = Oi[5], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[5] = Uo = zi & 65535 | _o << 16, Oi[5] = Do = $o & 65535 | Eo << 16, Ai = Co, Ni = wo, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[6], Ni = Oi[6], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[6] = Co = zi & 65535 | _o << 16, Oi[6] = wo = $o & 65535 | Eo << 16, Ai = ko, Ni = Li, $o = Ni & 65535, Eo = Ni >>> 16, zi = Ai & 65535, _o = Ai >>> 16, Ai = Ti[7], Ni = Oi[7], $o += Ni & 65535, Eo += Ni >>> 16, zi += Ai & 65535, _o += Ai >>> 16, Eo += $o >>> 16, zi += Eo >>> 16, _o += zi >>> 16, Ti[7] = ko = zi & 65535 | _o << 16, Oi[7] = Li = $o & 65535 | Eo << 16, Ii += 128, Ci -= 128;
    }
    return Ii;
  }
  function $i(xi) {
    var Ri = new Si();
    Ri.update(xi);
    var Ti = Ri.digest();
    return Ri.clean(), Ti;
  }
  se.hash = $i;
})(sha512);
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 }), se.convertSecretKeyToX25519 = se.convertPublicKeyToX25519 = se.verify = se.sign = se.extractPublicKeyFromSecretKey = se.generateKeyPair = se.generateKeyPairFromSeed = se.SEED_LENGTH = se.SECRET_KEY_LENGTH = se.PUBLIC_KEY_LENGTH = se.SIGNATURE_LENGTH = void 0;
  const e = random, Oe = sha512, Si = wipe$1;
  se.SIGNATURE_LENGTH = 64, se.PUBLIC_KEY_LENGTH = 32, se.SECRET_KEY_LENGTH = 64, se.SEED_LENGTH = 32;
  function wi(Vo) {
    const Wo = new Float64Array(16);
    if (Vo)
      for (let jo = 0; jo < Vo.length; jo++)
        Wo[jo] = Vo[jo];
    return Wo;
  }
  const Ei = new Uint8Array(32);
  Ei[0] = 9;
  const $i = wi(), xi = wi([1]), Ri = wi([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), Ti = wi([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), Oi = wi([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), Mi = wi([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), Ii = wi([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function Ci(Vo, Wo) {
    for (let jo = 0; jo < 16; jo++)
      Vo[jo] = Wo[jo] | 0;
  }
  function Oo(Vo) {
    let Wo = 1;
    for (let jo = 0; jo < 16; jo++) {
      let Ao = Vo[jo] + Wo + 65535;
      Wo = Math.floor(Ao / 65536), Vo[jo] = Ao - Wo * 65536;
    }
    Vo[0] += Wo - 1 + 37 * (Wo - 1);
  }
  function Ro(Vo, Wo, jo) {
    const Ao = ~(jo - 1);
    for (let Lo = 0; Lo < 16; Lo++) {
      const Zo = Ao & (Vo[Lo] ^ Wo[Lo]);
      Vo[Lo] ^= Zo, Wo[Lo] ^= Zo;
    }
  }
  function Bo(Vo, Wo) {
    const jo = wi(), Ao = wi();
    for (let Lo = 0; Lo < 16; Lo++)
      Ao[Lo] = Wo[Lo];
    Oo(Ao), Oo(Ao), Oo(Ao);
    for (let Lo = 0; Lo < 2; Lo++) {
      jo[0] = Ao[0] - 65517;
      for (let An = 1; An < 15; An++)
        jo[An] = Ao[An] - 65535 - (jo[An - 1] >> 16 & 1), jo[An - 1] &= 65535;
      jo[15] = Ao[15] - 32767 - (jo[14] >> 16 & 1);
      const Zo = jo[15] >> 16 & 1;
      jo[14] &= 65535, Ro(Ao, jo, 1 - Zo);
    }
    for (let Lo = 0; Lo < 16; Lo++)
      Vo[2 * Lo] = Ao[Lo] & 255, Vo[2 * Lo + 1] = Ao[Lo] >> 8;
  }
  function Fo(Vo, Wo) {
    let jo = 0;
    for (let Ao = 0; Ao < 32; Ao++)
      jo |= Vo[Ao] ^ Wo[Ao];
    return (1 & jo - 1 >>> 8) - 1;
  }
  function Io(Vo, Wo) {
    const jo = new Uint8Array(32), Ao = new Uint8Array(32);
    return Bo(jo, Vo), Bo(Ao, Wo), Fo(jo, Ao);
  }
  function Uo(Vo) {
    const Wo = new Uint8Array(32);
    return Bo(Wo, Vo), Wo[0] & 1;
  }
  function Co(Vo, Wo) {
    for (let jo = 0; jo < 16; jo++)
      Vo[jo] = Wo[2 * jo] + (Wo[2 * jo + 1] << 8);
    Vo[15] &= 32767;
  }
  function ko(Vo, Wo, jo) {
    for (let Ao = 0; Ao < 16; Ao++)
      Vo[Ao] = Wo[Ao] + jo[Ao];
  }
  function Po(Vo, Wo, jo) {
    for (let Ao = 0; Ao < 16; Ao++)
      Vo[Ao] = Wo[Ao] - jo[Ao];
  }
  function Mo(Vo, Wo, jo) {
    let Ao, Lo, Zo = 0, An = 0, ra = 0, sa = 0, Ma = 0, ba = 0, ma = 0, Va = 0, wa = 0, ha = 0, Fa = 0, Sa = 0, da = 0, Pa = 0, va = 0, ca = 0, Na = 0, Ea = 0, fa = 0, Ca = 0, Oa = 0, ya = 0, Ua = 0, xa = 0, Ra = 0, Ha = 0, ka = 0, Aa = 0, Ga = 0, Wa = 0, $a = 0, qa = jo[0], Ia = jo[1], Ho = jo[2], qo = jo[3], Go = jo[4], Xo = jo[5], ea = jo[6], ia = jo[7], oa = jo[8], aa = jo[9], ua = jo[10], na = jo[11], _a = jo[12], pa = jo[13], la = jo[14], Ba = jo[15];
    Ao = Wo[0], Zo += Ao * qa, An += Ao * Ia, ra += Ao * Ho, sa += Ao * qo, Ma += Ao * Go, ba += Ao * Xo, ma += Ao * ea, Va += Ao * ia, wa += Ao * oa, ha += Ao * aa, Fa += Ao * ua, Sa += Ao * na, da += Ao * _a, Pa += Ao * pa, va += Ao * la, ca += Ao * Ba, Ao = Wo[1], An += Ao * qa, ra += Ao * Ia, sa += Ao * Ho, Ma += Ao * qo, ba += Ao * Go, ma += Ao * Xo, Va += Ao * ea, wa += Ao * ia, ha += Ao * oa, Fa += Ao * aa, Sa += Ao * ua, da += Ao * na, Pa += Ao * _a, va += Ao * pa, ca += Ao * la, Na += Ao * Ba, Ao = Wo[2], ra += Ao * qa, sa += Ao * Ia, Ma += Ao * Ho, ba += Ao * qo, ma += Ao * Go, Va += Ao * Xo, wa += Ao * ea, ha += Ao * ia, Fa += Ao * oa, Sa += Ao * aa, da += Ao * ua, Pa += Ao * na, va += Ao * _a, ca += Ao * pa, Na += Ao * la, Ea += Ao * Ba, Ao = Wo[3], sa += Ao * qa, Ma += Ao * Ia, ba += Ao * Ho, ma += Ao * qo, Va += Ao * Go, wa += Ao * Xo, ha += Ao * ea, Fa += Ao * ia, Sa += Ao * oa, da += Ao * aa, Pa += Ao * ua, va += Ao * na, ca += Ao * _a, Na += Ao * pa, Ea += Ao * la, fa += Ao * Ba, Ao = Wo[4], Ma += Ao * qa, ba += Ao * Ia, ma += Ao * Ho, Va += Ao * qo, wa += Ao * Go, ha += Ao * Xo, Fa += Ao * ea, Sa += Ao * ia, da += Ao * oa, Pa += Ao * aa, va += Ao * ua, ca += Ao * na, Na += Ao * _a, Ea += Ao * pa, fa += Ao * la, Ca += Ao * Ba, Ao = Wo[5], ba += Ao * qa, ma += Ao * Ia, Va += Ao * Ho, wa += Ao * qo, ha += Ao * Go, Fa += Ao * Xo, Sa += Ao * ea, da += Ao * ia, Pa += Ao * oa, va += Ao * aa, ca += Ao * ua, Na += Ao * na, Ea += Ao * _a, fa += Ao * pa, Ca += Ao * la, Oa += Ao * Ba, Ao = Wo[6], ma += Ao * qa, Va += Ao * Ia, wa += Ao * Ho, ha += Ao * qo, Fa += Ao * Go, Sa += Ao * Xo, da += Ao * ea, Pa += Ao * ia, va += Ao * oa, ca += Ao * aa, Na += Ao * ua, Ea += Ao * na, fa += Ao * _a, Ca += Ao * pa, Oa += Ao * la, ya += Ao * Ba, Ao = Wo[7], Va += Ao * qa, wa += Ao * Ia, ha += Ao * Ho, Fa += Ao * qo, Sa += Ao * Go, da += Ao * Xo, Pa += Ao * ea, va += Ao * ia, ca += Ao * oa, Na += Ao * aa, Ea += Ao * ua, fa += Ao * na, Ca += Ao * _a, Oa += Ao * pa, ya += Ao * la, Ua += Ao * Ba, Ao = Wo[8], wa += Ao * qa, ha += Ao * Ia, Fa += Ao * Ho, Sa += Ao * qo, da += Ao * Go, Pa += Ao * Xo, va += Ao * ea, ca += Ao * ia, Na += Ao * oa, Ea += Ao * aa, fa += Ao * ua, Ca += Ao * na, Oa += Ao * _a, ya += Ao * pa, Ua += Ao * la, xa += Ao * Ba, Ao = Wo[9], ha += Ao * qa, Fa += Ao * Ia, Sa += Ao * Ho, da += Ao * qo, Pa += Ao * Go, va += Ao * Xo, ca += Ao * ea, Na += Ao * ia, Ea += Ao * oa, fa += Ao * aa, Ca += Ao * ua, Oa += Ao * na, ya += Ao * _a, Ua += Ao * pa, xa += Ao * la, Ra += Ao * Ba, Ao = Wo[10], Fa += Ao * qa, Sa += Ao * Ia, da += Ao * Ho, Pa += Ao * qo, va += Ao * Go, ca += Ao * Xo, Na += Ao * ea, Ea += Ao * ia, fa += Ao * oa, Ca += Ao * aa, Oa += Ao * ua, ya += Ao * na, Ua += Ao * _a, xa += Ao * pa, Ra += Ao * la, Ha += Ao * Ba, Ao = Wo[11], Sa += Ao * qa, da += Ao * Ia, Pa += Ao * Ho, va += Ao * qo, ca += Ao * Go, Na += Ao * Xo, Ea += Ao * ea, fa += Ao * ia, Ca += Ao * oa, Oa += Ao * aa, ya += Ao * ua, Ua += Ao * na, xa += Ao * _a, Ra += Ao * pa, Ha += Ao * la, ka += Ao * Ba, Ao = Wo[12], da += Ao * qa, Pa += Ao * Ia, va += Ao * Ho, ca += Ao * qo, Na += Ao * Go, Ea += Ao * Xo, fa += Ao * ea, Ca += Ao * ia, Oa += Ao * oa, ya += Ao * aa, Ua += Ao * ua, xa += Ao * na, Ra += Ao * _a, Ha += Ao * pa, ka += Ao * la, Aa += Ao * Ba, Ao = Wo[13], Pa += Ao * qa, va += Ao * Ia, ca += Ao * Ho, Na += Ao * qo, Ea += Ao * Go, fa += Ao * Xo, Ca += Ao * ea, Oa += Ao * ia, ya += Ao * oa, Ua += Ao * aa, xa += Ao * ua, Ra += Ao * na, Ha += Ao * _a, ka += Ao * pa, Aa += Ao * la, Ga += Ao * Ba, Ao = Wo[14], va += Ao * qa, ca += Ao * Ia, Na += Ao * Ho, Ea += Ao * qo, fa += Ao * Go, Ca += Ao * Xo, Oa += Ao * ea, ya += Ao * ia, Ua += Ao * oa, xa += Ao * aa, Ra += Ao * ua, Ha += Ao * na, ka += Ao * _a, Aa += Ao * pa, Ga += Ao * la, Wa += Ao * Ba, Ao = Wo[15], ca += Ao * qa, Na += Ao * Ia, Ea += Ao * Ho, fa += Ao * qo, Ca += Ao * Go, Oa += Ao * Xo, ya += Ao * ea, Ua += Ao * ia, xa += Ao * oa, Ra += Ao * aa, Ha += Ao * ua, ka += Ao * na, Aa += Ao * _a, Ga += Ao * pa, Wa += Ao * la, $a += Ao * Ba, Zo += 38 * Na, An += 38 * Ea, ra += 38 * fa, sa += 38 * Ca, Ma += 38 * Oa, ba += 38 * ya, ma += 38 * Ua, Va += 38 * xa, wa += 38 * Ra, ha += 38 * Ha, Fa += 38 * ka, Sa += 38 * Aa, da += 38 * Ga, Pa += 38 * Wa, va += 38 * $a, Lo = 1, Ao = Zo + Lo + 65535, Lo = Math.floor(Ao / 65536), Zo = Ao - Lo * 65536, Ao = An + Lo + 65535, Lo = Math.floor(Ao / 65536), An = Ao - Lo * 65536, Ao = ra + Lo + 65535, Lo = Math.floor(Ao / 65536), ra = Ao - Lo * 65536, Ao = sa + Lo + 65535, Lo = Math.floor(Ao / 65536), sa = Ao - Lo * 65536, Ao = Ma + Lo + 65535, Lo = Math.floor(Ao / 65536), Ma = Ao - Lo * 65536, Ao = ba + Lo + 65535, Lo = Math.floor(Ao / 65536), ba = Ao - Lo * 65536, Ao = ma + Lo + 65535, Lo = Math.floor(Ao / 65536), ma = Ao - Lo * 65536, Ao = Va + Lo + 65535, Lo = Math.floor(Ao / 65536), Va = Ao - Lo * 65536, Ao = wa + Lo + 65535, Lo = Math.floor(Ao / 65536), wa = Ao - Lo * 65536, Ao = ha + Lo + 65535, Lo = Math.floor(Ao / 65536), ha = Ao - Lo * 65536, Ao = Fa + Lo + 65535, Lo = Math.floor(Ao / 65536), Fa = Ao - Lo * 65536, Ao = Sa + Lo + 65535, Lo = Math.floor(Ao / 65536), Sa = Ao - Lo * 65536, Ao = da + Lo + 65535, Lo = Math.floor(Ao / 65536), da = Ao - Lo * 65536, Ao = Pa + Lo + 65535, Lo = Math.floor(Ao / 65536), Pa = Ao - Lo * 65536, Ao = va + Lo + 65535, Lo = Math.floor(Ao / 65536), va = Ao - Lo * 65536, Ao = ca + Lo + 65535, Lo = Math.floor(Ao / 65536), ca = Ao - Lo * 65536, Zo += Lo - 1 + 37 * (Lo - 1), Lo = 1, Ao = Zo + Lo + 65535, Lo = Math.floor(Ao / 65536), Zo = Ao - Lo * 65536, Ao = An + Lo + 65535, Lo = Math.floor(Ao / 65536), An = Ao - Lo * 65536, Ao = ra + Lo + 65535, Lo = Math.floor(Ao / 65536), ra = Ao - Lo * 65536, Ao = sa + Lo + 65535, Lo = Math.floor(Ao / 65536), sa = Ao - Lo * 65536, Ao = Ma + Lo + 65535, Lo = Math.floor(Ao / 65536), Ma = Ao - Lo * 65536, Ao = ba + Lo + 65535, Lo = Math.floor(Ao / 65536), ba = Ao - Lo * 65536, Ao = ma + Lo + 65535, Lo = Math.floor(Ao / 65536), ma = Ao - Lo * 65536, Ao = Va + Lo + 65535, Lo = Math.floor(Ao / 65536), Va = Ao - Lo * 65536, Ao = wa + Lo + 65535, Lo = Math.floor(Ao / 65536), wa = Ao - Lo * 65536, Ao = ha + Lo + 65535, Lo = Math.floor(Ao / 65536), ha = Ao - Lo * 65536, Ao = Fa + Lo + 65535, Lo = Math.floor(Ao / 65536), Fa = Ao - Lo * 65536, Ao = Sa + Lo + 65535, Lo = Math.floor(Ao / 65536), Sa = Ao - Lo * 65536, Ao = da + Lo + 65535, Lo = Math.floor(Ao / 65536), da = Ao - Lo * 65536, Ao = Pa + Lo + 65535, Lo = Math.floor(Ao / 65536), Pa = Ao - Lo * 65536, Ao = va + Lo + 65535, Lo = Math.floor(Ao / 65536), va = Ao - Lo * 65536, Ao = ca + Lo + 65535, Lo = Math.floor(Ao / 65536), ca = Ao - Lo * 65536, Zo += Lo - 1 + 37 * (Lo - 1), Vo[0] = Zo, Vo[1] = An, Vo[2] = ra, Vo[3] = sa, Vo[4] = Ma, Vo[5] = ba, Vo[6] = ma, Vo[7] = Va, Vo[8] = wa, Vo[9] = ha, Vo[10] = Fa, Vo[11] = Sa, Vo[12] = da, Vo[13] = Pa, Vo[14] = va, Vo[15] = ca;
  }
  function No(Vo, Wo) {
    Mo(Vo, Wo, Wo);
  }
  function Jo(Vo, Wo) {
    const jo = wi();
    let Ao;
    for (Ao = 0; Ao < 16; Ao++)
      jo[Ao] = Wo[Ao];
    for (Ao = 253; Ao >= 0; Ao--)
      No(jo, jo), Ao !== 2 && Ao !== 4 && Mo(jo, jo, Wo);
    for (Ao = 0; Ao < 16; Ao++)
      Vo[Ao] = jo[Ao];
  }
  function zo(Vo, Wo) {
    const jo = wi();
    let Ao;
    for (Ao = 0; Ao < 16; Ao++)
      jo[Ao] = Wo[Ao];
    for (Ao = 250; Ao >= 0; Ao--)
      No(jo, jo), Ao !== 1 && Mo(jo, jo, Wo);
    for (Ao = 0; Ao < 16; Ao++)
      Vo[Ao] = jo[Ao];
  }
  function Do(Vo, Wo) {
    const jo = wi(), Ao = wi(), Lo = wi(), Zo = wi(), An = wi(), ra = wi(), sa = wi(), Ma = wi(), ba = wi();
    Po(jo, Vo[1], Vo[0]), Po(ba, Wo[1], Wo[0]), Mo(jo, jo, ba), ko(Ao, Vo[0], Vo[1]), ko(ba, Wo[0], Wo[1]), Mo(Ao, Ao, ba), Mo(Lo, Vo[3], Wo[3]), Mo(Lo, Lo, Ti), Mo(Zo, Vo[2], Wo[2]), ko(Zo, Zo, Zo), Po(An, Ao, jo), Po(ra, Zo, Lo), ko(sa, Zo, Lo), ko(Ma, Ao, jo), Mo(Vo[0], An, ra), Mo(Vo[1], Ma, sa), Mo(Vo[2], sa, ra), Mo(Vo[3], An, Ma);
  }
  function wo(Vo, Wo, jo) {
    for (let Ao = 0; Ao < 4; Ao++)
      Ro(Vo[Ao], Wo[Ao], jo);
  }
  function Li(Vo, Wo) {
    const jo = wi(), Ao = wi(), Lo = wi();
    Jo(Lo, Wo[2]), Mo(jo, Wo[0], Lo), Mo(Ao, Wo[1], Lo), Bo(Vo, Ao), Vo[31] ^= Uo(jo) << 7;
  }
  function Ai(Vo, Wo, jo) {
    Ci(Vo[0], $i), Ci(Vo[1], xi), Ci(Vo[2], xi), Ci(Vo[3], $i);
    for (let Ao = 255; Ao >= 0; --Ao) {
      const Lo = jo[Ao / 8 | 0] >> (Ao & 7) & 1;
      wo(Vo, Wo, Lo), Do(Wo, Vo), Do(Vo, Vo), wo(Vo, Wo, Lo);
    }
  }
  function Ni(Vo, Wo) {
    const jo = [wi(), wi(), wi(), wi()];
    Ci(jo[0], Oi), Ci(jo[1], Mi), Ci(jo[2], xi), Mo(jo[3], Oi, Mi), Ai(Vo, jo, Wo);
  }
  function Ui(Vo) {
    if (Vo.length !== se.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${se.SEED_LENGTH} bytes`);
    const Wo = (0, Oe.hash)(Vo);
    Wo[0] &= 248, Wo[31] &= 127, Wo[31] |= 64;
    const jo = new Uint8Array(32), Ao = [wi(), wi(), wi(), wi()];
    Ni(Ao, Wo), Li(jo, Ao);
    const Lo = new Uint8Array(64);
    return Lo.set(Vo), Lo.set(jo, 32), {
      publicKey: jo,
      secretKey: Lo
    };
  }
  se.generateKeyPairFromSeed = Ui;
  function So(Vo) {
    const Wo = (0, e.randomBytes)(32, Vo), jo = Ui(Wo);
    return (0, Si.wipe)(Wo), jo;
  }
  se.generateKeyPair = So;
  function $o(Vo) {
    if (Vo.length !== se.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${se.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Vo.subarray(32));
  }
  se.extractPublicKeyFromSecretKey = $o;
  const Eo = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function zi(Vo, Wo) {
    let jo, Ao, Lo, Zo;
    for (Ao = 63; Ao >= 32; --Ao) {
      for (jo = 0, Lo = Ao - 32, Zo = Ao - 12; Lo < Zo; ++Lo)
        Wo[Lo] += jo - 16 * Wo[Ao] * Eo[Lo - (Ao - 32)], jo = Math.floor((Wo[Lo] + 128) / 256), Wo[Lo] -= jo * 256;
      Wo[Lo] += jo, Wo[Ao] = 0;
    }
    for (jo = 0, Lo = 0; Lo < 32; Lo++)
      Wo[Lo] += jo - (Wo[31] >> 4) * Eo[Lo], jo = Wo[Lo] >> 8, Wo[Lo] &= 255;
    for (Lo = 0; Lo < 32; Lo++)
      Wo[Lo] -= jo * Eo[Lo];
    for (Ao = 0; Ao < 32; Ao++)
      Wo[Ao + 1] += Wo[Ao] >> 8, Vo[Ao] = Wo[Ao] & 255;
  }
  function _o(Vo) {
    const Wo = new Float64Array(64);
    for (let jo = 0; jo < 64; jo++)
      Wo[jo] = Vo[jo];
    for (let jo = 0; jo < 64; jo++)
      Vo[jo] = 0;
    zi(Vo, Wo);
  }
  function Fi(Vo, Wo) {
    const jo = new Float64Array(64), Ao = [wi(), wi(), wi(), wi()], Lo = (0, Oe.hash)(Vo.subarray(0, 32));
    Lo[0] &= 248, Lo[31] &= 127, Lo[31] |= 64;
    const Zo = new Uint8Array(64);
    Zo.set(Lo.subarray(32), 32);
    const An = new Oe.SHA512();
    An.update(Zo.subarray(32)), An.update(Wo);
    const ra = An.digest();
    An.clean(), _o(ra), Ni(Ao, ra), Li(Zo, Ao), An.reset(), An.update(Zo.subarray(0, 32)), An.update(Vo.subarray(32)), An.update(Wo);
    const sa = An.digest();
    _o(sa);
    for (let Ma = 0; Ma < 32; Ma++)
      jo[Ma] = ra[Ma];
    for (let Ma = 0; Ma < 32; Ma++)
      for (let ba = 0; ba < 32; ba++)
        jo[Ma + ba] += sa[Ma] * Lo[ba];
    return zi(Zo.subarray(32), jo), Zo;
  }
  se.sign = Fi;
  function xo(Vo, Wo) {
    const jo = wi(), Ao = wi(), Lo = wi(), Zo = wi(), An = wi(), ra = wi(), sa = wi();
    return Ci(Vo[2], xi), Co(Vo[1], Wo), No(Lo, Vo[1]), Mo(Zo, Lo, Ri), Po(Lo, Lo, Vo[2]), ko(Zo, Vo[2], Zo), No(An, Zo), No(ra, An), Mo(sa, ra, An), Mo(jo, sa, Lo), Mo(jo, jo, Zo), zo(jo, jo), Mo(jo, jo, Lo), Mo(jo, jo, Zo), Mo(jo, jo, Zo), Mo(Vo[0], jo, Zo), No(Ao, Vo[0]), Mo(Ao, Ao, Zo), Io(Ao, Lo) && Mo(Vo[0], Vo[0], Ii), No(Ao, Vo[0]), Mo(Ao, Ao, Zo), Io(Ao, Lo) ? -1 : (Uo(Vo[0]) === Wo[31] >> 7 && Po(Vo[0], $i, Vo[0]), Mo(Vo[3], Vo[0], Vo[1]), 0);
  }
  function Qo(Vo, Wo, jo) {
    const Ao = new Uint8Array(32), Lo = [wi(), wi(), wi(), wi()], Zo = [wi(), wi(), wi(), wi()];
    if (jo.length !== se.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${se.SIGNATURE_LENGTH} bytes`);
    if (xo(Zo, Vo))
      return !1;
    const An = new Oe.SHA512();
    An.update(jo.subarray(0, 32)), An.update(Vo), An.update(Wo);
    const ra = An.digest();
    return _o(ra), Ai(Lo, Zo, ra), Ni(Zo, jo.subarray(32)), Do(Lo, Zo), Li(Ao, Lo), !Fo(jo, Ao);
  }
  se.verify = Qo;
  function To(Vo) {
    let Wo = [wi(), wi(), wi(), wi()];
    if (xo(Wo, Vo))
      throw new Error("Ed25519: invalid public key");
    let jo = wi(), Ao = wi(), Lo = Wo[1];
    ko(jo, xi, Lo), Po(Ao, xi, Lo), Jo(Ao, Ao), Mo(jo, jo, Ao);
    let Zo = new Uint8Array(32);
    return Bo(Zo, jo), Zo;
  }
  se.convertPublicKeyToX25519 = To;
  function Ko(Vo) {
    const Wo = (0, Oe.hash)(Vo.subarray(0, 32));
    Wo[0] &= 248, Wo[31] &= 127, Wo[31] |= 64;
    const jo = new Uint8Array(Wo.subarray(0, 32));
    return (0, Si.wipe)(Wo), jo;
  }
  se.convertSecretKeyToX25519 = Ko;
})(ed25519);
const JWT_IRIDIUM_ALG = "EdDSA", JWT_IRIDIUM_TYP = "JWT", JWT_DELIMITER = ".", JWT_ENCODING = "base64url", JSON_ENCODING = "utf8", DATA_ENCODING = "utf8", DID_DELIMITER = ":", DID_PREFIX = "did", DID_METHOD = "key", MULTICODEC_ED25519_ENCODING = "base58btc", MULTICODEC_ED25519_BASE = "z", MULTICODEC_ED25519_HEADER = "K36", KEY_PAIR_SEED_LENGTH = 32;
function asUint8Array(se) {
  return globalThis.Buffer != null ? new Uint8Array(se.buffer, se.byteOffset, se.byteLength) : se;
}
function allocUnsafe$2(se = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array(globalThis.Buffer.allocUnsafe(se)) : new Uint8Array(se);
}
function concat$3(se, e) {
  e || (e = se.reduce((wi, Ei) => wi + Ei.length, 0));
  const Oe = allocUnsafe$2(e);
  let Si = 0;
  for (const wi of se)
    Oe.set(wi, Si), Si += wi.length;
  return asUint8Array(Oe);
}
function base$4(se, e) {
  if (se.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var Oe = new Uint8Array(256), Si = 0; Si < Oe.length; Si++)
    Oe[Si] = 255;
  for (var wi = 0; wi < se.length; wi++) {
    var Ei = se.charAt(wi), $i = Ei.charCodeAt(0);
    if (Oe[$i] !== 255)
      throw new TypeError(Ei + " is ambiguous");
    Oe[$i] = wi;
  }
  var xi = se.length, Ri = se.charAt(0), Ti = Math.log(xi) / Math.log(256), Oi = Math.log(256) / Math.log(xi);
  function Mi(Oo) {
    if (Oo instanceof Uint8Array || (ArrayBuffer.isView(Oo) ? Oo = new Uint8Array(Oo.buffer, Oo.byteOffset, Oo.byteLength) : Array.isArray(Oo) && (Oo = Uint8Array.from(Oo))), !(Oo instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Oo.length === 0)
      return "";
    for (var Ro = 0, Bo = 0, Fo = 0, Io = Oo.length; Fo !== Io && Oo[Fo] === 0; )
      Fo++, Ro++;
    for (var Uo = (Io - Fo) * Oi + 1 >>> 0, Co = new Uint8Array(Uo); Fo !== Io; ) {
      for (var ko = Oo[Fo], Po = 0, Mo = Uo - 1; (ko !== 0 || Po < Bo) && Mo !== -1; Mo--, Po++)
        ko += 256 * Co[Mo] >>> 0, Co[Mo] = ko % xi >>> 0, ko = ko / xi >>> 0;
      if (ko !== 0)
        throw new Error("Non-zero carry");
      Bo = Po, Fo++;
    }
    for (var No = Uo - Bo; No !== Uo && Co[No] === 0; )
      No++;
    for (var Jo = Ri.repeat(Ro); No < Uo; ++No)
      Jo += se.charAt(Co[No]);
    return Jo;
  }
  function Ii(Oo) {
    if (typeof Oo != "string")
      throw new TypeError("Expected String");
    if (Oo.length === 0)
      return new Uint8Array();
    var Ro = 0;
    if (Oo[Ro] !== " ") {
      for (var Bo = 0, Fo = 0; Oo[Ro] === Ri; )
        Bo++, Ro++;
      for (var Io = (Oo.length - Ro) * Ti + 1 >>> 0, Uo = new Uint8Array(Io); Oo[Ro]; ) {
        var Co = Oe[Oo.charCodeAt(Ro)];
        if (Co === 255)
          return;
        for (var ko = 0, Po = Io - 1; (Co !== 0 || ko < Fo) && Po !== -1; Po--, ko++)
          Co += xi * Uo[Po] >>> 0, Uo[Po] = Co % 256 >>> 0, Co = Co / 256 >>> 0;
        if (Co !== 0)
          throw new Error("Non-zero carry");
        Fo = ko, Ro++;
      }
      if (Oo[Ro] !== " ") {
        for (var Mo = Io - Fo; Mo !== Io && Uo[Mo] === 0; )
          Mo++;
        for (var No = new Uint8Array(Bo + (Io - Mo)), Jo = Bo; Mo !== Io; )
          No[Jo++] = Uo[Mo++];
        return No;
      }
    }
  }
  function Ci(Oo) {
    var Ro = Ii(Oo);
    if (Ro)
      return Ro;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: Mi,
    decodeUnsafe: Ii,
    decode: Ci
  };
}
var src$3 = base$4, _brrp__multiformats_scope_baseX = src$3;
const coerce = (se) => {
  if (se instanceof Uint8Array && se.constructor.name === "Uint8Array")
    return se;
  if (se instanceof ArrayBuffer)
    return new Uint8Array(se);
  if (ArrayBuffer.isView(se))
    return new Uint8Array(se.buffer, se.byteOffset, se.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$2 = (se) => new TextEncoder().encode(se), toString$3 = (se) => new TextDecoder().decode(se);
class Encoder {
  constructor(e, Oe, Si) {
    this.name = e, this.prefix = Oe, this.baseEncode = Si;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder {
  constructor(e, Oe, Si) {
    if (this.name = e, this.prefix = Oe, Oe.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = Oe.codePointAt(0), this.baseDecode = Si;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return or$3(this, e);
  }
}
class ComposedDecoder {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return or$3(this, e);
  }
  decode(e) {
    const Oe = e[0], Si = this.decoders[Oe];
    if (Si)
      return Si.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$3 = (se, e) => new ComposedDecoder({
  ...se.decoders || { [se.prefix]: se },
  ...e.decoders || { [e.prefix]: e }
});
class Codec {
  constructor(e, Oe, Si, wi) {
    this.name = e, this.prefix = Oe, this.baseEncode = Si, this.baseDecode = wi, this.encoder = new Encoder(e, Oe, Si), this.decoder = new Decoder(e, Oe, wi);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const from = ({ name: se, prefix: e, encode: Oe, decode: Si }) => new Codec(se, e, Oe, Si), baseX$1 = ({ prefix: se, name: e, alphabet: Oe }) => {
  const { encode: Si, decode: wi } = _brrp__multiformats_scope_baseX(Oe, e);
  return from({
    prefix: se,
    name: e,
    encode: Si,
    decode: (Ei) => coerce(wi(Ei))
  });
}, decode$3 = (se, e, Oe, Si) => {
  const wi = {};
  for (let Oi = 0; Oi < e.length; ++Oi)
    wi[e[Oi]] = Oi;
  let Ei = se.length;
  for (; se[Ei - 1] === "="; )
    --Ei;
  const $i = new Uint8Array(Ei * Oe / 8 | 0);
  let xi = 0, Ri = 0, Ti = 0;
  for (let Oi = 0; Oi < Ei; ++Oi) {
    const Mi = wi[se[Oi]];
    if (Mi === void 0)
      throw new SyntaxError(`Non-${Si} character`);
    Ri = Ri << Oe | Mi, xi += Oe, xi >= 8 && (xi -= 8, $i[Ti++] = 255 & Ri >> xi);
  }
  if (xi >= Oe || 255 & Ri << 8 - xi)
    throw new SyntaxError("Unexpected end of data");
  return $i;
}, encode$2 = (se, e, Oe) => {
  const Si = e[e.length - 1] === "=", wi = (1 << Oe) - 1;
  let Ei = "", $i = 0, xi = 0;
  for (let Ri = 0; Ri < se.length; ++Ri)
    for (xi = xi << 8 | se[Ri], $i += 8; $i > Oe; )
      $i -= Oe, Ei += e[wi & xi >> $i];
  if ($i && (Ei += e[wi & xi << Oe - $i]), Si)
    for (; Ei.length * Oe & 7; )
      Ei += "=";
  return Ei;
}, rfc4648$2 = ({ name: se, prefix: e, bitsPerChar: Oe, alphabet: Si }) => from({
  prefix: e,
  name: se,
  encode(wi) {
    return encode$2(wi, Si, Oe);
  },
  decode(wi) {
    return decode$3(wi, Si, Oe, se);
  }
}), identity$1 = from({
  prefix: "\0",
  name: "identity",
  encode: (se) => toString$3(se),
  decode: (se) => fromString$2(se)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$1
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648$2({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648$2({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX$1({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648$2({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648$2({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648$2({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648$2({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648$2({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648$2({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648$2({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648$2({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648$2({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648$2({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648$2({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX$1({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX$1({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX$1({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX$1({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64$1 = rfc4648$2({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648$2({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648$2({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648$2({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$1,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), alphabetBytesToChars = alphabet.reduce((se, e, Oe) => (se[Oe] = e, se), []), alphabetCharsToBytes = alphabet.reduce((se, e, Oe) => (se[e.codePointAt(0)] = Oe, se), []);
function encode$1(se) {
  return se.reduce((e, Oe) => (e += alphabetBytesToChars[Oe], e), "");
}
function decode$2(se) {
  const e = [];
  for (const Oe of se) {
    const Si = alphabetCharsToBytes[Oe.codePointAt(0)];
    if (Si === void 0)
      throw new Error(`Non-base256emoji character: ${Oe}`);
    e.push(Si);
  }
  return new Uint8Array(e);
}
const base256emoji = from({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode$1,
  decode: decode$2
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$2,
  ...base256emoji$1
};
function createCodec$2(se, e, Oe, Si) {
  return {
    name: se,
    prefix: e,
    encoder: {
      name: se,
      prefix: e,
      encode: Oe
    },
    decoder: { decode: Si }
  };
}
const string$2 = createCodec$2("utf8", "u", (se) => "u" + new TextDecoder("utf8").decode(se), (se) => new TextEncoder().encode(se.substring(1))), ascii$2 = createCodec$2("ascii", "a", (se) => {
  let e = "a";
  for (let Oe = 0; Oe < se.length; Oe++)
    e += String.fromCharCode(se[Oe]);
  return e;
}, (se) => {
  se = se.substring(1);
  const e = allocUnsafe$2(se.length);
  for (let Oe = 0; Oe < se.length; Oe++)
    e[Oe] = se.charCodeAt(Oe);
  return e;
}), BASES$2 = {
  utf8: string$2,
  "utf-8": string$2,
  hex: bases.base16,
  latin1: ascii$2,
  ascii: ascii$2,
  binary: ascii$2,
  ...bases
};
function toString$2(se, e = "utf8") {
  const Oe = BASES$2[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(se.buffer, se.byteOffset, se.byteLength).toString("utf8") : Oe.encoder.encode(se).substring(1);
}
function fromString$1(se, e = "utf8") {
  const Oe = BASES$2[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? asUint8Array(globalThis.Buffer.from(se, "utf-8")) : Oe.decoder.decode(`${Oe.prefix}${se}`);
}
function decodeJSON(se) {
  return safeJsonParse(toString$2(fromString$1(se, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(se) {
  return toString$2(fromString$1(safeJsonStringify(se), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(se) {
  const e = fromString$1(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING), Oe = MULTICODEC_ED25519_BASE + toString$2(concat$3([e, se]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, Oe].join(DID_DELIMITER);
}
function encodeSig(se) {
  return toString$2(se, JWT_ENCODING);
}
function decodeSig(se) {
  return fromString$1(se, JWT_ENCODING);
}
function encodeData(se) {
  return fromString$1([encodeJSON(se.header), encodeJSON(se.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(se) {
  return [
    encodeJSON(se.header),
    encodeJSON(se.payload),
    encodeSig(se.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(se) {
  const e = se.split(JWT_DELIMITER), Oe = decodeJSON(e[0]), Si = decodeJSON(e[1]), wi = decodeSig(e[2]), Ei = fromString$1(e.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header: Oe, payload: Si, signature: wi, data: Ei };
}
function generateKeyPair(se = random.randomBytes(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(se);
}
async function signJWT(se, e, Oe, Si, wi = cjs$4.fromMiliseconds(Date.now())) {
  const Ei = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP }, $i = encodeIss(Si.publicKey), xi = wi + Oe, Ri = { iss: $i, sub: se, aud: e, iat: wi, exp: xi }, Ti = encodeData({ header: Ei, payload: Ri }), Oi = ed25519.sign(Si.secretKey, Ti);
  return encodeJWT({ header: Ei, payload: Ri, signature: Oi });
}
var chacha20poly1305 = {}, chacha = {};
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$2 = wipe$1, ROUNDS = 20;
function core(se, e, Oe) {
  for (var Si = 1634760805, wi = 857760878, Ei = 2036477234, $i = 1797285236, xi = Oe[3] << 24 | Oe[2] << 16 | Oe[1] << 8 | Oe[0], Ri = Oe[7] << 24 | Oe[6] << 16 | Oe[5] << 8 | Oe[4], Ti = Oe[11] << 24 | Oe[10] << 16 | Oe[9] << 8 | Oe[8], Oi = Oe[15] << 24 | Oe[14] << 16 | Oe[13] << 8 | Oe[12], Mi = Oe[19] << 24 | Oe[18] << 16 | Oe[17] << 8 | Oe[16], Ii = Oe[23] << 24 | Oe[22] << 16 | Oe[21] << 8 | Oe[20], Ci = Oe[27] << 24 | Oe[26] << 16 | Oe[25] << 8 | Oe[24], Oo = Oe[31] << 24 | Oe[30] << 16 | Oe[29] << 8 | Oe[28], Ro = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], Bo = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], Fo = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], Io = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], Uo = Si, Co = wi, ko = Ei, Po = $i, Mo = xi, No = Ri, Jo = Ti, zo = Oi, Do = Mi, wo = Ii, Li = Ci, Ai = Oo, Ni = Ro, Ui = Bo, So = Fo, $o = Io, Eo = 0; Eo < ROUNDS; Eo += 2)
    Uo = Uo + Mo | 0, Ni ^= Uo, Ni = Ni >>> 32 - 16 | Ni << 16, Do = Do + Ni | 0, Mo ^= Do, Mo = Mo >>> 32 - 12 | Mo << 12, Co = Co + No | 0, Ui ^= Co, Ui = Ui >>> 32 - 16 | Ui << 16, wo = wo + Ui | 0, No ^= wo, No = No >>> 32 - 12 | No << 12, ko = ko + Jo | 0, So ^= ko, So = So >>> 32 - 16 | So << 16, Li = Li + So | 0, Jo ^= Li, Jo = Jo >>> 32 - 12 | Jo << 12, Po = Po + zo | 0, $o ^= Po, $o = $o >>> 32 - 16 | $o << 16, Ai = Ai + $o | 0, zo ^= Ai, zo = zo >>> 32 - 12 | zo << 12, ko = ko + Jo | 0, So ^= ko, So = So >>> 32 - 8 | So << 8, Li = Li + So | 0, Jo ^= Li, Jo = Jo >>> 32 - 7 | Jo << 7, Po = Po + zo | 0, $o ^= Po, $o = $o >>> 32 - 8 | $o << 8, Ai = Ai + $o | 0, zo ^= Ai, zo = zo >>> 32 - 7 | zo << 7, Co = Co + No | 0, Ui ^= Co, Ui = Ui >>> 32 - 8 | Ui << 8, wo = wo + Ui | 0, No ^= wo, No = No >>> 32 - 7 | No << 7, Uo = Uo + Mo | 0, Ni ^= Uo, Ni = Ni >>> 32 - 8 | Ni << 8, Do = Do + Ni | 0, Mo ^= Do, Mo = Mo >>> 32 - 7 | Mo << 7, Uo = Uo + No | 0, $o ^= Uo, $o = $o >>> 32 - 16 | $o << 16, Li = Li + $o | 0, No ^= Li, No = No >>> 32 - 12 | No << 12, Co = Co + Jo | 0, Ni ^= Co, Ni = Ni >>> 32 - 16 | Ni << 16, Ai = Ai + Ni | 0, Jo ^= Ai, Jo = Jo >>> 32 - 12 | Jo << 12, ko = ko + zo | 0, Ui ^= ko, Ui = Ui >>> 32 - 16 | Ui << 16, Do = Do + Ui | 0, zo ^= Do, zo = zo >>> 32 - 12 | zo << 12, Po = Po + Mo | 0, So ^= Po, So = So >>> 32 - 16 | So << 16, wo = wo + So | 0, Mo ^= wo, Mo = Mo >>> 32 - 12 | Mo << 12, ko = ko + zo | 0, Ui ^= ko, Ui = Ui >>> 32 - 8 | Ui << 8, Do = Do + Ui | 0, zo ^= Do, zo = zo >>> 32 - 7 | zo << 7, Po = Po + Mo | 0, So ^= Po, So = So >>> 32 - 8 | So << 8, wo = wo + So | 0, Mo ^= wo, Mo = Mo >>> 32 - 7 | Mo << 7, Co = Co + Jo | 0, Ni ^= Co, Ni = Ni >>> 32 - 8 | Ni << 8, Ai = Ai + Ni | 0, Jo ^= Ai, Jo = Jo >>> 32 - 7 | Jo << 7, Uo = Uo + No | 0, $o ^= Uo, $o = $o >>> 32 - 8 | $o << 8, Li = Li + $o | 0, No ^= Li, No = No >>> 32 - 7 | No << 7;
  binary_1.writeUint32LE(Uo + Si | 0, se, 0), binary_1.writeUint32LE(Co + wi | 0, se, 4), binary_1.writeUint32LE(ko + Ei | 0, se, 8), binary_1.writeUint32LE(Po + $i | 0, se, 12), binary_1.writeUint32LE(Mo + xi | 0, se, 16), binary_1.writeUint32LE(No + Ri | 0, se, 20), binary_1.writeUint32LE(Jo + Ti | 0, se, 24), binary_1.writeUint32LE(zo + Oi | 0, se, 28), binary_1.writeUint32LE(Do + Mi | 0, se, 32), binary_1.writeUint32LE(wo + Ii | 0, se, 36), binary_1.writeUint32LE(Li + Ci | 0, se, 40), binary_1.writeUint32LE(Ai + Oo | 0, se, 44), binary_1.writeUint32LE(Ni + Ro | 0, se, 48), binary_1.writeUint32LE(Ui + Bo | 0, se, 52), binary_1.writeUint32LE(So + Fo | 0, se, 56), binary_1.writeUint32LE($o + Io | 0, se, 60);
}
function streamXOR(se, e, Oe, Si, wi) {
  if (wi === void 0 && (wi = 0), se.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (Si.length < Oe.length)
    throw new Error("ChaCha: destination is shorter than source");
  var Ei, $i;
  if (wi === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    Ei = new Uint8Array(16), $i = Ei.length - e.length, Ei.set(e, $i);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    Ei = e, $i = wi;
  }
  for (var xi = new Uint8Array(64), Ri = 0; Ri < Oe.length; Ri += 64) {
    core(xi, Ei, se);
    for (var Ti = Ri; Ti < Ri + 64 && Ti < Oe.length; Ti++)
      Si[Ti] = Oe[Ti] ^ xi[Ti - Ri];
    incrementCounter(Ei, 0, $i);
  }
  return wipe_1$2.wipe(xi), wi === 0 && wipe_1$2.wipe(Ei), Si;
}
chacha.streamXOR = streamXOR;
function stream(se, e, Oe, Si) {
  return Si === void 0 && (Si = 0), wipe_1$2.wipe(Oe), streamXOR(se, e, Oe, Oe, Si);
}
chacha.stream = stream;
function incrementCounter(se, e, Oe) {
  for (var Si = 1; Oe--; )
    Si = Si + (se[e] & 255) | 0, se[e] = Si & 255, Si >>>= 8, e++;
  if (Si > 0)
    throw new Error("ChaCha: counter overflow");
}
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(se, e, Oe) {
  return ~(se - 1) & e | se - 1 & Oe;
}
constantTime.select = select;
function lessOrEqual(se, e) {
  return (se | 0) - (e | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(se, e) {
  if (se.length !== e.length)
    return 0;
  for (var Oe = 0, Si = 0; Si < se.length; Si++)
    Oe |= se[Si] ^ e[Si];
  return 1 & Oe - 1 >>> 8;
}
constantTime.compare = compare;
function equal(se, e) {
  return se.length === 0 || e.length === 0 ? !1 : compare(se, e) !== 0;
}
constantTime.equal = equal;
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  var e = constantTime, Oe = wipe$1;
  se.DIGEST_LENGTH = 16;
  var Si = (
    /** @class */
    function() {
      function $i(xi) {
        this.digestLength = se.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var Ri = xi[0] | xi[1] << 8;
        this._r[0] = Ri & 8191;
        var Ti = xi[2] | xi[3] << 8;
        this._r[1] = (Ri >>> 13 | Ti << 3) & 8191;
        var Oi = xi[4] | xi[5] << 8;
        this._r[2] = (Ti >>> 10 | Oi << 6) & 7939;
        var Mi = xi[6] | xi[7] << 8;
        this._r[3] = (Oi >>> 7 | Mi << 9) & 8191;
        var Ii = xi[8] | xi[9] << 8;
        this._r[4] = (Mi >>> 4 | Ii << 12) & 255, this._r[5] = Ii >>> 1 & 8190;
        var Ci = xi[10] | xi[11] << 8;
        this._r[6] = (Ii >>> 14 | Ci << 2) & 8191;
        var Oo = xi[12] | xi[13] << 8;
        this._r[7] = (Ci >>> 11 | Oo << 5) & 8065;
        var Ro = xi[14] | xi[15] << 8;
        this._r[8] = (Oo >>> 8 | Ro << 8) & 8191, this._r[9] = Ro >>> 5 & 127, this._pad[0] = xi[16] | xi[17] << 8, this._pad[1] = xi[18] | xi[19] << 8, this._pad[2] = xi[20] | xi[21] << 8, this._pad[3] = xi[22] | xi[23] << 8, this._pad[4] = xi[24] | xi[25] << 8, this._pad[5] = xi[26] | xi[27] << 8, this._pad[6] = xi[28] | xi[29] << 8, this._pad[7] = xi[30] | xi[31] << 8;
      }
      return $i.prototype._blocks = function(xi, Ri, Ti) {
        for (var Oi = this._fin ? 0 : 2048, Mi = this._h[0], Ii = this._h[1], Ci = this._h[2], Oo = this._h[3], Ro = this._h[4], Bo = this._h[5], Fo = this._h[6], Io = this._h[7], Uo = this._h[8], Co = this._h[9], ko = this._r[0], Po = this._r[1], Mo = this._r[2], No = this._r[3], Jo = this._r[4], zo = this._r[5], Do = this._r[6], wo = this._r[7], Li = this._r[8], Ai = this._r[9]; Ti >= 16; ) {
          var Ni = xi[Ri + 0] | xi[Ri + 1] << 8;
          Mi += Ni & 8191;
          var Ui = xi[Ri + 2] | xi[Ri + 3] << 8;
          Ii += (Ni >>> 13 | Ui << 3) & 8191;
          var So = xi[Ri + 4] | xi[Ri + 5] << 8;
          Ci += (Ui >>> 10 | So << 6) & 8191;
          var $o = xi[Ri + 6] | xi[Ri + 7] << 8;
          Oo += (So >>> 7 | $o << 9) & 8191;
          var Eo = xi[Ri + 8] | xi[Ri + 9] << 8;
          Ro += ($o >>> 4 | Eo << 12) & 8191, Bo += Eo >>> 1 & 8191;
          var zi = xi[Ri + 10] | xi[Ri + 11] << 8;
          Fo += (Eo >>> 14 | zi << 2) & 8191;
          var _o = xi[Ri + 12] | xi[Ri + 13] << 8;
          Io += (zi >>> 11 | _o << 5) & 8191;
          var Fi = xi[Ri + 14] | xi[Ri + 15] << 8;
          Uo += (_o >>> 8 | Fi << 8) & 8191, Co += Fi >>> 5 | Oi;
          var xo = 0, Qo = xo;
          Qo += Mi * ko, Qo += Ii * (5 * Ai), Qo += Ci * (5 * Li), Qo += Oo * (5 * wo), Qo += Ro * (5 * Do), xo = Qo >>> 13, Qo &= 8191, Qo += Bo * (5 * zo), Qo += Fo * (5 * Jo), Qo += Io * (5 * No), Qo += Uo * (5 * Mo), Qo += Co * (5 * Po), xo += Qo >>> 13, Qo &= 8191;
          var To = xo;
          To += Mi * Po, To += Ii * ko, To += Ci * (5 * Ai), To += Oo * (5 * Li), To += Ro * (5 * wo), xo = To >>> 13, To &= 8191, To += Bo * (5 * Do), To += Fo * (5 * zo), To += Io * (5 * Jo), To += Uo * (5 * No), To += Co * (5 * Mo), xo += To >>> 13, To &= 8191;
          var Ko = xo;
          Ko += Mi * Mo, Ko += Ii * Po, Ko += Ci * ko, Ko += Oo * (5 * Ai), Ko += Ro * (5 * Li), xo = Ko >>> 13, Ko &= 8191, Ko += Bo * (5 * wo), Ko += Fo * (5 * Do), Ko += Io * (5 * zo), Ko += Uo * (5 * Jo), Ko += Co * (5 * No), xo += Ko >>> 13, Ko &= 8191;
          var Vo = xo;
          Vo += Mi * No, Vo += Ii * Mo, Vo += Ci * Po, Vo += Oo * ko, Vo += Ro * (5 * Ai), xo = Vo >>> 13, Vo &= 8191, Vo += Bo * (5 * Li), Vo += Fo * (5 * wo), Vo += Io * (5 * Do), Vo += Uo * (5 * zo), Vo += Co * (5 * Jo), xo += Vo >>> 13, Vo &= 8191;
          var Wo = xo;
          Wo += Mi * Jo, Wo += Ii * No, Wo += Ci * Mo, Wo += Oo * Po, Wo += Ro * ko, xo = Wo >>> 13, Wo &= 8191, Wo += Bo * (5 * Ai), Wo += Fo * (5 * Li), Wo += Io * (5 * wo), Wo += Uo * (5 * Do), Wo += Co * (5 * zo), xo += Wo >>> 13, Wo &= 8191;
          var jo = xo;
          jo += Mi * zo, jo += Ii * Jo, jo += Ci * No, jo += Oo * Mo, jo += Ro * Po, xo = jo >>> 13, jo &= 8191, jo += Bo * ko, jo += Fo * (5 * Ai), jo += Io * (5 * Li), jo += Uo * (5 * wo), jo += Co * (5 * Do), xo += jo >>> 13, jo &= 8191;
          var Ao = xo;
          Ao += Mi * Do, Ao += Ii * zo, Ao += Ci * Jo, Ao += Oo * No, Ao += Ro * Mo, xo = Ao >>> 13, Ao &= 8191, Ao += Bo * Po, Ao += Fo * ko, Ao += Io * (5 * Ai), Ao += Uo * (5 * Li), Ao += Co * (5 * wo), xo += Ao >>> 13, Ao &= 8191;
          var Lo = xo;
          Lo += Mi * wo, Lo += Ii * Do, Lo += Ci * zo, Lo += Oo * Jo, Lo += Ro * No, xo = Lo >>> 13, Lo &= 8191, Lo += Bo * Mo, Lo += Fo * Po, Lo += Io * ko, Lo += Uo * (5 * Ai), Lo += Co * (5 * Li), xo += Lo >>> 13, Lo &= 8191;
          var Zo = xo;
          Zo += Mi * Li, Zo += Ii * wo, Zo += Ci * Do, Zo += Oo * zo, Zo += Ro * Jo, xo = Zo >>> 13, Zo &= 8191, Zo += Bo * No, Zo += Fo * Mo, Zo += Io * Po, Zo += Uo * ko, Zo += Co * (5 * Ai), xo += Zo >>> 13, Zo &= 8191;
          var An = xo;
          An += Mi * Ai, An += Ii * Li, An += Ci * wo, An += Oo * Do, An += Ro * zo, xo = An >>> 13, An &= 8191, An += Bo * Jo, An += Fo * No, An += Io * Mo, An += Uo * Po, An += Co * ko, xo += An >>> 13, An &= 8191, xo = (xo << 2) + xo | 0, xo = xo + Qo | 0, Qo = xo & 8191, xo = xo >>> 13, To += xo, Mi = Qo, Ii = To, Ci = Ko, Oo = Vo, Ro = Wo, Bo = jo, Fo = Ao, Io = Lo, Uo = Zo, Co = An, Ri += 16, Ti -= 16;
        }
        this._h[0] = Mi, this._h[1] = Ii, this._h[2] = Ci, this._h[3] = Oo, this._h[4] = Ro, this._h[5] = Bo, this._h[6] = Fo, this._h[7] = Io, this._h[8] = Uo, this._h[9] = Co;
      }, $i.prototype.finish = function(xi, Ri) {
        Ri === void 0 && (Ri = 0);
        var Ti = new Uint16Array(10), Oi, Mi, Ii, Ci;
        if (this._leftover) {
          for (Ci = this._leftover, this._buffer[Ci++] = 1; Ci < 16; Ci++)
            this._buffer[Ci] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (Oi = this._h[1] >>> 13, this._h[1] &= 8191, Ci = 2; Ci < 10; Ci++)
          this._h[Ci] += Oi, Oi = this._h[Ci] >>> 13, this._h[Ci] &= 8191;
        for (this._h[0] += Oi * 5, Oi = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += Oi, Oi = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += Oi, Ti[0] = this._h[0] + 5, Oi = Ti[0] >>> 13, Ti[0] &= 8191, Ci = 1; Ci < 10; Ci++)
          Ti[Ci] = this._h[Ci] + Oi, Oi = Ti[Ci] >>> 13, Ti[Ci] &= 8191;
        for (Ti[9] -= 8192, Mi = (Oi ^ 1) - 1, Ci = 0; Ci < 10; Ci++)
          Ti[Ci] &= Mi;
        for (Mi = ~Mi, Ci = 0; Ci < 10; Ci++)
          this._h[Ci] = this._h[Ci] & Mi | Ti[Ci];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, Ii = this._h[0] + this._pad[0], this._h[0] = Ii & 65535, Ci = 1; Ci < 8; Ci++)
          Ii = (this._h[Ci] + this._pad[Ci] | 0) + (Ii >>> 16) | 0, this._h[Ci] = Ii & 65535;
        return xi[Ri + 0] = this._h[0] >>> 0, xi[Ri + 1] = this._h[0] >>> 8, xi[Ri + 2] = this._h[1] >>> 0, xi[Ri + 3] = this._h[1] >>> 8, xi[Ri + 4] = this._h[2] >>> 0, xi[Ri + 5] = this._h[2] >>> 8, xi[Ri + 6] = this._h[3] >>> 0, xi[Ri + 7] = this._h[3] >>> 8, xi[Ri + 8] = this._h[4] >>> 0, xi[Ri + 9] = this._h[4] >>> 8, xi[Ri + 10] = this._h[5] >>> 0, xi[Ri + 11] = this._h[5] >>> 8, xi[Ri + 12] = this._h[6] >>> 0, xi[Ri + 13] = this._h[6] >>> 8, xi[Ri + 14] = this._h[7] >>> 0, xi[Ri + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, $i.prototype.update = function(xi) {
        var Ri = 0, Ti = xi.length, Oi;
        if (this._leftover) {
          Oi = 16 - this._leftover, Oi > Ti && (Oi = Ti);
          for (var Mi = 0; Mi < Oi; Mi++)
            this._buffer[this._leftover + Mi] = xi[Ri + Mi];
          if (Ti -= Oi, Ri += Oi, this._leftover += Oi, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (Ti >= 16 && (Oi = Ti - Ti % 16, this._blocks(xi, Ri, Oi), Ri += Oi, Ti -= Oi), Ti) {
          for (var Mi = 0; Mi < Ti; Mi++)
            this._buffer[this._leftover + Mi] = xi[Ri + Mi];
          this._leftover += Ti;
        }
        return this;
      }, $i.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var xi = new Uint8Array(16);
        return this.finish(xi), xi;
      }, $i.prototype.clean = function() {
        return Oe.wipe(this._buffer), Oe.wipe(this._r), Oe.wipe(this._h), Oe.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, $i;
    }()
  );
  se.Poly1305 = Si;
  function wi($i, xi) {
    var Ri = new Si($i);
    Ri.update(xi);
    var Ti = Ri.digest();
    return Ri.clean(), Ti;
  }
  se.oneTimeAuth = wi;
  function Ei($i, xi) {
    return $i.length !== se.DIGEST_LENGTH || xi.length !== se.DIGEST_LENGTH ? !1 : e.equal($i, xi);
  }
  se.equal = Ei;
})(poly1305);
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  var e = chacha, Oe = poly1305, Si = wipe$1, wi = binary, Ei = constantTime;
  se.KEY_LENGTH = 32, se.NONCE_LENGTH = 12, se.TAG_LENGTH = 16;
  var $i = new Uint8Array(16), xi = (
    /** @class */
    function() {
      function Ri(Ti) {
        if (this.nonceLength = se.NONCE_LENGTH, this.tagLength = se.TAG_LENGTH, Ti.length !== se.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(Ti);
      }
      return Ri.prototype.seal = function(Ti, Oi, Mi, Ii) {
        if (Ti.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var Ci = new Uint8Array(16);
        Ci.set(Ti, Ci.length - Ti.length);
        var Oo = new Uint8Array(32);
        e.stream(this._key, Ci, Oo, 4);
        var Ro = Oi.length + this.tagLength, Bo;
        if (Ii) {
          if (Ii.length !== Ro)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Bo = Ii;
        } else
          Bo = new Uint8Array(Ro);
        return e.streamXOR(this._key, Ci, Oi, Bo, 4), this._authenticate(Bo.subarray(Bo.length - this.tagLength, Bo.length), Oo, Bo.subarray(0, Bo.length - this.tagLength), Mi), Si.wipe(Ci), Bo;
      }, Ri.prototype.open = function(Ti, Oi, Mi, Ii) {
        if (Ti.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (Oi.length < this.tagLength)
          return null;
        var Ci = new Uint8Array(16);
        Ci.set(Ti, Ci.length - Ti.length);
        var Oo = new Uint8Array(32);
        e.stream(this._key, Ci, Oo, 4);
        var Ro = new Uint8Array(this.tagLength);
        if (this._authenticate(Ro, Oo, Oi.subarray(0, Oi.length - this.tagLength), Mi), !Ei.equal(Ro, Oi.subarray(Oi.length - this.tagLength, Oi.length)))
          return null;
        var Bo = Oi.length - this.tagLength, Fo;
        if (Ii) {
          if (Ii.length !== Bo)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Fo = Ii;
        } else
          Fo = new Uint8Array(Bo);
        return e.streamXOR(this._key, Ci, Oi.subarray(0, Oi.length - this.tagLength), Fo, 4), Si.wipe(Ci), Fo;
      }, Ri.prototype.clean = function() {
        return Si.wipe(this._key), this;
      }, Ri.prototype._authenticate = function(Ti, Oi, Mi, Ii) {
        var Ci = new Oe.Poly1305(Oi);
        Ii && (Ci.update(Ii), Ii.length % 16 > 0 && Ci.update($i.subarray(Ii.length % 16))), Ci.update(Mi), Mi.length % 16 > 0 && Ci.update($i.subarray(Mi.length % 16));
        var Oo = new Uint8Array(8);
        Ii && wi.writeUint64LE(Ii.length, Oo), Ci.update(Oo), wi.writeUint64LE(Mi.length, Oo), Ci.update(Oo);
        for (var Ro = Ci.digest(), Bo = 0; Bo < Ro.length; Bo++)
          Ti[Bo] = Ro[Bo];
        Ci.clean(), Si.wipe(Ro), Si.wipe(Oo);
      }, Ri;
    }()
  );
  se.ChaCha20Poly1305 = xi;
})(chacha20poly1305);
var hkdf = {}, hmac$2 = {}, hash$5 = {};
Object.defineProperty(hash$5, "__esModule", { value: !0 });
function isSerializableHash(se) {
  return typeof se.saveState < "u" && typeof se.restoreState < "u" && typeof se.cleanSavedState < "u";
}
hash$5.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$2, "__esModule", { value: !0 });
var hash_1 = hash$5, constant_time_1 = constantTime, wipe_1$1 = wipe$1, HMAC = (
  /** @class */
  function() {
    function se(e, Oe) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var Si = new Uint8Array(this.blockSize);
      Oe.length > this.blockSize ? this._inner.update(Oe).finish(Si).clean() : Si.set(Oe);
      for (var wi = 0; wi < Si.length; wi++)
        Si[wi] ^= 54;
      this._inner.update(Si);
      for (var wi = 0; wi < Si.length; wi++)
        Si[wi] ^= 106;
      this._outer.update(Si), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$1.wipe(Si);
    }
    return se.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, se.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, se.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, se.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, se.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, se.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, se.prototype.restoreState = function(e) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, se.prototype.cleanSavedState = function(e) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, se;
  }()
);
hmac$2.HMAC = HMAC;
function hmac$1(se, e, Oe) {
  var Si = new HMAC(se, e);
  Si.update(Oe);
  var wi = Si.digest();
  return Si.clean(), wi;
}
hmac$2.hmac = hmac$1;
hmac$2.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$2, wipe_1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function se(e, Oe, Si, wi) {
      Si === void 0 && (Si = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = wi;
      var Ei = hmac_1.hmac(this._hash, Si, Oe);
      this._hmac = new hmac_1.HMAC(e, Ei), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return se.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, se.prototype.expand = function(e) {
      for (var Oe = new Uint8Array(e), Si = 0; Si < Oe.length; Si++)
        this._bufpos === this._buffer.length && this._fillBuffer(), Oe[Si] = this._buffer[this._bufpos++];
      return Oe;
    }, se.prototype.clean = function() {
      this._hmac.clean(), wipe_1.wipe(this._buffer), wipe_1.wipe(this._counter), this._bufpos = 0;
    }, se;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, sha256$1 = {};
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  var e = binary, Oe = wipe$1;
  se.DIGEST_LENGTH = 32, se.BLOCK_SIZE = 64;
  var Si = (
    /** @class */
    function() {
      function xi() {
        this.digestLength = se.DIGEST_LENGTH, this.blockSize = se.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return xi.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, xi.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, xi.prototype.clean = function() {
        Oe.wipe(this._buffer), Oe.wipe(this._temp), this.reset();
      }, xi.prototype.update = function(Ri, Ti) {
        if (Ti === void 0 && (Ti = Ri.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var Oi = 0;
        if (this._bytesHashed += Ti, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && Ti > 0; )
            this._buffer[this._bufferLength++] = Ri[Oi++], Ti--;
          this._bufferLength === this.blockSize && (Ei(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (Ti >= this.blockSize && (Oi = Ei(this._temp, this._state, Ri, Oi, Ti), Ti %= this.blockSize); Ti > 0; )
          this._buffer[this._bufferLength++] = Ri[Oi++], Ti--;
        return this;
      }, xi.prototype.finish = function(Ri) {
        if (!this._finished) {
          var Ti = this._bytesHashed, Oi = this._bufferLength, Mi = Ti / 536870912 | 0, Ii = Ti << 3, Ci = Ti % 64 < 56 ? 64 : 128;
          this._buffer[Oi] = 128;
          for (var Oo = Oi + 1; Oo < Ci - 8; Oo++)
            this._buffer[Oo] = 0;
          e.writeUint32BE(Mi, this._buffer, Ci - 8), e.writeUint32BE(Ii, this._buffer, Ci - 4), Ei(this._temp, this._state, this._buffer, 0, Ci), this._finished = !0;
        }
        for (var Oo = 0; Oo < this.digestLength / 4; Oo++)
          e.writeUint32BE(this._state[Oo], Ri, Oo * 4);
        return this;
      }, xi.prototype.digest = function() {
        var Ri = new Uint8Array(this.digestLength);
        return this.finish(Ri), Ri;
      }, xi.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, xi.prototype.restoreState = function(Ri) {
        return this._state.set(Ri.state), this._bufferLength = Ri.bufferLength, Ri.buffer && this._buffer.set(Ri.buffer), this._bytesHashed = Ri.bytesHashed, this._finished = !1, this;
      }, xi.prototype.cleanSavedState = function(Ri) {
        Oe.wipe(Ri.state), Ri.buffer && Oe.wipe(Ri.buffer), Ri.bufferLength = 0, Ri.bytesHashed = 0;
      }, xi;
    }()
  );
  se.SHA256 = Si;
  var wi = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function Ei(xi, Ri, Ti, Oi, Mi) {
    for (; Mi >= 64; ) {
      for (var Ii = Ri[0], Ci = Ri[1], Oo = Ri[2], Ro = Ri[3], Bo = Ri[4], Fo = Ri[5], Io = Ri[6], Uo = Ri[7], Co = 0; Co < 16; Co++) {
        var ko = Oi + Co * 4;
        xi[Co] = e.readUint32BE(Ti, ko);
      }
      for (var Co = 16; Co < 64; Co++) {
        var Po = xi[Co - 2], Mo = (Po >>> 17 | Po << 32 - 17) ^ (Po >>> 19 | Po << 32 - 19) ^ Po >>> 10;
        Po = xi[Co - 15];
        var No = (Po >>> 7 | Po << 32 - 7) ^ (Po >>> 18 | Po << 32 - 18) ^ Po >>> 3;
        xi[Co] = (Mo + xi[Co - 7] | 0) + (No + xi[Co - 16] | 0);
      }
      for (var Co = 0; Co < 64; Co++) {
        var Mo = (((Bo >>> 6 | Bo << 26) ^ (Bo >>> 11 | Bo << 21) ^ (Bo >>> 25 | Bo << 7)) + (Bo & Fo ^ ~Bo & Io) | 0) + (Uo + (wi[Co] + xi[Co] | 0) | 0) | 0, No = ((Ii >>> 2 | Ii << 32 - 2) ^ (Ii >>> 13 | Ii << 32 - 13) ^ (Ii >>> 22 | Ii << 32 - 22)) + (Ii & Ci ^ Ii & Oo ^ Ci & Oo) | 0;
        Uo = Io, Io = Fo, Fo = Bo, Bo = Ro + Mo | 0, Ro = Oo, Oo = Ci, Ci = Ii, Ii = Mo + No | 0;
      }
      Ri[0] += Ii, Ri[1] += Ci, Ri[2] += Oo, Ri[3] += Ro, Ri[4] += Bo, Ri[5] += Fo, Ri[6] += Io, Ri[7] += Uo, Oi += 64, Mi -= 64;
    }
    return Oi;
  }
  function $i(xi) {
    var Ri = new Si();
    Ri.update(xi);
    var Ti = Ri.digest();
    return Ri.clean(), Ti;
  }
  se.hash = $i;
})(sha256$1);
var x25519 = {};
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 }), se.sharedKey = se.generateKeyPair = se.generateKeyPairFromSeed = se.scalarMultBase = se.scalarMult = se.SHARED_KEY_LENGTH = se.SECRET_KEY_LENGTH = se.PUBLIC_KEY_LENGTH = void 0;
  const e = random, Oe = wipe$1;
  se.PUBLIC_KEY_LENGTH = 32, se.SECRET_KEY_LENGTH = 32, se.SHARED_KEY_LENGTH = 32;
  function Si(Co) {
    const ko = new Float64Array(16);
    if (Co)
      for (let Po = 0; Po < Co.length; Po++)
        ko[Po] = Co[Po];
    return ko;
  }
  const wi = new Uint8Array(32);
  wi[0] = 9;
  const Ei = Si([56129, 1]);
  function $i(Co) {
    let ko = 1;
    for (let Po = 0; Po < 16; Po++) {
      let Mo = Co[Po] + ko + 65535;
      ko = Math.floor(Mo / 65536), Co[Po] = Mo - ko * 65536;
    }
    Co[0] += ko - 1 + 37 * (ko - 1);
  }
  function xi(Co, ko, Po) {
    const Mo = ~(Po - 1);
    for (let No = 0; No < 16; No++) {
      const Jo = Mo & (Co[No] ^ ko[No]);
      Co[No] ^= Jo, ko[No] ^= Jo;
    }
  }
  function Ri(Co, ko) {
    const Po = Si(), Mo = Si();
    for (let No = 0; No < 16; No++)
      Mo[No] = ko[No];
    $i(Mo), $i(Mo), $i(Mo);
    for (let No = 0; No < 2; No++) {
      Po[0] = Mo[0] - 65517;
      for (let zo = 1; zo < 15; zo++)
        Po[zo] = Mo[zo] - 65535 - (Po[zo - 1] >> 16 & 1), Po[zo - 1] &= 65535;
      Po[15] = Mo[15] - 32767 - (Po[14] >> 16 & 1);
      const Jo = Po[15] >> 16 & 1;
      Po[14] &= 65535, xi(Mo, Po, 1 - Jo);
    }
    for (let No = 0; No < 16; No++)
      Co[2 * No] = Mo[No] & 255, Co[2 * No + 1] = Mo[No] >> 8;
  }
  function Ti(Co, ko) {
    for (let Po = 0; Po < 16; Po++)
      Co[Po] = ko[2 * Po] + (ko[2 * Po + 1] << 8);
    Co[15] &= 32767;
  }
  function Oi(Co, ko, Po) {
    for (let Mo = 0; Mo < 16; Mo++)
      Co[Mo] = ko[Mo] + Po[Mo];
  }
  function Mi(Co, ko, Po) {
    for (let Mo = 0; Mo < 16; Mo++)
      Co[Mo] = ko[Mo] - Po[Mo];
  }
  function Ii(Co, ko, Po) {
    let Mo, No, Jo = 0, zo = 0, Do = 0, wo = 0, Li = 0, Ai = 0, Ni = 0, Ui = 0, So = 0, $o = 0, Eo = 0, zi = 0, _o = 0, Fi = 0, xo = 0, Qo = 0, To = 0, Ko = 0, Vo = 0, Wo = 0, jo = 0, Ao = 0, Lo = 0, Zo = 0, An = 0, ra = 0, sa = 0, Ma = 0, ba = 0, ma = 0, Va = 0, wa = Po[0], ha = Po[1], Fa = Po[2], Sa = Po[3], da = Po[4], Pa = Po[5], va = Po[6], ca = Po[7], Na = Po[8], Ea = Po[9], fa = Po[10], Ca = Po[11], Oa = Po[12], ya = Po[13], Ua = Po[14], xa = Po[15];
    Mo = ko[0], Jo += Mo * wa, zo += Mo * ha, Do += Mo * Fa, wo += Mo * Sa, Li += Mo * da, Ai += Mo * Pa, Ni += Mo * va, Ui += Mo * ca, So += Mo * Na, $o += Mo * Ea, Eo += Mo * fa, zi += Mo * Ca, _o += Mo * Oa, Fi += Mo * ya, xo += Mo * Ua, Qo += Mo * xa, Mo = ko[1], zo += Mo * wa, Do += Mo * ha, wo += Mo * Fa, Li += Mo * Sa, Ai += Mo * da, Ni += Mo * Pa, Ui += Mo * va, So += Mo * ca, $o += Mo * Na, Eo += Mo * Ea, zi += Mo * fa, _o += Mo * Ca, Fi += Mo * Oa, xo += Mo * ya, Qo += Mo * Ua, To += Mo * xa, Mo = ko[2], Do += Mo * wa, wo += Mo * ha, Li += Mo * Fa, Ai += Mo * Sa, Ni += Mo * da, Ui += Mo * Pa, So += Mo * va, $o += Mo * ca, Eo += Mo * Na, zi += Mo * Ea, _o += Mo * fa, Fi += Mo * Ca, xo += Mo * Oa, Qo += Mo * ya, To += Mo * Ua, Ko += Mo * xa, Mo = ko[3], wo += Mo * wa, Li += Mo * ha, Ai += Mo * Fa, Ni += Mo * Sa, Ui += Mo * da, So += Mo * Pa, $o += Mo * va, Eo += Mo * ca, zi += Mo * Na, _o += Mo * Ea, Fi += Mo * fa, xo += Mo * Ca, Qo += Mo * Oa, To += Mo * ya, Ko += Mo * Ua, Vo += Mo * xa, Mo = ko[4], Li += Mo * wa, Ai += Mo * ha, Ni += Mo * Fa, Ui += Mo * Sa, So += Mo * da, $o += Mo * Pa, Eo += Mo * va, zi += Mo * ca, _o += Mo * Na, Fi += Mo * Ea, xo += Mo * fa, Qo += Mo * Ca, To += Mo * Oa, Ko += Mo * ya, Vo += Mo * Ua, Wo += Mo * xa, Mo = ko[5], Ai += Mo * wa, Ni += Mo * ha, Ui += Mo * Fa, So += Mo * Sa, $o += Mo * da, Eo += Mo * Pa, zi += Mo * va, _o += Mo * ca, Fi += Mo * Na, xo += Mo * Ea, Qo += Mo * fa, To += Mo * Ca, Ko += Mo * Oa, Vo += Mo * ya, Wo += Mo * Ua, jo += Mo * xa, Mo = ko[6], Ni += Mo * wa, Ui += Mo * ha, So += Mo * Fa, $o += Mo * Sa, Eo += Mo * da, zi += Mo * Pa, _o += Mo * va, Fi += Mo * ca, xo += Mo * Na, Qo += Mo * Ea, To += Mo * fa, Ko += Mo * Ca, Vo += Mo * Oa, Wo += Mo * ya, jo += Mo * Ua, Ao += Mo * xa, Mo = ko[7], Ui += Mo * wa, So += Mo * ha, $o += Mo * Fa, Eo += Mo * Sa, zi += Mo * da, _o += Mo * Pa, Fi += Mo * va, xo += Mo * ca, Qo += Mo * Na, To += Mo * Ea, Ko += Mo * fa, Vo += Mo * Ca, Wo += Mo * Oa, jo += Mo * ya, Ao += Mo * Ua, Lo += Mo * xa, Mo = ko[8], So += Mo * wa, $o += Mo * ha, Eo += Mo * Fa, zi += Mo * Sa, _o += Mo * da, Fi += Mo * Pa, xo += Mo * va, Qo += Mo * ca, To += Mo * Na, Ko += Mo * Ea, Vo += Mo * fa, Wo += Mo * Ca, jo += Mo * Oa, Ao += Mo * ya, Lo += Mo * Ua, Zo += Mo * xa, Mo = ko[9], $o += Mo * wa, Eo += Mo * ha, zi += Mo * Fa, _o += Mo * Sa, Fi += Mo * da, xo += Mo * Pa, Qo += Mo * va, To += Mo * ca, Ko += Mo * Na, Vo += Mo * Ea, Wo += Mo * fa, jo += Mo * Ca, Ao += Mo * Oa, Lo += Mo * ya, Zo += Mo * Ua, An += Mo * xa, Mo = ko[10], Eo += Mo * wa, zi += Mo * ha, _o += Mo * Fa, Fi += Mo * Sa, xo += Mo * da, Qo += Mo * Pa, To += Mo * va, Ko += Mo * ca, Vo += Mo * Na, Wo += Mo * Ea, jo += Mo * fa, Ao += Mo * Ca, Lo += Mo * Oa, Zo += Mo * ya, An += Mo * Ua, ra += Mo * xa, Mo = ko[11], zi += Mo * wa, _o += Mo * ha, Fi += Mo * Fa, xo += Mo * Sa, Qo += Mo * da, To += Mo * Pa, Ko += Mo * va, Vo += Mo * ca, Wo += Mo * Na, jo += Mo * Ea, Ao += Mo * fa, Lo += Mo * Ca, Zo += Mo * Oa, An += Mo * ya, ra += Mo * Ua, sa += Mo * xa, Mo = ko[12], _o += Mo * wa, Fi += Mo * ha, xo += Mo * Fa, Qo += Mo * Sa, To += Mo * da, Ko += Mo * Pa, Vo += Mo * va, Wo += Mo * ca, jo += Mo * Na, Ao += Mo * Ea, Lo += Mo * fa, Zo += Mo * Ca, An += Mo * Oa, ra += Mo * ya, sa += Mo * Ua, Ma += Mo * xa, Mo = ko[13], Fi += Mo * wa, xo += Mo * ha, Qo += Mo * Fa, To += Mo * Sa, Ko += Mo * da, Vo += Mo * Pa, Wo += Mo * va, jo += Mo * ca, Ao += Mo * Na, Lo += Mo * Ea, Zo += Mo * fa, An += Mo * Ca, ra += Mo * Oa, sa += Mo * ya, Ma += Mo * Ua, ba += Mo * xa, Mo = ko[14], xo += Mo * wa, Qo += Mo * ha, To += Mo * Fa, Ko += Mo * Sa, Vo += Mo * da, Wo += Mo * Pa, jo += Mo * va, Ao += Mo * ca, Lo += Mo * Na, Zo += Mo * Ea, An += Mo * fa, ra += Mo * Ca, sa += Mo * Oa, Ma += Mo * ya, ba += Mo * Ua, ma += Mo * xa, Mo = ko[15], Qo += Mo * wa, To += Mo * ha, Ko += Mo * Fa, Vo += Mo * Sa, Wo += Mo * da, jo += Mo * Pa, Ao += Mo * va, Lo += Mo * ca, Zo += Mo * Na, An += Mo * Ea, ra += Mo * fa, sa += Mo * Ca, Ma += Mo * Oa, ba += Mo * ya, ma += Mo * Ua, Va += Mo * xa, Jo += 38 * To, zo += 38 * Ko, Do += 38 * Vo, wo += 38 * Wo, Li += 38 * jo, Ai += 38 * Ao, Ni += 38 * Lo, Ui += 38 * Zo, So += 38 * An, $o += 38 * ra, Eo += 38 * sa, zi += 38 * Ma, _o += 38 * ba, Fi += 38 * ma, xo += 38 * Va, No = 1, Mo = Jo + No + 65535, No = Math.floor(Mo / 65536), Jo = Mo - No * 65536, Mo = zo + No + 65535, No = Math.floor(Mo / 65536), zo = Mo - No * 65536, Mo = Do + No + 65535, No = Math.floor(Mo / 65536), Do = Mo - No * 65536, Mo = wo + No + 65535, No = Math.floor(Mo / 65536), wo = Mo - No * 65536, Mo = Li + No + 65535, No = Math.floor(Mo / 65536), Li = Mo - No * 65536, Mo = Ai + No + 65535, No = Math.floor(Mo / 65536), Ai = Mo - No * 65536, Mo = Ni + No + 65535, No = Math.floor(Mo / 65536), Ni = Mo - No * 65536, Mo = Ui + No + 65535, No = Math.floor(Mo / 65536), Ui = Mo - No * 65536, Mo = So + No + 65535, No = Math.floor(Mo / 65536), So = Mo - No * 65536, Mo = $o + No + 65535, No = Math.floor(Mo / 65536), $o = Mo - No * 65536, Mo = Eo + No + 65535, No = Math.floor(Mo / 65536), Eo = Mo - No * 65536, Mo = zi + No + 65535, No = Math.floor(Mo / 65536), zi = Mo - No * 65536, Mo = _o + No + 65535, No = Math.floor(Mo / 65536), _o = Mo - No * 65536, Mo = Fi + No + 65535, No = Math.floor(Mo / 65536), Fi = Mo - No * 65536, Mo = xo + No + 65535, No = Math.floor(Mo / 65536), xo = Mo - No * 65536, Mo = Qo + No + 65535, No = Math.floor(Mo / 65536), Qo = Mo - No * 65536, Jo += No - 1 + 37 * (No - 1), No = 1, Mo = Jo + No + 65535, No = Math.floor(Mo / 65536), Jo = Mo - No * 65536, Mo = zo + No + 65535, No = Math.floor(Mo / 65536), zo = Mo - No * 65536, Mo = Do + No + 65535, No = Math.floor(Mo / 65536), Do = Mo - No * 65536, Mo = wo + No + 65535, No = Math.floor(Mo / 65536), wo = Mo - No * 65536, Mo = Li + No + 65535, No = Math.floor(Mo / 65536), Li = Mo - No * 65536, Mo = Ai + No + 65535, No = Math.floor(Mo / 65536), Ai = Mo - No * 65536, Mo = Ni + No + 65535, No = Math.floor(Mo / 65536), Ni = Mo - No * 65536, Mo = Ui + No + 65535, No = Math.floor(Mo / 65536), Ui = Mo - No * 65536, Mo = So + No + 65535, No = Math.floor(Mo / 65536), So = Mo - No * 65536, Mo = $o + No + 65535, No = Math.floor(Mo / 65536), $o = Mo - No * 65536, Mo = Eo + No + 65535, No = Math.floor(Mo / 65536), Eo = Mo - No * 65536, Mo = zi + No + 65535, No = Math.floor(Mo / 65536), zi = Mo - No * 65536, Mo = _o + No + 65535, No = Math.floor(Mo / 65536), _o = Mo - No * 65536, Mo = Fi + No + 65535, No = Math.floor(Mo / 65536), Fi = Mo - No * 65536, Mo = xo + No + 65535, No = Math.floor(Mo / 65536), xo = Mo - No * 65536, Mo = Qo + No + 65535, No = Math.floor(Mo / 65536), Qo = Mo - No * 65536, Jo += No - 1 + 37 * (No - 1), Co[0] = Jo, Co[1] = zo, Co[2] = Do, Co[3] = wo, Co[4] = Li, Co[5] = Ai, Co[6] = Ni, Co[7] = Ui, Co[8] = So, Co[9] = $o, Co[10] = Eo, Co[11] = zi, Co[12] = _o, Co[13] = Fi, Co[14] = xo, Co[15] = Qo;
  }
  function Ci(Co, ko) {
    Ii(Co, ko, ko);
  }
  function Oo(Co, ko) {
    const Po = Si();
    for (let Mo = 0; Mo < 16; Mo++)
      Po[Mo] = ko[Mo];
    for (let Mo = 253; Mo >= 0; Mo--)
      Ci(Po, Po), Mo !== 2 && Mo !== 4 && Ii(Po, Po, ko);
    for (let Mo = 0; Mo < 16; Mo++)
      Co[Mo] = Po[Mo];
  }
  function Ro(Co, ko) {
    const Po = new Uint8Array(32), Mo = new Float64Array(80), No = Si(), Jo = Si(), zo = Si(), Do = Si(), wo = Si(), Li = Si();
    for (let So = 0; So < 31; So++)
      Po[So] = Co[So];
    Po[31] = Co[31] & 127 | 64, Po[0] &= 248, Ti(Mo, ko);
    for (let So = 0; So < 16; So++)
      Jo[So] = Mo[So];
    No[0] = Do[0] = 1;
    for (let So = 254; So >= 0; --So) {
      const $o = Po[So >>> 3] >>> (So & 7) & 1;
      xi(No, Jo, $o), xi(zo, Do, $o), Oi(wo, No, zo), Mi(No, No, zo), Oi(zo, Jo, Do), Mi(Jo, Jo, Do), Ci(Do, wo), Ci(Li, No), Ii(No, zo, No), Ii(zo, Jo, wo), Oi(wo, No, zo), Mi(No, No, zo), Ci(Jo, No), Mi(zo, Do, Li), Ii(No, zo, Ei), Oi(No, No, Do), Ii(zo, zo, No), Ii(No, Do, Li), Ii(Do, Jo, Mo), Ci(Jo, wo), xi(No, Jo, $o), xi(zo, Do, $o);
    }
    for (let So = 0; So < 16; So++)
      Mo[So + 16] = No[So], Mo[So + 32] = zo[So], Mo[So + 48] = Jo[So], Mo[So + 64] = Do[So];
    const Ai = Mo.subarray(32), Ni = Mo.subarray(16);
    Oo(Ai, Ai), Ii(Ni, Ni, Ai);
    const Ui = new Uint8Array(32);
    return Ri(Ui, Ni), Ui;
  }
  se.scalarMult = Ro;
  function Bo(Co) {
    return Ro(Co, wi);
  }
  se.scalarMultBase = Bo;
  function Fo(Co) {
    if (Co.length !== se.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${se.SECRET_KEY_LENGTH} bytes`);
    const ko = new Uint8Array(Co);
    return {
      publicKey: Bo(ko),
      secretKey: ko
    };
  }
  se.generateKeyPairFromSeed = Fo;
  function Io(Co) {
    const ko = (0, e.randomBytes)(32, Co), Po = Fo(ko);
    return (0, Oe.wipe)(ko), Po;
  }
  se.generateKeyPair = Io;
  function Uo(Co, ko, Po = !1) {
    if (Co.length !== se.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (ko.length !== se.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const Mo = Ro(Co, ko);
    if (Po) {
      let No = 0;
      for (let Jo = 0; Jo < Mo.length; Jo++)
        No |= Mo[Jo];
      if (No === 0)
        throw new Error("X25519: invalid shared key");
    }
    return Mo;
  }
  se.sharedKey = Uo;
})(x25519);
var __spreadArray = globalThis && globalThis.__spreadArray || function(se, e, Oe) {
  if (Oe || arguments.length === 2)
    for (var Si = 0, wi = e.length, Ei; Si < wi; Si++)
      (Ei || !(Si in e)) && (Ei || (Ei = Array.prototype.slice.call(e, 0, Si)), Ei[Si] = e[Si]);
  return se.concat(Ei || Array.prototype.slice.call(e));
}, BrowserInfo = (
  /** @class */
  function() {
    function se(e, Oe, Si) {
      this.name = e, this.version = Oe, this.os = Si, this.type = "browser";
    }
    return se;
  }()
), NodeInfo = (
  /** @class */
  function() {
    function se(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return se;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  function() {
    function se(e, Oe, Si, wi) {
      this.name = e, this.version = Oe, this.os = Si, this.bot = wi, this.type = "bot-device";
    }
    return se;
  }()
), BotInfo = (
  /** @class */
  function() {
    function se() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return se;
  }()
), ReactNativeInfo = (
  /** @class */
  function() {
    function se() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return se;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(se) {
  return se ? parseUserAgent(se) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
function matchUserAgent(se) {
  return se !== "" && userAgentRules.reduce(function(e, Oe) {
    var Si = Oe[0], wi = Oe[1];
    if (e)
      return e;
    var Ei = wi.exec(se);
    return !!Ei && [Si, Ei];
  }, !1);
}
function parseUserAgent(se) {
  var e = matchUserAgent(se);
  if (!e)
    return null;
  var Oe = e[0], Si = e[1];
  if (Oe === "searchbot")
    return new BotInfo();
  var wi = Si[1] && Si[1].split(".").join("_").split("_").slice(0, 3);
  wi ? wi.length < REQUIRED_VERSION_PARTS && (wi = __spreadArray(__spreadArray([], wi, !0), createVersionParts(REQUIRED_VERSION_PARTS - wi.length), !0)) : wi = [];
  var Ei = wi.join("."), $i = detectOS(se), xi = SEARCHBOT_OS_REGEX.exec(se);
  return xi && xi[1] ? new SearchBotDeviceInfo(Oe, Ei, $i, xi[1]) : new BrowserInfo(Oe, Ei, $i);
}
function detectOS(se) {
  for (var e = 0, Oe = operatingSystemRules.length; e < Oe; e++) {
    var Si = operatingSystemRules[e], wi = Si[0], Ei = Si[1], $i = Ei.exec(se);
    if ($i)
      return wi;
  }
  return null;
}
function getNodeVersion() {
  var se = typeof process < "u" && process.version;
  return se ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(se) {
  for (var e = [], Oe = 0; Oe < se; Oe++)
    e.push("0");
  return e;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: !0 });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
function getFromWindow(se) {
  let e;
  return typeof window < "u" && typeof window[se] < "u" && (e = window[se]), e;
}
cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(se) {
  const e = getFromWindow(se);
  if (!e)
    throw new Error(`${se} is not defined in Window`);
  return e;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage;
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let se, e;
  try {
    se = window_getters_1.getDocumentOrThrow(), e = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function Oe() {
    const Mi = se.getElementsByTagName("link"), Ii = [];
    for (let Ci = 0; Ci < Mi.length; Ci++) {
      const Oo = Mi[Ci], Ro = Oo.getAttribute("rel");
      if (Ro && Ro.toLowerCase().indexOf("icon") > -1) {
        const Bo = Oo.getAttribute("href");
        if (Bo)
          if (Bo.toLowerCase().indexOf("https:") === -1 && Bo.toLowerCase().indexOf("http:") === -1 && Bo.indexOf("//") !== 0) {
            let Fo = e.protocol + "//" + e.host;
            if (Bo.indexOf("/") === 0)
              Fo += Bo;
            else {
              const Io = e.pathname.split("/");
              Io.pop();
              const Uo = Io.join("/");
              Fo += Uo + "/" + Bo;
            }
            Ii.push(Fo);
          } else if (Bo.indexOf("//") === 0) {
            const Fo = e.protocol + Bo;
            Ii.push(Fo);
          } else
            Ii.push(Bo);
      }
    }
    return Ii;
  }
  function Si(...Mi) {
    const Ii = se.getElementsByTagName("meta");
    for (let Ci = 0; Ci < Ii.length; Ci++) {
      const Oo = Ii[Ci], Ro = ["itemprop", "property", "name"].map((Bo) => Oo.getAttribute(Bo)).filter((Bo) => Bo ? Mi.includes(Bo) : !1);
      if (Ro.length && Ro) {
        const Bo = Oo.getAttribute("content");
        if (Bo)
          return Bo;
      }
    }
    return "";
  }
  function wi() {
    let Mi = Si("name", "og:site_name", "og:title", "twitter:title");
    return Mi || (Mi = se.title), Mi;
  }
  function Ei() {
    return Si("description", "og:description", "twitter:description", "keywords");
  }
  const $i = wi(), xi = Ei(), Ri = e.origin, Ti = Oe();
  return {
    description: xi,
    url: Ri,
    icons: Ti,
    name: $i
  };
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = (se) => encodeURIComponent(se).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(se, e) {
  try {
    return [decodeURIComponent(se.join(""))];
  } catch {
  }
  if (se.length === 1)
    return se;
  e = e || 1;
  var Oe = se.slice(0, e), Si = se.slice(e);
  return Array.prototype.concat.call([], decodeComponents(Oe), decodeComponents(Si));
}
function decode$1(se) {
  try {
    return decodeURIComponent(se);
  } catch {
    for (var e = se.match(singleMatcher) || [], Oe = 1; Oe < e.length; Oe++)
      se = decodeComponents(e, Oe).join(""), e = se.match(singleMatcher) || [];
    return se;
  }
}
function customDecodeURIComponent(se) {
  for (var e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, Oe = multiMatcher.exec(se); Oe; ) {
    try {
      e[Oe[0]] = decodeURIComponent(Oe[0]);
    } catch {
      var Si = decode$1(Oe[0]);
      Si !== Oe[0] && (e[Oe[0]] = Si);
    }
    Oe = multiMatcher.exec(se);
  }
  e["%C2"] = "�";
  for (var wi = Object.keys(e), Ei = 0; Ei < wi.length; Ei++) {
    var $i = wi[Ei];
    se = se.replace(new RegExp($i, "g"), e[$i]);
  }
  return se;
}
var decodeUriComponent = function(se) {
  if (typeof se != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof se + "`");
  try {
    return se = se.replace(/\+/g, " "), decodeURIComponent(se);
  } catch {
    return customDecodeURIComponent(se);
  }
}, splitOnFirst = (se, e) => {
  if (!(typeof se == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [se];
  const Oe = se.indexOf(e);
  return Oe === -1 ? [se] : [
    se.slice(0, Oe),
    se.slice(Oe + e.length)
  ];
}, filterObj = function(se, e) {
  for (var Oe = {}, Si = Object.keys(se), wi = Array.isArray(e), Ei = 0; Ei < Si.length; Ei++) {
    var $i = Si[Ei], xi = se[$i];
    (wi ? e.indexOf($i) !== -1 : e($i, xi, se)) && (Oe[$i] = xi);
  }
  return Oe;
};
(function(se) {
  const e = strictUriEncode, Oe = decodeUriComponent, Si = splitOnFirst, wi = filterObj, Ei = (Io) => Io == null, $i = Symbol("encodeFragmentIdentifier");
  function xi(Io) {
    switch (Io.arrayFormat) {
      case "index":
        return (Uo) => (Co, ko) => {
          const Po = Co.length;
          return ko === void 0 || Io.skipNull && ko === null || Io.skipEmptyString && ko === "" ? Co : ko === null ? [...Co, [Oi(Uo, Io), "[", Po, "]"].join("")] : [
            ...Co,
            [Oi(Uo, Io), "[", Oi(Po, Io), "]=", Oi(ko, Io)].join("")
          ];
        };
      case "bracket":
        return (Uo) => (Co, ko) => ko === void 0 || Io.skipNull && ko === null || Io.skipEmptyString && ko === "" ? Co : ko === null ? [...Co, [Oi(Uo, Io), "[]"].join("")] : [...Co, [Oi(Uo, Io), "[]=", Oi(ko, Io)].join("")];
      case "colon-list-separator":
        return (Uo) => (Co, ko) => ko === void 0 || Io.skipNull && ko === null || Io.skipEmptyString && ko === "" ? Co : ko === null ? [...Co, [Oi(Uo, Io), ":list="].join("")] : [...Co, [Oi(Uo, Io), ":list=", Oi(ko, Io)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const Uo = Io.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (Co) => (ko, Po) => Po === void 0 || Io.skipNull && Po === null || Io.skipEmptyString && Po === "" ? ko : (Po = Po === null ? "" : Po, ko.length === 0 ? [[Oi(Co, Io), Uo, Oi(Po, Io)].join("")] : [[ko, Oi(Po, Io)].join(Io.arrayFormatSeparator)]);
      }
      default:
        return (Uo) => (Co, ko) => ko === void 0 || Io.skipNull && ko === null || Io.skipEmptyString && ko === "" ? Co : ko === null ? [...Co, Oi(Uo, Io)] : [...Co, [Oi(Uo, Io), "=", Oi(ko, Io)].join("")];
    }
  }
  function Ri(Io) {
    let Uo;
    switch (Io.arrayFormat) {
      case "index":
        return (Co, ko, Po) => {
          if (Uo = /\[(\d*)\]$/.exec(Co), Co = Co.replace(/\[\d*\]$/, ""), !Uo) {
            Po[Co] = ko;
            return;
          }
          Po[Co] === void 0 && (Po[Co] = {}), Po[Co][Uo[1]] = ko;
        };
      case "bracket":
        return (Co, ko, Po) => {
          if (Uo = /(\[\])$/.exec(Co), Co = Co.replace(/\[\]$/, ""), !Uo) {
            Po[Co] = ko;
            return;
          }
          if (Po[Co] === void 0) {
            Po[Co] = [ko];
            return;
          }
          Po[Co] = [].concat(Po[Co], ko);
        };
      case "colon-list-separator":
        return (Co, ko, Po) => {
          if (Uo = /(:list)$/.exec(Co), Co = Co.replace(/:list$/, ""), !Uo) {
            Po[Co] = ko;
            return;
          }
          if (Po[Co] === void 0) {
            Po[Co] = [ko];
            return;
          }
          Po[Co] = [].concat(Po[Co], ko);
        };
      case "comma":
      case "separator":
        return (Co, ko, Po) => {
          const Mo = typeof ko == "string" && ko.includes(Io.arrayFormatSeparator), No = typeof ko == "string" && !Mo && Mi(ko, Io).includes(Io.arrayFormatSeparator);
          ko = No ? Mi(ko, Io) : ko;
          const Jo = Mo || No ? ko.split(Io.arrayFormatSeparator).map((zo) => Mi(zo, Io)) : ko === null ? ko : Mi(ko, Io);
          Po[Co] = Jo;
        };
      case "bracket-separator":
        return (Co, ko, Po) => {
          const Mo = /(\[\])$/.test(Co);
          if (Co = Co.replace(/\[\]$/, ""), !Mo) {
            Po[Co] = ko && Mi(ko, Io);
            return;
          }
          const No = ko === null ? [] : ko.split(Io.arrayFormatSeparator).map((Jo) => Mi(Jo, Io));
          if (Po[Co] === void 0) {
            Po[Co] = No;
            return;
          }
          Po[Co] = [].concat(Po[Co], No);
        };
      default:
        return (Co, ko, Po) => {
          if (Po[Co] === void 0) {
            Po[Co] = ko;
            return;
          }
          Po[Co] = [].concat(Po[Co], ko);
        };
    }
  }
  function Ti(Io) {
    if (typeof Io != "string" || Io.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function Oi(Io, Uo) {
    return Uo.encode ? Uo.strict ? e(Io) : encodeURIComponent(Io) : Io;
  }
  function Mi(Io, Uo) {
    return Uo.decode ? Oe(Io) : Io;
  }
  function Ii(Io) {
    return Array.isArray(Io) ? Io.sort() : typeof Io == "object" ? Ii(Object.keys(Io)).sort((Uo, Co) => Number(Uo) - Number(Co)).map((Uo) => Io[Uo]) : Io;
  }
  function Ci(Io) {
    const Uo = Io.indexOf("#");
    return Uo !== -1 && (Io = Io.slice(0, Uo)), Io;
  }
  function Oo(Io) {
    let Uo = "";
    const Co = Io.indexOf("#");
    return Co !== -1 && (Uo = Io.slice(Co)), Uo;
  }
  function Ro(Io) {
    Io = Ci(Io);
    const Uo = Io.indexOf("?");
    return Uo === -1 ? "" : Io.slice(Uo + 1);
  }
  function Bo(Io, Uo) {
    return Uo.parseNumbers && !Number.isNaN(Number(Io)) && typeof Io == "string" && Io.trim() !== "" ? Io = Number(Io) : Uo.parseBooleans && Io !== null && (Io.toLowerCase() === "true" || Io.toLowerCase() === "false") && (Io = Io.toLowerCase() === "true"), Io;
  }
  function Fo(Io, Uo) {
    Uo = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, Uo), Ti(Uo.arrayFormatSeparator);
    const Co = Ri(Uo), ko = /* @__PURE__ */ Object.create(null);
    if (typeof Io != "string" || (Io = Io.trim().replace(/^[?#&]/, ""), !Io))
      return ko;
    for (const Po of Io.split("&")) {
      if (Po === "")
        continue;
      let [Mo, No] = Si(Uo.decode ? Po.replace(/\+/g, " ") : Po, "=");
      No = No === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(Uo.arrayFormat) ? No : Mi(No, Uo), Co(Mi(Mo, Uo), No, ko);
    }
    for (const Po of Object.keys(ko)) {
      const Mo = ko[Po];
      if (typeof Mo == "object" && Mo !== null)
        for (const No of Object.keys(Mo))
          Mo[No] = Bo(Mo[No], Uo);
      else
        ko[Po] = Bo(Mo, Uo);
    }
    return Uo.sort === !1 ? ko : (Uo.sort === !0 ? Object.keys(ko).sort() : Object.keys(ko).sort(Uo.sort)).reduce((Po, Mo) => {
      const No = ko[Mo];
      return No && typeof No == "object" && !Array.isArray(No) ? Po[Mo] = Ii(No) : Po[Mo] = No, Po;
    }, /* @__PURE__ */ Object.create(null));
  }
  se.extract = Ro, se.parse = Fo, se.stringify = (Io, Uo) => {
    if (!Io)
      return "";
    Uo = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, Uo), Ti(Uo.arrayFormatSeparator);
    const Co = (No) => Uo.skipNull && Ei(Io[No]) || Uo.skipEmptyString && Io[No] === "", ko = xi(Uo), Po = {};
    for (const No of Object.keys(Io))
      Co(No) || (Po[No] = Io[No]);
    const Mo = Object.keys(Po);
    return Uo.sort !== !1 && Mo.sort(Uo.sort), Mo.map((No) => {
      const Jo = Io[No];
      return Jo === void 0 ? "" : Jo === null ? Oi(No, Uo) : Array.isArray(Jo) ? Jo.length === 0 && Uo.arrayFormat === "bracket-separator" ? Oi(No, Uo) + "[]" : Jo.reduce(ko(No), []).join("&") : Oi(No, Uo) + "=" + Oi(Jo, Uo);
    }).filter((No) => No.length > 0).join("&");
  }, se.parseUrl = (Io, Uo) => {
    Uo = Object.assign({
      decode: !0
    }, Uo);
    const [Co, ko] = Si(Io, "#");
    return Object.assign(
      {
        url: Co.split("?")[0] || "",
        query: Fo(Ro(Io), Uo)
      },
      Uo && Uo.parseFragmentIdentifier && ko ? { fragmentIdentifier: Mi(ko, Uo) } : {}
    );
  }, se.stringifyUrl = (Io, Uo) => {
    Uo = Object.assign({
      encode: !0,
      strict: !0,
      [$i]: !0
    }, Uo);
    const Co = Ci(Io.url).split("?")[0] || "", ko = se.extract(Io.url), Po = se.parse(ko, { sort: !1 }), Mo = Object.assign(Po, Io.query);
    let No = se.stringify(Mo, Uo);
    No && (No = `?${No}`);
    let Jo = Oo(Io.url);
    return Io.fragmentIdentifier && (Jo = `#${Uo[$i] ? Oi(Io.fragmentIdentifier, Uo) : Io.fragmentIdentifier}`), `${Co}${No}${Jo}`;
  }, se.pick = (Io, Uo, Co) => {
    Co = Object.assign({
      parseFragmentIdentifier: !0,
      [$i]: !1
    }, Co);
    const { url: ko, query: Po, fragmentIdentifier: Mo } = se.parseUrl(Io, Co);
    return se.stringifyUrl({
      url: ko,
      query: wi(Po, Uo),
      fragmentIdentifier: Mo
    }, Co);
  }, se.exclude = (Io, Uo, Co) => {
    const ko = Array.isArray(Uo) ? (Po) => !Uo.includes(Po) : (Po, Mo) => !Uo(Po, Mo);
    return se.pick(Io, ko, Co);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function M$4(se, e) {
  return se.includes(":") ? [se] : e.chains || [];
}
const J$3 = "base10", p$3 = "base16", L$2 = "base64pad", x$7 = "utf8", Q$4 = 0, _$5 = 1, $n$1 = 0, Ie$1 = 1, Z$3 = 12, X$4 = 32;
function jn$1() {
  const se = x25519.generateKeyPair();
  return { privateKey: toString$2(se.secretKey, p$3), publicKey: toString$2(se.publicKey, p$3) };
}
function Dn$1() {
  const se = random.randomBytes(X$4);
  return toString$2(se, p$3);
}
function kn$1(se, e) {
  const Oe = x25519.sharedKey(fromString$1(se, p$3), fromString$1(e, p$3)), Si = new HKDF_1(sha256$1.SHA256, Oe).expand(X$4);
  return toString$2(Si, p$3);
}
function Vn$1(se) {
  const e = sha256$1.hash(fromString$1(se, p$3));
  return toString$2(e, p$3);
}
function Mn$1(se) {
  const e = sha256$1.hash(fromString$1(se, x$7));
  return toString$2(e, p$3);
}
function Pe(se) {
  return fromString$1(`${se}`, J$3);
}
function $$2(se) {
  return Number(toString$2(se, J$3));
}
function Kn$1(se) {
  const e = Pe(typeof se.type < "u" ? se.type : Q$4);
  if ($$2(e) === _$5 && typeof se.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const Oe = typeof se.senderPublicKey < "u" ? fromString$1(se.senderPublicKey, p$3) : void 0, Si = typeof se.iv < "u" ? fromString$1(se.iv, p$3) : random.randomBytes(Z$3), wi = new chacha20poly1305.ChaCha20Poly1305(fromString$1(se.symKey, p$3)).seal(Si, fromString$1(se.message, x$7));
  return Te({ type: e, sealed: wi, iv: Si, senderPublicKey: Oe });
}
function Ln$1(se) {
  const e = new chacha20poly1305.ChaCha20Poly1305(fromString$1(se.symKey, p$3)), { sealed: Oe, iv: Si } = ee(se.encoded), wi = e.open(Si, Oe);
  if (wi === null)
    throw new Error("Failed to decrypt");
  return toString$2(wi, x$7);
}
function Te(se) {
  if ($$2(se.type) === _$5) {
    if (typeof se.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString$2(concat$3([se.type, se.senderPublicKey, se.iv, se.sealed]), L$2);
  }
  return toString$2(concat$3([se.type, se.iv, se.sealed]), L$2);
}
function ee(se) {
  const e = fromString$1(se, L$2), Oe = e.slice($n$1, Ie$1), Si = Ie$1;
  if ($$2(Oe) === _$5) {
    const xi = Si + X$4, Ri = xi + Z$3, Ti = e.slice(Si, xi), Oi = e.slice(xi, Ri), Mi = e.slice(Ri);
    return { type: Oe, sealed: Mi, iv: Oi, senderPublicKey: Ti };
  }
  const wi = Si + Z$3, Ei = e.slice(Si, wi), $i = e.slice(wi);
  return { type: Oe, sealed: $i, iv: Ei };
}
function xn$1(se, e) {
  const Oe = ee(se);
  return Re$1({ type: $$2(Oe.type), senderPublicKey: typeof Oe.senderPublicKey < "u" ? toString$2(Oe.senderPublicKey, p$3) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function Re$1(se) {
  const e = (se == null ? void 0 : se.type) || Q$4;
  if (e === _$5) {
    if (typeof (se == null ? void 0 : se.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (se == null ? void 0 : se.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: se == null ? void 0 : se.senderPublicKey, receiverPublicKey: se == null ? void 0 : se.receiverPublicKey };
}
function Fn$1(se) {
  return se.type === _$5 && typeof se.senderPublicKey == "string" && typeof se.receiverPublicKey == "string";
}
var Hn$1 = Object.defineProperty, Ae$1 = Object.getOwnPropertySymbols, qn$1 = Object.prototype.hasOwnProperty, Bn$1 = Object.prototype.propertyIsEnumerable, Ue$1 = (se, e, Oe) => e in se ? Hn$1(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, _e$2 = (se, e) => {
  for (var Oe in e || (e = {}))
    qn$1.call(e, Oe) && Ue$1(se, Oe, e[Oe]);
  if (Ae$1)
    for (var Oe of Ae$1(e))
      Bn$1.call(e, Oe) && Ue$1(se, Oe, e[Oe]);
  return se;
};
const Ce$1 = "ReactNative", m$1 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, je$1 = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function H$3() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce$1;
}
function q() {
  return !te() && !!getNavigator_1();
}
function R$3() {
  return H$3() ? m$1.reactNative : te() ? m$1.node : q() ? m$1.browser : m$1.unknown;
}
function De$2(se, e) {
  let Oe = queryString.parse(se);
  return Oe = _e$2(_e$2({}, Oe), e), se = queryString.stringify(Oe), se;
}
function zn$1() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function ke$1() {
  if (R$3() === m$1.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: Oe, Version: Si } = global.Platform;
    return [Oe, Si].join("-");
  }
  const se = detect();
  if (se === null)
    return "unknown";
  const e = se.os ? se.os.replace(" ", "").toLowerCase() : "unknown";
  return se.type === "browser" ? [e, se.name, se.version].join("-") : [e, se.version].join("-");
}
function Ve$1() {
  var se;
  const e = R$3();
  return e === m$1.browser ? [e, ((se = getLocation_1()) == null ? void 0 : se.host) || "unknown"].join(":") : e;
}
function Me$1(se, e, Oe) {
  const Si = ke$1(), wi = Ve$1();
  return [[se, e].join("-"), [je$1, Oe].join("-"), Si, wi].join("/");
}
function Jn$1({ protocol: se, version: e, relayUrl: Oe, sdkVersion: Si, auth: wi, projectId: Ei, useOnCloseEvent: $i }) {
  const xi = Oe.split("?"), Ri = Me$1(se, e, Si), Ti = { auth: wi, ua: Ri, projectId: Ei, useOnCloseEvent: $i || void 0 }, Oi = De$2(xi[1] || "", Ti);
  return xi[0] + "?" + Oi;
}
function O$3(se, e) {
  return se.filter((Oe) => e.includes(Oe)).length === se.length;
}
function et$3(se) {
  return Object.fromEntries(se.entries());
}
function nt$3(se) {
  return new Map(Object.entries(se));
}
function st$2(se = cjs$4.FIVE_MINUTES, e) {
  const Oe = cjs$4.toMiliseconds(se || cjs$4.FIVE_MINUTES);
  let Si, wi, Ei;
  return { resolve: ($i) => {
    Ei && Si && (clearTimeout(Ei), Si($i));
  }, reject: ($i) => {
    Ei && wi && (clearTimeout(Ei), wi($i));
  }, done: () => new Promise(($i, xi) => {
    Ei = setTimeout(() => {
      xi(new Error(e));
    }, Oe), Si = $i, wi = xi;
  }) };
}
function it$3(se, e, Oe) {
  return new Promise(async (Si, wi) => {
    const Ei = setTimeout(() => wi(new Error(Oe)), e);
    try {
      const $i = await se;
      Si($i);
    } catch ($i) {
      wi($i);
    }
    clearTimeout(Ei);
  });
}
function re$2(se, e) {
  if (typeof e == "string" && e.startsWith(`${se}:`))
    return e;
  if (se.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (se.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${se}`);
}
function ct$3(se) {
  return re$2("topic", se);
}
function at$3(se) {
  return re$2("id", se);
}
function ut$3(se) {
  const [e, Oe] = se.split(":"), Si = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof Oe == "string")
    Si.topic = Oe;
  else if (e === "id" && Number.isInteger(Number(Oe)))
    Si.id = Number(Oe);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${Oe}`);
  return Si;
}
function lt$3(se, e) {
  return cjs$4.fromMiliseconds((e || Date.now()) + cjs$4.toMiliseconds(se));
}
function dt$3(se) {
  return Date.now() >= cjs$4.toMiliseconds(se);
}
function ft$2(se, e) {
  return `${se}${e ? `:${e}` : ""}`;
}
async function pt$3({ id: se, topic: e, wcDeepLink: Oe }) {
  try {
    if (!Oe)
      return;
    const Si = typeof Oe == "string" ? JSON.parse(Oe) : Oe;
    let wi = Si == null ? void 0 : Si.href;
    if (typeof wi != "string")
      return;
    wi.endsWith("/") && (wi = wi.slice(0, -1));
    const Ei = `${wi}/wc?requestId=${se}&sessionTopic=${e}`, $i = R$3();
    $i === m$1.browser ? Ei.startsWith("https://") ? window.open(Ei, "_blank", "noreferrer noopener") : window.open(Ei, "_self", "noreferrer noopener") : $i === m$1.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(Ei);
  } catch (Si) {
    console.error(Si);
  }
}
const Fe$2 = "irn";
function mt$2(se) {
  return (se == null ? void 0 : se.relay) || { protocol: Fe$2 };
}
function yt$3(se) {
  const e = RELAY_JSONRPC[se];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${se}`);
  return e;
}
var ht$3 = Object.defineProperty, He$2 = Object.getOwnPropertySymbols, vt$3 = Object.prototype.hasOwnProperty, gt$4 = Object.prototype.propertyIsEnumerable, qe$2 = (se, e, Oe) => e in se ? ht$3(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Et$2 = (se, e) => {
  for (var Oe in e || (e = {}))
    vt$3.call(e, Oe) && qe$2(se, Oe, e[Oe]);
  if (He$2)
    for (var Oe of He$2(e))
      gt$4.call(e, Oe) && qe$2(se, Oe, e[Oe]);
  return se;
};
function Be$1(se, e = "-") {
  const Oe = {}, Si = "relay" + e;
  return Object.keys(se).forEach((wi) => {
    if (wi.startsWith(Si)) {
      const Ei = wi.replace(Si, ""), $i = se[wi];
      Oe[Ei] = $i;
    }
  }), Oe;
}
function bt$3(se) {
  const e = se.indexOf(":"), Oe = se.indexOf("?") !== -1 ? se.indexOf("?") : void 0, Si = se.substring(0, e), wi = se.substring(e + 1, Oe).split("@"), Ei = typeof Oe < "u" ? se.substring(Oe) : "", $i = queryString.parse(Ei);
  return { protocol: Si, topic: Ge$2(wi[0]), version: parseInt(wi[1], 10), symKey: $i.symKey, relay: Be$1($i) };
}
function Ge$2(se) {
  return se.startsWith("//") ? se.substring(2) : se;
}
function We$3(se, e = "-") {
  const Oe = "relay", Si = {};
  return Object.keys(se).forEach((wi) => {
    const Ei = Oe + e + wi;
    se[wi] && (Si[Ei] = se[wi]);
  }), Si;
}
function Nt$3(se) {
  return `${se.protocol}:${se.topic}@${se.version}?` + queryString.stringify(Et$2({ symKey: se.symKey }, We$3(se.relay)));
}
function A$3(se) {
  const e = [];
  return se.forEach((Oe) => {
    const [Si, wi] = Oe.split(":");
    e.push(`${Si}:${wi}`);
  }), e;
}
function Je$2(se) {
  const e = [];
  return Object.values(se).forEach((Oe) => {
    e.push(...A$3(Oe.accounts));
  }), e;
}
function Qe$2(se, e) {
  const Oe = [];
  return Object.values(se).forEach((Si) => {
    A$3(Si.accounts).includes(e) && Oe.push(...Si.methods);
  }), Oe;
}
function Ze$2(se, e) {
  const Oe = [];
  return Object.values(se).forEach((Si) => {
    A$3(Si.accounts).includes(e) && Oe.push(...Si.events);
  }), Oe;
}
function At$3(se, e) {
  const Oe = cn$2(se, e);
  if (Oe)
    throw new Error(Oe.message);
  const Si = {};
  for (const [wi, Ei] of Object.entries(se))
    Si[wi] = { methods: Ei.methods, events: Ei.events, chains: Ei.accounts.map(($i) => `${$i.split(":")[0]}:${$i.split(":")[1]}`) };
  return Si;
}
const _t$2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Ct$3 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N$2(se, e) {
  const { message: Oe, code: Si } = Ct$3[se];
  return { message: e ? `${Oe} ${e}` : Oe, code: Si };
}
function U$2(se, e) {
  const { message: Oe, code: Si } = _t$2[se];
  return { message: e ? `${Oe} ${e}` : Oe, code: Si };
}
function j$2(se, e) {
  return Array.isArray(se) ? typeof e < "u" && se.length ? se.every(e) : !0 : !1;
}
function B$2(se) {
  return Object.getPrototypeOf(se) === Object.prototype && Object.keys(se).length;
}
function w$4(se) {
  return typeof se > "u";
}
function h$3(se, e) {
  return e && w$4(se) ? !0 : typeof se == "string" && !!se.trim().length;
}
function G$2(se, e) {
  return e && w$4(se) ? !0 : typeof se == "number" && !isNaN(se);
}
function $t$3(se, e) {
  const { requiredNamespaces: Oe } = e, Si = Object.keys(se.namespaces), wi = Object.keys(Oe);
  let Ei = !0;
  return O$3(wi, Si) ? (Si.forEach(($i) => {
    const { accounts: xi, methods: Ri, events: Ti } = se.namespaces[$i], Oi = A$3(xi), Mi = Oe[$i];
    (!O$3(M$4($i, Mi), Oi) || !O$3(Mi.methods, Ri) || !O$3(Mi.events, Ti)) && (Ei = !1);
  }), Ei) : !1;
}
function D$4(se) {
  return h$3(se, !1) && se.includes(":") ? se.split(":").length === 2 : !1;
}
function en$2(se) {
  if (h$3(se, !1) && se.includes(":")) {
    const e = se.split(":");
    if (e.length === 3) {
      const Oe = e[0] + ":" + e[1];
      return !!e[2] && D$4(Oe);
    }
  }
  return !1;
}
function jt$1(se) {
  if (h$3(se, !1))
    try {
      return typeof new URL(se) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function Dt$3(se) {
  var e;
  return (e = se == null ? void 0 : se.proposer) == null ? void 0 : e.publicKey;
}
function kt$2(se) {
  return se == null ? void 0 : se.topic;
}
function Vt$3(se, e) {
  let Oe = null;
  return h$3(se == null ? void 0 : se.publicKey, !1) || (Oe = N$2("MISSING_OR_INVALID", `${e} controller public key should be a string`)), Oe;
}
function ie(se) {
  let e = !0;
  return j$2(se) ? se.length && (e = se.every((Oe) => h$3(Oe, !1))) : e = !1, e;
}
function nn$2(se, e, Oe) {
  let Si = null;
  return j$2(e) && e.length ? e.forEach((wi) => {
    Si || D$4(wi) || (Si = U$2("UNSUPPORTED_CHAINS", `${Oe}, chain ${wi} should be a string and conform to "namespace:chainId" format`));
  }) : D$4(se) || (Si = U$2("UNSUPPORTED_CHAINS", `${Oe}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), Si;
}
function tn$2(se, e, Oe) {
  let Si = null;
  return Object.entries(se).forEach(([wi, Ei]) => {
    if (Si)
      return;
    const $i = nn$2(wi, M$4(wi, Ei), `${e} ${Oe}`);
    $i && (Si = $i);
  }), Si;
}
function rn$2(se, e) {
  let Oe = null;
  return j$2(se) ? se.forEach((Si) => {
    Oe || en$2(Si) || (Oe = U$2("UNSUPPORTED_ACCOUNTS", `${e}, account ${Si} should be a string and conform to "namespace:chainId:address" format`));
  }) : Oe = U$2("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), Oe;
}
function on$2(se, e) {
  let Oe = null;
  return Object.values(se).forEach((Si) => {
    if (Oe)
      return;
    const wi = rn$2(Si == null ? void 0 : Si.accounts, `${e} namespace`);
    wi && (Oe = wi);
  }), Oe;
}
function sn$2(se, e) {
  let Oe = null;
  return ie(se == null ? void 0 : se.methods) ? ie(se == null ? void 0 : se.events) || (Oe = U$2("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : Oe = U$2("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), Oe;
}
function ce$3(se, e) {
  let Oe = null;
  return Object.values(se).forEach((Si) => {
    if (Oe)
      return;
    const wi = sn$2(Si, `${e}, namespace`);
    wi && (Oe = wi);
  }), Oe;
}
function Mt$3(se, e, Oe) {
  let Si = null;
  if (se && B$2(se)) {
    const wi = ce$3(se, e);
    wi && (Si = wi);
    const Ei = tn$2(se, e, Oe);
    Ei && (Si = Ei);
  } else
    Si = N$2("MISSING_OR_INVALID", `${e}, ${Oe} should be an object with data`);
  return Si;
}
function cn$2(se, e) {
  let Oe = null;
  if (se && B$2(se)) {
    const Si = ce$3(se, e);
    Si && (Oe = Si);
    const wi = on$2(se, e);
    wi && (Oe = wi);
  } else
    Oe = N$2("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return Oe;
}
function an$2(se) {
  return h$3(se.protocol, !0);
}
function Kt$3(se, e) {
  let Oe = !1;
  return e && !se ? Oe = !0 : se && j$2(se) && se.length && se.forEach((Si) => {
    Oe = an$2(Si);
  }), Oe;
}
function Lt$3(se) {
  return typeof se == "number";
}
function xt$3(se) {
  return typeof se < "u" && typeof se !== null;
}
function Ft$3(se) {
  return !(!se || typeof se != "object" || !se.code || !G$2(se.code, !1) || !se.message || !h$3(se.message, !1));
}
function Ht$2(se) {
  return !(w$4(se) || !h$3(se.method, !1));
}
function qt$2(se) {
  return !(w$4(se) || w$4(se.result) && w$4(se.error) || !G$2(se.id, !1) || !h$3(se.jsonrpc, !1));
}
function Bt$3(se) {
  return !(w$4(se) || !h$3(se.name, !1));
}
function Gt$2(se, e) {
  return !(!D$4(e) || !Je$2(se).includes(e));
}
function Wt$2(se, e, Oe) {
  return h$3(Oe, !1) ? Qe$2(se, e).includes(Oe) : !1;
}
function zt$3(se, e, Oe) {
  return h$3(Oe, !1) ? Ze$2(se, e).includes(Oe) : !1;
}
function un$2(se, e, Oe) {
  let Si = null;
  const wi = Yt$2(se), Ei = Jt$2(e), $i = Object.keys(wi), xi = Object.keys(Ei), Ri = ln$2(Object.keys(se)), Ti = ln$2(Object.keys(e)), Oi = Ri.filter((Mi) => !Ti.includes(Mi));
  return Oi.length && (Si = N$2("NON_CONFORMING_NAMESPACES", `${Oe} namespaces keys don't satisfy requiredNamespaces.
      Required: ${Oi.toString()}
      Received: ${Object.keys(e).toString()}`)), O$3($i, xi) || (Si = N$2("NON_CONFORMING_NAMESPACES", `${Oe} namespaces chains don't satisfy required namespaces.
      Required: ${$i.toString()}
      Approved: ${xi.toString()}`)), Object.keys(e).forEach((Mi) => {
    if (!Mi.includes(":") || Si)
      return;
    const Ii = A$3(e[Mi].accounts);
    Ii.includes(Mi) || (Si = N$2("NON_CONFORMING_NAMESPACES", `${Oe} namespaces accounts don't satisfy namespace accounts for ${Mi}
        Required: ${Mi}
        Approved: ${Ii.toString()}`));
  }), $i.forEach((Mi) => {
    Si || (O$3(wi[Mi].methods, Ei[Mi].methods) ? O$3(wi[Mi].events, Ei[Mi].events) || (Si = N$2("NON_CONFORMING_NAMESPACES", `${Oe} namespaces events don't satisfy namespace events for ${Mi}`)) : Si = N$2("NON_CONFORMING_NAMESPACES", `${Oe} namespaces methods don't satisfy namespace methods for ${Mi}`));
  }), Si;
}
function Yt$2(se) {
  const e = {};
  return Object.keys(se).forEach((Oe) => {
    var Si;
    Oe.includes(":") ? e[Oe] = se[Oe] : (Si = se[Oe].chains) == null || Si.forEach((wi) => {
      e[wi] = { methods: se[Oe].methods, events: se[Oe].events };
    });
  }), e;
}
function ln$2(se) {
  return [...new Set(se.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Jt$2(se) {
  const e = {};
  return Object.keys(se).forEach((Oe) => {
    if (Oe.includes(":"))
      e[Oe] = se[Oe];
    else {
      const Si = A$3(se[Oe].accounts);
      Si == null || Si.forEach((wi) => {
        e[wi] = { accounts: se[Oe].accounts.filter((Ei) => Ei.includes(`${wi}:`)), methods: se[Oe].methods, events: se[Oe].events };
      });
    }
  }), e;
}
function Qt$2(se, e) {
  return G$2(se, !1) && se <= e.max && se >= e.min;
}
function Zt$2() {
  const se = R$3();
  return new Promise((e) => {
    switch (se) {
      case m$1.browser:
        e(dn$2());
        break;
      case m$1.reactNative:
        e(fn$1());
        break;
      case m$1.node:
        e(pn$1());
        break;
      default:
        e(!0);
    }
  });
}
function dn$2() {
  return q() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn$1() {
  if (H$3() && typeof global < "u" && global != null && global.NetInfo) {
    const se = await (global == null ? void 0 : global.NetInfo.fetch());
    return se == null ? void 0 : se.isConnected;
  }
  return !0;
}
function pn$1() {
  return !0;
}
function Xt$2(se) {
  switch (R$3()) {
    case m$1.browser:
      mn$1(se);
      break;
    case m$1.reactNative:
      yn$2(se);
      break;
  }
}
function mn$1(se) {
  q() && (window.addEventListener("online", () => se(!0)), window.addEventListener("offline", () => se(!1)));
}
function yn$2(se) {
  H$3() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => se(e == null ? void 0 : e.isConnected)));
}
const ae$4 = {};
let er$3 = class {
  static get(e) {
    return ae$4[e];
  }
  static set(e, Oe) {
    ae$4[e] = Oe;
  }
  static delete(e) {
    delete ae$4[e];
  }
};
const PARSE_ERROR = "PARSE_ERROR", INVALID_REQUEST = "INVALID_REQUEST", METHOD_NOT_FOUND = "METHOD_NOT_FOUND", INVALID_PARAMS = "INVALID_PARAMS", INTERNAL_ERROR = "INTERNAL_ERROR", SERVER_ERROR = "SERVER_ERROR", RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603], STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
}, DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(se) {
  return RESERVED_ERROR_CODES.includes(se);
}
function getError(se) {
  return Object.keys(STANDARD_ERROR_MAP).includes(se) ? STANDARD_ERROR_MAP[se] : STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function getErrorByCode(se) {
  const e = Object.values(STANDARD_ERROR_MAP).find((Oe) => Oe.code === se);
  return e || STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function parseConnectionError(se, e, Oe) {
  return se.message.includes("getaddrinfo ENOTFOUND") || se.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${Oe} RPC url at ${e}`) : se;
}
var cjs = {}, crypto$3 = {}, hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto)
    return crypto$3;
  hasRequiredCrypto = 1, Object.defineProperty(crypto$3, "__esModule", { value: !0 }), crypto$3.isBrowserCryptoAvailable = crypto$3.getSubtleCrypto = crypto$3.getBrowerCrypto = void 0;
  function se() {
    return (commonjsGlobal == null ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal == null ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$3.getBrowerCrypto = se;
  function e() {
    const Si = se();
    return Si.subtle || Si.webkitSubtle;
  }
  crypto$3.getSubtleCrypto = e;
  function Oe() {
    return !!se() && !!e();
  }
  return crypto$3.isBrowserCryptoAvailable = Oe, crypto$3;
}
var env = {}, hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv)
    return env;
  hasRequiredEnv = 1, Object.defineProperty(env, "__esModule", { value: !0 }), env.isBrowser = env.isNode = env.isReactNative = void 0;
  function se() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  env.isReactNative = se;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  env.isNode = e;
  function Oe() {
    return !se() && !e();
  }
  return env.isBrowser = Oe, env;
}
(function(se) {
  Object.defineProperty(se, "__esModule", { value: !0 });
  const e = tslibExports;
  e.__exportStar(requireCrypto(), se), e.__exportStar(requireEnv(), se);
})(cjs);
function payloadId(se = 3) {
  const e = Date.now() * Math.pow(10, se), Oe = Math.floor(Math.random() * Math.pow(10, se));
  return e + Oe;
}
function getBigIntRpcId(se = 6) {
  return BigInt(payloadId(se));
}
function formatJsonRpcRequest(se, e, Oe) {
  return {
    id: Oe || payloadId(),
    jsonrpc: "2.0",
    method: se,
    params: e
  };
}
function formatJsonRpcResult(se, e) {
  return {
    id: se,
    jsonrpc: "2.0",
    result: e
  };
}
function formatJsonRpcError(se, e, Oe) {
  return {
    id: se,
    jsonrpc: "2.0",
    error: formatErrorMessage(e, Oe)
  };
}
function formatErrorMessage(se, e) {
  return typeof se > "u" ? getError(INTERNAL_ERROR) : (typeof se == "string" && (se = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: se })), typeof e < "u" && (se.data = e), isReservedErrorCode(se.code) && (se = getErrorByCode(se.code)), se);
}
class IEvents {
}
class IBaseJsonRpcProvider extends IEvents {
  constructor() {
    super();
  }
}
class IJsonRpcProvider extends IBaseJsonRpcProvider {
  constructor(e) {
    super();
  }
}
const WS_REGEX = "^wss?:";
function getUrlProtocol(se) {
  const e = se.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function matchRegexProtocol(se, e) {
  const Oe = getUrlProtocol(se);
  return typeof Oe > "u" ? !1 : new RegExp(e).test(Oe);
}
function isWsUrl(se) {
  return matchRegexProtocol(se, WS_REGEX);
}
function isLocalhostUrl(se) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(se);
}
function isJsonRpcPayload(se) {
  return typeof se == "object" && "id" in se && "jsonrpc" in se && se.jsonrpc === "2.0";
}
function isJsonRpcRequest(se) {
  return isJsonRpcPayload(se) && "method" in se;
}
function isJsonRpcResponse(se) {
  return isJsonRpcPayload(se) && (isJsonRpcResult(se) || isJsonRpcError(se));
}
function isJsonRpcResult(se) {
  return "result" in se;
}
function isJsonRpcError(se) {
  return "error" in se;
}
class JsonRpcProvider extends IJsonRpcProvider {
  constructor(e) {
    super(e), this.events = new EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async request(e, Oe) {
    return this.requestStrict(formatJsonRpcRequest(e.method, e.params || [], e.id || getBigIntRpcId().toString()), Oe);
  }
  async requestStrict(e, Oe) {
    return new Promise(async (Si, wi) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (Ei) {
          wi(Ei);
        }
      this.events.on(`${e.id}`, (Ei) => {
        isJsonRpcError(Ei) ? wi(Ei.error) : Si(Ei.result);
      });
      try {
        await this.connection.send(e, Oe);
      } catch (Ei) {
        wi(Ei);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), isJsonRpcResponse(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const resolveWebSocketImplementation = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), hasBuiltInWebSocket = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", truncateQuery = (se) => se.split("?")[0], EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10, WS = resolveWebSocketImplementation();
class WsConnection {
  constructor(e) {
    if (this.url = e, this.events = new EventEmitter(), this.registering = !1, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, Oe) => {
      if (typeof this.socket > "u") {
        Oe(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (Si) => {
        this.onClose(Si), e();
      }, this.socket.close();
    });
  }
  async send(e, Oe) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (Si) {
      this.onError(e.id, Si);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const Oe = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= Oe || this.events.listenerCount("open") >= Oe) && this.events.setMaxListeners(Oe + 1), new Promise((Si, wi) => {
        this.events.once("register_error", (Ei) => {
          this.resetMaxListeners(), wi(Ei);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return wi(new Error("WebSocket connection is missing or invalid"));
          Si(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((Oe, Si) => {
      const wi = cjs.isReactNative() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, Ei = new WS(e, [], wi);
      hasBuiltInWebSocket() ? Ei.onerror = ($i) => {
        const xi = $i;
        Si(this.emitError(xi.error));
      } : Ei.on("error", ($i) => {
        Si(this.emitError($i));
      }), Ei.onopen = () => {
        this.onOpen(Ei), Oe(Ei);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (Oe) => this.onPayload(Oe), e.onclose = (Oe) => this.onClose(Oe), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const Oe = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", Oe);
  }
  onError(e, Oe) {
    const Si = this.parseError(Oe), wi = Si.message || Si.toString(), Ei = formatJsonRpcError(e, wi);
    this.events.emit("payload", Ei);
  }
  parseError(e, Oe = this.url) {
    return parseConnectionError(e, truncateQuery(Oe), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT && this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
  }
  emitError(e) {
    const Oe = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${truncateQuery(this.url)}`));
    return this.events.emit("register_error", Oe), Oe;
  }
}
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(se, e) {
  var Oe = 200, Si = "__lodash_hash_undefined__", wi = 1, Ei = 2, $i = 9007199254740991, xi = "[object Arguments]", Ri = "[object Array]", Ti = "[object AsyncFunction]", Oi = "[object Boolean]", Mi = "[object Date]", Ii = "[object Error]", Ci = "[object Function]", Oo = "[object GeneratorFunction]", Ro = "[object Map]", Bo = "[object Number]", Fo = "[object Null]", Io = "[object Object]", Uo = "[object Promise]", Co = "[object Proxy]", ko = "[object RegExp]", Po = "[object Set]", Mo = "[object String]", No = "[object Symbol]", Jo = "[object Undefined]", zo = "[object WeakMap]", Do = "[object ArrayBuffer]", wo = "[object DataView]", Li = "[object Float32Array]", Ai = "[object Float64Array]", Ni = "[object Int8Array]", Ui = "[object Int16Array]", So = "[object Int32Array]", $o = "[object Uint8Array]", Eo = "[object Uint8ClampedArray]", zi = "[object Uint16Array]", _o = "[object Uint32Array]", Fi = /[\\^$.*+?()[\]{}|]/g, xo = /^\[object .+?Constructor\]$/, Qo = /^(?:0|[1-9]\d*)$/, To = {};
  To[Li] = To[Ai] = To[Ni] = To[Ui] = To[So] = To[$o] = To[Eo] = To[zi] = To[_o] = !0, To[xi] = To[Ri] = To[Do] = To[Oi] = To[wo] = To[Mi] = To[Ii] = To[Ci] = To[Ro] = To[Bo] = To[Io] = To[ko] = To[Po] = To[Mo] = To[zo] = !1;
  var Ko = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, Vo = typeof self == "object" && self && self.Object === Object && self, Wo = Ko || Vo || Function("return this")(), jo = e && !e.nodeType && e, Ao = jo && !0 && se && !se.nodeType && se, Lo = Ao && Ao.exports === jo, Zo = Lo && Ko.process, An = function() {
    try {
      return Zo && Zo.binding && Zo.binding("util");
    } catch {
    }
  }(), ra = An && An.isTypedArray;
  function sa(Yo, ta) {
    for (var ga = -1, La = Yo == null ? 0 : Yo.length, Ya = 0, Ka = []; ++ga < La; ) {
      var rl = Yo[ga];
      ta(rl, ga, Yo) && (Ka[Ya++] = rl);
    }
    return Ka;
  }
  function Ma(Yo, ta) {
    for (var ga = -1, La = ta.length, Ya = Yo.length; ++ga < La; )
      Yo[Ya + ga] = ta[ga];
    return Yo;
  }
  function ba(Yo, ta) {
    for (var ga = -1, La = Yo == null ? 0 : Yo.length; ++ga < La; )
      if (ta(Yo[ga], ga, Yo))
        return !0;
    return !1;
  }
  function ma(Yo, ta) {
    for (var ga = -1, La = Array(Yo); ++ga < Yo; )
      La[ga] = ta(ga);
    return La;
  }
  function Va(Yo) {
    return function(ta) {
      return Yo(ta);
    };
  }
  function wa(Yo, ta) {
    return Yo.has(ta);
  }
  function ha(Yo, ta) {
    return Yo == null ? void 0 : Yo[ta];
  }
  function Fa(Yo) {
    var ta = -1, ga = Array(Yo.size);
    return Yo.forEach(function(La, Ya) {
      ga[++ta] = [Ya, La];
    }), ga;
  }
  function Sa(Yo, ta) {
    return function(ga) {
      return Yo(ta(ga));
    };
  }
  function da(Yo) {
    var ta = -1, ga = Array(Yo.size);
    return Yo.forEach(function(La) {
      ga[++ta] = La;
    }), ga;
  }
  var Pa = Array.prototype, va = Function.prototype, ca = Object.prototype, Na = Wo["__core-js_shared__"], Ea = va.toString, fa = ca.hasOwnProperty, Ca = function() {
    var Yo = /[^.]+$/.exec(Na && Na.keys && Na.keys.IE_PROTO || "");
    return Yo ? "Symbol(src)_1." + Yo : "";
  }(), Oa = ca.toString, ya = RegExp(
    "^" + Ea.call(fa).replace(Fi, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ua = Lo ? Wo.Buffer : void 0, xa = Wo.Symbol, Ra = Wo.Uint8Array, Ha = ca.propertyIsEnumerable, ka = Pa.splice, Aa = xa ? xa.toStringTag : void 0, Ga = Object.getOwnPropertySymbols, Wa = Ua ? Ua.isBuffer : void 0, $a = Sa(Object.keys, Object), qa = Il(Wo, "DataView"), Ia = Il(Wo, "Map"), Ho = Il(Wo, "Promise"), qo = Il(Wo, "Set"), Go = Il(Wo, "WeakMap"), Xo = Il(Object, "create"), ea = Rl(qa), ia = Rl(Ia), oa = Rl(Ho), aa = Rl(qo), ua = Rl(Go), na = xa ? xa.prototype : void 0, _a = na ? na.valueOf : void 0;
  function pa(Yo) {
    var ta = -1, ga = Yo == null ? 0 : Yo.length;
    for (this.clear(); ++ta < ga; ) {
      var La = Yo[ta];
      this.set(La[0], La[1]);
    }
  }
  function la() {
    this.__data__ = Xo ? Xo(null) : {}, this.size = 0;
  }
  function Ba(Yo) {
    var ta = this.has(Yo) && delete this.__data__[Yo];
    return this.size -= ta ? 1 : 0, ta;
  }
  function Da(Yo) {
    var ta = this.__data__;
    if (Xo) {
      var ga = ta[Yo];
      return ga === Si ? void 0 : ga;
    }
    return fa.call(ta, Yo) ? ta[Yo] : void 0;
  }
  function Ta(Yo) {
    var ta = this.__data__;
    return Xo ? ta[Yo] !== void 0 : fa.call(ta, Yo);
  }
  function Ja(Yo, ta) {
    var ga = this.__data__;
    return this.size += this.has(Yo) ? 0 : 1, ga[Yo] = Xo && ta === void 0 ? Si : ta, this;
  }
  pa.prototype.clear = la, pa.prototype.delete = Ba, pa.prototype.get = Da, pa.prototype.has = Ta, pa.prototype.set = Ja;
  function ja(Yo) {
    var ta = -1, ga = Yo == null ? 0 : Yo.length;
    for (this.clear(); ++ta < ga; ) {
      var La = Yo[ta];
      this.set(La[0], La[1]);
    }
  }
  function za() {
    this.__data__ = [], this.size = 0;
  }
  function Qa(Yo) {
    var ta = this.__data__, ga = Nl(ta, Yo);
    if (ga < 0)
      return !1;
    var La = ta.length - 1;
    return ga == La ? ta.pop() : ka.call(ta, ga, 1), --this.size, !0;
  }
  function tl(Yo) {
    var ta = this.__data__, ga = Nl(ta, Yo);
    return ga < 0 ? void 0 : ta[ga][1];
  }
  function Xa(Yo) {
    return Nl(this.__data__, Yo) > -1;
  }
  function ol(Yo, ta) {
    var ga = this.__data__, La = Nl(ga, Yo);
    return La < 0 ? (++this.size, ga.push([Yo, ta])) : ga[La][1] = ta, this;
  }
  ja.prototype.clear = za, ja.prototype.delete = Qa, ja.prototype.get = tl, ja.prototype.has = Xa, ja.prototype.set = ol;
  function Za(Yo) {
    var ta = -1, ga = Yo == null ? 0 : Yo.length;
    for (this.clear(); ++ta < ga; ) {
      var La = Yo[ta];
      this.set(La[0], La[1]);
    }
  }
  function ul() {
    this.size = 0, this.__data__ = {
      hash: new pa(),
      map: new (Ia || ja)(),
      string: new pa()
    };
  }
  function cl(Yo) {
    var ta = Fl(this, Yo).delete(Yo);
    return this.size -= ta ? 1 : 0, ta;
  }
  function fl(Yo) {
    return Fl(this, Yo).get(Yo);
  }
  function pl(Yo) {
    return Fl(this, Yo).has(Yo);
  }
  function dl(Yo, ta) {
    var ga = Fl(this, Yo), La = ga.size;
    return ga.set(Yo, ta), this.size += ga.size == La ? 0 : 1, this;
  }
  Za.prototype.clear = ul, Za.prototype.delete = cl, Za.prototype.get = fl, Za.prototype.has = pl, Za.prototype.set = dl;
  function al(Yo) {
    var ta = -1, ga = Yo == null ? 0 : Yo.length;
    for (this.__data__ = new Za(); ++ta < ga; )
      this.add(Yo[ta]);
  }
  function hl(Yo) {
    return this.__data__.set(Yo, Si), this;
  }
  function gl(Yo) {
    return this.__data__.has(Yo);
  }
  al.prototype.add = al.prototype.push = hl, al.prototype.has = gl;
  function il(Yo) {
    var ta = this.__data__ = new ja(Yo);
    this.size = ta.size;
  }
  function yl() {
    this.__data__ = new ja(), this.size = 0;
  }
  function bl(Yo) {
    var ta = this.__data__, ga = ta.delete(Yo);
    return this.size = ta.size, ga;
  }
  function ml(Yo) {
    return this.__data__.get(Yo);
  }
  function Ol(Yo) {
    return this.__data__.has(Yo);
  }
  function $l(Yo, ta) {
    var ga = this.__data__;
    if (ga instanceof ja) {
      var La = ga.__data__;
      if (!Ia || La.length < Oe - 1)
        return La.push([Yo, ta]), this.size = ++ga.size, this;
      ga = this.__data__ = new Za(La);
    }
    return ga.set(Yo, ta), this.size = ga.size, this;
  }
  il.prototype.clear = yl, il.prototype.delete = bl, il.prototype.get = ml, il.prototype.has = Ol, il.prototype.set = $l;
  function tu(Yo, ta) {
    var ga = Bl(Yo), La = !ga && yu(Yo), Ya = !ga && !La && Ll(Yo), Ka = !ga && !La && !Ya && Jl(Yo), rl = ga || La || Ya || Ka, nl = rl ? ma(Yo.length, String) : [], sl = nl.length;
    for (var el in Yo)
      (ta || fa.call(Yo, el)) && !(rl && // Safari 9 has enumerable `arguments.length` in strict mode.
      (el == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ya && (el == "offset" || el == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ka && (el == "buffer" || el == "byteLength" || el == "byteOffset") || // Skip index properties.
      fu(el, sl))) && nl.push(el);
    return nl;
  }
  function Nl(Yo, ta) {
    for (var ga = Yo.length; ga--; )
      if (Wl(Yo[ga][0], ta))
        return ga;
    return -1;
  }
  function ru(Yo, ta, ga) {
    var La = ta(Yo);
    return Bl(Yo) ? La : Ma(La, ga(Yo));
  }
  function Pl(Yo) {
    return Yo == null ? Yo === void 0 ? Jo : Fo : Aa && Aa in Object(Yo) ? uu(Yo) : gu(Yo);
  }
  function Ul(Yo) {
    return Dl(Yo) && Pl(Yo) == xi;
  }
  function kl(Yo, ta, ga, La, Ya) {
    return Yo === ta ? !0 : Yo == null || ta == null || !Dl(Yo) && !Dl(ta) ? Yo !== Yo && ta !== ta : iu(Yo, ta, ga, La, kl, Ya);
  }
  function iu(Yo, ta, ga, La, Ya, Ka) {
    var rl = Bl(Yo), nl = Bl(ta), sl = rl ? Ri : xl(Yo), el = nl ? Ri : xl(ta);
    sl = sl == xi ? Io : sl, el = el == xi ? Io : el;
    var _l = sl == Io, Sl = el == Io, ll = sl == el;
    if (ll && Ll(Yo)) {
      if (!Ll(ta))
        return !1;
      rl = !0, _l = !1;
    }
    if (ll && !_l)
      return Ka || (Ka = new il()), rl || Jl(Yo) ? ql(Yo, ta, ga, La, Ya, Ka) : au(Yo, ta, sl, ga, La, Ya, Ka);
    if (!(ga & wi)) {
      var vl = _l && fa.call(Yo, "__wrapped__"), wl = Sl && fa.call(ta, "__wrapped__");
      if (vl || wl) {
        var Al = vl ? Yo.value() : Yo, Ml = wl ? ta.value() : ta;
        return Ka || (Ka = new il()), Ya(Al, Ml, ga, La, Ka);
      }
    }
    return ll ? (Ka || (Ka = new il()), lu(Yo, ta, ga, La, Ya, Ka)) : !1;
  }
  function ou(Yo) {
    if (!Gl(Yo) || du(Yo))
      return !1;
    var ta = Vl(Yo) ? ya : xo;
    return ta.test(Rl(Yo));
  }
  function nu(Yo) {
    return Dl(Yo) && Hl(Yo.length) && !!To[Pl(Yo)];
  }
  function su(Yo) {
    if (!hu(Yo))
      return $a(Yo);
    var ta = [];
    for (var ga in Object(Yo))
      fa.call(Yo, ga) && ga != "constructor" && ta.push(ga);
    return ta;
  }
  function ql(Yo, ta, ga, La, Ya, Ka) {
    var rl = ga & wi, nl = Yo.length, sl = ta.length;
    if (nl != sl && !(rl && sl > nl))
      return !1;
    var el = Ka.get(Yo);
    if (el && Ka.get(ta))
      return el == ta;
    var _l = -1, Sl = !0, ll = ga & Ei ? new al() : void 0;
    for (Ka.set(Yo, ta), Ka.set(ta, Yo); ++_l < nl; ) {
      var vl = Yo[_l], wl = ta[_l];
      if (La)
        var Al = rl ? La(wl, vl, _l, ta, Yo, Ka) : La(vl, wl, _l, Yo, ta, Ka);
      if (Al !== void 0) {
        if (Al)
          continue;
        Sl = !1;
        break;
      }
      if (ll) {
        if (!ba(ta, function(Ml, Tl) {
          if (!wa(ll, Tl) && (vl === Ml || Ya(vl, Ml, ga, La, Ka)))
            return ll.push(Tl);
        })) {
          Sl = !1;
          break;
        }
      } else if (!(vl === wl || Ya(vl, wl, ga, La, Ka))) {
        Sl = !1;
        break;
      }
    }
    return Ka.delete(Yo), Ka.delete(ta), Sl;
  }
  function au(Yo, ta, ga, La, Ya, Ka, rl) {
    switch (ga) {
      case wo:
        if (Yo.byteLength != ta.byteLength || Yo.byteOffset != ta.byteOffset)
          return !1;
        Yo = Yo.buffer, ta = ta.buffer;
      case Do:
        return !(Yo.byteLength != ta.byteLength || !Ka(new Ra(Yo), new Ra(ta)));
      case Oi:
      case Mi:
      case Bo:
        return Wl(+Yo, +ta);
      case Ii:
        return Yo.name == ta.name && Yo.message == ta.message;
      case ko:
      case Mo:
        return Yo == ta + "";
      case Ro:
        var nl = Fa;
      case Po:
        var sl = La & wi;
        if (nl || (nl = da), Yo.size != ta.size && !sl)
          return !1;
        var el = rl.get(Yo);
        if (el)
          return el == ta;
        La |= Ei, rl.set(Yo, ta);
        var _l = ql(nl(Yo), nl(ta), La, Ya, Ka, rl);
        return rl.delete(Yo), _l;
      case No:
        if (_a)
          return _a.call(Yo) == _a.call(ta);
    }
    return !1;
  }
  function lu(Yo, ta, ga, La, Ya, Ka) {
    var rl = ga & wi, nl = zl(Yo), sl = nl.length, el = zl(ta), _l = el.length;
    if (sl != _l && !rl)
      return !1;
    for (var Sl = sl; Sl--; ) {
      var ll = nl[Sl];
      if (!(rl ? ll in ta : fa.call(ta, ll)))
        return !1;
    }
    var vl = Ka.get(Yo);
    if (vl && Ka.get(ta))
      return vl == ta;
    var wl = !0;
    Ka.set(Yo, ta), Ka.set(ta, Yo);
    for (var Al = rl; ++Sl < sl; ) {
      ll = nl[Sl];
      var Ml = Yo[ll], Tl = ta[ll];
      if (La)
        var Yl = rl ? La(Tl, Ml, ll, ta, Yo, Ka) : La(Ml, Tl, ll, Yo, ta, Ka);
      if (!(Yl === void 0 ? Ml === Tl || Ya(Ml, Tl, ga, La, Ka) : Yl)) {
        wl = !1;
        break;
      }
      Al || (Al = ll == "constructor");
    }
    if (wl && !Al) {
      var Cl = Yo.constructor, jl = ta.constructor;
      Cl != jl && "constructor" in Yo && "constructor" in ta && !(typeof Cl == "function" && Cl instanceof Cl && typeof jl == "function" && jl instanceof jl) && (wl = !1);
    }
    return Ka.delete(Yo), Ka.delete(ta), wl;
  }
  function zl(Yo) {
    return ru(Yo, _u, cu);
  }
  function Fl(Yo, ta) {
    var ga = Yo.__data__;
    return pu(ta) ? ga[typeof ta == "string" ? "string" : "hash"] : ga.map;
  }
  function Il(Yo, ta) {
    var ga = ha(Yo, ta);
    return ou(ga) ? ga : void 0;
  }
  function uu(Yo) {
    var ta = fa.call(Yo, Aa), ga = Yo[Aa];
    try {
      Yo[Aa] = void 0;
      var La = !0;
    } catch {
    }
    var Ya = Oa.call(Yo);
    return La && (ta ? Yo[Aa] = ga : delete Yo[Aa]), Ya;
  }
  var cu = Ga ? function(Yo) {
    return Yo == null ? [] : (Yo = Object(Yo), sa(Ga(Yo), function(ta) {
      return Ha.call(Yo, ta);
    }));
  } : vu, xl = Pl;
  (qa && xl(new qa(new ArrayBuffer(1))) != wo || Ia && xl(new Ia()) != Ro || Ho && xl(Ho.resolve()) != Uo || qo && xl(new qo()) != Po || Go && xl(new Go()) != zo) && (xl = function(Yo) {
    var ta = Pl(Yo), ga = ta == Io ? Yo.constructor : void 0, La = ga ? Rl(ga) : "";
    if (La)
      switch (La) {
        case ea:
          return wo;
        case ia:
          return Ro;
        case oa:
          return Uo;
        case aa:
          return Po;
        case ua:
          return zo;
      }
    return ta;
  });
  function fu(Yo, ta) {
    return ta = ta ?? $i, !!ta && (typeof Yo == "number" || Qo.test(Yo)) && Yo > -1 && Yo % 1 == 0 && Yo < ta;
  }
  function pu(Yo) {
    var ta = typeof Yo;
    return ta == "string" || ta == "number" || ta == "symbol" || ta == "boolean" ? Yo !== "__proto__" : Yo === null;
  }
  function du(Yo) {
    return !!Ca && Ca in Yo;
  }
  function hu(Yo) {
    var ta = Yo && Yo.constructor, ga = typeof ta == "function" && ta.prototype || ca;
    return Yo === ga;
  }
  function gu(Yo) {
    return Oa.call(Yo);
  }
  function Rl(Yo) {
    if (Yo != null) {
      try {
        return Ea.call(Yo);
      } catch {
      }
      try {
        return Yo + "";
      } catch {
      }
    }
    return "";
  }
  function Wl(Yo, ta) {
    return Yo === ta || Yo !== Yo && ta !== ta;
  }
  var yu = Ul(function() {
    return arguments;
  }()) ? Ul : function(Yo) {
    return Dl(Yo) && fa.call(Yo, "callee") && !Ha.call(Yo, "callee");
  }, Bl = Array.isArray;
  function bu(Yo) {
    return Yo != null && Hl(Yo.length) && !Vl(Yo);
  }
  var Ll = Wa || wu;
  function mu(Yo, ta) {
    return kl(Yo, ta);
  }
  function Vl(Yo) {
    if (!Gl(Yo))
      return !1;
    var ta = Pl(Yo);
    return ta == Ci || ta == Oo || ta == Ti || ta == Co;
  }
  function Hl(Yo) {
    return typeof Yo == "number" && Yo > -1 && Yo % 1 == 0 && Yo <= $i;
  }
  function Gl(Yo) {
    var ta = typeof Yo;
    return Yo != null && (ta == "object" || ta == "function");
  }
  function Dl(Yo) {
    return Yo != null && typeof Yo == "object";
  }
  var Jl = ra ? Va(ra) : nu;
  function _u(Yo) {
    return bu(Yo) ? tu(Yo) : su(Yo);
  }
  function vu() {
    return [];
  }
  function wu() {
    return !1;
  }
  se.exports = mu;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const _s$2 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports);
function ki(se, e) {
  if (se.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var Oe = new Uint8Array(256), Si = 0; Si < Oe.length; Si++)
    Oe[Si] = 255;
  for (var wi = 0; wi < se.length; wi++) {
    var Ei = se.charAt(wi), $i = Ei.charCodeAt(0);
    if (Oe[$i] !== 255)
      throw new TypeError(Ei + " is ambiguous");
    Oe[$i] = wi;
  }
  var xi = se.length, Ri = se.charAt(0), Ti = Math.log(xi) / Math.log(256), Oi = Math.log(256) / Math.log(xi);
  function Mi(Oo) {
    if (Oo instanceof Uint8Array || (ArrayBuffer.isView(Oo) ? Oo = new Uint8Array(Oo.buffer, Oo.byteOffset, Oo.byteLength) : Array.isArray(Oo) && (Oo = Uint8Array.from(Oo))), !(Oo instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Oo.length === 0)
      return "";
    for (var Ro = 0, Bo = 0, Fo = 0, Io = Oo.length; Fo !== Io && Oo[Fo] === 0; )
      Fo++, Ro++;
    for (var Uo = (Io - Fo) * Oi + 1 >>> 0, Co = new Uint8Array(Uo); Fo !== Io; ) {
      for (var ko = Oo[Fo], Po = 0, Mo = Uo - 1; (ko !== 0 || Po < Bo) && Mo !== -1; Mo--, Po++)
        ko += 256 * Co[Mo] >>> 0, Co[Mo] = ko % xi >>> 0, ko = ko / xi >>> 0;
      if (ko !== 0)
        throw new Error("Non-zero carry");
      Bo = Po, Fo++;
    }
    for (var No = Uo - Bo; No !== Uo && Co[No] === 0; )
      No++;
    for (var Jo = Ri.repeat(Ro); No < Uo; ++No)
      Jo += se.charAt(Co[No]);
    return Jo;
  }
  function Ii(Oo) {
    if (typeof Oo != "string")
      throw new TypeError("Expected String");
    if (Oo.length === 0)
      return new Uint8Array();
    var Ro = 0;
    if (Oo[Ro] !== " ") {
      for (var Bo = 0, Fo = 0; Oo[Ro] === Ri; )
        Bo++, Ro++;
      for (var Io = (Oo.length - Ro) * Ti + 1 >>> 0, Uo = new Uint8Array(Io); Oo[Ro]; ) {
        var Co = Oe[Oo.charCodeAt(Ro)];
        if (Co === 255)
          return;
        for (var ko = 0, Po = Io - 1; (Co !== 0 || ko < Fo) && Po !== -1; Po--, ko++)
          Co += xi * Uo[Po] >>> 0, Uo[Po] = Co % 256 >>> 0, Co = Co / 256 >>> 0;
        if (Co !== 0)
          throw new Error("Non-zero carry");
        Fo = ko, Ro++;
      }
      if (Oo[Ro] !== " ") {
        for (var Mo = Io - Fo; Mo !== Io && Uo[Mo] === 0; )
          Mo++;
        for (var No = new Uint8Array(Bo + (Io - Mo)), Jo = Bo; Mo !== Io; )
          No[Jo++] = Uo[Mo++];
        return No;
      }
    }
  }
  function Ci(Oo) {
    var Ro = Ii(Oo);
    if (Ro)
      return Ro;
    throw new Error(`Non-${e} character`);
  }
  return { encode: Mi, decodeUnsafe: Ii, decode: Ci };
}
var Ki = ki, Bi = Ki;
const Ae = (se) => {
  if (se instanceof Uint8Array && se.constructor.name === "Uint8Array")
    return se;
  if (se instanceof ArrayBuffer)
    return new Uint8Array(se);
  if (ArrayBuffer.isView(se))
    return new Uint8Array(se.buffer, se.byteOffset, se.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Vi = (se) => new TextEncoder().encode(se), qi = (se) => new TextDecoder().decode(se);
class ji {
  constructor(e, Oe, Si) {
    this.name = e, this.prefix = Oe, this.baseEncode = Si;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Yi {
  constructor(e, Oe, Si) {
    if (this.name = e, this.prefix = Oe, Oe.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = Oe.codePointAt(0), this.baseDecode = Si;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ze$1(this, e);
  }
}
class Gi {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ze$1(this, e);
  }
  decode(e) {
    const Oe = e[0], Si = this.decoders[Oe];
    if (Si)
      return Si.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const ze$1 = (se, e) => new Gi({ ...se.decoders || { [se.prefix]: se }, ...e.decoders || { [e.prefix]: e } });
class Hi {
  constructor(e, Oe, Si, wi) {
    this.name = e, this.prefix = Oe, this.baseEncode = Si, this.baseDecode = wi, this.encoder = new ji(e, Oe, Si), this.decoder = new Yi(e, Oe, wi);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const J$2 = ({ name: se, prefix: e, encode: Oe, decode: Si }) => new Hi(se, e, Oe, Si), K$3 = ({ prefix: se, name: e, alphabet: Oe }) => {
  const { encode: Si, decode: wi } = Bi(Oe, e);
  return J$2({ prefix: se, name: e, encode: Si, decode: (Ei) => Ae(wi(Ei)) });
}, Ji = (se, e, Oe, Si) => {
  const wi = {};
  for (let Oi = 0; Oi < e.length; ++Oi)
    wi[e[Oi]] = Oi;
  let Ei = se.length;
  for (; se[Ei - 1] === "="; )
    --Ei;
  const $i = new Uint8Array(Ei * Oe / 8 | 0);
  let xi = 0, Ri = 0, Ti = 0;
  for (let Oi = 0; Oi < Ei; ++Oi) {
    const Mi = wi[se[Oi]];
    if (Mi === void 0)
      throw new SyntaxError(`Non-${Si} character`);
    Ri = Ri << Oe | Mi, xi += Oe, xi >= 8 && (xi -= 8, $i[Ti++] = 255 & Ri >> xi);
  }
  if (xi >= Oe || 255 & Ri << 8 - xi)
    throw new SyntaxError("Unexpected end of data");
  return $i;
}, Wi = (se, e, Oe) => {
  const Si = e[e.length - 1] === "=", wi = (1 << Oe) - 1;
  let Ei = "", $i = 0, xi = 0;
  for (let Ri = 0; Ri < se.length; ++Ri)
    for (xi = xi << 8 | se[Ri], $i += 8; $i > Oe; )
      $i -= Oe, Ei += e[wi & xi >> $i];
  if ($i && (Ei += e[wi & xi << Oe - $i]), Si)
    for (; Ei.length * Oe & 7; )
      Ei += "=";
  return Ei;
}, g$5 = ({ name: se, prefix: e, bitsPerChar: Oe, alphabet: Si }) => J$2({ prefix: e, name: se, encode(wi) {
  return Wi(wi, Si, Oe);
}, decode(wi) {
  return Ji(wi, Si, Oe, se);
} }), Xi = J$2({ prefix: "\0", name: "identity", encode: (se) => qi(se), decode: (se) => Vi(se) });
var Qi = Object.freeze({ __proto__: null, identity: Xi });
const Zi = g$5({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var es = Object.freeze({ __proto__: null, base2: Zi });
const ts = g$5({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var is = Object.freeze({ __proto__: null, base8: ts });
const ss = K$3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var rs$1 = Object.freeze({ __proto__: null, base10: ss });
const ns$1 = g$5({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), as$1 = g$5({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var os$1 = Object.freeze({ __proto__: null, base16: ns$1, base16upper: as$1 });
const hs$1 = g$5({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), cs$1 = g$5({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), us = g$5({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), ls$1 = g$5({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), ds$1 = g$5({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), gs = g$5({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ps$1 = g$5({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Ds = g$5({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), ys$1 = g$5({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var bs = Object.freeze({ __proto__: null, base32: hs$1, base32upper: cs$1, base32pad: us, base32padupper: ls$1, base32hex: ds$1, base32hexupper: gs, base32hexpad: ps$1, base32hexpadupper: Ds, base32z: ys$1 });
const ms$1 = K$3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), fs$2 = K$3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Es$1 = Object.freeze({ __proto__: null, base36: ms$1, base36upper: fs$2 });
const ws$1 = K$3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), vs$1 = K$3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Is$1 = Object.freeze({ __proto__: null, base58btc: ws$1, base58flickr: vs$1 });
const Cs = g$5({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Rs$1 = g$5({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), _s$1 = g$5({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), Ts$1 = g$5({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ss$2 = Object.freeze({ __proto__: null, base64: Cs, base64pad: Rs$1, base64url: _s$1, base64urlpad: Ts$1 });
const Ne = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), Ps$1 = Ne.reduce((se, e, Oe) => (se[Oe] = e, se), []), Os$1 = Ne.reduce((se, e, Oe) => (se[e.codePointAt(0)] = Oe, se), []);
function xs$1(se) {
  return se.reduce((e, Oe) => (e += Ps$1[Oe], e), "");
}
function As$1(se) {
  const e = [];
  for (const Oe of se) {
    const Si = Os$1[Oe.codePointAt(0)];
    if (Si === void 0)
      throw new Error(`Non-base256emoji character: ${Oe}`);
    e.push(Si);
  }
  return new Uint8Array(e);
}
const zs$1 = J$2({ prefix: "🚀", name: "base256emoji", encode: xs$1, decode: As$1 });
var Ns$1 = Object.freeze({ __proto__: null, base256emoji: zs$1 }), Ls$1 = Ue, Le$2 = 128, Us$1 = 127, Fs$1 = ~Us$1, $s$1 = Math.pow(2, 31);
function Ue(se, e, Oe) {
  e = e || [], Oe = Oe || 0;
  for (var Si = Oe; se >= $s$1; )
    e[Oe++] = se & 255 | Le$2, se /= 128;
  for (; se & Fs$1; )
    e[Oe++] = se & 255 | Le$2, se >>>= 7;
  return e[Oe] = se | 0, Ue.bytes = Oe - Si + 1, e;
}
var Ms$1 = ae$3, ks$1 = 128, Fe$1 = 127;
function ae$3(se, Si) {
  var Oe = 0, Si = Si || 0, wi = 0, Ei = Si, $i, xi = se.length;
  do {
    if (Ei >= xi)
      throw ae$3.bytes = 0, new RangeError("Could not decode varint");
    $i = se[Ei++], Oe += wi < 28 ? ($i & Fe$1) << wi : ($i & Fe$1) * Math.pow(2, wi), wi += 7;
  } while ($i >= ks$1);
  return ae$3.bytes = Ei - Si, Oe;
}
var Ks$1 = Math.pow(2, 7), Bs$1 = Math.pow(2, 14), Vs$1 = Math.pow(2, 21), qs$2 = Math.pow(2, 28), js$1 = Math.pow(2, 35), Ys$1 = Math.pow(2, 42), Gs$1 = Math.pow(2, 49), Hs$1 = Math.pow(2, 56), Js$1 = Math.pow(2, 63), Ws$1 = function(se) {
  return se < Ks$1 ? 1 : se < Bs$1 ? 2 : se < Vs$1 ? 3 : se < qs$2 ? 4 : se < js$1 ? 5 : se < Ys$1 ? 6 : se < Gs$1 ? 7 : se < Hs$1 ? 8 : se < Js$1 ? 9 : 10;
}, Xs$1 = { encode: Ls$1, decode: Ms$1, encodingLength: Ws$1 }, $e$1 = Xs$1;
const Me = (se, e, Oe = 0) => ($e$1.encode(se, e, Oe), e), ke = (se) => $e$1.encodingLength(se), oe$3 = (se, e) => {
  const Oe = e.byteLength, Si = ke(se), wi = Si + ke(Oe), Ei = new Uint8Array(wi + Oe);
  return Me(se, Ei, 0), Me(Oe, Ei, Si), Ei.set(e, wi), new Qs$1(se, Oe, e, Ei);
};
let Qs$1 = class {
  constructor(e, Oe, Si, wi) {
    this.code = e, this.size = Oe, this.digest = Si, this.bytes = wi;
  }
};
const Ke$1 = ({ name: se, code: e, encode: Oe }) => new Zs$1(se, e, Oe);
let Zs$1 = class {
  constructor(e, Oe, Si) {
    this.name = e, this.code = Oe, this.encode = Si;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const Oe = this.encode(e);
      return Oe instanceof Uint8Array ? oe$3(this.code, Oe) : Oe.then((Si) => oe$3(this.code, Si));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
const Be = (se) => async (e) => new Uint8Array(await crypto.subtle.digest(se, e)), er$2 = Ke$1({ name: "sha2-256", code: 18, encode: Be("SHA-256") }), tr$2 = Ke$1({ name: "sha2-512", code: 19, encode: Be("SHA-512") });
var ir$1 = Object.freeze({ __proto__: null, sha256: er$2, sha512: tr$2 });
const Ve = 0, sr$1 = "identity", qe$1 = Ae, rr$2 = (se) => oe$3(Ve, qe$1(se)), nr$2 = { code: Ve, name: sr$1, encode: qe$1, digest: rr$2 };
var ar$1 = Object.freeze({ __proto__: null, identity: nr$2 });
new TextEncoder(), new TextDecoder();
const je = { ...Qi, ...es, ...is, ...rs$1, ...os$1, ...bs, ...Es$1, ...Is$1, ...Ss$2, ...Ns$1 };
({ ...ir$1, ...ar$1 });
function Ye(se) {
  return globalThis.Buffer != null ? new Uint8Array(se.buffer, se.byteOffset, se.byteLength) : se;
}
function or$2(se = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ye(globalThis.Buffer.allocUnsafe(se)) : new Uint8Array(se);
}
function Ge$1(se, e, Oe, Si) {
  return { name: se, prefix: e, encoder: { name: se, prefix: e, encode: Oe }, decoder: { decode: Si } };
}
const He$1 = Ge$1("utf8", "u", (se) => "u" + new TextDecoder("utf8").decode(se), (se) => new TextEncoder().encode(se.substring(1))), he$2 = Ge$1("ascii", "a", (se) => {
  let e = "a";
  for (let Oe = 0; Oe < se.length; Oe++)
    e += String.fromCharCode(se[Oe]);
  return e;
}, (se) => {
  se = se.substring(1);
  const e = or$2(se.length);
  for (let Oe = 0; Oe < se.length; Oe++)
    e[Oe] = se.charCodeAt(Oe);
  return e;
}), hr$2 = { utf8: He$1, "utf-8": He$1, hex: je.base16, latin1: he$2, ascii: he$2, binary: he$2, ...je };
function cr$1(se, e = "utf8") {
  const Oe = hr$2[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ye(globalThis.Buffer.from(se, "utf-8")) : Oe.decoder.decode(`${Oe.prefix}${se}`);
}
const ce$2 = "wc", Je$1 = 2, W$2 = "core", x$6 = `${ce$2}@2:${W$2}:`, We$2 = { name: W$2, logger: "error" }, Xe$2 = { database: ":memory:" }, Qe$1 = "crypto", ue = "client_ed25519_seed", Ze$1 = cjs$4.ONE_DAY, et$2 = "keychain", tt$1 = "0.3", it$2 = "messages", st$1 = "0.3", rt$2 = cjs$4.SIX_HOURS, nt$2 = "publisher", at$2 = "irn", ot$2 = "error", le$2 = "wss://relay.walletconnect.com", de$2 = "wss://relay.walletconnect.org", ht$2 = "relayer", D$3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, ct$2 = "_subscription", P$1 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, ut$2 = cjs$4.ONE_SECOND, lt$2 = "2.10.0", dt$2 = 1e4, gt$3 = "0.3", pt$2 = "WALLETCONNECT_CLIENT_ID", C$6 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, Dt$2 = "subscription", yt$2 = "0.3", bt$2 = cjs$4.FIVE_SECONDS * 1e3, mt$1 = "pairing", ft$1 = "0.3", F$2 = { wc_pairingDelete: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 0 } } }, R$2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Et$1 = "history", wt$2 = "0.3", vt$2 = "expirer", w$3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, It$2 = "0.3", X$3 = "verify-api", Q$3 = "https://verify.walletconnect.com", ge$1 = "https://verify.walletconnect.org";
let Ct$2 = class {
  constructor(e, Oe) {
    this.core = e, this.logger = Oe, this.keychain = /* @__PURE__ */ new Map(), this.name = et$2, this.version = tt$1, this.initialized = !1, this.storagePrefix = x$6, this.init = async () => {
      if (!this.initialized) {
        const Si = await this.getKeyChain();
        typeof Si < "u" && (this.keychain = Si), this.initialized = !0;
      }
    }, this.has = (Si) => (this.isInitialized(), this.keychain.has(Si)), this.set = async (Si, wi) => {
      this.isInitialized(), this.keychain.set(Si, wi), await this.persist();
    }, this.get = (Si) => {
      this.isInitialized();
      const wi = this.keychain.get(Si);
      if (typeof wi > "u") {
        const { message: Ei } = N$2("NO_MATCHING_KEY", `${this.name}: ${Si}`);
        throw new Error(Ei);
      }
      return wi;
    }, this.del = async (Si) => {
      this.isInitialized(), this.keychain.delete(Si), await this.persist();
    }, this.core = e, this.logger = cjs$3.generateChildLogger(Oe, this.name);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, et$3(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt$3(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, Rt$1 = class {
  constructor(e, Oe, Si) {
    this.core = e, this.logger = Oe, this.name = Qe$1, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (wi) => (this.isInitialized(), this.keychain.has(wi)), this.getClientId = async () => {
      this.isInitialized();
      const wi = await this.getClientSeed(), Ei = generateKeyPair(wi);
      return encodeIss(Ei.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const wi = jn$1();
      return this.setPrivateKey(wi.publicKey, wi.privateKey);
    }, this.signJWT = async (wi) => {
      this.isInitialized();
      const Ei = await this.getClientSeed(), $i = generateKeyPair(Ei), xi = Dn$1();
      return await signJWT(xi, wi, Ze$1, $i);
    }, this.generateSharedKey = (wi, Ei, $i) => {
      this.isInitialized();
      const xi = this.getPrivateKey(wi), Ri = kn$1(xi, Ei);
      return this.setSymKey(Ri, $i);
    }, this.setSymKey = async (wi, Ei) => {
      this.isInitialized();
      const $i = Ei || Vn$1(wi);
      return await this.keychain.set($i, wi), $i;
    }, this.deleteKeyPair = async (wi) => {
      this.isInitialized(), await this.keychain.del(wi);
    }, this.deleteSymKey = async (wi) => {
      this.isInitialized(), await this.keychain.del(wi);
    }, this.encode = async (wi, Ei, $i) => {
      this.isInitialized();
      const xi = Re$1($i), Ri = safeJsonStringify(Ei);
      if (Fn$1(xi)) {
        const Ii = xi.senderPublicKey, Ci = xi.receiverPublicKey;
        wi = await this.generateSharedKey(Ii, Ci);
      }
      const Ti = this.getSymKey(wi), { type: Oi, senderPublicKey: Mi } = xi;
      return Kn$1({ type: Oi, symKey: Ti, message: Ri, senderPublicKey: Mi });
    }, this.decode = async (wi, Ei, $i) => {
      this.isInitialized();
      const xi = xn$1(Ei, $i);
      if (Fn$1(xi)) {
        const Ri = xi.receiverPublicKey, Ti = xi.senderPublicKey;
        wi = await this.generateSharedKey(Ri, Ti);
      }
      try {
        const Ri = this.getSymKey(wi), Ti = Ln$1({ symKey: Ri, encoded: Ei });
        return safeJsonParse(Ti);
      } catch (Ri) {
        this.logger.error(`Failed to decode message from topic: '${wi}', clientId: '${await this.getClientId()}'`), this.logger.error(Ri);
      }
    }, this.getPayloadType = (wi) => {
      const Ei = ee(wi);
      return $$2(Ei.type);
    }, this.getPayloadSenderPublicKey = (wi) => {
      const Ei = ee(wi);
      return Ei.senderPublicKey ? toString$2(Ei.senderPublicKey, p$3) : void 0;
    }, this.core = e, this.logger = cjs$3.generateChildLogger(Oe, this.name), this.keychain = Si || new Ct$2(this.core, this.logger);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, Oe) {
    return await this.keychain.set(e, Oe), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ue);
    } catch {
      e = Dn$1(), await this.keychain.set(ue, e);
    }
    return cr$1(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, _t$1 = class extends a$1 {
  constructor(e, Oe) {
    super(e, Oe), this.logger = e, this.core = Oe, this.messages = /* @__PURE__ */ new Map(), this.name = it$2, this.version = st$1, this.initialized = !1, this.storagePrefix = x$6, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const Si = await this.getRelayerMessages();
          typeof Si < "u" && (this.messages = Si), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (Si) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(Si);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (Si, wi) => {
      this.isInitialized();
      const Ei = Mn$1(wi);
      let $i = this.messages.get(Si);
      return typeof $i > "u" && ($i = {}), typeof $i[Ei] < "u" || ($i[Ei] = wi, this.messages.set(Si, $i), await this.persist()), Ei;
    }, this.get = (Si) => {
      this.isInitialized();
      let wi = this.messages.get(Si);
      return typeof wi > "u" && (wi = {}), wi;
    }, this.has = (Si, wi) => {
      this.isInitialized();
      const Ei = this.get(Si), $i = Mn$1(wi);
      return typeof Ei[$i] < "u";
    }, this.del = async (Si) => {
      this.isInitialized(), this.messages.delete(Si), await this.persist();
    }, this.logger = cjs$3.generateChildLogger(e, this.name), this.core = Oe;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, et$3(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt$3(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, pr$2 = class extends u$1 {
  constructor(e, Oe) {
    super(e, Oe), this.relayer = e, this.logger = Oe, this.events = new EventEmitter(), this.name = nt$2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$4.toMiliseconds(cjs$4.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (Si, wi, Ei) => {
      var $i;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: Si, message: wi, opts: Ei } });
      try {
        const xi = (Ei == null ? void 0 : Ei.ttl) || rt$2, Ri = mt$2(Ei), Ti = (Ei == null ? void 0 : Ei.prompt) || !1, Oi = (Ei == null ? void 0 : Ei.tag) || 0, Mi = (Ei == null ? void 0 : Ei.id) || getBigIntRpcId().toString(), Ii = { topic: Si, message: wi, opts: { ttl: xi, relay: Ri, prompt: Ti, tag: Oi, id: Mi } }, Ci = setTimeout(() => this.queue.set(Mi, Ii), this.publishTimeout);
        try {
          await await it$3(this.rpcPublish(Si, wi, xi, Ri, Ti, Oi, Mi), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(Mi), this.relayer.events.emit(D$3.publish, Ii);
        } catch (Oo) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, ($i = Ei == null ? void 0 : Ei.internal) != null && $i.throwOnFailedPublish)
            throw this.removeRequestFromQueue(Mi), Oo;
          return;
        } finally {
          clearTimeout(Ci);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: Si, message: wi, opts: Ei } });
      } catch (xi) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(xi), xi;
      }
    }, this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.relayer = e, this.logger = cjs$3.generateChildLogger(Oe, this.name), this.registerEventListeners();
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  rpcPublish(e, Oe, Si, wi, Ei, $i, xi) {
    var Ri, Ti, Oi, Mi;
    const Ii = { method: yt$3(wi.protocol).publish, params: { topic: e, message: Oe, ttl: Si, prompt: Ei, tag: $i }, id: xi };
    return w$4((Ri = Ii.params) == null ? void 0 : Ri.prompt) && ((Ti = Ii.params) == null || delete Ti.prompt), w$4((Oi = Ii.params) == null ? void 0 : Oi.tag) && ((Mi = Ii.params) == null || delete Mi.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: Ii }), this.relayer.request(Ii);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: Oe, message: Si, opts: wi } = e;
      await this.publish(Oe, Si, wi);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(D$3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D$3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}, Dr$2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, Oe) => {
      const Si = this.get(e);
      this.exists(e, Oe) || this.map.set(e, [...Si, Oe]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, Oe) => this.get(e).includes(Oe), this.delete = (e, Oe) => {
      if (typeof Oe > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const Si = this.get(e);
      if (!this.exists(e, Oe))
        return;
      const wi = Si.filter((Ei) => Ei !== Oe);
      if (!wi.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, wi);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var yr$2 = Object.defineProperty, br$2 = Object.defineProperties, mr$2 = Object.getOwnPropertyDescriptors, Tt$2 = Object.getOwnPropertySymbols, fr$2 = Object.prototype.hasOwnProperty, Er$2 = Object.prototype.propertyIsEnumerable, St$2 = (se, e, Oe) => e in se ? yr$2(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, B$1 = (se, e) => {
  for (var Oe in e || (e = {}))
    fr$2.call(e, Oe) && St$2(se, Oe, e[Oe]);
  if (Tt$2)
    for (var Oe of Tt$2(e))
      Er$2.call(e, Oe) && St$2(se, Oe, e[Oe]);
  return se;
}, pe$2 = (se, e) => br$2(se, mr$2(e));
let Pt$1 = class extends d$3 {
  constructor(e, Oe) {
    super(e, Oe), this.relayer = e, this.logger = Oe, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Dr$2(), this.events = new EventEmitter(), this.name = Dt$2, this.version = yt$2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x$6, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (Si, wi) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Si, opts: wi } });
      try {
        const Ei = mt$2(wi), $i = { topic: Si, relay: Ei };
        this.pending.set(Si, $i);
        const xi = await this.rpcSubscribe(Si, Ei);
        return this.onSubscribe(xi, $i), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Si, opts: wi } }), xi;
      } catch (Ei) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(Ei), Ei;
      }
    }, this.unsubscribe = async (Si, wi) => {
      await this.restartToComplete(), this.isInitialized(), typeof (wi == null ? void 0 : wi.id) < "u" ? await this.unsubscribeById(Si, wi.id, wi) : await this.unsubscribeByTopic(Si, wi);
    }, this.isSubscribed = async (Si) => this.topics.includes(Si) ? !0 : await new Promise((wi, Ei) => {
      const $i = new cjs$4.Watch();
      $i.start(this.pendingSubscriptionWatchLabel);
      const xi = setInterval(() => {
        !this.pending.has(Si) && this.topics.includes(Si) && (clearInterval(xi), $i.stop(this.pendingSubscriptionWatchLabel), wi(!0)), $i.elapsed(this.pendingSubscriptionWatchLabel) >= bt$2 && (clearInterval(xi), $i.stop(this.pendingSubscriptionWatchLabel), Ei(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => !1), this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = cjs$3.generateChildLogger(Oe, this.name), this.clientId = "";
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, Oe) {
    let Si = !1;
    try {
      Si = this.getSubscription(e).topic === Oe;
    } catch {
    }
    return Si;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, Oe) {
    const Si = this.topicMap.get(e);
    await Promise.all(Si.map(async (wi) => await this.unsubscribeById(e, wi, Oe)));
  }
  async unsubscribeById(e, Oe, Si) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: Oe, opts: Si } });
    try {
      const wi = mt$2(Si);
      await this.rpcUnsubscribe(e, Oe, wi);
      const Ei = U$2("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, Oe, Ei), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: Oe, opts: Si } });
    } catch (wi) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(wi), wi;
    }
  }
  async rpcSubscribe(e, Oe) {
    const Si = { method: yt$3(Oe.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Si });
    try {
      await await it$3(this.relayer.request(Si), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D$3.connection_stalled);
    }
    return Mn$1(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const Oe = e[0].relay, Si = { method: yt$3(Oe.protocol).batchSubscribe, params: { topics: e.map((wi) => wi.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Si });
    try {
      return await await it$3(this.relayer.request(Si), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D$3.connection_stalled);
    }
  }
  rpcUnsubscribe(e, Oe, Si) {
    const wi = { method: yt$3(Si.protocol).unsubscribe, params: { topic: e, id: Oe } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: wi }), this.relayer.request(wi);
  }
  onSubscribe(e, Oe) {
    this.setSubscription(e, pe$2(B$1({}, Oe), { id: e })), this.pending.delete(Oe.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((Oe) => {
      this.setSubscription(Oe.id, B$1({}, Oe)), this.pending.delete(Oe.topic);
    });
  }
  async onUnsubscribe(e, Oe, Si) {
    this.events.removeAllListeners(Oe), this.hasSubscription(Oe, e) && this.deleteSubscription(Oe, Si), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, Oe) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: Oe }), this.addSubscription(e, Oe));
  }
  addSubscription(e, Oe) {
    this.subscriptions.set(e, B$1({}, Oe)), this.topicMap.set(Oe.topic, e), this.events.emit(C$6.created, Oe);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const Oe = this.subscriptions.get(e);
    if (!Oe) {
      const { message: Si } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(Si);
    }
    return Oe;
  }
  deleteSubscription(e, Oe) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: Oe });
    const Si = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(Si.topic, e), this.events.emit(C$6.deleted, pe$2(B$1({}, Si), { reason: Oe }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(C$6.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let Oe = 0; Oe < e; Oe++) {
        const Si = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(Si);
      }
    }
    this.events.emit(C$6.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: Oe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const Oe = await this.rpcBatchSubscribe(e);
    j$2(Oe) && this.onBatchSubscribe(Oe.map((Si, wi) => pe$2(B$1({}, e[wi]), { id: Si })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((Oe) => {
      e.push(Oe);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D$3.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D$3.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(C$6.created, async (e) => {
      const Oe = C$6.created;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), await this.persist();
    }), this.events.on(C$6.deleted, async (e) => {
      const Oe = C$6.deleted;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const Oe = setInterval(() => {
        this.restartInProgress || (clearInterval(Oe), e());
      }, this.pollingInterval);
    });
  }
};
var wr$2 = Object.defineProperty, Ot$2 = Object.getOwnPropertySymbols, vr$2 = Object.prototype.hasOwnProperty, Ir$2 = Object.prototype.propertyIsEnumerable, xt$2 = (se, e, Oe) => e in se ? wr$2(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Cr$2 = (se, e) => {
  for (var Oe in e || (e = {}))
    vr$2.call(e, Oe) && xt$2(se, Oe, e[Oe]);
  if (Ot$2)
    for (var Oe of Ot$2(e))
      Ir$2.call(e, Oe) && xt$2(se, Oe, e[Oe]);
  return se;
};
let At$2 = class extends g$6 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new EventEmitter(), this.name = ht$2, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async (Oe) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(Oe);
      } catch (Si) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(Si), Si;
      }
    }, this.onPayloadHandler = (Oe) => {
      this.onProviderPayload(Oe);
    }, this.onConnectHandler = () => {
      this.events.emit(D$3.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (Oe) => {
      this.logger.error(Oe), this.events.emit(D$3.error, Oe);
    }, this.registerProviderListeners = () => {
      this.provider.on(P$1.payload, this.onPayloadHandler), this.provider.on(P$1.connect, this.onConnectHandler), this.provider.on(P$1.disconnect, this.onDisconnectHandler), this.provider.on(P$1.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? cjs$3.generateChildLogger(e.logger, this.name) : cjs$3.pino(cjs$3.getDefaultLoggerOptions({ level: e.logger || ot$2 })), this.messages = new _t$1(this.logger, e.core), this.subscriber = new Pt$1(this, this.logger), this.publisher = new pr$2(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || le$2, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de$2}...`), await this.restartTransport(de$2);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, dt$2);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, Oe, Si) {
    this.isInitialized(), await this.publisher.publish(e, Oe, Si), await this.recordMessageEvent({ topic: e, message: Oe, publishedAt: Date.now() });
  }
  async subscribe(e, Oe) {
    var Si;
    this.isInitialized();
    let wi = ((Si = this.subscriber.topicMap.get(e)) == null ? void 0 : Si[0]) || "";
    return wi || (await Promise.all([new Promise((Ei) => {
      this.subscriber.once(C$6.created, ($i) => {
        $i.topic === e && Ei();
      });
    }), new Promise(async (Ei) => {
      wi = await this.subscriber.subscribe(e, Oe), Ei();
    })]), wi);
  }
  async unsubscribe(e, Oe) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, Oe);
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await it$3(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((Oe) => {
          if (!this.initialized)
            return Oe();
          this.subscriber.once(C$6.resubscribed, () => {
            Oe();
          });
        }), new Promise(async (Oe, Si) => {
          try {
            await it$3(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (wi) {
            Si(wi);
            return;
          }
          Oe();
        })]);
      } catch (Oe) {
        this.logger.error(Oe);
        const Si = Oe;
        if (!this.isConnectionStalled(Si.message))
          throw Oe;
        this.provider.events.emit(P$1.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt$2())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((Oe) => e.includes(Oe));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new WsConnection(Jn$1({ sdkVersion: lt$2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: Oe, message: Si } = e;
    await this.messages.set(Oe, Si);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: Oe, message: Si } = e;
    if (!Si || Si.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${Si}`), !0;
    if (!await this.subscriber.isSubscribed(Oe))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${Oe}`), !0;
    const wi = this.messages.has(Oe, Si);
    return wi && this.logger.debug(`Ignoring duplicate message: ${Si}`), wi;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ct$2))
        return;
      const Oe = e.params, { topic: Si, message: wi, publishedAt: Ei } = Oe.data, $i = { topic: Si, message: wi, publishedAt: Ei };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Cr$2({ type: "event", event: Oe.id }, $i)), this.events.emit(Oe.id, $i), await this.acknowledgePayload(e), await this.onMessageEvent($i);
    } else
      isJsonRpcResponse(e) && this.events.emit(D$3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D$3.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const Oe = formatJsonRpcResult(e.id, !0);
    await this.provider.connection.send(Oe);
  }
  unregisterProviderListeners() {
    this.provider.off(P$1.payload, this.onPayloadHandler), this.provider.off(P$1.connect, this.onConnectHandler), this.provider.off(P$1.disconnect, this.onDisconnectHandler), this.provider.off(P$1.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D$3.connection_stalled, () => {
      this.restartTransport().catch((Oe) => this.logger.error(Oe));
    });
    let e = await Zt$2();
    Xt$2(async (Oe) => {
      this.initialized && e !== Oe && (e = Oe, Oe ? await this.restartTransport().catch((Si) => this.logger.error(Si)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((Si) => this.logger.error(Si))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D$3.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, cjs$4.toMiliseconds(ut$2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const Oe = setInterval(() => {
            this.connected && (clearInterval(Oe), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Rr$2 = Object.defineProperty, zt$2 = Object.getOwnPropertySymbols, _r$2 = Object.prototype.hasOwnProperty, Tr$2 = Object.prototype.propertyIsEnumerable, Nt$2 = (se, e, Oe) => e in se ? Rr$2(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Lt$2 = (se, e) => {
  for (var Oe in e || (e = {}))
    _r$2.call(e, Oe) && Nt$2(se, Oe, e[Oe]);
  if (zt$2)
    for (var Oe of zt$2(e))
      Tr$2.call(e, Oe) && Nt$2(se, Oe, e[Oe]);
  return se;
};
let Ut$1 = class extends p$4 {
  constructor(e, Oe, Si, wi = x$6, Ei = void 0) {
    super(e, Oe, Si, wi), this.core = e, this.logger = Oe, this.name = Si, this.map = /* @__PURE__ */ new Map(), this.version = gt$3, this.cached = [], this.initialized = !1, this.storagePrefix = x$6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(($i) => {
        this.getKey && $i !== null && !w$4($i) ? this.map.set(this.getKey($i), $i) : Dt$3($i) ? this.map.set($i.id, $i) : kt$2($i) && this.map.set($i.topic, $i);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async ($i, xi) => {
      this.isInitialized(), this.map.has($i) ? await this.update($i, xi) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: $i, value: xi }), this.map.set($i, xi), await this.persist());
    }, this.get = ($i) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: $i }), this.getData($i)), this.getAll = ($i) => (this.isInitialized(), $i ? this.values.filter((xi) => Object.keys($i).every((Ri) => _s$2(xi[Ri], $i[Ri]))) : this.values), this.update = async ($i, xi) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: $i, update: xi });
      const Ri = Lt$2(Lt$2({}, this.getData($i)), xi);
      this.map.set($i, Ri), await this.persist();
    }, this.delete = async ($i, xi) => {
      this.isInitialized(), this.map.has($i) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: $i, reason: xi }), this.map.delete($i), await this.persist());
    }, this.logger = cjs$3.generateChildLogger(Oe, this.name), this.storagePrefix = wi, this.getKey = Ei;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const Oe = this.map.get(e);
    if (!Oe) {
      const { message: Si } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(Si), new Error(Si);
    }
    return Oe;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: Oe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, Ft$2 = class {
  constructor(e, Oe) {
    this.core = e, this.logger = Oe, this.name = mt$1, this.version = ft$1, this.events = new c$5(), this.initialized = !1, this.storagePrefix = x$6, this.ignoredPayloadTypes = [_$5], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: Si }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...Si])];
    }, this.create = async () => {
      this.isInitialized();
      const Si = Dn$1(), wi = await this.core.crypto.setSymKey(Si), Ei = lt$3(cjs$4.FIVE_MINUTES), $i = { protocol: at$2 }, xi = { topic: wi, expiry: Ei, relay: $i, active: !1 }, Ri = Nt$3({ protocol: this.core.protocol, version: this.core.version, topic: wi, symKey: Si, relay: $i });
      return await this.pairings.set(wi, xi), await this.core.relayer.subscribe(wi), this.core.expirer.set(wi, Ei), { topic: wi, uri: Ri };
    }, this.pair = async (Si) => {
      this.isInitialized(), this.isValidPair(Si);
      const { topic: wi, symKey: Ei, relay: $i } = bt$3(Si.uri);
      if (this.pairings.keys.includes(wi))
        throw new Error(`Pairing already exists: ${wi}`);
      if (this.core.crypto.hasKeys(wi))
        throw new Error(`Keychain already exists: ${wi}`);
      const xi = lt$3(cjs$4.FIVE_MINUTES), Ri = { topic: wi, relay: $i, expiry: xi, active: !1 };
      return await this.pairings.set(wi, Ri), await this.core.crypto.setSymKey(Ei, wi), await this.core.relayer.subscribe(wi, { relay: $i }), this.core.expirer.set(wi, xi), Si.activatePairing && await this.activate({ topic: wi }), Ri;
    }, this.activate = async ({ topic: Si }) => {
      this.isInitialized();
      const wi = lt$3(cjs$4.THIRTY_DAYS);
      await this.pairings.update(Si, { active: !0, expiry: wi }), this.core.expirer.set(Si, wi);
    }, this.ping = async (Si) => {
      this.isInitialized(), await this.isValidPing(Si);
      const { topic: wi } = Si;
      if (this.pairings.keys.includes(wi)) {
        const Ei = await this.sendRequest(wi, "wc_pairingPing", {}), { done: $i, resolve: xi, reject: Ri } = st$2();
        this.events.once(ft$2("pairing_ping", Ei), ({ error: Ti }) => {
          Ti ? Ri(Ti) : xi();
        }), await $i();
      }
    }, this.updateExpiry = async ({ topic: Si, expiry: wi }) => {
      this.isInitialized(), await this.pairings.update(Si, { expiry: wi });
    }, this.updateMetadata = async ({ topic: Si, metadata: wi }) => {
      this.isInitialized(), await this.pairings.update(Si, { peerMetadata: wi });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (Si) => {
      this.isInitialized(), await this.isValidDisconnect(Si);
      const { topic: wi } = Si;
      this.pairings.keys.includes(wi) && (await this.sendRequest(wi, "wc_pairingDelete", U$2("USER_DISCONNECTED")), await this.deletePairing(wi));
    }, this.sendRequest = async (Si, wi, Ei) => {
      const $i = formatJsonRpcRequest(wi, Ei), xi = await this.core.crypto.encode(Si, $i), Ri = F$2[wi].req;
      return this.core.history.set(Si, $i), this.core.relayer.publish(Si, xi, Ri), $i.id;
    }, this.sendResult = async (Si, wi, Ei) => {
      const $i = formatJsonRpcResult(Si, Ei), xi = await this.core.crypto.encode(wi, $i), Ri = await this.core.history.get(wi, Si), Ti = F$2[Ri.request.method].res;
      await this.core.relayer.publish(wi, xi, Ti), await this.core.history.resolve($i);
    }, this.sendError = async (Si, wi, Ei) => {
      const $i = formatJsonRpcError(Si, Ei), xi = await this.core.crypto.encode(wi, $i), Ri = await this.core.history.get(wi, Si), Ti = F$2[Ri.request.method] ? F$2[Ri.request.method].res : F$2.unregistered_method.res;
      await this.core.relayer.publish(wi, xi, Ti), await this.core.history.resolve($i);
    }, this.deletePairing = async (Si, wi) => {
      await this.core.relayer.unsubscribe(Si), await Promise.all([this.pairings.delete(Si, U$2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(Si), wi ? Promise.resolve() : this.core.expirer.del(Si)]);
    }, this.cleanup = async () => {
      const Si = this.pairings.getAll().filter((wi) => dt$3(wi.expiry));
      await Promise.all(Si.map((wi) => this.deletePairing(wi.topic)));
    }, this.onRelayEventRequest = (Si) => {
      const { topic: wi, payload: Ei } = Si;
      switch (Ei.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(wi, Ei);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(wi, Ei);
        default:
          return this.onUnknownRpcMethodRequest(wi, Ei);
      }
    }, this.onRelayEventResponse = async (Si) => {
      const { topic: wi, payload: Ei } = Si, $i = (await this.core.history.get(wi, Ei.id)).request.method;
      switch ($i) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(wi, Ei);
        default:
          return this.onUnknownRpcMethodResponse($i);
      }
    }, this.onPairingPingRequest = async (Si, wi) => {
      const { id: Ei } = wi;
      try {
        this.isValidPing({ topic: Si }), await this.sendResult(Ei, Si, !0), this.events.emit("pairing_ping", { id: Ei, topic: Si });
      } catch ($i) {
        await this.sendError(Ei, Si, $i), this.logger.error($i);
      }
    }, this.onPairingPingResponse = (Si, wi) => {
      const { id: Ei } = wi;
      setTimeout(() => {
        isJsonRpcResult(wi) ? this.events.emit(ft$2("pairing_ping", Ei), {}) : isJsonRpcError(wi) && this.events.emit(ft$2("pairing_ping", Ei), { error: wi.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (Si, wi) => {
      const { id: Ei } = wi;
      try {
        this.isValidDisconnect({ topic: Si }), await this.deletePairing(Si), this.events.emit("pairing_delete", { id: Ei, topic: Si });
      } catch ($i) {
        await this.sendError(Ei, Si, $i), this.logger.error($i);
      }
    }, this.onUnknownRpcMethodRequest = async (Si, wi) => {
      const { id: Ei, method: $i } = wi;
      try {
        if (this.registeredMethods.includes($i))
          return;
        const xi = U$2("WC_METHOD_UNSUPPORTED", $i);
        await this.sendError(Ei, Si, xi), this.logger.error(xi);
      } catch (xi) {
        await this.sendError(Ei, Si, xi), this.logger.error(xi);
      }
    }, this.onUnknownRpcMethodResponse = (Si) => {
      this.registeredMethods.includes(Si) || this.logger.error(U$2("WC_METHOD_UNSUPPORTED", Si));
    }, this.isValidPair = (Si) => {
      if (!xt$3(Si)) {
        const { message: wi } = N$2("MISSING_OR_INVALID", `pair() params: ${Si}`);
        throw new Error(wi);
      }
      if (!jt$1(Si.uri)) {
        const { message: wi } = N$2("MISSING_OR_INVALID", `pair() uri: ${Si.uri}`);
        throw new Error(wi);
      }
    }, this.isValidPing = async (Si) => {
      if (!xt$3(Si)) {
        const { message: Ei } = N$2("MISSING_OR_INVALID", `ping() params: ${Si}`);
        throw new Error(Ei);
      }
      const { topic: wi } = Si;
      await this.isValidPairingTopic(wi);
    }, this.isValidDisconnect = async (Si) => {
      if (!xt$3(Si)) {
        const { message: Ei } = N$2("MISSING_OR_INVALID", `disconnect() params: ${Si}`);
        throw new Error(Ei);
      }
      const { topic: wi } = Si;
      await this.isValidPairingTopic(wi);
    }, this.isValidPairingTopic = async (Si) => {
      if (!h$3(Si, !1)) {
        const { message: wi } = N$2("MISSING_OR_INVALID", `pairing topic should be a string: ${Si}`);
        throw new Error(wi);
      }
      if (!this.pairings.keys.includes(Si)) {
        const { message: wi } = N$2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${Si}`);
        throw new Error(wi);
      }
      if (dt$3(this.pairings.get(Si).expiry)) {
        await this.deletePairing(Si);
        const { message: wi } = N$2("EXPIRED", `pairing topic: ${Si}`);
        throw new Error(wi);
      }
    }, this.core = e, this.logger = cjs$3.generateChildLogger(Oe, this.name), this.pairings = new Ut$1(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D$3.message, async (e) => {
      const { topic: Oe, message: Si } = e;
      if (!this.pairings.keys.includes(Oe) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(Si)))
        return;
      const wi = await this.core.crypto.decode(Oe, Si);
      try {
        isJsonRpcRequest(wi) ? (this.core.history.set(Oe, wi), this.onRelayEventRequest({ topic: Oe, payload: wi })) : isJsonRpcResponse(wi) && (await this.core.history.resolve(wi), await this.onRelayEventResponse({ topic: Oe, payload: wi }), this.core.history.delete(Oe, wi.id));
      } catch (Ei) {
        this.logger.error(Ei);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(w$3.expired, async (e) => {
      const { topic: Oe } = ut$3(e.target);
      Oe && this.pairings.keys.includes(Oe) && (await this.deletePairing(Oe, !0), this.events.emit("pairing_expire", { topic: Oe }));
    });
  }
}, $t$2 = class extends h$4 {
  constructor(e, Oe) {
    super(e, Oe), this.core = e, this.logger = Oe, this.records = /* @__PURE__ */ new Map(), this.events = new EventEmitter(), this.name = Et$1, this.version = wt$2, this.cached = [], this.initialized = !1, this.storagePrefix = x$6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Si) => this.records.set(Si.id, Si)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (Si, wi, Ei) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: Si, request: wi, chainId: Ei }), this.records.has(wi.id))
        return;
      const $i = { id: wi.id, topic: Si, request: { method: wi.method, params: wi.params || null }, chainId: Ei, expiry: lt$3(cjs$4.THIRTY_DAYS) };
      this.records.set($i.id, $i), this.events.emit(R$2.created, $i);
    }, this.resolve = async (Si) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: Si }), !this.records.has(Si.id))
        return;
      const wi = await this.getRecord(Si.id);
      typeof wi.response > "u" && (wi.response = isJsonRpcError(Si) ? { error: Si.error } : { result: Si.result }, this.records.set(wi.id, wi), this.events.emit(R$2.updated, wi));
    }, this.get = async (Si, wi) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: Si, id: wi }), await this.getRecord(wi)), this.delete = (Si, wi) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: wi }), this.values.forEach((Ei) => {
        if (Ei.topic === Si) {
          if (typeof wi < "u" && Ei.id !== wi)
            return;
          this.records.delete(Ei.id), this.events.emit(R$2.deleted, Ei);
        }
      });
    }, this.exists = async (Si, wi) => (this.isInitialized(), this.records.has(wi) ? (await this.getRecord(wi)).topic === Si : !1), this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.logger = cjs$3.generateChildLogger(Oe, this.name);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((Oe) => {
      if (typeof Oe.response < "u")
        return;
      const Si = { topic: Oe.topic, request: formatJsonRpcRequest(Oe.request.method, Oe.request.params, Oe.id), chainId: Oe.chainId };
      return e.push(Si);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const Oe = this.records.get(e);
    if (!Oe) {
      const { message: Si } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(Si);
    }
    return Oe;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R$2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: Oe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R$2.created, (e) => {
      const Oe = R$2.created;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, record: e }), this.persist();
    }), this.events.on(R$2.updated, (e) => {
      const Oe = R$2.updated;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, record: e }), this.persist();
    }), this.events.on(R$2.deleted, (e) => {
      const Oe = R$2.deleted;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, record: e }), this.persist();
    }), this.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        cjs$4.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, Mt$2 = class extends E$4 {
  constructor(e, Oe) {
    super(e, Oe), this.core = e, this.logger = Oe, this.expirations = /* @__PURE__ */ new Map(), this.events = new EventEmitter(), this.name = vt$2, this.version = It$2, this.cached = [], this.initialized = !1, this.storagePrefix = x$6, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Si) => this.expirations.set(Si.target, Si)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (Si) => {
      try {
        const wi = this.formatTarget(Si);
        return typeof this.getExpiration(wi) < "u";
      } catch {
        return !1;
      }
    }, this.set = (Si, wi) => {
      this.isInitialized();
      const Ei = this.formatTarget(Si), $i = { target: Ei, expiry: wi };
      this.expirations.set(Ei, $i), this.checkExpiry(Ei, $i), this.events.emit(w$3.created, { target: Ei, expiration: $i });
    }, this.get = (Si) => {
      this.isInitialized();
      const wi = this.formatTarget(Si);
      return this.getExpiration(wi);
    }, this.del = (Si) => {
      if (this.isInitialized(), this.has(Si)) {
        const wi = this.formatTarget(Si), Ei = this.getExpiration(wi);
        this.expirations.delete(wi), this.events.emit(w$3.deleted, { target: wi, expiration: Ei });
      }
    }, this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.logger = cjs$3.generateChildLogger(Oe, this.name);
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return ct$3(e);
    if (typeof e == "number")
      return at$3(e);
    const { message: Oe } = N$2("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(Oe);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(w$3.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: Oe } = N$2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const Oe = this.expirations.get(e);
    if (!Oe) {
      const { message: Si } = N$2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(Si), new Error(Si);
    }
    return Oe;
  }
  checkExpiry(e, Oe) {
    const { expiry: Si } = Oe;
    cjs$4.toMiliseconds(Si) - Date.now() <= 0 && this.expire(e, Oe);
  }
  expire(e, Oe) {
    this.expirations.delete(e), this.events.emit(w$3.expired, { target: e, expiration: Oe });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, Oe) => this.checkExpiry(Oe, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(cjs$5.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(w$3.created, (e) => {
      const Oe = w$3.created;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), this.persist();
    }), this.events.on(w$3.expired, (e) => {
      const Oe = w$3.expired;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), this.persist();
    }), this.events.on(w$3.deleted, (e) => {
      const Oe = w$3.deleted;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, kt$1 = class extends y$5 {
  constructor(e, Oe) {
    super(e, Oe), this.projectId = e, this.logger = Oe, this.name = X$3, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (Si) => {
      if (this.verifyDisabled || H$3() || !q())
        return;
      const wi = (Si == null ? void 0 : Si.verifyUrl) || Q$3;
      this.verifyUrl !== wi && this.removeIframe(), this.verifyUrl = wi;
      try {
        await this.createIframe();
      } catch (Ei) {
        this.logger.warn(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.warn(Ei);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ge$1;
        try {
          await this.createIframe();
        } catch (Ei) {
          this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(Ei), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (Si) => {
      this.initialized ? this.sendPost(Si.attestationId) : (this.addToQueue(Si.attestationId), await this.init());
    }, this.resolve = async (Si) => {
      if (this.isDevEnv)
        return "";
      const wi = (Si == null ? void 0 : Si.verifyUrl) || Q$3;
      let Ei = "";
      try {
        Ei = await this.fetchAttestation(Si.attestationId, wi);
      } catch ($i) {
        this.logger.warn(`failed to resolve attestation: ${Si.attestationId} from url: ${wi}`), this.logger.warn($i), Ei = await this.fetchAttestation(Si.attestationId, ge$1);
      }
      return Ei;
    }, this.fetchAttestation = async (Si, wi) => {
      var Ei;
      this.logger.info(`resolving attestation: ${Si} from url: ${wi}`);
      const $i = this.startAbortTimer(cjs$4.ONE_SECOND * 2), xi = await fetch(`${wi}/attestation/${Si}`, { signal: this.abortController.signal });
      return clearTimeout($i), xi.status === 200 ? (Ei = await xi.json()) == null ? void 0 : Ei.origin : "";
    }, this.addToQueue = (Si) => {
      this.queue.push(Si);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((Si) => this.sendPost(Si)), this.queue = []);
    }, this.sendPost = (Si) => {
      var wi;
      try {
        if (!this.iframe)
          return;
        (wi = this.iframe.contentWindow) == null || wi.postMessage(Si, "*"), this.logger.info(`postMessage sent: ${Si} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let Si;
      const wi = (Ei) => {
        Ei.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", wi), Si());
      };
      await Promise.race([new Promise((Ei) => {
        if (document.getElementById(X$3))
          return Ei();
        window.addEventListener("message", wi);
        const $i = document.createElement("iframe");
        $i.id = X$3, $i.src = `${this.verifyUrl}/${this.projectId}`, $i.style.display = "none", document.body.append($i), this.iframe = $i, Si = Ei;
      }), new Promise((Ei, $i) => setTimeout(() => {
        window.removeEventListener("message", wi), $i("verify iframe load timeout");
      }, cjs$4.toMiliseconds(cjs$4.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.logger = cjs$3.generateChildLogger(Oe, this.name), this.verifyUrl = Q$3, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$4.toMiliseconds(e));
  }
};
var Sr$2 = Object.defineProperty, Kt$2 = Object.getOwnPropertySymbols, Pr$2 = Object.prototype.hasOwnProperty, Or$2 = Object.prototype.propertyIsEnumerable, Bt$2 = (se, e, Oe) => e in se ? Sr$2(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Vt$2 = (se, e) => {
  for (var Oe in e || (e = {}))
    Pr$2.call(e, Oe) && Bt$2(se, Oe, e[Oe]);
  if (Kt$2)
    for (var Oe of Kt$2(e))
      Or$2.call(e, Oe) && Bt$2(se, Oe, e[Oe]);
  return se;
};
let Z$2 = class Xl extends n$4 {
  constructor(e) {
    super(e), this.protocol = ce$2, this.version = Je$1, this.name = W$2, this.events = new EventEmitter(), this.initialized = !1, this.on = (Si, wi) => this.events.on(Si, wi), this.once = (Si, wi) => this.events.once(Si, wi), this.off = (Si, wi) => this.events.off(Si, wi), this.removeListener = (Si, wi) => this.events.removeListener(Si, wi), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || le$2;
    const Oe = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : cjs$3.pino(cjs$3.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || We$2.logger }));
    this.logger = cjs$3.generateChildLogger(Oe, this.name), this.heartbeat = new cjs$5.HeartBeat(), this.crypto = new Rt$1(this, this.logger, e == null ? void 0 : e.keychain), this.history = new $t$2(this, this.logger), this.expirer = new Mt$2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h$5(Vt$2(Vt$2({}, Xe$2), e == null ? void 0 : e.storageOptions)), this.relayer = new At$2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Ft$2(this, this.logger), this.verify = new kt$1(this.projectId || "", this.logger);
  }
  static async init(e) {
    const Oe = new Xl(e);
    await Oe.initialize();
    const Si = await Oe.crypto.getClientId();
    return await Oe.storage.setItem(pt$2, Si), Oe;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
const xr$2 = Z$2, J$1 = "wc", X$2 = 2, F$1 = "client", G$1 = `${J$1}@${X$2}:${F$1}:`, M$3 = { name: F$1, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, H$2 = "WALLETCONNECT_DEEPLINK_CHOICE", ne$1 = "proposal", oe$2 = "Proposal expired", ae$2 = "session", C$5 = cjs$4.SEVEN_DAYS, ce$1 = "engine", V$2 = { wc_sessionPropose: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, U$1 = { min: cjs$4.FIVE_MINUTES, max: cjs$4.SEVEN_DAYS }, E$3 = { idle: "IDLE", active: "ACTIVE" }, le$1 = "request", pe$1 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var rs = Object.defineProperty, ns = Object.defineProperties, os = Object.getOwnPropertyDescriptors, he$1 = Object.getOwnPropertySymbols, as = Object.prototype.hasOwnProperty, cs = Object.prototype.propertyIsEnumerable, de$1 = (se, e, Oe) => e in se ? rs(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, g$4 = (se, e) => {
  for (var Oe in e || (e = {}))
    as.call(e, Oe) && de$1(se, Oe, e[Oe]);
  if (he$1)
    for (var Oe of he$1(e))
      cs.call(e, Oe) && de$1(se, Oe, e[Oe]);
  return se;
}, b$4 = (se, e) => ns(se, os(e));
class ls extends S$4 {
  constructor(e) {
    super(e), this.name = ce$1, this.events = new c$5(), this.initialized = !1, this.ignoredPayloadTypes = [_$5], this.requestQueue = { state: E$3.idle, queue: [] }, this.sessionRequestQueue = { state: E$3.idle, queue: [] }, this.requestQueueDelay = cjs$4.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(V$2) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$4.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (Oe) => {
      await this.isInitialized();
      const Si = b$4(g$4({}, Oe), { requiredNamespaces: Oe.requiredNamespaces || {}, optionalNamespaces: Oe.optionalNamespaces || {} });
      await this.isValidConnect(Si);
      const { pairingTopic: wi, requiredNamespaces: Ei, optionalNamespaces: $i, sessionProperties: xi, relays: Ri } = Si;
      let Ti = wi, Oi, Mi = !1;
      if (Ti && (Mi = this.client.core.pairing.pairings.get(Ti).active), !Ti || !Mi) {
        const { topic: Uo, uri: Co } = await this.client.core.pairing.create();
        Ti = Uo, Oi = Co;
      }
      const Ii = await this.client.core.crypto.generateKeyPair(), Ci = g$4({ requiredNamespaces: Ei, optionalNamespaces: $i, relays: Ri ?? [{ protocol: at$2 }], proposer: { publicKey: Ii, metadata: this.client.metadata } }, xi && { sessionProperties: xi }), { reject: Oo, resolve: Ro, done: Bo } = st$2(cjs$4.FIVE_MINUTES, oe$2);
      if (this.events.once(ft$2("session_connect"), async ({ error: Uo, session: Co }) => {
        if (Uo)
          Oo(Uo);
        else if (Co) {
          Co.self.publicKey = Ii;
          const ko = b$4(g$4({}, Co), { requiredNamespaces: Co.requiredNamespaces, optionalNamespaces: Co.optionalNamespaces });
          await this.client.session.set(Co.topic, ko), await this.setExpiry(Co.topic, Co.expiry), Ti && await this.client.core.pairing.updateMetadata({ topic: Ti, metadata: Co.peer.metadata }), Ro(ko);
        }
      }), !Ti) {
        const { message: Uo } = N$2("NO_MATCHING_KEY", `connect() pairing topic: ${Ti}`);
        throw new Error(Uo);
      }
      const Fo = await this.sendRequest({ topic: Ti, method: "wc_sessionPropose", params: Ci }), Io = lt$3(cjs$4.FIVE_MINUTES);
      return await this.setProposal(Fo, g$4({ id: Fo, expiry: Io }, Ci)), { uri: Oi, approval: Bo };
    }, this.pair = async (Oe) => (await this.isInitialized(), await this.client.core.pairing.pair(Oe)), this.approve = async (Oe) => {
      await this.isInitialized(), await this.isValidApprove(Oe);
      const { id: Si, relayProtocol: wi, namespaces: Ei, sessionProperties: $i } = Oe, xi = this.client.proposal.get(Si);
      let { pairingTopic: Ri, proposer: Ti, requiredNamespaces: Oi, optionalNamespaces: Mi } = xi;
      Ri = Ri || "", B$2(Oi) || (Oi = At$3(Ei, "approve()"));
      const Ii = await this.client.core.crypto.generateKeyPair(), Ci = Ti.publicKey, Oo = await this.client.core.crypto.generateSharedKey(Ii, Ci);
      Ri && Si && (await this.client.core.pairing.updateMetadata({ topic: Ri, metadata: Ti.metadata }), await this.sendResult({ id: Si, topic: Ri, result: { relay: { protocol: wi ?? "irn" }, responderPublicKey: Ii } }), await this.client.proposal.delete(Si, U$2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: Ri }));
      const Ro = g$4({ relay: { protocol: wi ?? "irn" }, namespaces: Ei, requiredNamespaces: Oi, optionalNamespaces: Mi, pairingTopic: Ri, controller: { publicKey: Ii, metadata: this.client.metadata }, expiry: lt$3(C$5) }, $i && { sessionProperties: $i });
      await this.client.core.relayer.subscribe(Oo), await this.sendRequest({ topic: Oo, method: "wc_sessionSettle", params: Ro, throwOnFailedPublish: !0 });
      const Bo = b$4(g$4({}, Ro), { topic: Oo, pairingTopic: Ri, acknowledged: !1, self: Ro.controller, peer: { publicKey: Ti.publicKey, metadata: Ti.metadata }, controller: Ii });
      return await this.client.session.set(Oo, Bo), await this.setExpiry(Oo, lt$3(C$5)), { topic: Oo, acknowledged: () => new Promise((Fo) => setTimeout(() => Fo(this.client.session.get(Oo)), 500)) };
    }, this.reject = async (Oe) => {
      await this.isInitialized(), await this.isValidReject(Oe);
      const { id: Si, reason: wi } = Oe, { pairingTopic: Ei } = this.client.proposal.get(Si);
      Ei && (await this.sendError(Si, Ei, wi), await this.client.proposal.delete(Si, U$2("USER_DISCONNECTED")));
    }, this.update = async (Oe) => {
      await this.isInitialized(), await this.isValidUpdate(Oe);
      const { topic: Si, namespaces: wi } = Oe, Ei = await this.sendRequest({ topic: Si, method: "wc_sessionUpdate", params: { namespaces: wi } }), { done: $i, resolve: xi, reject: Ri } = st$2();
      return this.events.once(ft$2("session_update", Ei), ({ error: Ti }) => {
        Ti ? Ri(Ti) : xi();
      }), await this.client.session.update(Si, { namespaces: wi }), { acknowledged: $i };
    }, this.extend = async (Oe) => {
      await this.isInitialized(), await this.isValidExtend(Oe);
      const { topic: Si } = Oe, wi = await this.sendRequest({ topic: Si, method: "wc_sessionExtend", params: {} }), { done: Ei, resolve: $i, reject: xi } = st$2();
      return this.events.once(ft$2("session_extend", wi), ({ error: Ri }) => {
        Ri ? xi(Ri) : $i();
      }), await this.setExpiry(Si, lt$3(C$5)), { acknowledged: Ei };
    }, this.request = async (Oe) => {
      await this.isInitialized(), await this.isValidRequest(Oe);
      const { chainId: Si, request: wi, topic: Ei, expiry: $i } = Oe, xi = payloadId(), { done: Ri, resolve: Ti, reject: Oi } = st$2($i);
      return this.events.once(ft$2("session_request", xi), ({ error: Mi, result: Ii }) => {
        Mi ? Oi(Mi) : Ti(Ii);
      }), await Promise.all([new Promise(async (Mi) => {
        await this.sendRequest({ clientRpcId: xi, topic: Ei, method: "wc_sessionRequest", params: { request: wi, chainId: Si }, expiry: $i, throwOnFailedPublish: !0 }).catch((Ii) => Oi(Ii)), this.client.events.emit("session_request_sent", { topic: Ei, request: wi, chainId: Si, id: xi }), Mi();
      }), new Promise(async (Mi) => {
        const Ii = await this.client.core.storage.getItem(H$2);
        pt$3({ id: xi, topic: Ei, wcDeepLink: Ii }), Mi();
      }), Ri()]).then((Mi) => Mi[2]);
    }, this.respond = async (Oe) => {
      await this.isInitialized(), await this.isValidRespond(Oe);
      const { topic: Si, response: wi } = Oe, { id: Ei } = wi;
      isJsonRpcResult(wi) ? await this.sendResult({ id: Ei, topic: Si, result: wi.result, throwOnFailedPublish: !0 }) : isJsonRpcError(wi) && await this.sendError(Ei, Si, wi.error), this.cleanupAfterResponse(Oe);
    }, this.ping = async (Oe) => {
      await this.isInitialized(), await this.isValidPing(Oe);
      const { topic: Si } = Oe;
      if (this.client.session.keys.includes(Si)) {
        const wi = await this.sendRequest({ topic: Si, method: "wc_sessionPing", params: {} }), { done: Ei, resolve: $i, reject: xi } = st$2();
        this.events.once(ft$2("session_ping", wi), ({ error: Ri }) => {
          Ri ? xi(Ri) : $i();
        }), await Ei();
      } else
        this.client.core.pairing.pairings.keys.includes(Si) && await this.client.core.pairing.ping({ topic: Si });
    }, this.emit = async (Oe) => {
      await this.isInitialized(), await this.isValidEmit(Oe);
      const { topic: Si, event: wi, chainId: Ei } = Oe;
      await this.sendRequest({ topic: Si, method: "wc_sessionEvent", params: { event: wi, chainId: Ei } });
    }, this.disconnect = async (Oe) => {
      await this.isInitialized(), await this.isValidDisconnect(Oe);
      const { topic: Si } = Oe;
      this.client.session.keys.includes(Si) ? (await this.sendRequest({ topic: Si, method: "wc_sessionDelete", params: U$2("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession(Si)) : await this.client.core.pairing.disconnect({ topic: Si });
    }, this.find = (Oe) => (this.isInitialized(), this.client.session.getAll().filter((Si) => $t$3(Si, Oe))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (Oe) => {
      if (Oe.pairingTopic)
        try {
          const Si = this.client.core.pairing.pairings.get(Oe.pairingTopic), wi = this.client.core.pairing.pairings.getAll().filter((Ei) => {
            var $i, xi;
            return (($i = Ei.peerMetadata) == null ? void 0 : $i.url) && ((xi = Ei.peerMetadata) == null ? void 0 : xi.url) === Oe.peer.metadata.url && Ei.topic && Ei.topic !== Si.topic;
          });
          if (wi.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${wi.length} duplicate pairing(s)`), await Promise.all(wi.map((Ei) => this.client.core.pairing.disconnect({ topic: Ei.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (Si) {
          this.client.logger.error(Si);
        }
    }, this.deleteSession = async (Oe, Si) => {
      const { self: wi } = this.client.session.get(Oe);
      await this.client.core.relayer.unsubscribe(Oe), this.client.session.delete(Oe, U$2("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(wi.publicKey) && await this.client.core.crypto.deleteKeyPair(wi.publicKey), this.client.core.crypto.keychain.has(Oe) && await this.client.core.crypto.deleteSymKey(Oe), Si || this.client.core.expirer.del(Oe), this.client.core.storage.removeItem(H$2).catch((Ei) => this.client.logger.warn(Ei));
    }, this.deleteProposal = async (Oe, Si) => {
      await Promise.all([this.client.proposal.delete(Oe, U$2("USER_DISCONNECTED")), Si ? Promise.resolve() : this.client.core.expirer.del(Oe)]);
    }, this.deletePendingSessionRequest = async (Oe, Si, wi = !1) => {
      await Promise.all([this.client.pendingRequest.delete(Oe, Si), wi ? Promise.resolve() : this.client.core.expirer.del(Oe)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((Ei) => Ei.id !== Oe), wi && (this.sessionRequestQueue.state = E$3.idle);
    }, this.setExpiry = async (Oe, Si) => {
      this.client.session.keys.includes(Oe) && await this.client.session.update(Oe, { expiry: Si }), this.client.core.expirer.set(Oe, Si);
    }, this.setProposal = async (Oe, Si) => {
      await this.client.proposal.set(Oe, Si), this.client.core.expirer.set(Oe, Si.expiry);
    }, this.setPendingSessionRequest = async (Oe) => {
      const Si = V$2.wc_sessionRequest.req.ttl, { id: wi, topic: Ei, params: $i } = Oe;
      await this.client.pendingRequest.set(wi, { id: wi, topic: Ei, params: $i }), Si && this.client.core.expirer.set(wi, lt$3(Si));
    }, this.sendRequest = async (Oe) => {
      const { topic: Si, method: wi, params: Ei, expiry: $i, relayRpcId: xi, clientRpcId: Ri, throwOnFailedPublish: Ti } = Oe, Oi = formatJsonRpcRequest(wi, Ei, Ri);
      if (q() && pe$1.includes(wi)) {
        const Ci = Mn$1(JSON.stringify(Oi));
        this.client.core.verify.register({ attestationId: Ci });
      }
      const Mi = await this.client.core.crypto.encode(Si, Oi), Ii = V$2[wi].req;
      return $i && (Ii.ttl = $i), xi && (Ii.id = xi), this.client.core.history.set(Si, Oi), Ti ? (Ii.internal = b$4(g$4({}, Ii.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Si, Mi, Ii)) : this.client.core.relayer.publish(Si, Mi, Ii).catch((Ci) => this.client.logger.error(Ci)), Oi.id;
    }, this.sendResult = async (Oe) => {
      const { id: Si, topic: wi, result: Ei, throwOnFailedPublish: $i } = Oe, xi = formatJsonRpcResult(Si, Ei), Ri = await this.client.core.crypto.encode(wi, xi), Ti = await this.client.core.history.get(wi, Si), Oi = V$2[Ti.request.method].res;
      $i ? (Oi.internal = b$4(g$4({}, Oi.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(wi, Ri, Oi)) : this.client.core.relayer.publish(wi, Ri, Oi).catch((Mi) => this.client.logger.error(Mi)), await this.client.core.history.resolve(xi);
    }, this.sendError = async (Oe, Si, wi) => {
      const Ei = formatJsonRpcError(Oe, wi), $i = await this.client.core.crypto.encode(Si, Ei), xi = await this.client.core.history.get(Si, Oe), Ri = V$2[xi.request.method].res;
      this.client.core.relayer.publish(Si, $i, Ri), await this.client.core.history.resolve(Ei);
    }, this.cleanup = async () => {
      const Oe = [], Si = [];
      this.client.session.getAll().forEach((wi) => {
        dt$3(wi.expiry) && Oe.push(wi.topic);
      }), this.client.proposal.getAll().forEach((wi) => {
        dt$3(wi.expiry) && Si.push(wi.id);
      }), await Promise.all([...Oe.map((wi) => this.deleteSession(wi)), ...Si.map((wi) => this.deleteProposal(wi))]);
    }, this.onRelayEventRequest = async (Oe) => {
      this.requestQueue.queue.push(Oe), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === E$3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = E$3.active;
        const Oe = this.requestQueue.queue.shift();
        if (Oe)
          try {
            this.processRequest(Oe), await new Promise((Si) => setTimeout(Si, 300));
          } catch (Si) {
            this.client.logger.warn(Si);
          }
      }
      this.requestQueue.state = E$3.idle;
    }, this.processRequest = (Oe) => {
      const { topic: Si, payload: wi } = Oe, Ei = wi.method;
      switch (Ei) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(Si, wi);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(Si, wi);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(Si, wi);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(Si, wi);
        case "wc_sessionPing":
          return this.onSessionPingRequest(Si, wi);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(Si, wi);
        case "wc_sessionRequest":
          return this.onSessionRequest(Si, wi);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(Si, wi);
        default:
          return this.client.logger.info(`Unsupported request method ${Ei}`);
      }
    }, this.onRelayEventResponse = async (Oe) => {
      const { topic: Si, payload: wi } = Oe, Ei = (await this.client.core.history.get(Si, wi.id)).request.method;
      switch (Ei) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(Si, wi);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(Si, wi);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(Si, wi);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(Si, wi);
        case "wc_sessionPing":
          return this.onSessionPingResponse(Si, wi);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(Si, wi);
        default:
          return this.client.logger.info(`Unsupported response method ${Ei}`);
      }
    }, this.onRelayEventUnknownPayload = (Oe) => {
      const { topic: Si } = Oe, { message: wi } = N$2("MISSING_OR_INVALID", `Decoded payload on topic ${Si} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(wi);
    }, this.onSessionProposeRequest = async (Oe, Si) => {
      const { params: wi, id: Ei } = Si;
      try {
        this.isValidConnect(g$4({}, Si.params));
        const $i = lt$3(cjs$4.FIVE_MINUTES), xi = g$4({ id: Ei, pairingTopic: Oe, expiry: $i }, wi);
        await this.setProposal(Ei, xi);
        const Ri = Mn$1(JSON.stringify(Si)), Ti = await this.getVerifyContext(Ri, xi.proposer.metadata);
        this.client.events.emit("session_proposal", { id: Ei, params: xi, verifyContext: Ti });
      } catch ($i) {
        await this.sendError(Ei, Oe, $i), this.client.logger.error($i);
      }
    }, this.onSessionProposeResponse = async (Oe, Si) => {
      const { id: wi } = Si;
      if (isJsonRpcResult(Si)) {
        const { result: Ei } = Si;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: Ei });
        const $i = this.client.proposal.get(wi);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: $i });
        const xi = $i.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: xi });
        const Ri = Ei.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: Ri });
        const Ti = await this.client.core.crypto.generateSharedKey(xi, Ri);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: Ti });
        const Oi = await this.client.core.relayer.subscribe(Ti);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: Oi }), await this.client.core.pairing.activate({ topic: Oe });
      } else
        isJsonRpcError(Si) && (await this.client.proposal.delete(wi, U$2("USER_DISCONNECTED")), this.events.emit(ft$2("session_connect"), { error: Si.error }));
    }, this.onSessionSettleRequest = async (Oe, Si) => {
      const { id: wi, params: Ei } = Si;
      try {
        this.isValidSessionSettleRequest(Ei);
        const { relay: $i, controller: xi, expiry: Ri, namespaces: Ti, requiredNamespaces: Oi, optionalNamespaces: Mi, sessionProperties: Ii, pairingTopic: Ci } = Si.params, Oo = g$4({ topic: Oe, relay: $i, expiry: Ri, namespaces: Ti, acknowledged: !0, pairingTopic: Ci, requiredNamespaces: Oi, optionalNamespaces: Mi, controller: xi.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: xi.publicKey, metadata: xi.metadata } }, Ii && { sessionProperties: Ii });
        await this.sendResult({ id: Si.id, topic: Oe, result: !0 }), this.events.emit(ft$2("session_connect"), { session: Oo }), this.cleanupDuplicatePairings(Oo);
      } catch ($i) {
        await this.sendError(wi, Oe, $i), this.client.logger.error($i);
      }
    }, this.onSessionSettleResponse = async (Oe, Si) => {
      const { id: wi } = Si;
      isJsonRpcResult(Si) ? (await this.client.session.update(Oe, { acknowledged: !0 }), this.events.emit(ft$2("session_approve", wi), {})) : isJsonRpcError(Si) && (await this.client.session.delete(Oe, U$2("USER_DISCONNECTED")), this.events.emit(ft$2("session_approve", wi), { error: Si.error }));
    }, this.onSessionUpdateRequest = async (Oe, Si) => {
      const { params: wi, id: Ei } = Si;
      try {
        const $i = `${Oe}_session_update`, xi = er$3.get($i);
        if (xi && this.isRequestOutOfSync(xi, Ei)) {
          this.client.logger.info(`Discarding out of sync request - ${Ei}`);
          return;
        }
        this.isValidUpdate(g$4({ topic: Oe }, wi)), await this.client.session.update(Oe, { namespaces: wi.namespaces }), await this.sendResult({ id: Ei, topic: Oe, result: !0 }), this.client.events.emit("session_update", { id: Ei, topic: Oe, params: wi }), er$3.set($i, Ei);
      } catch ($i) {
        await this.sendError(Ei, Oe, $i), this.client.logger.error($i);
      }
    }, this.isRequestOutOfSync = (Oe, Si) => parseInt(Si.toString().slice(0, -3)) <= parseInt(Oe.toString().slice(0, -3)), this.onSessionUpdateResponse = (Oe, Si) => {
      const { id: wi } = Si;
      isJsonRpcResult(Si) ? this.events.emit(ft$2("session_update", wi), {}) : isJsonRpcError(Si) && this.events.emit(ft$2("session_update", wi), { error: Si.error });
    }, this.onSessionExtendRequest = async (Oe, Si) => {
      const { id: wi } = Si;
      try {
        this.isValidExtend({ topic: Oe }), await this.setExpiry(Oe, lt$3(C$5)), await this.sendResult({ id: wi, topic: Oe, result: !0 }), this.client.events.emit("session_extend", { id: wi, topic: Oe });
      } catch (Ei) {
        await this.sendError(wi, Oe, Ei), this.client.logger.error(Ei);
      }
    }, this.onSessionExtendResponse = (Oe, Si) => {
      const { id: wi } = Si;
      isJsonRpcResult(Si) ? this.events.emit(ft$2("session_extend", wi), {}) : isJsonRpcError(Si) && this.events.emit(ft$2("session_extend", wi), { error: Si.error });
    }, this.onSessionPingRequest = async (Oe, Si) => {
      const { id: wi } = Si;
      try {
        this.isValidPing({ topic: Oe }), await this.sendResult({ id: wi, topic: Oe, result: !0 }), this.client.events.emit("session_ping", { id: wi, topic: Oe });
      } catch (Ei) {
        await this.sendError(wi, Oe, Ei), this.client.logger.error(Ei);
      }
    }, this.onSessionPingResponse = (Oe, Si) => {
      const { id: wi } = Si;
      setTimeout(() => {
        isJsonRpcResult(Si) ? this.events.emit(ft$2("session_ping", wi), {}) : isJsonRpcError(Si) && this.events.emit(ft$2("session_ping", wi), { error: Si.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (Oe, Si) => {
      const { id: wi } = Si;
      try {
        this.isValidDisconnect({ topic: Oe, reason: Si.params }), await Promise.all([new Promise((Ei) => {
          this.client.core.relayer.once(D$3.publish, async () => {
            Ei(await this.deleteSession(Oe));
          });
        }), this.sendResult({ id: wi, topic: Oe, result: !0 })]), this.client.events.emit("session_delete", { id: wi, topic: Oe });
      } catch (Ei) {
        this.client.logger.error(Ei);
      }
    }, this.onSessionRequest = async (Oe, Si) => {
      const { id: wi, params: Ei } = Si;
      try {
        this.isValidRequest(g$4({ topic: Oe }, Ei)), await this.setPendingSessionRequest({ id: wi, topic: Oe, params: Ei }), this.addSessionRequestToSessionRequestQueue({ id: wi, topic: Oe, params: Ei }), await this.processSessionRequestQueue();
      } catch ($i) {
        await this.sendError(wi, Oe, $i), this.client.logger.error($i);
      }
    }, this.onSessionRequestResponse = (Oe, Si) => {
      const { id: wi } = Si;
      isJsonRpcResult(Si) ? this.events.emit(ft$2("session_request", wi), { result: Si.result }) : isJsonRpcError(Si) && this.events.emit(ft$2("session_request", wi), { error: Si.error });
    }, this.onSessionEventRequest = async (Oe, Si) => {
      const { id: wi, params: Ei } = Si;
      try {
        const $i = `${Oe}_session_event_${Ei.event.name}`, xi = er$3.get($i);
        if (xi && this.isRequestOutOfSync(xi, wi)) {
          this.client.logger.info(`Discarding out of sync request - ${wi}`);
          return;
        }
        this.isValidEmit(g$4({ topic: Oe }, Ei)), this.client.events.emit("session_event", { id: wi, topic: Oe, params: Ei }), er$3.set($i, wi);
      } catch ($i) {
        await this.sendError(wi, Oe, $i), this.client.logger.error($i);
      }
    }, this.addSessionRequestToSessionRequestQueue = (Oe) => {
      this.sessionRequestQueue.queue.push(Oe);
    }, this.cleanupAfterResponse = (Oe) => {
      this.deletePendingSessionRequest(Oe.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = E$3.idle, this.processSessionRequestQueue();
      }, cjs$4.toMiliseconds(this.requestQueueDelay));
    }, this.processSessionRequestQueue = async () => {
      if (this.sessionRequestQueue.state === E$3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const Oe = this.sessionRequestQueue.queue[0];
      if (!Oe) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        const { id: Si, topic: wi, params: Ei } = Oe, $i = Mn$1(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", Ei, Si))), xi = this.client.session.get(wi), Ri = await this.getVerifyContext($i, xi.peer.metadata);
        this.sessionRequestQueue.state = E$3.active, this.client.events.emit("session_request", { id: Si, topic: wi, params: Ei, verifyContext: Ri });
      } catch (Si) {
        this.client.logger.error(Si);
      }
    }, this.isValidConnect = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(Oe)}`);
        throw new Error(Ri);
      }
      const { pairingTopic: Si, requiredNamespaces: wi, optionalNamespaces: Ei, sessionProperties: $i, relays: xi } = Oe;
      if (w$4(Si) || await this.isValidPairingTopic(Si), !Kt$3(xi, !0)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `connect() relays: ${xi}`);
        throw new Error(Ri);
      }
      !w$4(wi) && B$2(wi) !== 0 && this.validateNamespaces(wi, "requiredNamespaces"), !w$4(Ei) && B$2(Ei) !== 0 && this.validateNamespaces(Ei, "optionalNamespaces"), w$4($i) || this.validateSessionProps($i, "sessionProperties");
    }, this.validateNamespaces = (Oe, Si) => {
      const wi = Mt$3(Oe, "connect()", Si);
      if (wi)
        throw new Error(wi.message);
    }, this.isValidApprove = async (Oe) => {
      if (!xt$3(Oe))
        throw new Error(N$2("MISSING_OR_INVALID", `approve() params: ${Oe}`).message);
      const { id: Si, namespaces: wi, relayProtocol: Ei, sessionProperties: $i } = Oe;
      await this.isValidProposalId(Si);
      const xi = this.client.proposal.get(Si), Ri = cn$2(wi, "approve()");
      if (Ri)
        throw new Error(Ri.message);
      const Ti = un$2(xi.requiredNamespaces, wi, "approve()");
      if (Ti)
        throw new Error(Ti.message);
      if (!h$3(Ei, !0)) {
        const { message: Oi } = N$2("MISSING_OR_INVALID", `approve() relayProtocol: ${Ei}`);
        throw new Error(Oi);
      }
      w$4($i) || this.validateSessionProps($i, "sessionProperties");
    }, this.isValidReject = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: Ei } = N$2("MISSING_OR_INVALID", `reject() params: ${Oe}`);
        throw new Error(Ei);
      }
      const { id: Si, reason: wi } = Oe;
      if (await this.isValidProposalId(Si), !Ft$3(wi)) {
        const { message: Ei } = N$2("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(wi)}`);
        throw new Error(Ei);
      }
    }, this.isValidSessionSettleRequest = (Oe) => {
      if (!xt$3(Oe)) {
        const { message: Ti } = N$2("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${Oe}`);
        throw new Error(Ti);
      }
      const { relay: Si, controller: wi, namespaces: Ei, expiry: $i } = Oe;
      if (!an$2(Si)) {
        const { message: Ti } = N$2("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(Ti);
      }
      const xi = Vt$3(wi, "onSessionSettleRequest()");
      if (xi)
        throw new Error(xi.message);
      const Ri = cn$2(Ei, "onSessionSettleRequest()");
      if (Ri)
        throw new Error(Ri.message);
      if (dt$3($i)) {
        const { message: Ti } = N$2("EXPIRED", "onSessionSettleRequest()");
        throw new Error(Ti);
      }
    }, this.isValidUpdate = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `update() params: ${Oe}`);
        throw new Error(Ri);
      }
      const { topic: Si, namespaces: wi } = Oe;
      await this.isValidSessionTopic(Si);
      const Ei = this.client.session.get(Si), $i = cn$2(wi, "update()");
      if ($i)
        throw new Error($i.message);
      const xi = un$2(Ei.requiredNamespaces, wi, "update()");
      if (xi)
        throw new Error(xi.message);
    }, this.isValidExtend = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: wi } = N$2("MISSING_OR_INVALID", `extend() params: ${Oe}`);
        throw new Error(wi);
      }
      const { topic: Si } = Oe;
      await this.isValidSessionTopic(Si);
    }, this.isValidRequest = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `request() params: ${Oe}`);
        throw new Error(Ri);
      }
      const { topic: Si, request: wi, chainId: Ei, expiry: $i } = Oe;
      await this.isValidSessionTopic(Si);
      const { namespaces: xi } = this.client.session.get(Si);
      if (!Gt$2(xi, Ei)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `request() chainId: ${Ei}`);
        throw new Error(Ri);
      }
      if (!Ht$2(wi)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `request() ${JSON.stringify(wi)}`);
        throw new Error(Ri);
      }
      if (!Wt$2(xi, Ei, wi.method)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `request() method: ${wi.method}`);
        throw new Error(Ri);
      }
      if ($i && !Qt$2($i, U$1)) {
        const { message: Ri } = N$2("MISSING_OR_INVALID", `request() expiry: ${$i}. Expiry must be a number (in seconds) between ${U$1.min} and ${U$1.max}`);
        throw new Error(Ri);
      }
    }, this.isValidRespond = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: Ei } = N$2("MISSING_OR_INVALID", `respond() params: ${Oe}`);
        throw new Error(Ei);
      }
      const { topic: Si, response: wi } = Oe;
      if (await this.isValidSessionTopic(Si), !qt$2(wi)) {
        const { message: Ei } = N$2("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(wi)}`);
        throw new Error(Ei);
      }
    }, this.isValidPing = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: wi } = N$2("MISSING_OR_INVALID", `ping() params: ${Oe}`);
        throw new Error(wi);
      }
      const { topic: Si } = Oe;
      await this.isValidSessionOrPairingTopic(Si);
    }, this.isValidEmit = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: xi } = N$2("MISSING_OR_INVALID", `emit() params: ${Oe}`);
        throw new Error(xi);
      }
      const { topic: Si, event: wi, chainId: Ei } = Oe;
      await this.isValidSessionTopic(Si);
      const { namespaces: $i } = this.client.session.get(Si);
      if (!Gt$2($i, Ei)) {
        const { message: xi } = N$2("MISSING_OR_INVALID", `emit() chainId: ${Ei}`);
        throw new Error(xi);
      }
      if (!Bt$3(wi)) {
        const { message: xi } = N$2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(wi)}`);
        throw new Error(xi);
      }
      if (!zt$3($i, Ei, wi.name)) {
        const { message: xi } = N$2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(wi)}`);
        throw new Error(xi);
      }
    }, this.isValidDisconnect = async (Oe) => {
      if (!xt$3(Oe)) {
        const { message: wi } = N$2("MISSING_OR_INVALID", `disconnect() params: ${Oe}`);
        throw new Error(wi);
      }
      const { topic: Si } = Oe;
      await this.isValidSessionOrPairingTopic(Si);
    }, this.getVerifyContext = async (Oe, Si) => {
      const wi = { verified: { verifyUrl: Si.verifyUrl || Q$3, validation: "UNKNOWN", origin: Si.url || "" } };
      try {
        const Ei = await this.client.core.verify.resolve({ attestationId: Oe, verifyUrl: Si.verifyUrl });
        Ei && (wi.verified.origin = Ei, wi.verified.validation = Ei === new URL(Si.url).origin ? "VALID" : "INVALID");
      } catch (Ei) {
        this.client.logger.error(Ei);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(wi)}`), wi;
    }, this.validateSessionProps = (Oe, Si) => {
      Object.values(Oe).forEach((wi) => {
        if (!h$3(wi, !1)) {
          const { message: Ei } = N$2("MISSING_OR_INVALID", `${Si} must be in Record<string, string> format. Received: ${JSON.stringify(wi)}`);
          throw new Error(Ei);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = N$2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D$3.message, async (e) => {
      const { topic: Oe, message: Si } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(Si)))
        return;
      const wi = await this.client.core.crypto.decode(Oe, Si);
      try {
        isJsonRpcRequest(wi) ? (this.client.core.history.set(Oe, wi), this.onRelayEventRequest({ topic: Oe, payload: wi })) : isJsonRpcResponse(wi) ? (await this.client.core.history.resolve(wi), await this.onRelayEventResponse({ topic: Oe, payload: wi }), this.client.core.history.delete(Oe, wi.id)) : this.onRelayEventUnknownPayload({ topic: Oe, payload: wi });
      } catch (Ei) {
        this.client.logger.error(Ei);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(w$3.expired, async (e) => {
      const { topic: Oe, id: Si } = ut$3(e.target);
      if (Si && this.client.pendingRequest.keys.includes(Si))
        return await this.deletePendingSessionRequest(Si, N$2("EXPIRED"), !0);
      Oe ? this.client.session.keys.includes(Oe) && (await this.deleteSession(Oe, !0), this.client.events.emit("session_expire", { topic: Oe })) : Si && (await this.deleteProposal(Si, !0), this.client.events.emit("proposal_expire", { id: Si }));
    });
  }
  isValidPairingTopic(e) {
    if (!h$3(e, !1)) {
      const { message: Oe } = N$2("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(Oe);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: Oe } = N$2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(Oe);
    }
    if (dt$3(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: Oe } = N$2("EXPIRED", `pairing topic: ${e}`);
      throw new Error(Oe);
    }
  }
  async isValidSessionTopic(e) {
    if (!h$3(e, !1)) {
      const { message: Oe } = N$2("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(Oe);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: Oe } = N$2("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(Oe);
    }
    if (dt$3(this.client.session.get(e).expiry)) {
      await this.deleteSession(e);
      const { message: Oe } = N$2("EXPIRED", `session topic: ${e}`);
      throw new Error(Oe);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (h$3(e, !1)) {
      const { message: Oe } = N$2("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(Oe);
    } else {
      const { message: Oe } = N$2("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(Oe);
    }
  }
  async isValidProposalId(e) {
    if (!Lt$3(e)) {
      const { message: Oe } = N$2("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(Oe);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: Oe } = N$2("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(Oe);
    }
    if (dt$3(this.client.proposal.get(e).expiry)) {
      await this.deleteProposal(e);
      const { message: Oe } = N$2("EXPIRED", `proposal id: ${e}`);
      throw new Error(Oe);
    }
  }
}
class ps extends Ut$1 {
  constructor(e, Oe) {
    super(e, Oe, ne$1, G$1), this.core = e, this.logger = Oe;
  }
}
class hs extends Ut$1 {
  constructor(e, Oe) {
    super(e, Oe, ae$2, G$1), this.core = e, this.logger = Oe;
  }
}
class ds extends Ut$1 {
  constructor(e, Oe) {
    super(e, Oe, le$1, G$1, (Si) => Si.id), this.core = e, this.logger = Oe;
  }
}
let Q$2 = class Zl extends b$5 {
  constructor(e) {
    super(e), this.protocol = J$1, this.version = X$2, this.name = M$3.name, this.events = new EventEmitter(), this.on = (Si, wi) => this.events.on(Si, wi), this.once = (Si, wi) => this.events.once(Si, wi), this.off = (Si, wi) => this.events.off(Si, wi), this.removeListener = (Si, wi) => this.events.removeListener(Si, wi), this.removeAllListeners = (Si) => this.events.removeAllListeners(Si), this.connect = async (Si) => {
      try {
        return await this.engine.connect(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.pair = async (Si) => {
      try {
        return await this.engine.pair(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.approve = async (Si) => {
      try {
        return await this.engine.approve(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.reject = async (Si) => {
      try {
        return await this.engine.reject(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.update = async (Si) => {
      try {
        return await this.engine.update(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.extend = async (Si) => {
      try {
        return await this.engine.extend(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.request = async (Si) => {
      try {
        return await this.engine.request(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.respond = async (Si) => {
      try {
        return await this.engine.respond(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.ping = async (Si) => {
      try {
        return await this.engine.ping(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.emit = async (Si) => {
      try {
        return await this.engine.emit(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.disconnect = async (Si) => {
      try {
        return await this.engine.disconnect(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.find = (Si) => {
      try {
        return this.engine.find(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (Si) {
        throw this.logger.error(Si.message), Si;
      }
    }, this.name = (e == null ? void 0 : e.name) || M$3.name, this.metadata = (e == null ? void 0 : e.metadata) || zn$1();
    const Oe = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : cjs$3.pino(cjs$3.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || M$3.logger }));
    this.core = (e == null ? void 0 : e.core) || new xr$2(e), this.logger = cjs$3.generateChildLogger(Oe, this.name), this.session = new hs(this.core, this.logger), this.proposal = new ps(this.core, this.logger), this.pendingRequest = new ds(this.core, this.logger), this.engine = new ls(this);
  }
  static async init(e) {
    const Oe = new Zl(e);
    return await Oe.initialize(), Oe;
  }
  get context() {
    return cjs$3.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
};
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (se, e, Oe) => e in se ? __defProp(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, __spreadValues = (se, e) => {
  for (var Oe in e || (e = {}))
    __hasOwnProp.call(e, Oe) && __defNormalProp(se, Oe, e[Oe]);
  if (__getOwnPropSymbols)
    for (var Oe of __getOwnPropSymbols(e))
      __propIsEnum.call(e, Oe) && __defNormalProp(se, Oe, e[Oe]);
  return se;
}, __spreadProps = (se, e) => __defProps(se, __getOwnPropDescs(e)), __accessCheck = (se, e, Oe) => {
  if (!e.has(se))
    throw TypeError("Cannot " + Oe);
}, __privateGet = (se, e, Oe) => (__accessCheck(se, e, "read from private field"), Oe ? Oe.call(se) : e.get(se)), __privateAdd = (se, e, Oe) => {
  if (e.has(se))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(se) : e.set(se, Oe);
}, __privateSet = (se, e, Oe, Si) => (__accessCheck(se, e, "write to private field"), Si ? Si.call(se, Oe) : e.set(se, Oe), Oe), __privateMethod = (se, e, Oe) => (__accessCheck(se, e, "access private method"), Oe), _options, _modal, _initSignClientPromise, _signClient, _initModal, initModal_fn, _initSignClient, initSignClient_fn, _createSignClient, createSignClient_fn;
class WalletConnectModalSign {
  constructor(e) {
    __privateAdd(this, _initModal), __privateAdd(this, _initSignClient), __privateAdd(this, _createSignClient), __privateAdd(this, _options, void 0), __privateAdd(this, _modal, void 0), __privateAdd(this, _initSignClientPromise, void 0), __privateAdd(this, _signClient, void 0), __privateSet(this, _options, e), __privateSet(this, _modal, __privateMethod(this, _initModal, initModal_fn).call(this)), __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
  }
  // -- public ------------------------------------------------------------
  async connect(e) {
    const { requiredNamespaces: Oe, optionalNamespaces: Si } = e;
    return new Promise(async (wi, Ei) => {
      await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
      const $i = __privateGet(this, _modal).subscribeModal((Ti) => {
        Ti.open || ($i(), Ei(new Error("Modal closed")));
      }), { uri: xi, approval: Ri } = await __privateGet(this, _signClient).connect(e);
      if (xi) {
        const Ti = /* @__PURE__ */ new Set();
        Oe && Object.values(Oe).forEach(({ chains: Oi }) => {
          Oi && Oi.forEach((Mi) => Ti.add(Mi));
        }), Si && Object.values(Si).forEach(({ chains: Oi }) => {
          Oi && Oi.forEach((Mi) => Ti.add(Mi));
        }), await __privateGet(this, _modal).openModal({ uri: xi, chains: Array.from(Ti) });
      }
      try {
        const Ti = await Ri();
        wi(Ti);
      } catch (Ti) {
        Ei(Ti);
      } finally {
        $i(), __privateGet(this, _modal).closeModal();
      }
    });
  }
  async disconnect(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), await __privateGet(this, _signClient).disconnect(e);
  }
  async request(e) {
    return await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), await __privateGet(this, _signClient).request(e);
  }
  async getSessions() {
    return await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).session.getAll();
  }
  async getSession() {
    return await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).session.getAll().at(-1);
  }
  async onSessionEvent(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).on("session_event", e);
  }
  async offSessionEvent(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).off("session_event", e);
  }
  async onSessionUpdate(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).on("session_update", e);
  }
  async offSessionUpdate(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).off("session_update", e);
  }
  async onSessionDelete(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).on("session_delete", e);
  }
  async offSessionDelete(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).off("session_delete", e);
  }
  async onSessionExpire(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).on("session_expire", e);
  }
  async offSessionExpire(e) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this), __privateGet(this, _signClient).off("session_expire", e);
  }
}
_options = /* @__PURE__ */ new WeakMap();
_modal = /* @__PURE__ */ new WeakMap();
_initSignClientPromise = /* @__PURE__ */ new WeakMap();
_signClient = /* @__PURE__ */ new WeakMap();
_initModal = /* @__PURE__ */ new WeakSet();
initModal_fn = function() {
  const { modalOptions: se, projectId: e } = __privateGet(this, _options);
  return new WalletConnectModal(__spreadProps(__spreadValues({}, se), {
    projectId: e
  }));
};
_initSignClient = /* @__PURE__ */ new WeakSet();
initSignClient_fn = async function() {
  return __privateGet(this, _signClient) ? !0 : (!__privateGet(this, _initSignClientPromise) && typeof window < "u" && __privateSet(this, _initSignClientPromise, __privateMethod(this, _createSignClient, createSignClient_fn).call(this)), __privateGet(this, _initSignClientPromise));
};
_createSignClient = /* @__PURE__ */ new WeakSet();
createSignClient_fn = async function() {
  __privateSet(this, _signClient, await Q$2.init({
    metadata: __privateGet(this, _options).metadata,
    projectId: __privateGet(this, _options).projectId,
    relayUrl: __privateGet(this, _options).relayUrl
  }));
  const se = await __privateGet(this, _signClient).core.crypto.getClientId();
  try {
    localStorage.setItem("WCM_WALLETCONNECT_CLIENT_ID", se);
  } catch {
    console.info("Unable to set client id");
  }
};
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(se) {
  (function() {
    var e = "input is invalid type", Oe = "finalize already called", Si = typeof window == "object", wi = Si ? window : {};
    wi.JS_SHA3_NO_WINDOW && (Si = !1);
    var Ei = !Si && typeof self == "object", $i = !wi.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    $i ? wi = commonjsGlobal : Ei && (wi = self);
    var xi = !wi.JS_SHA3_NO_COMMON_JS && !0 && se.exports, Ri = !wi.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", Ti = "0123456789abcdef".split(""), Oi = [31, 7936, 2031616, 520093696], Mi = [4, 1024, 262144, 67108864], Ii = [1, 256, 65536, 16777216], Ci = [6, 1536, 393216, 100663296], Oo = [0, 8, 16, 24], Ro = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], Bo = [224, 256, 384, 512], Fo = [128, 256], Io = ["hex", "buffer", "arrayBuffer", "array", "digest"], Uo = {
      128: 168,
      256: 136
    };
    (wi.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(To) {
      return Object.prototype.toString.call(To) === "[object Array]";
    }), Ri && (wi.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(To) {
      return typeof To == "object" && To.buffer && To.buffer.constructor === ArrayBuffer;
    });
    for (var Co = function(To, Ko, Vo) {
      return function(Wo) {
        return new Fi(To, Ko, To).update(Wo)[Vo]();
      };
    }, ko = function(To, Ko, Vo) {
      return function(Wo, jo) {
        return new Fi(To, Ko, jo).update(Wo)[Vo]();
      };
    }, Po = function(To, Ko, Vo) {
      return function(Wo, jo, Ao, Lo) {
        return Ai["cshake" + To].update(Wo, jo, Ao, Lo)[Vo]();
      };
    }, Mo = function(To, Ko, Vo) {
      return function(Wo, jo, Ao, Lo) {
        return Ai["kmac" + To].update(Wo, jo, Ao, Lo)[Vo]();
      };
    }, No = function(To, Ko, Vo, Wo) {
      for (var jo = 0; jo < Io.length; ++jo) {
        var Ao = Io[jo];
        To[Ao] = Ko(Vo, Wo, Ao);
      }
      return To;
    }, Jo = function(To, Ko) {
      var Vo = Co(To, Ko, "hex");
      return Vo.create = function() {
        return new Fi(To, Ko, To);
      }, Vo.update = function(Wo) {
        return Vo.create().update(Wo);
      }, No(Vo, Co, To, Ko);
    }, zo = function(To, Ko) {
      var Vo = ko(To, Ko, "hex");
      return Vo.create = function(Wo) {
        return new Fi(To, Ko, Wo);
      }, Vo.update = function(Wo, jo) {
        return Vo.create(jo).update(Wo);
      }, No(Vo, ko, To, Ko);
    }, Do = function(To, Ko) {
      var Vo = Uo[To], Wo = Po(To, Ko, "hex");
      return Wo.create = function(jo, Ao, Lo) {
        return !Ao && !Lo ? Ai["shake" + To].create(jo) : new Fi(To, Ko, jo).bytepad([Ao, Lo], Vo);
      }, Wo.update = function(jo, Ao, Lo, Zo) {
        return Wo.create(Ao, Lo, Zo).update(jo);
      }, No(Wo, Po, To, Ko);
    }, wo = function(To, Ko) {
      var Vo = Uo[To], Wo = Mo(To, Ko, "hex");
      return Wo.create = function(jo, Ao, Lo) {
        return new xo(To, Ko, Ao).bytepad(["KMAC", Lo], Vo).bytepad([jo], Vo);
      }, Wo.update = function(jo, Ao, Lo, Zo) {
        return Wo.create(jo, Lo, Zo).update(Ao);
      }, No(Wo, Mo, To, Ko);
    }, Li = [
      { name: "keccak", padding: Ii, bits: Bo, createMethod: Jo },
      { name: "sha3", padding: Ci, bits: Bo, createMethod: Jo },
      { name: "shake", padding: Oi, bits: Fo, createMethod: zo },
      { name: "cshake", padding: Mi, bits: Fo, createMethod: Do },
      { name: "kmac", padding: Mi, bits: Fo, createMethod: wo }
    ], Ai = {}, Ni = [], Ui = 0; Ui < Li.length; ++Ui)
      for (var So = Li[Ui], $o = So.bits, Eo = 0; Eo < $o.length; ++Eo) {
        var zi = So.name + "_" + $o[Eo];
        if (Ni.push(zi), Ai[zi] = So.createMethod($o[Eo], So.padding), So.name !== "sha3") {
          var _o = So.name + $o[Eo];
          Ni.push(_o), Ai[_o] = Ai[zi];
        }
      }
    function Fi(To, Ko, Vo) {
      this.blocks = [], this.s = [], this.padding = Ko, this.outputBits = Vo, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (To << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Vo >> 5, this.extraBytes = (Vo & 31) >> 3;
      for (var Wo = 0; Wo < 50; ++Wo)
        this.s[Wo] = 0;
    }
    Fi.prototype.update = function(To) {
      if (this.finalized)
        throw new Error(Oe);
      var Ko, Vo = typeof To;
      if (Vo !== "string") {
        if (Vo === "object") {
          if (To === null)
            throw new Error(e);
          if (Ri && To.constructor === ArrayBuffer)
            To = new Uint8Array(To);
          else if (!Array.isArray(To) && (!Ri || !ArrayBuffer.isView(To)))
            throw new Error(e);
        } else
          throw new Error(e);
        Ko = !0;
      }
      for (var Wo = this.blocks, jo = this.byteCount, Ao = To.length, Lo = this.blockCount, Zo = 0, An = this.s, ra, sa; Zo < Ao; ) {
        if (this.reset)
          for (this.reset = !1, Wo[0] = this.block, ra = 1; ra < Lo + 1; ++ra)
            Wo[ra] = 0;
        if (Ko)
          for (ra = this.start; Zo < Ao && ra < jo; ++Zo)
            Wo[ra >> 2] |= To[Zo] << Oo[ra++ & 3];
        else
          for (ra = this.start; Zo < Ao && ra < jo; ++Zo)
            sa = To.charCodeAt(Zo), sa < 128 ? Wo[ra >> 2] |= sa << Oo[ra++ & 3] : sa < 2048 ? (Wo[ra >> 2] |= (192 | sa >> 6) << Oo[ra++ & 3], Wo[ra >> 2] |= (128 | sa & 63) << Oo[ra++ & 3]) : sa < 55296 || sa >= 57344 ? (Wo[ra >> 2] |= (224 | sa >> 12) << Oo[ra++ & 3], Wo[ra >> 2] |= (128 | sa >> 6 & 63) << Oo[ra++ & 3], Wo[ra >> 2] |= (128 | sa & 63) << Oo[ra++ & 3]) : (sa = 65536 + ((sa & 1023) << 10 | To.charCodeAt(++Zo) & 1023), Wo[ra >> 2] |= (240 | sa >> 18) << Oo[ra++ & 3], Wo[ra >> 2] |= (128 | sa >> 12 & 63) << Oo[ra++ & 3], Wo[ra >> 2] |= (128 | sa >> 6 & 63) << Oo[ra++ & 3], Wo[ra >> 2] |= (128 | sa & 63) << Oo[ra++ & 3]);
        if (this.lastByteIndex = ra, ra >= jo) {
          for (this.start = ra - jo, this.block = Wo[Lo], ra = 0; ra < Lo; ++ra)
            An[ra] ^= Wo[ra];
          Qo(An), this.reset = !0;
        } else
          this.start = ra;
      }
      return this;
    }, Fi.prototype.encode = function(To, Ko) {
      var Vo = To & 255, Wo = 1, jo = [Vo];
      for (To = To >> 8, Vo = To & 255; Vo > 0; )
        jo.unshift(Vo), To = To >> 8, Vo = To & 255, ++Wo;
      return Ko ? jo.push(Wo) : jo.unshift(Wo), this.update(jo), jo.length;
    }, Fi.prototype.encodeString = function(To) {
      var Ko, Vo = typeof To;
      if (Vo !== "string") {
        if (Vo === "object") {
          if (To === null)
            throw new Error(e);
          if (Ri && To.constructor === ArrayBuffer)
            To = new Uint8Array(To);
          else if (!Array.isArray(To) && (!Ri || !ArrayBuffer.isView(To)))
            throw new Error(e);
        } else
          throw new Error(e);
        Ko = !0;
      }
      var Wo = 0, jo = To.length;
      if (Ko)
        Wo = jo;
      else
        for (var Ao = 0; Ao < To.length; ++Ao) {
          var Lo = To.charCodeAt(Ao);
          Lo < 128 ? Wo += 1 : Lo < 2048 ? Wo += 2 : Lo < 55296 || Lo >= 57344 ? Wo += 3 : (Lo = 65536 + ((Lo & 1023) << 10 | To.charCodeAt(++Ao) & 1023), Wo += 4);
        }
      return Wo += this.encode(Wo * 8), this.update(To), Wo;
    }, Fi.prototype.bytepad = function(To, Ko) {
      for (var Vo = this.encode(Ko), Wo = 0; Wo < To.length; ++Wo)
        Vo += this.encodeString(To[Wo]);
      var jo = Ko - Vo % Ko, Ao = [];
      return Ao.length = jo, this.update(Ao), this;
    }, Fi.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var To = this.blocks, Ko = this.lastByteIndex, Vo = this.blockCount, Wo = this.s;
        if (To[Ko >> 2] |= this.padding[Ko & 3], this.lastByteIndex === this.byteCount)
          for (To[0] = To[Vo], Ko = 1; Ko < Vo + 1; ++Ko)
            To[Ko] = 0;
        for (To[Vo - 1] |= 2147483648, Ko = 0; Ko < Vo; ++Ko)
          Wo[Ko] ^= To[Ko];
        Qo(Wo);
      }
    }, Fi.prototype.toString = Fi.prototype.hex = function() {
      this.finalize();
      for (var To = this.blockCount, Ko = this.s, Vo = this.outputBlocks, Wo = this.extraBytes, jo = 0, Ao = 0, Lo = "", Zo; Ao < Vo; ) {
        for (jo = 0; jo < To && Ao < Vo; ++jo, ++Ao)
          Zo = Ko[jo], Lo += Ti[Zo >> 4 & 15] + Ti[Zo & 15] + Ti[Zo >> 12 & 15] + Ti[Zo >> 8 & 15] + Ti[Zo >> 20 & 15] + Ti[Zo >> 16 & 15] + Ti[Zo >> 28 & 15] + Ti[Zo >> 24 & 15];
        Ao % To === 0 && (Qo(Ko), jo = 0);
      }
      return Wo && (Zo = Ko[jo], Lo += Ti[Zo >> 4 & 15] + Ti[Zo & 15], Wo > 1 && (Lo += Ti[Zo >> 12 & 15] + Ti[Zo >> 8 & 15]), Wo > 2 && (Lo += Ti[Zo >> 20 & 15] + Ti[Zo >> 16 & 15])), Lo;
    }, Fi.prototype.arrayBuffer = function() {
      this.finalize();
      var To = this.blockCount, Ko = this.s, Vo = this.outputBlocks, Wo = this.extraBytes, jo = 0, Ao = 0, Lo = this.outputBits >> 3, Zo;
      Wo ? Zo = new ArrayBuffer(Vo + 1 << 2) : Zo = new ArrayBuffer(Lo);
      for (var An = new Uint32Array(Zo); Ao < Vo; ) {
        for (jo = 0; jo < To && Ao < Vo; ++jo, ++Ao)
          An[Ao] = Ko[jo];
        Ao % To === 0 && Qo(Ko);
      }
      return Wo && (An[jo] = Ko[jo], Zo = Zo.slice(0, Lo)), Zo;
    }, Fi.prototype.buffer = Fi.prototype.arrayBuffer, Fi.prototype.digest = Fi.prototype.array = function() {
      this.finalize();
      for (var To = this.blockCount, Ko = this.s, Vo = this.outputBlocks, Wo = this.extraBytes, jo = 0, Ao = 0, Lo = [], Zo, An; Ao < Vo; ) {
        for (jo = 0; jo < To && Ao < Vo; ++jo, ++Ao)
          Zo = Ao << 2, An = Ko[jo], Lo[Zo] = An & 255, Lo[Zo + 1] = An >> 8 & 255, Lo[Zo + 2] = An >> 16 & 255, Lo[Zo + 3] = An >> 24 & 255;
        Ao % To === 0 && Qo(Ko);
      }
      return Wo && (Zo = Ao << 2, An = Ko[jo], Lo[Zo] = An & 255, Wo > 1 && (Lo[Zo + 1] = An >> 8 & 255), Wo > 2 && (Lo[Zo + 2] = An >> 16 & 255)), Lo;
    };
    function xo(To, Ko, Vo) {
      Fi.call(this, To, Ko, Vo);
    }
    xo.prototype = new Fi(), xo.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), Fi.prototype.finalize.call(this);
    };
    var Qo = function(To) {
      var Ko, Vo, Wo, jo, Ao, Lo, Zo, An, ra, sa, Ma, ba, ma, Va, wa, ha, Fa, Sa, da, Pa, va, ca, Na, Ea, fa, Ca, Oa, ya, Ua, xa, Ra, Ha, ka, Aa, Ga, Wa, $a, qa, Ia, Ho, qo, Go, Xo, ea, ia, oa, aa, ua, na, _a, pa, la, Ba, Da, Ta, Ja, ja, za, Qa, tl, Xa, ol, Za;
      for (Wo = 0; Wo < 48; Wo += 2)
        jo = To[0] ^ To[10] ^ To[20] ^ To[30] ^ To[40], Ao = To[1] ^ To[11] ^ To[21] ^ To[31] ^ To[41], Lo = To[2] ^ To[12] ^ To[22] ^ To[32] ^ To[42], Zo = To[3] ^ To[13] ^ To[23] ^ To[33] ^ To[43], An = To[4] ^ To[14] ^ To[24] ^ To[34] ^ To[44], ra = To[5] ^ To[15] ^ To[25] ^ To[35] ^ To[45], sa = To[6] ^ To[16] ^ To[26] ^ To[36] ^ To[46], Ma = To[7] ^ To[17] ^ To[27] ^ To[37] ^ To[47], ba = To[8] ^ To[18] ^ To[28] ^ To[38] ^ To[48], ma = To[9] ^ To[19] ^ To[29] ^ To[39] ^ To[49], Ko = ba ^ (Lo << 1 | Zo >>> 31), Vo = ma ^ (Zo << 1 | Lo >>> 31), To[0] ^= Ko, To[1] ^= Vo, To[10] ^= Ko, To[11] ^= Vo, To[20] ^= Ko, To[21] ^= Vo, To[30] ^= Ko, To[31] ^= Vo, To[40] ^= Ko, To[41] ^= Vo, Ko = jo ^ (An << 1 | ra >>> 31), Vo = Ao ^ (ra << 1 | An >>> 31), To[2] ^= Ko, To[3] ^= Vo, To[12] ^= Ko, To[13] ^= Vo, To[22] ^= Ko, To[23] ^= Vo, To[32] ^= Ko, To[33] ^= Vo, To[42] ^= Ko, To[43] ^= Vo, Ko = Lo ^ (sa << 1 | Ma >>> 31), Vo = Zo ^ (Ma << 1 | sa >>> 31), To[4] ^= Ko, To[5] ^= Vo, To[14] ^= Ko, To[15] ^= Vo, To[24] ^= Ko, To[25] ^= Vo, To[34] ^= Ko, To[35] ^= Vo, To[44] ^= Ko, To[45] ^= Vo, Ko = An ^ (ba << 1 | ma >>> 31), Vo = ra ^ (ma << 1 | ba >>> 31), To[6] ^= Ko, To[7] ^= Vo, To[16] ^= Ko, To[17] ^= Vo, To[26] ^= Ko, To[27] ^= Vo, To[36] ^= Ko, To[37] ^= Vo, To[46] ^= Ko, To[47] ^= Vo, Ko = sa ^ (jo << 1 | Ao >>> 31), Vo = Ma ^ (Ao << 1 | jo >>> 31), To[8] ^= Ko, To[9] ^= Vo, To[18] ^= Ko, To[19] ^= Vo, To[28] ^= Ko, To[29] ^= Vo, To[38] ^= Ko, To[39] ^= Vo, To[48] ^= Ko, To[49] ^= Vo, Va = To[0], wa = To[1], oa = To[11] << 4 | To[10] >>> 28, aa = To[10] << 4 | To[11] >>> 28, ya = To[20] << 3 | To[21] >>> 29, Ua = To[21] << 3 | To[20] >>> 29, tl = To[31] << 9 | To[30] >>> 23, Xa = To[30] << 9 | To[31] >>> 23, Go = To[40] << 18 | To[41] >>> 14, Xo = To[41] << 18 | To[40] >>> 14, Aa = To[2] << 1 | To[3] >>> 31, Ga = To[3] << 1 | To[2] >>> 31, ha = To[13] << 12 | To[12] >>> 20, Fa = To[12] << 12 | To[13] >>> 20, ua = To[22] << 10 | To[23] >>> 22, na = To[23] << 10 | To[22] >>> 22, xa = To[33] << 13 | To[32] >>> 19, Ra = To[32] << 13 | To[33] >>> 19, ol = To[42] << 2 | To[43] >>> 30, Za = To[43] << 2 | To[42] >>> 30, Da = To[5] << 30 | To[4] >>> 2, Ta = To[4] << 30 | To[5] >>> 2, Wa = To[14] << 6 | To[15] >>> 26, $a = To[15] << 6 | To[14] >>> 26, Sa = To[25] << 11 | To[24] >>> 21, da = To[24] << 11 | To[25] >>> 21, _a = To[34] << 15 | To[35] >>> 17, pa = To[35] << 15 | To[34] >>> 17, Ha = To[45] << 29 | To[44] >>> 3, ka = To[44] << 29 | To[45] >>> 3, Ea = To[6] << 28 | To[7] >>> 4, fa = To[7] << 28 | To[6] >>> 4, Ja = To[17] << 23 | To[16] >>> 9, ja = To[16] << 23 | To[17] >>> 9, qa = To[26] << 25 | To[27] >>> 7, Ia = To[27] << 25 | To[26] >>> 7, Pa = To[36] << 21 | To[37] >>> 11, va = To[37] << 21 | To[36] >>> 11, la = To[47] << 24 | To[46] >>> 8, Ba = To[46] << 24 | To[47] >>> 8, ea = To[8] << 27 | To[9] >>> 5, ia = To[9] << 27 | To[8] >>> 5, Ca = To[18] << 20 | To[19] >>> 12, Oa = To[19] << 20 | To[18] >>> 12, za = To[29] << 7 | To[28] >>> 25, Qa = To[28] << 7 | To[29] >>> 25, Ho = To[38] << 8 | To[39] >>> 24, qo = To[39] << 8 | To[38] >>> 24, ca = To[48] << 14 | To[49] >>> 18, Na = To[49] << 14 | To[48] >>> 18, To[0] = Va ^ ~ha & Sa, To[1] = wa ^ ~Fa & da, To[10] = Ea ^ ~Ca & ya, To[11] = fa ^ ~Oa & Ua, To[20] = Aa ^ ~Wa & qa, To[21] = Ga ^ ~$a & Ia, To[30] = ea ^ ~oa & ua, To[31] = ia ^ ~aa & na, To[40] = Da ^ ~Ja & za, To[41] = Ta ^ ~ja & Qa, To[2] = ha ^ ~Sa & Pa, To[3] = Fa ^ ~da & va, To[12] = Ca ^ ~ya & xa, To[13] = Oa ^ ~Ua & Ra, To[22] = Wa ^ ~qa & Ho, To[23] = $a ^ ~Ia & qo, To[32] = oa ^ ~ua & _a, To[33] = aa ^ ~na & pa, To[42] = Ja ^ ~za & tl, To[43] = ja ^ ~Qa & Xa, To[4] = Sa ^ ~Pa & ca, To[5] = da ^ ~va & Na, To[14] = ya ^ ~xa & Ha, To[15] = Ua ^ ~Ra & ka, To[24] = qa ^ ~Ho & Go, To[25] = Ia ^ ~qo & Xo, To[34] = ua ^ ~_a & la, To[35] = na ^ ~pa & Ba, To[44] = za ^ ~tl & ol, To[45] = Qa ^ ~Xa & Za, To[6] = Pa ^ ~ca & Va, To[7] = va ^ ~Na & wa, To[16] = xa ^ ~Ha & Ea, To[17] = Ra ^ ~ka & fa, To[26] = Ho ^ ~Go & Aa, To[27] = qo ^ ~Xo & Ga, To[36] = _a ^ ~la & ea, To[37] = pa ^ ~Ba & ia, To[46] = tl ^ ~ol & Da, To[47] = Xa ^ ~Za & Ta, To[8] = ca ^ ~Va & ha, To[9] = Na ^ ~wa & Fa, To[18] = Ha ^ ~Ea & Ca, To[19] = ka ^ ~fa & Oa, To[28] = Go ^ ~Aa & Wa, To[29] = Xo ^ ~Ga & $a, To[38] = la ^ ~ea & oa, To[39] = Ba ^ ~ia & aa, To[48] = ol ^ ~Da & Ja, To[49] = Za ^ ~Ta & ja, To[0] ^= Ro[Wo], To[1] ^= Ro[Wo + 1];
    };
    if (xi)
      se.exports = Ai;
    else
      for (Ui = 0; Ui < Ni.length; ++Ui)
        wi[Ni[Ui]] = Ai[Ni[Ui]];
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports), version$5 = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const se = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        se.push(e);
      }
    }), se.length)
      throw new Error("missing " + se.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (se) {
    return se.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel$1;
(function(se) {
  se.DEBUG = "DEBUG", se.INFO = "INFO", se.WARNING = "WARNING", se.ERROR = "ERROR", se.OFF = "OFF";
})(LogLevel$1 || (LogLevel$1 = {}));
var ErrorCode;
(function(se) {
  se.UNKNOWN_ERROR = "UNKNOWN_ERROR", se.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", se.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", se.NETWORK_ERROR = "NETWORK_ERROR", se.SERVER_ERROR = "SERVER_ERROR", se.TIMEOUT = "TIMEOUT", se.BUFFER_OVERRUN = "BUFFER_OVERRUN", se.NUMERIC_FAULT = "NUMERIC_FAULT", se.MISSING_NEW = "MISSING_NEW", se.INVALID_ARGUMENT = "INVALID_ARGUMENT", se.MISSING_ARGUMENT = "MISSING_ARGUMENT", se.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", se.CALL_EXCEPTION = "CALL_EXCEPTION", se.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", se.NONCE_EXPIRED = "NONCE_EXPIRED", se.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", se.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", se.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", se.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, Oe) {
    const Si = e.toLowerCase();
    LogLevels[Si] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(_logLevel > LogLevels[Si]) && console.log.apply(console, Oe);
  }
  debug(...e) {
    this._log(Logger.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Logger.levels.INFO, e);
  }
  warn(...e) {
    this._log(Logger.levels.WARNING, e);
  }
  makeError(e, Oe, Si) {
    if (_censorErrors)
      return this.makeError("censored error", Oe, {});
    Oe || (Oe = Logger.errors.UNKNOWN_ERROR), Si || (Si = {});
    const wi = [];
    Object.keys(Si).forEach((Ri) => {
      const Ti = Si[Ri];
      try {
        if (Ti instanceof Uint8Array) {
          let Oi = "";
          for (let Mi = 0; Mi < Ti.length; Mi++)
            Oi += HEX[Ti[Mi] >> 4], Oi += HEX[Ti[Mi] & 15];
          wi.push(Ri + "=Uint8Array(0x" + Oi + ")");
        } else
          wi.push(Ri + "=" + JSON.stringify(Ti));
      } catch {
        wi.push(Ri + "=" + JSON.stringify(Si[Ri].toString()));
      }
    }), wi.push(`code=${Oe}`), wi.push(`version=${this.version}`);
    const Ei = e;
    let $i = "";
    switch (Oe) {
      case ErrorCode.NUMERIC_FAULT: {
        $i = "NUMERIC_FAULT";
        const Ri = e;
        switch (Ri) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            $i += "-" + Ri;
            break;
          case "negative-power":
          case "negative-width":
            $i += "-unsupported";
            break;
          case "unbound-bitwise-result":
            $i += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        $i = Oe;
        break;
    }
    $i && (e += " [ See: https://links.ethers.org/v5-errors-" + $i + " ]"), wi.length && (e += " (" + wi.join(", ") + ")");
    const xi = new Error(e);
    return xi.reason = Ei, xi.code = Oe, Object.keys(Si).forEach(function(Ri) {
      xi[Ri] = Si[Ri];
    }), xi;
  }
  throwError(e, Oe, Si) {
    throw this.makeError(e, Oe, Si);
  }
  throwArgumentError(e, Oe, Si) {
    return this.throwError(e, Logger.errors.INVALID_ARGUMENT, {
      argument: Oe,
      value: Si
    });
  }
  assert(e, Oe, Si, wi) {
    e || this.throwError(Oe, Si, wi);
  }
  assertArgument(e, Oe, Si, wi) {
    e || this.throwArgumentError(Oe, Si, wi);
  }
  checkNormalize(e) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(e, Oe) {
    typeof e == "number" && (Oe == null && (Oe = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(Oe, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(Oe, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, Oe, Si) {
    Si ? Si = ": " + Si : Si = "", e < Oe && this.throwError("missing argument" + Si, Logger.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: Oe
    }), e > Oe && this.throwError("too many arguments" + Si, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: Oe
    });
  }
  checkNew(e, Oe) {
    (e === Object || e == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Oe.name });
  }
  checkAbstract(e, Oe) {
    e === Oe ? this.throwError("cannot instantiate abstract class " + JSON.stringify(Oe.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Oe.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$5)), _globalLogger;
  }
  static setCensorship(e, Oe) {
    if (!e && Oe && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!e, _permanentCensorErrors = !!Oe;
  }
  static setLogLevel(e) {
    const Oe = LogLevels[e.toLowerCase()];
    if (Oe == null) {
      Logger.globalLogger().warn("invalid log level - " + e);
      return;
    }
    _logLevel = Oe;
  }
  static from(e) {
    return new Logger(e);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel$1;
const version$4 = "bytes/5.7.0", logger$3 = new Logger(version$4);
function isHexable(se) {
  return !!se.toHexString;
}
function addSlice(se) {
  return se.slice || (se.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(se, e)));
  }), se;
}
function isBytesLike(se) {
  return isHexString(se) && !(se.length % 2) || isBytes(se);
}
function isInteger(se) {
  return typeof se == "number" && se == se && se % 1 === 0;
}
function isBytes(se) {
  if (se == null)
    return !1;
  if (se.constructor === Uint8Array)
    return !0;
  if (typeof se == "string" || !isInteger(se.length) || se.length < 0)
    return !1;
  for (let e = 0; e < se.length; e++) {
    const Oe = se[e];
    if (!isInteger(Oe) || Oe < 0 || Oe >= 256)
      return !1;
  }
  return !0;
}
function arrayify(se, e) {
  if (e || (e = {}), typeof se == "number") {
    logger$3.checkSafeUint53(se, "invalid arrayify value");
    const Oe = [];
    for (; se; )
      Oe.unshift(se & 255), se = parseInt(String(se / 256));
    return Oe.length === 0 && Oe.push(0), addSlice(new Uint8Array(Oe));
  }
  if (e.allowMissingPrefix && typeof se == "string" && se.substring(0, 2) !== "0x" && (se = "0x" + se), isHexable(se) && (se = se.toHexString()), isHexString(se)) {
    let Oe = se.substring(2);
    Oe.length % 2 && (e.hexPad === "left" ? Oe = "0" + Oe : e.hexPad === "right" ? Oe += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", se));
    const Si = [];
    for (let wi = 0; wi < Oe.length; wi += 2)
      Si.push(parseInt(Oe.substring(wi, wi + 2), 16));
    return addSlice(new Uint8Array(Si));
  }
  return isBytes(se) ? addSlice(new Uint8Array(se)) : logger$3.throwArgumentError("invalid arrayify value", "value", se);
}
function concat$2(se) {
  const e = se.map((wi) => arrayify(wi)), Oe = e.reduce((wi, Ei) => wi + Ei.length, 0), Si = new Uint8Array(Oe);
  return e.reduce((wi, Ei) => (Si.set(Ei, wi), wi + Ei.length), 0), addSlice(Si);
}
function zeroPad(se, e) {
  se = arrayify(se), se.length > e && logger$3.throwArgumentError("value out of range", "value", arguments[0]);
  const Oe = new Uint8Array(e);
  return Oe.set(se, e - se.length), addSlice(Oe);
}
function isHexString(se, e) {
  return !(typeof se != "string" || !se.match(/^0x[0-9A-Fa-f]*$/) || e && se.length !== 2 + 2 * e);
}
const HexCharacters = "0123456789abcdef";
function hexlify(se, e) {
  if (e || (e = {}), typeof se == "number") {
    logger$3.checkSafeUint53(se, "invalid hexlify value");
    let Oe = "";
    for (; se; )
      Oe = HexCharacters[se & 15] + Oe, se = Math.floor(se / 16);
    return Oe.length ? (Oe.length % 2 && (Oe = "0" + Oe), "0x" + Oe) : "0x00";
  }
  if (typeof se == "bigint")
    return se = se.toString(16), se.length % 2 ? "0x0" + se : "0x" + se;
  if (e.allowMissingPrefix && typeof se == "string" && se.substring(0, 2) !== "0x" && (se = "0x" + se), isHexable(se))
    return se.toHexString();
  if (isHexString(se))
    return se.length % 2 && (e.hexPad === "left" ? se = "0x0" + se.substring(2) : e.hexPad === "right" ? se += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", se)), se.toLowerCase();
  if (isBytes(se)) {
    let Oe = "0x";
    for (let Si = 0; Si < se.length; Si++) {
      let wi = se[Si];
      Oe += HexCharacters[(wi & 240) >> 4] + HexCharacters[wi & 15];
    }
    return Oe;
  }
  return logger$3.throwArgumentError("invalid hexlify value", "value", se);
}
function hexDataLength(se) {
  if (typeof se != "string")
    se = hexlify(se);
  else if (!isHexString(se) || se.length % 2)
    return null;
  return (se.length - 2) / 2;
}
function hexDataSlice(se, e, Oe) {
  return typeof se != "string" ? se = hexlify(se) : (!isHexString(se) || se.length % 2) && logger$3.throwArgumentError("invalid hexData", "value", se), e = 2 + 2 * e, Oe != null ? "0x" + se.substring(e, 2 + 2 * Oe) : "0x" + se.substring(e);
}
function hexZeroPad(se, e) {
  for (typeof se != "string" ? se = hexlify(se) : isHexString(se) || logger$3.throwArgumentError("invalid hex string", "value", se), se.length > 2 * e + 2 && logger$3.throwArgumentError("value out of range", "value", arguments[1]); se.length < 2 * e + 2; )
    se = "0x0" + se.substring(2);
  return se;
}
function splitSignature(se) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(se)) {
    let Oe = arrayify(se);
    Oe.length === 64 ? (e.v = 27 + (Oe[32] >> 7), Oe[32] &= 127, e.r = hexlify(Oe.slice(0, 32)), e.s = hexlify(Oe.slice(32, 64))) : Oe.length === 65 ? (e.r = hexlify(Oe.slice(0, 32)), e.s = hexlify(Oe.slice(32, 64)), e.v = Oe[64]) : logger$3.throwArgumentError("invalid signature string", "signature", se), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : logger$3.throwArgumentError("signature invalid v byte", "signature", se)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (Oe[32] |= 128), e._vs = hexlify(Oe.slice(32, 64));
  } else {
    if (e.r = se.r, e.s = se.s, e.v = se.v, e.recoveryParam = se.recoveryParam, e._vs = se._vs, e._vs != null) {
      const wi = zeroPad(arrayify(e._vs), 32);
      e._vs = hexlify(wi);
      const Ei = wi[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = Ei : e.recoveryParam !== Ei && logger$3.throwArgumentError("signature recoveryParam mismatch _vs", "signature", se), wi[0] &= 127;
      const $i = hexlify(wi);
      e.s == null ? e.s = $i : e.s !== $i && logger$3.throwArgumentError("signature v mismatch _vs", "signature", se);
    }
    if (e.recoveryParam == null)
      e.v == null ? logger$3.throwArgumentError("signature missing v and recoveryParam", "signature", se) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const wi = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== wi && logger$3.throwArgumentError("signature recoveryParam mismatch v", "signature", se);
    }
    e.r == null || !isHexString(e.r) ? logger$3.throwArgumentError("signature missing or invalid r", "signature", se) : e.r = hexZeroPad(e.r, 32), e.s == null || !isHexString(e.s) ? logger$3.throwArgumentError("signature missing or invalid s", "signature", se) : e.s = hexZeroPad(e.s, 32);
    const Oe = arrayify(e.s);
    Oe[0] >= 128 && logger$3.throwArgumentError("signature s out of range", "signature", se), e.recoveryParam && (Oe[0] |= 128);
    const Si = hexlify(Oe);
    e._vs && (isHexString(e._vs) || logger$3.throwArgumentError("signature invalid _vs", "signature", se), e._vs = hexZeroPad(e._vs, 32)), e._vs == null ? e._vs = Si : e._vs !== Si && logger$3.throwArgumentError("signature _vs mismatch v and s", "signature", se);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function keccak256(se) {
  return "0x" + sha3.keccak_256(arrayify(se));
}
var bn$4 = { exports: {} };
bn$4.exports;
(function(se) {
  (function(e, Oe) {
    function Si(Li, Ai) {
      if (!Li)
        throw new Error(Ai || "Assertion failed");
    }
    function wi(Li, Ai) {
      Li.super_ = Ai;
      var Ni = function() {
      };
      Ni.prototype = Ai.prototype, Li.prototype = new Ni(), Li.prototype.constructor = Li;
    }
    function Ei(Li, Ai, Ni) {
      if (Ei.isBN(Li))
        return Li;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Li !== null && ((Ai === "le" || Ai === "be") && (Ni = Ai, Ai = 10), this._init(Li || 0, Ai || 10, Ni || "be"));
    }
    typeof e == "object" ? e.exports = Ei : Oe.BN = Ei, Ei.BN = Ei, Ei.wordSize = 26;
    var $i;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? $i = window.Buffer : $i = require("buffer").Buffer;
    } catch {
    }
    Ei.isBN = function(Ai) {
      return Ai instanceof Ei ? !0 : Ai !== null && typeof Ai == "object" && Ai.constructor.wordSize === Ei.wordSize && Array.isArray(Ai.words);
    }, Ei.max = function(Ai, Ni) {
      return Ai.cmp(Ni) > 0 ? Ai : Ni;
    }, Ei.min = function(Ai, Ni) {
      return Ai.cmp(Ni) < 0 ? Ai : Ni;
    }, Ei.prototype._init = function(Ai, Ni, Ui) {
      if (typeof Ai == "number")
        return this._initNumber(Ai, Ni, Ui);
      if (typeof Ai == "object")
        return this._initArray(Ai, Ni, Ui);
      Ni === "hex" && (Ni = 16), Si(Ni === (Ni | 0) && Ni >= 2 && Ni <= 36), Ai = Ai.toString().replace(/\s+/g, "");
      var So = 0;
      Ai[0] === "-" && (So++, this.negative = 1), So < Ai.length && (Ni === 16 ? this._parseHex(Ai, So, Ui) : (this._parseBase(Ai, Ni, So), Ui === "le" && this._initArray(this.toArray(), Ni, Ui)));
    }, Ei.prototype._initNumber = function(Ai, Ni, Ui) {
      Ai < 0 && (this.negative = 1, Ai = -Ai), Ai < 67108864 ? (this.words = [Ai & 67108863], this.length = 1) : Ai < 4503599627370496 ? (this.words = [
        Ai & 67108863,
        Ai / 67108864 & 67108863
      ], this.length = 2) : (Si(Ai < 9007199254740992), this.words = [
        Ai & 67108863,
        Ai / 67108864 & 67108863,
        1
      ], this.length = 3), Ui === "le" && this._initArray(this.toArray(), Ni, Ui);
    }, Ei.prototype._initArray = function(Ai, Ni, Ui) {
      if (Si(typeof Ai.length == "number"), Ai.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Ai.length / 3), this.words = new Array(this.length);
      for (var So = 0; So < this.length; So++)
        this.words[So] = 0;
      var $o, Eo, zi = 0;
      if (Ui === "be")
        for (So = Ai.length - 1, $o = 0; So >= 0; So -= 3)
          Eo = Ai[So] | Ai[So - 1] << 8 | Ai[So - 2] << 16, this.words[$o] |= Eo << zi & 67108863, this.words[$o + 1] = Eo >>> 26 - zi & 67108863, zi += 24, zi >= 26 && (zi -= 26, $o++);
      else if (Ui === "le")
        for (So = 0, $o = 0; So < Ai.length; So += 3)
          Eo = Ai[So] | Ai[So + 1] << 8 | Ai[So + 2] << 16, this.words[$o] |= Eo << zi & 67108863, this.words[$o + 1] = Eo >>> 26 - zi & 67108863, zi += 24, zi >= 26 && (zi -= 26, $o++);
      return this._strip();
    };
    function xi(Li, Ai) {
      var Ni = Li.charCodeAt(Ai);
      if (Ni >= 48 && Ni <= 57)
        return Ni - 48;
      if (Ni >= 65 && Ni <= 70)
        return Ni - 55;
      if (Ni >= 97 && Ni <= 102)
        return Ni - 87;
      Si(!1, "Invalid character in " + Li);
    }
    function Ri(Li, Ai, Ni) {
      var Ui = xi(Li, Ni);
      return Ni - 1 >= Ai && (Ui |= xi(Li, Ni - 1) << 4), Ui;
    }
    Ei.prototype._parseHex = function(Ai, Ni, Ui) {
      this.length = Math.ceil((Ai.length - Ni) / 6), this.words = new Array(this.length);
      for (var So = 0; So < this.length; So++)
        this.words[So] = 0;
      var $o = 0, Eo = 0, zi;
      if (Ui === "be")
        for (So = Ai.length - 1; So >= Ni; So -= 2)
          zi = Ri(Ai, Ni, So) << $o, this.words[Eo] |= zi & 67108863, $o >= 18 ? ($o -= 18, Eo += 1, this.words[Eo] |= zi >>> 26) : $o += 8;
      else {
        var _o = Ai.length - Ni;
        for (So = _o % 2 === 0 ? Ni + 1 : Ni; So < Ai.length; So += 2)
          zi = Ri(Ai, Ni, So) << $o, this.words[Eo] |= zi & 67108863, $o >= 18 ? ($o -= 18, Eo += 1, this.words[Eo] |= zi >>> 26) : $o += 8;
      }
      this._strip();
    };
    function Ti(Li, Ai, Ni, Ui) {
      for (var So = 0, $o = 0, Eo = Math.min(Li.length, Ni), zi = Ai; zi < Eo; zi++) {
        var _o = Li.charCodeAt(zi) - 48;
        So *= Ui, _o >= 49 ? $o = _o - 49 + 10 : _o >= 17 ? $o = _o - 17 + 10 : $o = _o, Si(_o >= 0 && $o < Ui, "Invalid character"), So += $o;
      }
      return So;
    }
    Ei.prototype._parseBase = function(Ai, Ni, Ui) {
      this.words = [0], this.length = 1;
      for (var So = 0, $o = 1; $o <= 67108863; $o *= Ni)
        So++;
      So--, $o = $o / Ni | 0;
      for (var Eo = Ai.length - Ui, zi = Eo % So, _o = Math.min(Eo, Eo - zi) + Ui, Fi = 0, xo = Ui; xo < _o; xo += So)
        Fi = Ti(Ai, xo, xo + So, Ni), this.imuln($o), this.words[0] + Fi < 67108864 ? this.words[0] += Fi : this._iaddn(Fi);
      if (zi !== 0) {
        var Qo = 1;
        for (Fi = Ti(Ai, xo, Ai.length, Ni), xo = 0; xo < zi; xo++)
          Qo *= Ni;
        this.imuln(Qo), this.words[0] + Fi < 67108864 ? this.words[0] += Fi : this._iaddn(Fi);
      }
      this._strip();
    }, Ei.prototype.copy = function(Ai) {
      Ai.words = new Array(this.length);
      for (var Ni = 0; Ni < this.length; Ni++)
        Ai.words[Ni] = this.words[Ni];
      Ai.length = this.length, Ai.negative = this.negative, Ai.red = this.red;
    };
    function Oi(Li, Ai) {
      Li.words = Ai.words, Li.length = Ai.length, Li.negative = Ai.negative, Li.red = Ai.red;
    }
    if (Ei.prototype._move = function(Ai) {
      Oi(Ai, this);
    }, Ei.prototype.clone = function() {
      var Ai = new Ei(null);
      return this.copy(Ai), Ai;
    }, Ei.prototype._expand = function(Ai) {
      for (; this.length < Ai; )
        this.words[this.length++] = 0;
      return this;
    }, Ei.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Ei.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Ei.prototype[Symbol.for("nodejs.util.inspect.custom")] = Mi;
      } catch {
        Ei.prototype.inspect = Mi;
      }
    else
      Ei.prototype.inspect = Mi;
    function Mi() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Ii = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ci = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Oo = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Ei.prototype.toString = function(Ai, Ni) {
      Ai = Ai || 10, Ni = Ni | 0 || 1;
      var Ui;
      if (Ai === 16 || Ai === "hex") {
        Ui = "";
        for (var So = 0, $o = 0, Eo = 0; Eo < this.length; Eo++) {
          var zi = this.words[Eo], _o = ((zi << So | $o) & 16777215).toString(16);
          $o = zi >>> 24 - So & 16777215, So += 2, So >= 26 && (So -= 26, Eo--), $o !== 0 || Eo !== this.length - 1 ? Ui = Ii[6 - _o.length] + _o + Ui : Ui = _o + Ui;
        }
        for ($o !== 0 && (Ui = $o.toString(16) + Ui); Ui.length % Ni !== 0; )
          Ui = "0" + Ui;
        return this.negative !== 0 && (Ui = "-" + Ui), Ui;
      }
      if (Ai === (Ai | 0) && Ai >= 2 && Ai <= 36) {
        var Fi = Ci[Ai], xo = Oo[Ai];
        Ui = "";
        var Qo = this.clone();
        for (Qo.negative = 0; !Qo.isZero(); ) {
          var To = Qo.modrn(xo).toString(Ai);
          Qo = Qo.idivn(xo), Qo.isZero() ? Ui = To + Ui : Ui = Ii[Fi - To.length] + To + Ui;
        }
        for (this.isZero() && (Ui = "0" + Ui); Ui.length % Ni !== 0; )
          Ui = "0" + Ui;
        return this.negative !== 0 && (Ui = "-" + Ui), Ui;
      }
      Si(!1, "Base should be between 2 and 36");
    }, Ei.prototype.toNumber = function() {
      var Ai = this.words[0];
      return this.length === 2 ? Ai += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Ai += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Si(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Ai : Ai;
    }, Ei.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, $i && (Ei.prototype.toBuffer = function(Ai, Ni) {
      return this.toArrayLike($i, Ai, Ni);
    }), Ei.prototype.toArray = function(Ai, Ni) {
      return this.toArrayLike(Array, Ai, Ni);
    };
    var Ro = function(Ai, Ni) {
      return Ai.allocUnsafe ? Ai.allocUnsafe(Ni) : new Ai(Ni);
    };
    Ei.prototype.toArrayLike = function(Ai, Ni, Ui) {
      this._strip();
      var So = this.byteLength(), $o = Ui || Math.max(1, So);
      Si(So <= $o, "byte array longer than desired length"), Si($o > 0, "Requested array length <= 0");
      var Eo = Ro(Ai, $o), zi = Ni === "le" ? "LE" : "BE";
      return this["_toArrayLike" + zi](Eo, So), Eo;
    }, Ei.prototype._toArrayLikeLE = function(Ai, Ni) {
      for (var Ui = 0, So = 0, $o = 0, Eo = 0; $o < this.length; $o++) {
        var zi = this.words[$o] << Eo | So;
        Ai[Ui++] = zi & 255, Ui < Ai.length && (Ai[Ui++] = zi >> 8 & 255), Ui < Ai.length && (Ai[Ui++] = zi >> 16 & 255), Eo === 6 ? (Ui < Ai.length && (Ai[Ui++] = zi >> 24 & 255), So = 0, Eo = 0) : (So = zi >>> 24, Eo += 2);
      }
      if (Ui < Ai.length)
        for (Ai[Ui++] = So; Ui < Ai.length; )
          Ai[Ui++] = 0;
    }, Ei.prototype._toArrayLikeBE = function(Ai, Ni) {
      for (var Ui = Ai.length - 1, So = 0, $o = 0, Eo = 0; $o < this.length; $o++) {
        var zi = this.words[$o] << Eo | So;
        Ai[Ui--] = zi & 255, Ui >= 0 && (Ai[Ui--] = zi >> 8 & 255), Ui >= 0 && (Ai[Ui--] = zi >> 16 & 255), Eo === 6 ? (Ui >= 0 && (Ai[Ui--] = zi >> 24 & 255), So = 0, Eo = 0) : (So = zi >>> 24, Eo += 2);
      }
      if (Ui >= 0)
        for (Ai[Ui--] = So; Ui >= 0; )
          Ai[Ui--] = 0;
    }, Math.clz32 ? Ei.prototype._countBits = function(Ai) {
      return 32 - Math.clz32(Ai);
    } : Ei.prototype._countBits = function(Ai) {
      var Ni = Ai, Ui = 0;
      return Ni >= 4096 && (Ui += 13, Ni >>>= 13), Ni >= 64 && (Ui += 7, Ni >>>= 7), Ni >= 8 && (Ui += 4, Ni >>>= 4), Ni >= 2 && (Ui += 2, Ni >>>= 2), Ui + Ni;
    }, Ei.prototype._zeroBits = function(Ai) {
      if (Ai === 0)
        return 26;
      var Ni = Ai, Ui = 0;
      return Ni & 8191 || (Ui += 13, Ni >>>= 13), Ni & 127 || (Ui += 7, Ni >>>= 7), Ni & 15 || (Ui += 4, Ni >>>= 4), Ni & 3 || (Ui += 2, Ni >>>= 2), Ni & 1 || Ui++, Ui;
    }, Ei.prototype.bitLength = function() {
      var Ai = this.words[this.length - 1], Ni = this._countBits(Ai);
      return (this.length - 1) * 26 + Ni;
    };
    function Bo(Li) {
      for (var Ai = new Array(Li.bitLength()), Ni = 0; Ni < Ai.length; Ni++) {
        var Ui = Ni / 26 | 0, So = Ni % 26;
        Ai[Ni] = Li.words[Ui] >>> So & 1;
      }
      return Ai;
    }
    Ei.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var Ai = 0, Ni = 0; Ni < this.length; Ni++) {
        var Ui = this._zeroBits(this.words[Ni]);
        if (Ai += Ui, Ui !== 26)
          break;
      }
      return Ai;
    }, Ei.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ei.prototype.toTwos = function(Ai) {
      return this.negative !== 0 ? this.abs().inotn(Ai).iaddn(1) : this.clone();
    }, Ei.prototype.fromTwos = function(Ai) {
      return this.testn(Ai - 1) ? this.notn(Ai).iaddn(1).ineg() : this.clone();
    }, Ei.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Ei.prototype.neg = function() {
      return this.clone().ineg();
    }, Ei.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Ei.prototype.iuor = function(Ai) {
      for (; this.length < Ai.length; )
        this.words[this.length++] = 0;
      for (var Ni = 0; Ni < Ai.length; Ni++)
        this.words[Ni] = this.words[Ni] | Ai.words[Ni];
      return this._strip();
    }, Ei.prototype.ior = function(Ai) {
      return Si((this.negative | Ai.negative) === 0), this.iuor(Ai);
    }, Ei.prototype.or = function(Ai) {
      return this.length > Ai.length ? this.clone().ior(Ai) : Ai.clone().ior(this);
    }, Ei.prototype.uor = function(Ai) {
      return this.length > Ai.length ? this.clone().iuor(Ai) : Ai.clone().iuor(this);
    }, Ei.prototype.iuand = function(Ai) {
      var Ni;
      this.length > Ai.length ? Ni = Ai : Ni = this;
      for (var Ui = 0; Ui < Ni.length; Ui++)
        this.words[Ui] = this.words[Ui] & Ai.words[Ui];
      return this.length = Ni.length, this._strip();
    }, Ei.prototype.iand = function(Ai) {
      return Si((this.negative | Ai.negative) === 0), this.iuand(Ai);
    }, Ei.prototype.and = function(Ai) {
      return this.length > Ai.length ? this.clone().iand(Ai) : Ai.clone().iand(this);
    }, Ei.prototype.uand = function(Ai) {
      return this.length > Ai.length ? this.clone().iuand(Ai) : Ai.clone().iuand(this);
    }, Ei.prototype.iuxor = function(Ai) {
      var Ni, Ui;
      this.length > Ai.length ? (Ni = this, Ui = Ai) : (Ni = Ai, Ui = this);
      for (var So = 0; So < Ui.length; So++)
        this.words[So] = Ni.words[So] ^ Ui.words[So];
      if (this !== Ni)
        for (; So < Ni.length; So++)
          this.words[So] = Ni.words[So];
      return this.length = Ni.length, this._strip();
    }, Ei.prototype.ixor = function(Ai) {
      return Si((this.negative | Ai.negative) === 0), this.iuxor(Ai);
    }, Ei.prototype.xor = function(Ai) {
      return this.length > Ai.length ? this.clone().ixor(Ai) : Ai.clone().ixor(this);
    }, Ei.prototype.uxor = function(Ai) {
      return this.length > Ai.length ? this.clone().iuxor(Ai) : Ai.clone().iuxor(this);
    }, Ei.prototype.inotn = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Math.ceil(Ai / 26) | 0, Ui = Ai % 26;
      this._expand(Ni), Ui > 0 && Ni--;
      for (var So = 0; So < Ni; So++)
        this.words[So] = ~this.words[So] & 67108863;
      return Ui > 0 && (this.words[So] = ~this.words[So] & 67108863 >> 26 - Ui), this._strip();
    }, Ei.prototype.notn = function(Ai) {
      return this.clone().inotn(Ai);
    }, Ei.prototype.setn = function(Ai, Ni) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ui = Ai / 26 | 0, So = Ai % 26;
      return this._expand(Ui + 1), Ni ? this.words[Ui] = this.words[Ui] | 1 << So : this.words[Ui] = this.words[Ui] & ~(1 << So), this._strip();
    }, Ei.prototype.iadd = function(Ai) {
      var Ni;
      if (this.negative !== 0 && Ai.negative === 0)
        return this.negative = 0, Ni = this.isub(Ai), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Ai.negative !== 0)
        return Ai.negative = 0, Ni = this.isub(Ai), Ai.negative = 1, Ni._normSign();
      var Ui, So;
      this.length > Ai.length ? (Ui = this, So = Ai) : (Ui = Ai, So = this);
      for (var $o = 0, Eo = 0; Eo < So.length; Eo++)
        Ni = (Ui.words[Eo] | 0) + (So.words[Eo] | 0) + $o, this.words[Eo] = Ni & 67108863, $o = Ni >>> 26;
      for (; $o !== 0 && Eo < Ui.length; Eo++)
        Ni = (Ui.words[Eo] | 0) + $o, this.words[Eo] = Ni & 67108863, $o = Ni >>> 26;
      if (this.length = Ui.length, $o !== 0)
        this.words[this.length] = $o, this.length++;
      else if (Ui !== this)
        for (; Eo < Ui.length; Eo++)
          this.words[Eo] = Ui.words[Eo];
      return this;
    }, Ei.prototype.add = function(Ai) {
      var Ni;
      return Ai.negative !== 0 && this.negative === 0 ? (Ai.negative = 0, Ni = this.sub(Ai), Ai.negative ^= 1, Ni) : Ai.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ni = Ai.sub(this), this.negative = 1, Ni) : this.length > Ai.length ? this.clone().iadd(Ai) : Ai.clone().iadd(this);
    }, Ei.prototype.isub = function(Ai) {
      if (Ai.negative !== 0) {
        Ai.negative = 0;
        var Ni = this.iadd(Ai);
        return Ai.negative = 1, Ni._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Ai), this.negative = 1, this._normSign();
      var Ui = this.cmp(Ai);
      if (Ui === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var So, $o;
      Ui > 0 ? (So = this, $o = Ai) : (So = Ai, $o = this);
      for (var Eo = 0, zi = 0; zi < $o.length; zi++)
        Ni = (So.words[zi] | 0) - ($o.words[zi] | 0) + Eo, Eo = Ni >> 26, this.words[zi] = Ni & 67108863;
      for (; Eo !== 0 && zi < So.length; zi++)
        Ni = (So.words[zi] | 0) + Eo, Eo = Ni >> 26, this.words[zi] = Ni & 67108863;
      if (Eo === 0 && zi < So.length && So !== this)
        for (; zi < So.length; zi++)
          this.words[zi] = So.words[zi];
      return this.length = Math.max(this.length, zi), So !== this && (this.negative = 1), this._strip();
    }, Ei.prototype.sub = function(Ai) {
      return this.clone().isub(Ai);
    };
    function Fo(Li, Ai, Ni) {
      Ni.negative = Ai.negative ^ Li.negative;
      var Ui = Li.length + Ai.length | 0;
      Ni.length = Ui, Ui = Ui - 1 | 0;
      var So = Li.words[0] | 0, $o = Ai.words[0] | 0, Eo = So * $o, zi = Eo & 67108863, _o = Eo / 67108864 | 0;
      Ni.words[0] = zi;
      for (var Fi = 1; Fi < Ui; Fi++) {
        for (var xo = _o >>> 26, Qo = _o & 67108863, To = Math.min(Fi, Ai.length - 1), Ko = Math.max(0, Fi - Li.length + 1); Ko <= To; Ko++) {
          var Vo = Fi - Ko | 0;
          So = Li.words[Vo] | 0, $o = Ai.words[Ko] | 0, Eo = So * $o + Qo, xo += Eo / 67108864 | 0, Qo = Eo & 67108863;
        }
        Ni.words[Fi] = Qo | 0, _o = xo | 0;
      }
      return _o !== 0 ? Ni.words[Fi] = _o | 0 : Ni.length--, Ni._strip();
    }
    var Io = function(Ai, Ni, Ui) {
      var So = Ai.words, $o = Ni.words, Eo = Ui.words, zi = 0, _o, Fi, xo, Qo = So[0] | 0, To = Qo & 8191, Ko = Qo >>> 13, Vo = So[1] | 0, Wo = Vo & 8191, jo = Vo >>> 13, Ao = So[2] | 0, Lo = Ao & 8191, Zo = Ao >>> 13, An = So[3] | 0, ra = An & 8191, sa = An >>> 13, Ma = So[4] | 0, ba = Ma & 8191, ma = Ma >>> 13, Va = So[5] | 0, wa = Va & 8191, ha = Va >>> 13, Fa = So[6] | 0, Sa = Fa & 8191, da = Fa >>> 13, Pa = So[7] | 0, va = Pa & 8191, ca = Pa >>> 13, Na = So[8] | 0, Ea = Na & 8191, fa = Na >>> 13, Ca = So[9] | 0, Oa = Ca & 8191, ya = Ca >>> 13, Ua = $o[0] | 0, xa = Ua & 8191, Ra = Ua >>> 13, Ha = $o[1] | 0, ka = Ha & 8191, Aa = Ha >>> 13, Ga = $o[2] | 0, Wa = Ga & 8191, $a = Ga >>> 13, qa = $o[3] | 0, Ia = qa & 8191, Ho = qa >>> 13, qo = $o[4] | 0, Go = qo & 8191, Xo = qo >>> 13, ea = $o[5] | 0, ia = ea & 8191, oa = ea >>> 13, aa = $o[6] | 0, ua = aa & 8191, na = aa >>> 13, _a = $o[7] | 0, pa = _a & 8191, la = _a >>> 13, Ba = $o[8] | 0, Da = Ba & 8191, Ta = Ba >>> 13, Ja = $o[9] | 0, ja = Ja & 8191, za = Ja >>> 13;
      Ui.negative = Ai.negative ^ Ni.negative, Ui.length = 19, _o = Math.imul(To, xa), Fi = Math.imul(To, Ra), Fi = Fi + Math.imul(Ko, xa) | 0, xo = Math.imul(Ko, Ra);
      var Qa = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Qa >>> 26) | 0, Qa &= 67108863, _o = Math.imul(Wo, xa), Fi = Math.imul(Wo, Ra), Fi = Fi + Math.imul(jo, xa) | 0, xo = Math.imul(jo, Ra), _o = _o + Math.imul(To, ka) | 0, Fi = Fi + Math.imul(To, Aa) | 0, Fi = Fi + Math.imul(Ko, ka) | 0, xo = xo + Math.imul(Ko, Aa) | 0;
      var tl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (tl >>> 26) | 0, tl &= 67108863, _o = Math.imul(Lo, xa), Fi = Math.imul(Lo, Ra), Fi = Fi + Math.imul(Zo, xa) | 0, xo = Math.imul(Zo, Ra), _o = _o + Math.imul(Wo, ka) | 0, Fi = Fi + Math.imul(Wo, Aa) | 0, Fi = Fi + Math.imul(jo, ka) | 0, xo = xo + Math.imul(jo, Aa) | 0, _o = _o + Math.imul(To, Wa) | 0, Fi = Fi + Math.imul(To, $a) | 0, Fi = Fi + Math.imul(Ko, Wa) | 0, xo = xo + Math.imul(Ko, $a) | 0;
      var Xa = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, _o = Math.imul(ra, xa), Fi = Math.imul(ra, Ra), Fi = Fi + Math.imul(sa, xa) | 0, xo = Math.imul(sa, Ra), _o = _o + Math.imul(Lo, ka) | 0, Fi = Fi + Math.imul(Lo, Aa) | 0, Fi = Fi + Math.imul(Zo, ka) | 0, xo = xo + Math.imul(Zo, Aa) | 0, _o = _o + Math.imul(Wo, Wa) | 0, Fi = Fi + Math.imul(Wo, $a) | 0, Fi = Fi + Math.imul(jo, Wa) | 0, xo = xo + Math.imul(jo, $a) | 0, _o = _o + Math.imul(To, Ia) | 0, Fi = Fi + Math.imul(To, Ho) | 0, Fi = Fi + Math.imul(Ko, Ia) | 0, xo = xo + Math.imul(Ko, Ho) | 0;
      var ol = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (ol >>> 26) | 0, ol &= 67108863, _o = Math.imul(ba, xa), Fi = Math.imul(ba, Ra), Fi = Fi + Math.imul(ma, xa) | 0, xo = Math.imul(ma, Ra), _o = _o + Math.imul(ra, ka) | 0, Fi = Fi + Math.imul(ra, Aa) | 0, Fi = Fi + Math.imul(sa, ka) | 0, xo = xo + Math.imul(sa, Aa) | 0, _o = _o + Math.imul(Lo, Wa) | 0, Fi = Fi + Math.imul(Lo, $a) | 0, Fi = Fi + Math.imul(Zo, Wa) | 0, xo = xo + Math.imul(Zo, $a) | 0, _o = _o + Math.imul(Wo, Ia) | 0, Fi = Fi + Math.imul(Wo, Ho) | 0, Fi = Fi + Math.imul(jo, Ia) | 0, xo = xo + Math.imul(jo, Ho) | 0, _o = _o + Math.imul(To, Go) | 0, Fi = Fi + Math.imul(To, Xo) | 0, Fi = Fi + Math.imul(Ko, Go) | 0, xo = xo + Math.imul(Ko, Xo) | 0;
      var Za = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, _o = Math.imul(wa, xa), Fi = Math.imul(wa, Ra), Fi = Fi + Math.imul(ha, xa) | 0, xo = Math.imul(ha, Ra), _o = _o + Math.imul(ba, ka) | 0, Fi = Fi + Math.imul(ba, Aa) | 0, Fi = Fi + Math.imul(ma, ka) | 0, xo = xo + Math.imul(ma, Aa) | 0, _o = _o + Math.imul(ra, Wa) | 0, Fi = Fi + Math.imul(ra, $a) | 0, Fi = Fi + Math.imul(sa, Wa) | 0, xo = xo + Math.imul(sa, $a) | 0, _o = _o + Math.imul(Lo, Ia) | 0, Fi = Fi + Math.imul(Lo, Ho) | 0, Fi = Fi + Math.imul(Zo, Ia) | 0, xo = xo + Math.imul(Zo, Ho) | 0, _o = _o + Math.imul(Wo, Go) | 0, Fi = Fi + Math.imul(Wo, Xo) | 0, Fi = Fi + Math.imul(jo, Go) | 0, xo = xo + Math.imul(jo, Xo) | 0, _o = _o + Math.imul(To, ia) | 0, Fi = Fi + Math.imul(To, oa) | 0, Fi = Fi + Math.imul(Ko, ia) | 0, xo = xo + Math.imul(Ko, oa) | 0;
      var ul = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (ul >>> 26) | 0, ul &= 67108863, _o = Math.imul(Sa, xa), Fi = Math.imul(Sa, Ra), Fi = Fi + Math.imul(da, xa) | 0, xo = Math.imul(da, Ra), _o = _o + Math.imul(wa, ka) | 0, Fi = Fi + Math.imul(wa, Aa) | 0, Fi = Fi + Math.imul(ha, ka) | 0, xo = xo + Math.imul(ha, Aa) | 0, _o = _o + Math.imul(ba, Wa) | 0, Fi = Fi + Math.imul(ba, $a) | 0, Fi = Fi + Math.imul(ma, Wa) | 0, xo = xo + Math.imul(ma, $a) | 0, _o = _o + Math.imul(ra, Ia) | 0, Fi = Fi + Math.imul(ra, Ho) | 0, Fi = Fi + Math.imul(sa, Ia) | 0, xo = xo + Math.imul(sa, Ho) | 0, _o = _o + Math.imul(Lo, Go) | 0, Fi = Fi + Math.imul(Lo, Xo) | 0, Fi = Fi + Math.imul(Zo, Go) | 0, xo = xo + Math.imul(Zo, Xo) | 0, _o = _o + Math.imul(Wo, ia) | 0, Fi = Fi + Math.imul(Wo, oa) | 0, Fi = Fi + Math.imul(jo, ia) | 0, xo = xo + Math.imul(jo, oa) | 0, _o = _o + Math.imul(To, ua) | 0, Fi = Fi + Math.imul(To, na) | 0, Fi = Fi + Math.imul(Ko, ua) | 0, xo = xo + Math.imul(Ko, na) | 0;
      var cl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (cl >>> 26) | 0, cl &= 67108863, _o = Math.imul(va, xa), Fi = Math.imul(va, Ra), Fi = Fi + Math.imul(ca, xa) | 0, xo = Math.imul(ca, Ra), _o = _o + Math.imul(Sa, ka) | 0, Fi = Fi + Math.imul(Sa, Aa) | 0, Fi = Fi + Math.imul(da, ka) | 0, xo = xo + Math.imul(da, Aa) | 0, _o = _o + Math.imul(wa, Wa) | 0, Fi = Fi + Math.imul(wa, $a) | 0, Fi = Fi + Math.imul(ha, Wa) | 0, xo = xo + Math.imul(ha, $a) | 0, _o = _o + Math.imul(ba, Ia) | 0, Fi = Fi + Math.imul(ba, Ho) | 0, Fi = Fi + Math.imul(ma, Ia) | 0, xo = xo + Math.imul(ma, Ho) | 0, _o = _o + Math.imul(ra, Go) | 0, Fi = Fi + Math.imul(ra, Xo) | 0, Fi = Fi + Math.imul(sa, Go) | 0, xo = xo + Math.imul(sa, Xo) | 0, _o = _o + Math.imul(Lo, ia) | 0, Fi = Fi + Math.imul(Lo, oa) | 0, Fi = Fi + Math.imul(Zo, ia) | 0, xo = xo + Math.imul(Zo, oa) | 0, _o = _o + Math.imul(Wo, ua) | 0, Fi = Fi + Math.imul(Wo, na) | 0, Fi = Fi + Math.imul(jo, ua) | 0, xo = xo + Math.imul(jo, na) | 0, _o = _o + Math.imul(To, pa) | 0, Fi = Fi + Math.imul(To, la) | 0, Fi = Fi + Math.imul(Ko, pa) | 0, xo = xo + Math.imul(Ko, la) | 0;
      var fl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (fl >>> 26) | 0, fl &= 67108863, _o = Math.imul(Ea, xa), Fi = Math.imul(Ea, Ra), Fi = Fi + Math.imul(fa, xa) | 0, xo = Math.imul(fa, Ra), _o = _o + Math.imul(va, ka) | 0, Fi = Fi + Math.imul(va, Aa) | 0, Fi = Fi + Math.imul(ca, ka) | 0, xo = xo + Math.imul(ca, Aa) | 0, _o = _o + Math.imul(Sa, Wa) | 0, Fi = Fi + Math.imul(Sa, $a) | 0, Fi = Fi + Math.imul(da, Wa) | 0, xo = xo + Math.imul(da, $a) | 0, _o = _o + Math.imul(wa, Ia) | 0, Fi = Fi + Math.imul(wa, Ho) | 0, Fi = Fi + Math.imul(ha, Ia) | 0, xo = xo + Math.imul(ha, Ho) | 0, _o = _o + Math.imul(ba, Go) | 0, Fi = Fi + Math.imul(ba, Xo) | 0, Fi = Fi + Math.imul(ma, Go) | 0, xo = xo + Math.imul(ma, Xo) | 0, _o = _o + Math.imul(ra, ia) | 0, Fi = Fi + Math.imul(ra, oa) | 0, Fi = Fi + Math.imul(sa, ia) | 0, xo = xo + Math.imul(sa, oa) | 0, _o = _o + Math.imul(Lo, ua) | 0, Fi = Fi + Math.imul(Lo, na) | 0, Fi = Fi + Math.imul(Zo, ua) | 0, xo = xo + Math.imul(Zo, na) | 0, _o = _o + Math.imul(Wo, pa) | 0, Fi = Fi + Math.imul(Wo, la) | 0, Fi = Fi + Math.imul(jo, pa) | 0, xo = xo + Math.imul(jo, la) | 0, _o = _o + Math.imul(To, Da) | 0, Fi = Fi + Math.imul(To, Ta) | 0, Fi = Fi + Math.imul(Ko, Da) | 0, xo = xo + Math.imul(Ko, Ta) | 0;
      var pl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (pl >>> 26) | 0, pl &= 67108863, _o = Math.imul(Oa, xa), Fi = Math.imul(Oa, Ra), Fi = Fi + Math.imul(ya, xa) | 0, xo = Math.imul(ya, Ra), _o = _o + Math.imul(Ea, ka) | 0, Fi = Fi + Math.imul(Ea, Aa) | 0, Fi = Fi + Math.imul(fa, ka) | 0, xo = xo + Math.imul(fa, Aa) | 0, _o = _o + Math.imul(va, Wa) | 0, Fi = Fi + Math.imul(va, $a) | 0, Fi = Fi + Math.imul(ca, Wa) | 0, xo = xo + Math.imul(ca, $a) | 0, _o = _o + Math.imul(Sa, Ia) | 0, Fi = Fi + Math.imul(Sa, Ho) | 0, Fi = Fi + Math.imul(da, Ia) | 0, xo = xo + Math.imul(da, Ho) | 0, _o = _o + Math.imul(wa, Go) | 0, Fi = Fi + Math.imul(wa, Xo) | 0, Fi = Fi + Math.imul(ha, Go) | 0, xo = xo + Math.imul(ha, Xo) | 0, _o = _o + Math.imul(ba, ia) | 0, Fi = Fi + Math.imul(ba, oa) | 0, Fi = Fi + Math.imul(ma, ia) | 0, xo = xo + Math.imul(ma, oa) | 0, _o = _o + Math.imul(ra, ua) | 0, Fi = Fi + Math.imul(ra, na) | 0, Fi = Fi + Math.imul(sa, ua) | 0, xo = xo + Math.imul(sa, na) | 0, _o = _o + Math.imul(Lo, pa) | 0, Fi = Fi + Math.imul(Lo, la) | 0, Fi = Fi + Math.imul(Zo, pa) | 0, xo = xo + Math.imul(Zo, la) | 0, _o = _o + Math.imul(Wo, Da) | 0, Fi = Fi + Math.imul(Wo, Ta) | 0, Fi = Fi + Math.imul(jo, Da) | 0, xo = xo + Math.imul(jo, Ta) | 0, _o = _o + Math.imul(To, ja) | 0, Fi = Fi + Math.imul(To, za) | 0, Fi = Fi + Math.imul(Ko, ja) | 0, xo = xo + Math.imul(Ko, za) | 0;
      var dl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (dl >>> 26) | 0, dl &= 67108863, _o = Math.imul(Oa, ka), Fi = Math.imul(Oa, Aa), Fi = Fi + Math.imul(ya, ka) | 0, xo = Math.imul(ya, Aa), _o = _o + Math.imul(Ea, Wa) | 0, Fi = Fi + Math.imul(Ea, $a) | 0, Fi = Fi + Math.imul(fa, Wa) | 0, xo = xo + Math.imul(fa, $a) | 0, _o = _o + Math.imul(va, Ia) | 0, Fi = Fi + Math.imul(va, Ho) | 0, Fi = Fi + Math.imul(ca, Ia) | 0, xo = xo + Math.imul(ca, Ho) | 0, _o = _o + Math.imul(Sa, Go) | 0, Fi = Fi + Math.imul(Sa, Xo) | 0, Fi = Fi + Math.imul(da, Go) | 0, xo = xo + Math.imul(da, Xo) | 0, _o = _o + Math.imul(wa, ia) | 0, Fi = Fi + Math.imul(wa, oa) | 0, Fi = Fi + Math.imul(ha, ia) | 0, xo = xo + Math.imul(ha, oa) | 0, _o = _o + Math.imul(ba, ua) | 0, Fi = Fi + Math.imul(ba, na) | 0, Fi = Fi + Math.imul(ma, ua) | 0, xo = xo + Math.imul(ma, na) | 0, _o = _o + Math.imul(ra, pa) | 0, Fi = Fi + Math.imul(ra, la) | 0, Fi = Fi + Math.imul(sa, pa) | 0, xo = xo + Math.imul(sa, la) | 0, _o = _o + Math.imul(Lo, Da) | 0, Fi = Fi + Math.imul(Lo, Ta) | 0, Fi = Fi + Math.imul(Zo, Da) | 0, xo = xo + Math.imul(Zo, Ta) | 0, _o = _o + Math.imul(Wo, ja) | 0, Fi = Fi + Math.imul(Wo, za) | 0, Fi = Fi + Math.imul(jo, ja) | 0, xo = xo + Math.imul(jo, za) | 0;
      var al = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (al >>> 26) | 0, al &= 67108863, _o = Math.imul(Oa, Wa), Fi = Math.imul(Oa, $a), Fi = Fi + Math.imul(ya, Wa) | 0, xo = Math.imul(ya, $a), _o = _o + Math.imul(Ea, Ia) | 0, Fi = Fi + Math.imul(Ea, Ho) | 0, Fi = Fi + Math.imul(fa, Ia) | 0, xo = xo + Math.imul(fa, Ho) | 0, _o = _o + Math.imul(va, Go) | 0, Fi = Fi + Math.imul(va, Xo) | 0, Fi = Fi + Math.imul(ca, Go) | 0, xo = xo + Math.imul(ca, Xo) | 0, _o = _o + Math.imul(Sa, ia) | 0, Fi = Fi + Math.imul(Sa, oa) | 0, Fi = Fi + Math.imul(da, ia) | 0, xo = xo + Math.imul(da, oa) | 0, _o = _o + Math.imul(wa, ua) | 0, Fi = Fi + Math.imul(wa, na) | 0, Fi = Fi + Math.imul(ha, ua) | 0, xo = xo + Math.imul(ha, na) | 0, _o = _o + Math.imul(ba, pa) | 0, Fi = Fi + Math.imul(ba, la) | 0, Fi = Fi + Math.imul(ma, pa) | 0, xo = xo + Math.imul(ma, la) | 0, _o = _o + Math.imul(ra, Da) | 0, Fi = Fi + Math.imul(ra, Ta) | 0, Fi = Fi + Math.imul(sa, Da) | 0, xo = xo + Math.imul(sa, Ta) | 0, _o = _o + Math.imul(Lo, ja) | 0, Fi = Fi + Math.imul(Lo, za) | 0, Fi = Fi + Math.imul(Zo, ja) | 0, xo = xo + Math.imul(Zo, za) | 0;
      var hl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (hl >>> 26) | 0, hl &= 67108863, _o = Math.imul(Oa, Ia), Fi = Math.imul(Oa, Ho), Fi = Fi + Math.imul(ya, Ia) | 0, xo = Math.imul(ya, Ho), _o = _o + Math.imul(Ea, Go) | 0, Fi = Fi + Math.imul(Ea, Xo) | 0, Fi = Fi + Math.imul(fa, Go) | 0, xo = xo + Math.imul(fa, Xo) | 0, _o = _o + Math.imul(va, ia) | 0, Fi = Fi + Math.imul(va, oa) | 0, Fi = Fi + Math.imul(ca, ia) | 0, xo = xo + Math.imul(ca, oa) | 0, _o = _o + Math.imul(Sa, ua) | 0, Fi = Fi + Math.imul(Sa, na) | 0, Fi = Fi + Math.imul(da, ua) | 0, xo = xo + Math.imul(da, na) | 0, _o = _o + Math.imul(wa, pa) | 0, Fi = Fi + Math.imul(wa, la) | 0, Fi = Fi + Math.imul(ha, pa) | 0, xo = xo + Math.imul(ha, la) | 0, _o = _o + Math.imul(ba, Da) | 0, Fi = Fi + Math.imul(ba, Ta) | 0, Fi = Fi + Math.imul(ma, Da) | 0, xo = xo + Math.imul(ma, Ta) | 0, _o = _o + Math.imul(ra, ja) | 0, Fi = Fi + Math.imul(ra, za) | 0, Fi = Fi + Math.imul(sa, ja) | 0, xo = xo + Math.imul(sa, za) | 0;
      var gl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (gl >>> 26) | 0, gl &= 67108863, _o = Math.imul(Oa, Go), Fi = Math.imul(Oa, Xo), Fi = Fi + Math.imul(ya, Go) | 0, xo = Math.imul(ya, Xo), _o = _o + Math.imul(Ea, ia) | 0, Fi = Fi + Math.imul(Ea, oa) | 0, Fi = Fi + Math.imul(fa, ia) | 0, xo = xo + Math.imul(fa, oa) | 0, _o = _o + Math.imul(va, ua) | 0, Fi = Fi + Math.imul(va, na) | 0, Fi = Fi + Math.imul(ca, ua) | 0, xo = xo + Math.imul(ca, na) | 0, _o = _o + Math.imul(Sa, pa) | 0, Fi = Fi + Math.imul(Sa, la) | 0, Fi = Fi + Math.imul(da, pa) | 0, xo = xo + Math.imul(da, la) | 0, _o = _o + Math.imul(wa, Da) | 0, Fi = Fi + Math.imul(wa, Ta) | 0, Fi = Fi + Math.imul(ha, Da) | 0, xo = xo + Math.imul(ha, Ta) | 0, _o = _o + Math.imul(ba, ja) | 0, Fi = Fi + Math.imul(ba, za) | 0, Fi = Fi + Math.imul(ma, ja) | 0, xo = xo + Math.imul(ma, za) | 0;
      var il = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (il >>> 26) | 0, il &= 67108863, _o = Math.imul(Oa, ia), Fi = Math.imul(Oa, oa), Fi = Fi + Math.imul(ya, ia) | 0, xo = Math.imul(ya, oa), _o = _o + Math.imul(Ea, ua) | 0, Fi = Fi + Math.imul(Ea, na) | 0, Fi = Fi + Math.imul(fa, ua) | 0, xo = xo + Math.imul(fa, na) | 0, _o = _o + Math.imul(va, pa) | 0, Fi = Fi + Math.imul(va, la) | 0, Fi = Fi + Math.imul(ca, pa) | 0, xo = xo + Math.imul(ca, la) | 0, _o = _o + Math.imul(Sa, Da) | 0, Fi = Fi + Math.imul(Sa, Ta) | 0, Fi = Fi + Math.imul(da, Da) | 0, xo = xo + Math.imul(da, Ta) | 0, _o = _o + Math.imul(wa, ja) | 0, Fi = Fi + Math.imul(wa, za) | 0, Fi = Fi + Math.imul(ha, ja) | 0, xo = xo + Math.imul(ha, za) | 0;
      var yl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (yl >>> 26) | 0, yl &= 67108863, _o = Math.imul(Oa, ua), Fi = Math.imul(Oa, na), Fi = Fi + Math.imul(ya, ua) | 0, xo = Math.imul(ya, na), _o = _o + Math.imul(Ea, pa) | 0, Fi = Fi + Math.imul(Ea, la) | 0, Fi = Fi + Math.imul(fa, pa) | 0, xo = xo + Math.imul(fa, la) | 0, _o = _o + Math.imul(va, Da) | 0, Fi = Fi + Math.imul(va, Ta) | 0, Fi = Fi + Math.imul(ca, Da) | 0, xo = xo + Math.imul(ca, Ta) | 0, _o = _o + Math.imul(Sa, ja) | 0, Fi = Fi + Math.imul(Sa, za) | 0, Fi = Fi + Math.imul(da, ja) | 0, xo = xo + Math.imul(da, za) | 0;
      var bl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (bl >>> 26) | 0, bl &= 67108863, _o = Math.imul(Oa, pa), Fi = Math.imul(Oa, la), Fi = Fi + Math.imul(ya, pa) | 0, xo = Math.imul(ya, la), _o = _o + Math.imul(Ea, Da) | 0, Fi = Fi + Math.imul(Ea, Ta) | 0, Fi = Fi + Math.imul(fa, Da) | 0, xo = xo + Math.imul(fa, Ta) | 0, _o = _o + Math.imul(va, ja) | 0, Fi = Fi + Math.imul(va, za) | 0, Fi = Fi + Math.imul(ca, ja) | 0, xo = xo + Math.imul(ca, za) | 0;
      var ml = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (ml >>> 26) | 0, ml &= 67108863, _o = Math.imul(Oa, Da), Fi = Math.imul(Oa, Ta), Fi = Fi + Math.imul(ya, Da) | 0, xo = Math.imul(ya, Ta), _o = _o + Math.imul(Ea, ja) | 0, Fi = Fi + Math.imul(Ea, za) | 0, Fi = Fi + Math.imul(fa, ja) | 0, xo = xo + Math.imul(fa, za) | 0;
      var Ol = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Ol >>> 26) | 0, Ol &= 67108863, _o = Math.imul(Oa, ja), Fi = Math.imul(Oa, za), Fi = Fi + Math.imul(ya, ja) | 0, xo = Math.imul(ya, za);
      var $l = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      return zi = (xo + (Fi >>> 13) | 0) + ($l >>> 26) | 0, $l &= 67108863, Eo[0] = Qa, Eo[1] = tl, Eo[2] = Xa, Eo[3] = ol, Eo[4] = Za, Eo[5] = ul, Eo[6] = cl, Eo[7] = fl, Eo[8] = pl, Eo[9] = dl, Eo[10] = al, Eo[11] = hl, Eo[12] = gl, Eo[13] = il, Eo[14] = yl, Eo[15] = bl, Eo[16] = ml, Eo[17] = Ol, Eo[18] = $l, zi !== 0 && (Eo[19] = zi, Ui.length++), Ui;
    };
    Math.imul || (Io = Fo);
    function Uo(Li, Ai, Ni) {
      Ni.negative = Ai.negative ^ Li.negative, Ni.length = Li.length + Ai.length;
      for (var Ui = 0, So = 0, $o = 0; $o < Ni.length - 1; $o++) {
        var Eo = So;
        So = 0;
        for (var zi = Ui & 67108863, _o = Math.min($o, Ai.length - 1), Fi = Math.max(0, $o - Li.length + 1); Fi <= _o; Fi++) {
          var xo = $o - Fi, Qo = Li.words[xo] | 0, To = Ai.words[Fi] | 0, Ko = Qo * To, Vo = Ko & 67108863;
          Eo = Eo + (Ko / 67108864 | 0) | 0, Vo = Vo + zi | 0, zi = Vo & 67108863, Eo = Eo + (Vo >>> 26) | 0, So += Eo >>> 26, Eo &= 67108863;
        }
        Ni.words[$o] = zi, Ui = Eo, Eo = So;
      }
      return Ui !== 0 ? Ni.words[$o] = Ui : Ni.length--, Ni._strip();
    }
    function Co(Li, Ai, Ni) {
      return Uo(Li, Ai, Ni);
    }
    Ei.prototype.mulTo = function(Ai, Ni) {
      var Ui, So = this.length + Ai.length;
      return this.length === 10 && Ai.length === 10 ? Ui = Io(this, Ai, Ni) : So < 63 ? Ui = Fo(this, Ai, Ni) : So < 1024 ? Ui = Uo(this, Ai, Ni) : Ui = Co(this, Ai, Ni), Ui;
    }, Ei.prototype.mul = function(Ai) {
      var Ni = new Ei(null);
      return Ni.words = new Array(this.length + Ai.length), this.mulTo(Ai, Ni);
    }, Ei.prototype.mulf = function(Ai) {
      var Ni = new Ei(null);
      return Ni.words = new Array(this.length + Ai.length), Co(this, Ai, Ni);
    }, Ei.prototype.imul = function(Ai) {
      return this.clone().mulTo(Ai, this);
    }, Ei.prototype.imuln = function(Ai) {
      var Ni = Ai < 0;
      Ni && (Ai = -Ai), Si(typeof Ai == "number"), Si(Ai < 67108864);
      for (var Ui = 0, So = 0; So < this.length; So++) {
        var $o = (this.words[So] | 0) * Ai, Eo = ($o & 67108863) + (Ui & 67108863);
        Ui >>= 26, Ui += $o / 67108864 | 0, Ui += Eo >>> 26, this.words[So] = Eo & 67108863;
      }
      return Ui !== 0 && (this.words[So] = Ui, this.length++), Ni ? this.ineg() : this;
    }, Ei.prototype.muln = function(Ai) {
      return this.clone().imuln(Ai);
    }, Ei.prototype.sqr = function() {
      return this.mul(this);
    }, Ei.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ei.prototype.pow = function(Ai) {
      var Ni = Bo(Ai);
      if (Ni.length === 0)
        return new Ei(1);
      for (var Ui = this, So = 0; So < Ni.length && Ni[So] === 0; So++, Ui = Ui.sqr())
        ;
      if (++So < Ni.length)
        for (var $o = Ui.sqr(); So < Ni.length; So++, $o = $o.sqr())
          Ni[So] !== 0 && (Ui = Ui.mul($o));
      return Ui;
    }, Ei.prototype.iushln = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26, So = 67108863 >>> 26 - Ni << 26 - Ni, $o;
      if (Ni !== 0) {
        var Eo = 0;
        for ($o = 0; $o < this.length; $o++) {
          var zi = this.words[$o] & So, _o = (this.words[$o] | 0) - zi << Ni;
          this.words[$o] = _o | Eo, Eo = zi >>> 26 - Ni;
        }
        Eo && (this.words[$o] = Eo, this.length++);
      }
      if (Ui !== 0) {
        for ($o = this.length - 1; $o >= 0; $o--)
          this.words[$o + Ui] = this.words[$o];
        for ($o = 0; $o < Ui; $o++)
          this.words[$o] = 0;
        this.length += Ui;
      }
      return this._strip();
    }, Ei.prototype.ishln = function(Ai) {
      return Si(this.negative === 0), this.iushln(Ai);
    }, Ei.prototype.iushrn = function(Ai, Ni, Ui) {
      Si(typeof Ai == "number" && Ai >= 0);
      var So;
      Ni ? So = (Ni - Ni % 26) / 26 : So = 0;
      var $o = Ai % 26, Eo = Math.min((Ai - $o) / 26, this.length), zi = 67108863 ^ 67108863 >>> $o << $o, _o = Ui;
      if (So -= Eo, So = Math.max(0, So), _o) {
        for (var Fi = 0; Fi < Eo; Fi++)
          _o.words[Fi] = this.words[Fi];
        _o.length = Eo;
      }
      if (Eo !== 0)
        if (this.length > Eo)
          for (this.length -= Eo, Fi = 0; Fi < this.length; Fi++)
            this.words[Fi] = this.words[Fi + Eo];
        else
          this.words[0] = 0, this.length = 1;
      var xo = 0;
      for (Fi = this.length - 1; Fi >= 0 && (xo !== 0 || Fi >= So); Fi--) {
        var Qo = this.words[Fi] | 0;
        this.words[Fi] = xo << 26 - $o | Qo >>> $o, xo = Qo & zi;
      }
      return _o && xo !== 0 && (_o.words[_o.length++] = xo), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, Ei.prototype.ishrn = function(Ai, Ni, Ui) {
      return Si(this.negative === 0), this.iushrn(Ai, Ni, Ui);
    }, Ei.prototype.shln = function(Ai) {
      return this.clone().ishln(Ai);
    }, Ei.prototype.ushln = function(Ai) {
      return this.clone().iushln(Ai);
    }, Ei.prototype.shrn = function(Ai) {
      return this.clone().ishrn(Ai);
    }, Ei.prototype.ushrn = function(Ai) {
      return this.clone().iushrn(Ai);
    }, Ei.prototype.testn = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26, So = 1 << Ni;
      if (this.length <= Ui)
        return !1;
      var $o = this.words[Ui];
      return !!($o & So);
    }, Ei.prototype.imaskn = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26;
      if (Si(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ui)
        return this;
      if (Ni !== 0 && Ui++, this.length = Math.min(Ui, this.length), Ni !== 0) {
        var So = 67108863 ^ 67108863 >>> Ni << Ni;
        this.words[this.length - 1] &= So;
      }
      return this._strip();
    }, Ei.prototype.maskn = function(Ai) {
      return this.clone().imaskn(Ai);
    }, Ei.prototype.iaddn = function(Ai) {
      return Si(typeof Ai == "number"), Si(Ai < 67108864), Ai < 0 ? this.isubn(-Ai) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= Ai ? (this.words[0] = Ai - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Ai), this.negative = 1, this) : this._iaddn(Ai);
    }, Ei.prototype._iaddn = function(Ai) {
      this.words[0] += Ai;
      for (var Ni = 0; Ni < this.length && this.words[Ni] >= 67108864; Ni++)
        this.words[Ni] -= 67108864, Ni === this.length - 1 ? this.words[Ni + 1] = 1 : this.words[Ni + 1]++;
      return this.length = Math.max(this.length, Ni + 1), this;
    }, Ei.prototype.isubn = function(Ai) {
      if (Si(typeof Ai == "number"), Si(Ai < 67108864), Ai < 0)
        return this.iaddn(-Ai);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Ai), this.negative = 1, this;
      if (this.words[0] -= Ai, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ni = 0; Ni < this.length && this.words[Ni] < 0; Ni++)
          this.words[Ni] += 67108864, this.words[Ni + 1] -= 1;
      return this._strip();
    }, Ei.prototype.addn = function(Ai) {
      return this.clone().iaddn(Ai);
    }, Ei.prototype.subn = function(Ai) {
      return this.clone().isubn(Ai);
    }, Ei.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Ei.prototype.abs = function() {
      return this.clone().iabs();
    }, Ei.prototype._ishlnsubmul = function(Ai, Ni, Ui) {
      var So = Ai.length + Ui, $o;
      this._expand(So);
      var Eo, zi = 0;
      for ($o = 0; $o < Ai.length; $o++) {
        Eo = (this.words[$o + Ui] | 0) + zi;
        var _o = (Ai.words[$o] | 0) * Ni;
        Eo -= _o & 67108863, zi = (Eo >> 26) - (_o / 67108864 | 0), this.words[$o + Ui] = Eo & 67108863;
      }
      for (; $o < this.length - Ui; $o++)
        Eo = (this.words[$o + Ui] | 0) + zi, zi = Eo >> 26, this.words[$o + Ui] = Eo & 67108863;
      if (zi === 0)
        return this._strip();
      for (Si(zi === -1), zi = 0, $o = 0; $o < this.length; $o++)
        Eo = -(this.words[$o] | 0) + zi, zi = Eo >> 26, this.words[$o] = Eo & 67108863;
      return this.negative = 1, this._strip();
    }, Ei.prototype._wordDiv = function(Ai, Ni) {
      var Ui = this.length - Ai.length, So = this.clone(), $o = Ai, Eo = $o.words[$o.length - 1] | 0, zi = this._countBits(Eo);
      Ui = 26 - zi, Ui !== 0 && ($o = $o.ushln(Ui), So.iushln(Ui), Eo = $o.words[$o.length - 1] | 0);
      var _o = So.length - $o.length, Fi;
      if (Ni !== "mod") {
        Fi = new Ei(null), Fi.length = _o + 1, Fi.words = new Array(Fi.length);
        for (var xo = 0; xo < Fi.length; xo++)
          Fi.words[xo] = 0;
      }
      var Qo = So.clone()._ishlnsubmul($o, 1, _o);
      Qo.negative === 0 && (So = Qo, Fi && (Fi.words[_o] = 1));
      for (var To = _o - 1; To >= 0; To--) {
        var Ko = (So.words[$o.length + To] | 0) * 67108864 + (So.words[$o.length + To - 1] | 0);
        for (Ko = Math.min(Ko / Eo | 0, 67108863), So._ishlnsubmul($o, Ko, To); So.negative !== 0; )
          Ko--, So.negative = 0, So._ishlnsubmul($o, 1, To), So.isZero() || (So.negative ^= 1);
        Fi && (Fi.words[To] = Ko);
      }
      return Fi && Fi._strip(), So._strip(), Ni !== "div" && Ui !== 0 && So.iushrn(Ui), {
        div: Fi || null,
        mod: So
      };
    }, Ei.prototype.divmod = function(Ai, Ni, Ui) {
      if (Si(!Ai.isZero()), this.isZero())
        return {
          div: new Ei(0),
          mod: new Ei(0)
        };
      var So, $o, Eo;
      return this.negative !== 0 && Ai.negative === 0 ? (Eo = this.neg().divmod(Ai, Ni), Ni !== "mod" && (So = Eo.div.neg()), Ni !== "div" && ($o = Eo.mod.neg(), Ui && $o.negative !== 0 && $o.iadd(Ai)), {
        div: So,
        mod: $o
      }) : this.negative === 0 && Ai.negative !== 0 ? (Eo = this.divmod(Ai.neg(), Ni), Ni !== "mod" && (So = Eo.div.neg()), {
        div: So,
        mod: Eo.mod
      }) : this.negative & Ai.negative ? (Eo = this.neg().divmod(Ai.neg(), Ni), Ni !== "div" && ($o = Eo.mod.neg(), Ui && $o.negative !== 0 && $o.isub(Ai)), {
        div: Eo.div,
        mod: $o
      }) : Ai.length > this.length || this.cmp(Ai) < 0 ? {
        div: new Ei(0),
        mod: this
      } : Ai.length === 1 ? Ni === "div" ? {
        div: this.divn(Ai.words[0]),
        mod: null
      } : Ni === "mod" ? {
        div: null,
        mod: new Ei(this.modrn(Ai.words[0]))
      } : {
        div: this.divn(Ai.words[0]),
        mod: new Ei(this.modrn(Ai.words[0]))
      } : this._wordDiv(Ai, Ni);
    }, Ei.prototype.div = function(Ai) {
      return this.divmod(Ai, "div", !1).div;
    }, Ei.prototype.mod = function(Ai) {
      return this.divmod(Ai, "mod", !1).mod;
    }, Ei.prototype.umod = function(Ai) {
      return this.divmod(Ai, "mod", !0).mod;
    }, Ei.prototype.divRound = function(Ai) {
      var Ni = this.divmod(Ai);
      if (Ni.mod.isZero())
        return Ni.div;
      var Ui = Ni.div.negative !== 0 ? Ni.mod.isub(Ai) : Ni.mod, So = Ai.ushrn(1), $o = Ai.andln(1), Eo = Ui.cmp(So);
      return Eo < 0 || $o === 1 && Eo === 0 ? Ni.div : Ni.div.negative !== 0 ? Ni.div.isubn(1) : Ni.div.iaddn(1);
    }, Ei.prototype.modrn = function(Ai) {
      var Ni = Ai < 0;
      Ni && (Ai = -Ai), Si(Ai <= 67108863);
      for (var Ui = (1 << 26) % Ai, So = 0, $o = this.length - 1; $o >= 0; $o--)
        So = (Ui * So + (this.words[$o] | 0)) % Ai;
      return Ni ? -So : So;
    }, Ei.prototype.modn = function(Ai) {
      return this.modrn(Ai);
    }, Ei.prototype.idivn = function(Ai) {
      var Ni = Ai < 0;
      Ni && (Ai = -Ai), Si(Ai <= 67108863);
      for (var Ui = 0, So = this.length - 1; So >= 0; So--) {
        var $o = (this.words[So] | 0) + Ui * 67108864;
        this.words[So] = $o / Ai | 0, Ui = $o % Ai;
      }
      return this._strip(), Ni ? this.ineg() : this;
    }, Ei.prototype.divn = function(Ai) {
      return this.clone().idivn(Ai);
    }, Ei.prototype.egcd = function(Ai) {
      Si(Ai.negative === 0), Si(!Ai.isZero());
      var Ni = this, Ui = Ai.clone();
      Ni.negative !== 0 ? Ni = Ni.umod(Ai) : Ni = Ni.clone();
      for (var So = new Ei(1), $o = new Ei(0), Eo = new Ei(0), zi = new Ei(1), _o = 0; Ni.isEven() && Ui.isEven(); )
        Ni.iushrn(1), Ui.iushrn(1), ++_o;
      for (var Fi = Ui.clone(), xo = Ni.clone(); !Ni.isZero(); ) {
        for (var Qo = 0, To = 1; !(Ni.words[0] & To) && Qo < 26; ++Qo, To <<= 1)
          ;
        if (Qo > 0)
          for (Ni.iushrn(Qo); Qo-- > 0; )
            (So.isOdd() || $o.isOdd()) && (So.iadd(Fi), $o.isub(xo)), So.iushrn(1), $o.iushrn(1);
        for (var Ko = 0, Vo = 1; !(Ui.words[0] & Vo) && Ko < 26; ++Ko, Vo <<= 1)
          ;
        if (Ko > 0)
          for (Ui.iushrn(Ko); Ko-- > 0; )
            (Eo.isOdd() || zi.isOdd()) && (Eo.iadd(Fi), zi.isub(xo)), Eo.iushrn(1), zi.iushrn(1);
        Ni.cmp(Ui) >= 0 ? (Ni.isub(Ui), So.isub(Eo), $o.isub(zi)) : (Ui.isub(Ni), Eo.isub(So), zi.isub($o));
      }
      return {
        a: Eo,
        b: zi,
        gcd: Ui.iushln(_o)
      };
    }, Ei.prototype._invmp = function(Ai) {
      Si(Ai.negative === 0), Si(!Ai.isZero());
      var Ni = this, Ui = Ai.clone();
      Ni.negative !== 0 ? Ni = Ni.umod(Ai) : Ni = Ni.clone();
      for (var So = new Ei(1), $o = new Ei(0), Eo = Ui.clone(); Ni.cmpn(1) > 0 && Ui.cmpn(1) > 0; ) {
        for (var zi = 0, _o = 1; !(Ni.words[0] & _o) && zi < 26; ++zi, _o <<= 1)
          ;
        if (zi > 0)
          for (Ni.iushrn(zi); zi-- > 0; )
            So.isOdd() && So.iadd(Eo), So.iushrn(1);
        for (var Fi = 0, xo = 1; !(Ui.words[0] & xo) && Fi < 26; ++Fi, xo <<= 1)
          ;
        if (Fi > 0)
          for (Ui.iushrn(Fi); Fi-- > 0; )
            $o.isOdd() && $o.iadd(Eo), $o.iushrn(1);
        Ni.cmp(Ui) >= 0 ? (Ni.isub(Ui), So.isub($o)) : (Ui.isub(Ni), $o.isub(So));
      }
      var Qo;
      return Ni.cmpn(1) === 0 ? Qo = So : Qo = $o, Qo.cmpn(0) < 0 && Qo.iadd(Ai), Qo;
    }, Ei.prototype.gcd = function(Ai) {
      if (this.isZero())
        return Ai.abs();
      if (Ai.isZero())
        return this.abs();
      var Ni = this.clone(), Ui = Ai.clone();
      Ni.negative = 0, Ui.negative = 0;
      for (var So = 0; Ni.isEven() && Ui.isEven(); So++)
        Ni.iushrn(1), Ui.iushrn(1);
      do {
        for (; Ni.isEven(); )
          Ni.iushrn(1);
        for (; Ui.isEven(); )
          Ui.iushrn(1);
        var $o = Ni.cmp(Ui);
        if ($o < 0) {
          var Eo = Ni;
          Ni = Ui, Ui = Eo;
        } else if ($o === 0 || Ui.cmpn(1) === 0)
          break;
        Ni.isub(Ui);
      } while (!0);
      return Ui.iushln(So);
    }, Ei.prototype.invm = function(Ai) {
      return this.egcd(Ai).a.umod(Ai);
    }, Ei.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Ei.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Ei.prototype.andln = function(Ai) {
      return this.words[0] & Ai;
    }, Ei.prototype.bincn = function(Ai) {
      Si(typeof Ai == "number");
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26, So = 1 << Ni;
      if (this.length <= Ui)
        return this._expand(Ui + 1), this.words[Ui] |= So, this;
      for (var $o = So, Eo = Ui; $o !== 0 && Eo < this.length; Eo++) {
        var zi = this.words[Eo] | 0;
        zi += $o, $o = zi >>> 26, zi &= 67108863, this.words[Eo] = zi;
      }
      return $o !== 0 && (this.words[Eo] = $o, this.length++), this;
    }, Ei.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Ei.prototype.cmpn = function(Ai) {
      var Ni = Ai < 0;
      if (this.negative !== 0 && !Ni)
        return -1;
      if (this.negative === 0 && Ni)
        return 1;
      this._strip();
      var Ui;
      if (this.length > 1)
        Ui = 1;
      else {
        Ni && (Ai = -Ai), Si(Ai <= 67108863, "Number is too big");
        var So = this.words[0] | 0;
        Ui = So === Ai ? 0 : So < Ai ? -1 : 1;
      }
      return this.negative !== 0 ? -Ui | 0 : Ui;
    }, Ei.prototype.cmp = function(Ai) {
      if (this.negative !== 0 && Ai.negative === 0)
        return -1;
      if (this.negative === 0 && Ai.negative !== 0)
        return 1;
      var Ni = this.ucmp(Ai);
      return this.negative !== 0 ? -Ni | 0 : Ni;
    }, Ei.prototype.ucmp = function(Ai) {
      if (this.length > Ai.length)
        return 1;
      if (this.length < Ai.length)
        return -1;
      for (var Ni = 0, Ui = this.length - 1; Ui >= 0; Ui--) {
        var So = this.words[Ui] | 0, $o = Ai.words[Ui] | 0;
        if (So !== $o) {
          So < $o ? Ni = -1 : So > $o && (Ni = 1);
          break;
        }
      }
      return Ni;
    }, Ei.prototype.gtn = function(Ai) {
      return this.cmpn(Ai) === 1;
    }, Ei.prototype.gt = function(Ai) {
      return this.cmp(Ai) === 1;
    }, Ei.prototype.gten = function(Ai) {
      return this.cmpn(Ai) >= 0;
    }, Ei.prototype.gte = function(Ai) {
      return this.cmp(Ai) >= 0;
    }, Ei.prototype.ltn = function(Ai) {
      return this.cmpn(Ai) === -1;
    }, Ei.prototype.lt = function(Ai) {
      return this.cmp(Ai) === -1;
    }, Ei.prototype.lten = function(Ai) {
      return this.cmpn(Ai) <= 0;
    }, Ei.prototype.lte = function(Ai) {
      return this.cmp(Ai) <= 0;
    }, Ei.prototype.eqn = function(Ai) {
      return this.cmpn(Ai) === 0;
    }, Ei.prototype.eq = function(Ai) {
      return this.cmp(Ai) === 0;
    }, Ei.red = function(Ai) {
      return new Do(Ai);
    }, Ei.prototype.toRed = function(Ai) {
      return Si(!this.red, "Already a number in reduction context"), Si(this.negative === 0, "red works only with positives"), Ai.convertTo(this)._forceRed(Ai);
    }, Ei.prototype.fromRed = function() {
      return Si(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Ei.prototype._forceRed = function(Ai) {
      return this.red = Ai, this;
    }, Ei.prototype.forceRed = function(Ai) {
      return Si(!this.red, "Already a number in reduction context"), this._forceRed(Ai);
    }, Ei.prototype.redAdd = function(Ai) {
      return Si(this.red, "redAdd works only with red numbers"), this.red.add(this, Ai);
    }, Ei.prototype.redIAdd = function(Ai) {
      return Si(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Ai);
    }, Ei.prototype.redSub = function(Ai) {
      return Si(this.red, "redSub works only with red numbers"), this.red.sub(this, Ai);
    }, Ei.prototype.redISub = function(Ai) {
      return Si(this.red, "redISub works only with red numbers"), this.red.isub(this, Ai);
    }, Ei.prototype.redShl = function(Ai) {
      return Si(this.red, "redShl works only with red numbers"), this.red.shl(this, Ai);
    }, Ei.prototype.redMul = function(Ai) {
      return Si(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ai), this.red.mul(this, Ai);
    }, Ei.prototype.redIMul = function(Ai) {
      return Si(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ai), this.red.imul(this, Ai);
    }, Ei.prototype.redSqr = function() {
      return Si(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Ei.prototype.redISqr = function() {
      return Si(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Ei.prototype.redSqrt = function() {
      return Si(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Ei.prototype.redInvm = function() {
      return Si(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Ei.prototype.redNeg = function() {
      return Si(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Ei.prototype.redPow = function(Ai) {
      return Si(this.red && !Ai.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Ai);
    };
    var ko = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Po(Li, Ai) {
      this.name = Li, this.p = new Ei(Ai, 16), this.n = this.p.bitLength(), this.k = new Ei(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Po.prototype._tmp = function() {
      var Ai = new Ei(null);
      return Ai.words = new Array(Math.ceil(this.n / 13)), Ai;
    }, Po.prototype.ireduce = function(Ai) {
      var Ni = Ai, Ui;
      do
        this.split(Ni, this.tmp), Ni = this.imulK(Ni), Ni = Ni.iadd(this.tmp), Ui = Ni.bitLength();
      while (Ui > this.n);
      var So = Ui < this.n ? -1 : Ni.ucmp(this.p);
      return So === 0 ? (Ni.words[0] = 0, Ni.length = 1) : So > 0 ? Ni.isub(this.p) : Ni.strip !== void 0 ? Ni.strip() : Ni._strip(), Ni;
    }, Po.prototype.split = function(Ai, Ni) {
      Ai.iushrn(this.n, 0, Ni);
    }, Po.prototype.imulK = function(Ai) {
      return Ai.imul(this.k);
    };
    function Mo() {
      Po.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    wi(Mo, Po), Mo.prototype.split = function(Ai, Ni) {
      for (var Ui = 4194303, So = Math.min(Ai.length, 9), $o = 0; $o < So; $o++)
        Ni.words[$o] = Ai.words[$o];
      if (Ni.length = So, Ai.length <= 9) {
        Ai.words[0] = 0, Ai.length = 1;
        return;
      }
      var Eo = Ai.words[9];
      for (Ni.words[Ni.length++] = Eo & Ui, $o = 10; $o < Ai.length; $o++) {
        var zi = Ai.words[$o] | 0;
        Ai.words[$o - 10] = (zi & Ui) << 4 | Eo >>> 22, Eo = zi;
      }
      Eo >>>= 22, Ai.words[$o - 10] = Eo, Eo === 0 && Ai.length > 10 ? Ai.length -= 10 : Ai.length -= 9;
    }, Mo.prototype.imulK = function(Ai) {
      Ai.words[Ai.length] = 0, Ai.words[Ai.length + 1] = 0, Ai.length += 2;
      for (var Ni = 0, Ui = 0; Ui < Ai.length; Ui++) {
        var So = Ai.words[Ui] | 0;
        Ni += So * 977, Ai.words[Ui] = Ni & 67108863, Ni = So * 64 + (Ni / 67108864 | 0);
      }
      return Ai.words[Ai.length - 1] === 0 && (Ai.length--, Ai.words[Ai.length - 1] === 0 && Ai.length--), Ai;
    };
    function No() {
      Po.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    wi(No, Po);
    function Jo() {
      Po.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    wi(Jo, Po);
    function zo() {
      Po.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    wi(zo, Po), zo.prototype.imulK = function(Ai) {
      for (var Ni = 0, Ui = 0; Ui < Ai.length; Ui++) {
        var So = (Ai.words[Ui] | 0) * 19 + Ni, $o = So & 67108863;
        So >>>= 26, Ai.words[Ui] = $o, Ni = So;
      }
      return Ni !== 0 && (Ai.words[Ai.length++] = Ni), Ai;
    }, Ei._prime = function(Ai) {
      if (ko[Ai])
        return ko[Ai];
      var Ni;
      if (Ai === "k256")
        Ni = new Mo();
      else if (Ai === "p224")
        Ni = new No();
      else if (Ai === "p192")
        Ni = new Jo();
      else if (Ai === "p25519")
        Ni = new zo();
      else
        throw new Error("Unknown prime " + Ai);
      return ko[Ai] = Ni, Ni;
    };
    function Do(Li) {
      if (typeof Li == "string") {
        var Ai = Ei._prime(Li);
        this.m = Ai.p, this.prime = Ai;
      } else
        Si(Li.gtn(1), "modulus must be greater than 1"), this.m = Li, this.prime = null;
    }
    Do.prototype._verify1 = function(Ai) {
      Si(Ai.negative === 0, "red works only with positives"), Si(Ai.red, "red works only with red numbers");
    }, Do.prototype._verify2 = function(Ai, Ni) {
      Si((Ai.negative | Ni.negative) === 0, "red works only with positives"), Si(
        Ai.red && Ai.red === Ni.red,
        "red works only with red numbers"
      );
    }, Do.prototype.imod = function(Ai) {
      return this.prime ? this.prime.ireduce(Ai)._forceRed(this) : (Oi(Ai, Ai.umod(this.m)._forceRed(this)), Ai);
    }, Do.prototype.neg = function(Ai) {
      return Ai.isZero() ? Ai.clone() : this.m.sub(Ai)._forceRed(this);
    }, Do.prototype.add = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.add(Ni);
      return Ui.cmp(this.m) >= 0 && Ui.isub(this.m), Ui._forceRed(this);
    }, Do.prototype.iadd = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.iadd(Ni);
      return Ui.cmp(this.m) >= 0 && Ui.isub(this.m), Ui;
    }, Do.prototype.sub = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.sub(Ni);
      return Ui.cmpn(0) < 0 && Ui.iadd(this.m), Ui._forceRed(this);
    }, Do.prototype.isub = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.isub(Ni);
      return Ui.cmpn(0) < 0 && Ui.iadd(this.m), Ui;
    }, Do.prototype.shl = function(Ai, Ni) {
      return this._verify1(Ai), this.imod(Ai.ushln(Ni));
    }, Do.prototype.imul = function(Ai, Ni) {
      return this._verify2(Ai, Ni), this.imod(Ai.imul(Ni));
    }, Do.prototype.mul = function(Ai, Ni) {
      return this._verify2(Ai, Ni), this.imod(Ai.mul(Ni));
    }, Do.prototype.isqr = function(Ai) {
      return this.imul(Ai, Ai.clone());
    }, Do.prototype.sqr = function(Ai) {
      return this.mul(Ai, Ai);
    }, Do.prototype.sqrt = function(Ai) {
      if (Ai.isZero())
        return Ai.clone();
      var Ni = this.m.andln(3);
      if (Si(Ni % 2 === 1), Ni === 3) {
        var Ui = this.m.add(new Ei(1)).iushrn(2);
        return this.pow(Ai, Ui);
      }
      for (var So = this.m.subn(1), $o = 0; !So.isZero() && So.andln(1) === 0; )
        $o++, So.iushrn(1);
      Si(!So.isZero());
      var Eo = new Ei(1).toRed(this), zi = Eo.redNeg(), _o = this.m.subn(1).iushrn(1), Fi = this.m.bitLength();
      for (Fi = new Ei(2 * Fi * Fi).toRed(this); this.pow(Fi, _o).cmp(zi) !== 0; )
        Fi.redIAdd(zi);
      for (var xo = this.pow(Fi, So), Qo = this.pow(Ai, So.addn(1).iushrn(1)), To = this.pow(Ai, So), Ko = $o; To.cmp(Eo) !== 0; ) {
        for (var Vo = To, Wo = 0; Vo.cmp(Eo) !== 0; Wo++)
          Vo = Vo.redSqr();
        Si(Wo < Ko);
        var jo = this.pow(xo, new Ei(1).iushln(Ko - Wo - 1));
        Qo = Qo.redMul(jo), xo = jo.redSqr(), To = To.redMul(xo), Ko = Wo;
      }
      return Qo;
    }, Do.prototype.invm = function(Ai) {
      var Ni = Ai._invmp(this.m);
      return Ni.negative !== 0 ? (Ni.negative = 0, this.imod(Ni).redNeg()) : this.imod(Ni);
    }, Do.prototype.pow = function(Ai, Ni) {
      if (Ni.isZero())
        return new Ei(1).toRed(this);
      if (Ni.cmpn(1) === 0)
        return Ai.clone();
      var Ui = 4, So = new Array(1 << Ui);
      So[0] = new Ei(1).toRed(this), So[1] = Ai;
      for (var $o = 2; $o < So.length; $o++)
        So[$o] = this.mul(So[$o - 1], Ai);
      var Eo = So[0], zi = 0, _o = 0, Fi = Ni.bitLength() % 26;
      for (Fi === 0 && (Fi = 26), $o = Ni.length - 1; $o >= 0; $o--) {
        for (var xo = Ni.words[$o], Qo = Fi - 1; Qo >= 0; Qo--) {
          var To = xo >> Qo & 1;
          if (Eo !== So[0] && (Eo = this.sqr(Eo)), To === 0 && zi === 0) {
            _o = 0;
            continue;
          }
          zi <<= 1, zi |= To, _o++, !(_o !== Ui && ($o !== 0 || Qo !== 0)) && (Eo = this.mul(Eo, So[zi]), _o = 0, zi = 0);
        }
        Fi = 26;
      }
      return Eo;
    }, Do.prototype.convertTo = function(Ai) {
      var Ni = Ai.umod(this.m);
      return Ni === Ai ? Ni.clone() : Ni;
    }, Do.prototype.convertFrom = function(Ai) {
      var Ni = Ai.clone();
      return Ni.red = null, Ni;
    }, Ei.mont = function(Ai) {
      return new wo(Ai);
    };
    function wo(Li) {
      Do.call(this, Li), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Ei(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    wi(wo, Do), wo.prototype.convertTo = function(Ai) {
      return this.imod(Ai.ushln(this.shift));
    }, wo.prototype.convertFrom = function(Ai) {
      var Ni = this.imod(Ai.mul(this.rinv));
      return Ni.red = null, Ni;
    }, wo.prototype.imul = function(Ai, Ni) {
      if (Ai.isZero() || Ni.isZero())
        return Ai.words[0] = 0, Ai.length = 1, Ai;
      var Ui = Ai.imul(Ni), So = Ui.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $o = Ui.isub(So).iushrn(this.shift), Eo = $o;
      return $o.cmp(this.m) >= 0 ? Eo = $o.isub(this.m) : $o.cmpn(0) < 0 && (Eo = $o.iadd(this.m)), Eo._forceRed(this);
    }, wo.prototype.mul = function(Ai, Ni) {
      if (Ai.isZero() || Ni.isZero())
        return new Ei(0)._forceRed(this);
      var Ui = Ai.mul(Ni), So = Ui.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $o = Ui.isub(So).iushrn(this.shift), Eo = $o;
      return $o.cmp(this.m) >= 0 ? Eo = $o.isub(this.m) : $o.cmpn(0) < 0 && (Eo = $o.iadd(this.m)), Eo._forceRed(this);
    }, wo.prototype.invm = function(Ai) {
      var Ni = this.imod(Ai._invmp(this.m).mul(this.r2));
      return Ni._forceRed(this);
    };
  })(se, commonjsGlobal);
})(bn$4);
var bnExports$2 = bn$4.exports;
const _BN = /* @__PURE__ */ getDefaultExportFromCjs(bnExports$2);
var BN$9 = _BN.BN;
function _base36To16(se) {
  return new BN$9(se, 36).toString(16);
}
const version$3 = "strings/5.7.0", logger$2 = new Logger(version$3);
var UnicodeNormalizationForm;
(function(se) {
  se.current = "", se.NFC = "NFC", se.NFD = "NFD", se.NFKC = "NFKC", se.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(se) {
  se.UNEXPECTED_CONTINUE = "unexpected continuation byte", se.BAD_PREFIX = "bad codepoint prefix", se.OVERRUN = "string overrun", se.MISSING_CONTINUE = "missing continuation byte", se.OUT_OF_RANGE = "out of UTF-8 range", se.UTF16_SURROGATE = "UTF-16 surrogate", se.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function toUtf8Bytes(se, e = UnicodeNormalizationForm.current) {
  e != UnicodeNormalizationForm.current && (logger$2.checkNormalize(), se = se.normalize(e));
  let Oe = [];
  for (let Si = 0; Si < se.length; Si++) {
    const wi = se.charCodeAt(Si);
    if (wi < 128)
      Oe.push(wi);
    else if (wi < 2048)
      Oe.push(wi >> 6 | 192), Oe.push(wi & 63 | 128);
    else if ((wi & 64512) == 55296) {
      Si++;
      const Ei = se.charCodeAt(Si);
      if (Si >= se.length || (Ei & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const $i = 65536 + ((wi & 1023) << 10) + (Ei & 1023);
      Oe.push($i >> 18 | 240), Oe.push($i >> 12 & 63 | 128), Oe.push($i >> 6 & 63 | 128), Oe.push($i & 63 | 128);
    } else
      Oe.push(wi >> 12 | 224), Oe.push(wi >> 6 & 63 | 128), Oe.push(wi & 63 | 128);
  }
  return arrayify(Oe);
}
const messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(se) {
  return typeof se == "string" && (se = toUtf8Bytes(se)), keccak256(concat$2([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(se.length)),
    se
  ]));
}
const version$2 = "address/5.7.0", logger$1 = new Logger(version$2);
function getChecksumAddress(se) {
  isHexString(se, 20) || logger$1.throwArgumentError("invalid address", "address", se), se = se.toLowerCase();
  const e = se.substring(2).split(""), Oe = new Uint8Array(40);
  for (let wi = 0; wi < 40; wi++)
    Oe[wi] = e[wi].charCodeAt(0);
  const Si = arrayify(keccak256(Oe));
  for (let wi = 0; wi < 40; wi += 2)
    Si[wi >> 1] >> 4 >= 8 && (e[wi] = e[wi].toUpperCase()), (Si[wi >> 1] & 15) >= 8 && (e[wi + 1] = e[wi + 1].toUpperCase());
  return "0x" + e.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(se) {
  return Math.log10 ? Math.log10(se) : Math.log(se) / Math.LN10;
}
const ibanLookup = {};
for (let se = 0; se < 10; se++)
  ibanLookup[String(se)] = String(se);
for (let se = 0; se < 26; se++)
  ibanLookup[String.fromCharCode(65 + se)] = String(10 + se);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(se) {
  se = se.toUpperCase(), se = se.substring(4) + se.substring(0, 2) + "00";
  let e = se.split("").map((Si) => ibanLookup[Si]).join("");
  for (; e.length >= safeDigits; ) {
    let Si = e.substring(0, safeDigits);
    e = parseInt(Si, 10) % 97 + e.substring(Si.length);
  }
  let Oe = String(98 - parseInt(e, 10) % 97);
  for (; Oe.length < 2; )
    Oe = "0" + Oe;
  return Oe;
}
function getAddress(se) {
  let e = null;
  if (typeof se != "string" && logger$1.throwArgumentError("invalid address", "address", se), se.match(/^(0x)?[0-9a-fA-F]{40}$/))
    se.substring(0, 2) !== "0x" && (se = "0x" + se), e = getChecksumAddress(se), se.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== se && logger$1.throwArgumentError("bad address checksum", "address", se);
  else if (se.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (se.substring(2, 4) !== ibanChecksum(se) && logger$1.throwArgumentError("bad icap checksum", "address", se), e = _base36To16(se.substring(4)); e.length < 40; )
      e = "0" + e;
    e = getChecksumAddress("0x" + e);
  } else
    logger$1.throwArgumentError("invalid address", "address", se);
  return e;
}
globalThis && globalThis.__awaiter;
function defineReadOnly(se, e, Oe) {
  Object.defineProperty(se, e, {
    enumerable: !0,
    value: Oe,
    writable: !1
  });
}
var bn$3 = { exports: {} };
bn$3.exports;
(function(se) {
  (function(e, Oe) {
    function Si(Li, Ai) {
      if (!Li)
        throw new Error(Ai || "Assertion failed");
    }
    function wi(Li, Ai) {
      Li.super_ = Ai;
      var Ni = function() {
      };
      Ni.prototype = Ai.prototype, Li.prototype = new Ni(), Li.prototype.constructor = Li;
    }
    function Ei(Li, Ai, Ni) {
      if (Ei.isBN(Li))
        return Li;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Li !== null && ((Ai === "le" || Ai === "be") && (Ni = Ai, Ai = 10), this._init(Li || 0, Ai || 10, Ni || "be"));
    }
    typeof e == "object" ? e.exports = Ei : Oe.BN = Ei, Ei.BN = Ei, Ei.wordSize = 26;
    var $i;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? $i = window.Buffer : $i = require("buffer").Buffer;
    } catch {
    }
    Ei.isBN = function(Ai) {
      return Ai instanceof Ei ? !0 : Ai !== null && typeof Ai == "object" && Ai.constructor.wordSize === Ei.wordSize && Array.isArray(Ai.words);
    }, Ei.max = function(Ai, Ni) {
      return Ai.cmp(Ni) > 0 ? Ai : Ni;
    }, Ei.min = function(Ai, Ni) {
      return Ai.cmp(Ni) < 0 ? Ai : Ni;
    }, Ei.prototype._init = function(Ai, Ni, Ui) {
      if (typeof Ai == "number")
        return this._initNumber(Ai, Ni, Ui);
      if (typeof Ai == "object")
        return this._initArray(Ai, Ni, Ui);
      Ni === "hex" && (Ni = 16), Si(Ni === (Ni | 0) && Ni >= 2 && Ni <= 36), Ai = Ai.toString().replace(/\s+/g, "");
      var So = 0;
      Ai[0] === "-" && (So++, this.negative = 1), So < Ai.length && (Ni === 16 ? this._parseHex(Ai, So, Ui) : (this._parseBase(Ai, Ni, So), Ui === "le" && this._initArray(this.toArray(), Ni, Ui)));
    }, Ei.prototype._initNumber = function(Ai, Ni, Ui) {
      Ai < 0 && (this.negative = 1, Ai = -Ai), Ai < 67108864 ? (this.words = [Ai & 67108863], this.length = 1) : Ai < 4503599627370496 ? (this.words = [
        Ai & 67108863,
        Ai / 67108864 & 67108863
      ], this.length = 2) : (Si(Ai < 9007199254740992), this.words = [
        Ai & 67108863,
        Ai / 67108864 & 67108863,
        1
      ], this.length = 3), Ui === "le" && this._initArray(this.toArray(), Ni, Ui);
    }, Ei.prototype._initArray = function(Ai, Ni, Ui) {
      if (Si(typeof Ai.length == "number"), Ai.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Ai.length / 3), this.words = new Array(this.length);
      for (var So = 0; So < this.length; So++)
        this.words[So] = 0;
      var $o, Eo, zi = 0;
      if (Ui === "be")
        for (So = Ai.length - 1, $o = 0; So >= 0; So -= 3)
          Eo = Ai[So] | Ai[So - 1] << 8 | Ai[So - 2] << 16, this.words[$o] |= Eo << zi & 67108863, this.words[$o + 1] = Eo >>> 26 - zi & 67108863, zi += 24, zi >= 26 && (zi -= 26, $o++);
      else if (Ui === "le")
        for (So = 0, $o = 0; So < Ai.length; So += 3)
          Eo = Ai[So] | Ai[So + 1] << 8 | Ai[So + 2] << 16, this.words[$o] |= Eo << zi & 67108863, this.words[$o + 1] = Eo >>> 26 - zi & 67108863, zi += 24, zi >= 26 && (zi -= 26, $o++);
      return this._strip();
    };
    function xi(Li, Ai) {
      var Ni = Li.charCodeAt(Ai);
      if (Ni >= 48 && Ni <= 57)
        return Ni - 48;
      if (Ni >= 65 && Ni <= 70)
        return Ni - 55;
      if (Ni >= 97 && Ni <= 102)
        return Ni - 87;
      Si(!1, "Invalid character in " + Li);
    }
    function Ri(Li, Ai, Ni) {
      var Ui = xi(Li, Ni);
      return Ni - 1 >= Ai && (Ui |= xi(Li, Ni - 1) << 4), Ui;
    }
    Ei.prototype._parseHex = function(Ai, Ni, Ui) {
      this.length = Math.ceil((Ai.length - Ni) / 6), this.words = new Array(this.length);
      for (var So = 0; So < this.length; So++)
        this.words[So] = 0;
      var $o = 0, Eo = 0, zi;
      if (Ui === "be")
        for (So = Ai.length - 1; So >= Ni; So -= 2)
          zi = Ri(Ai, Ni, So) << $o, this.words[Eo] |= zi & 67108863, $o >= 18 ? ($o -= 18, Eo += 1, this.words[Eo] |= zi >>> 26) : $o += 8;
      else {
        var _o = Ai.length - Ni;
        for (So = _o % 2 === 0 ? Ni + 1 : Ni; So < Ai.length; So += 2)
          zi = Ri(Ai, Ni, So) << $o, this.words[Eo] |= zi & 67108863, $o >= 18 ? ($o -= 18, Eo += 1, this.words[Eo] |= zi >>> 26) : $o += 8;
      }
      this._strip();
    };
    function Ti(Li, Ai, Ni, Ui) {
      for (var So = 0, $o = 0, Eo = Math.min(Li.length, Ni), zi = Ai; zi < Eo; zi++) {
        var _o = Li.charCodeAt(zi) - 48;
        So *= Ui, _o >= 49 ? $o = _o - 49 + 10 : _o >= 17 ? $o = _o - 17 + 10 : $o = _o, Si(_o >= 0 && $o < Ui, "Invalid character"), So += $o;
      }
      return So;
    }
    Ei.prototype._parseBase = function(Ai, Ni, Ui) {
      this.words = [0], this.length = 1;
      for (var So = 0, $o = 1; $o <= 67108863; $o *= Ni)
        So++;
      So--, $o = $o / Ni | 0;
      for (var Eo = Ai.length - Ui, zi = Eo % So, _o = Math.min(Eo, Eo - zi) + Ui, Fi = 0, xo = Ui; xo < _o; xo += So)
        Fi = Ti(Ai, xo, xo + So, Ni), this.imuln($o), this.words[0] + Fi < 67108864 ? this.words[0] += Fi : this._iaddn(Fi);
      if (zi !== 0) {
        var Qo = 1;
        for (Fi = Ti(Ai, xo, Ai.length, Ni), xo = 0; xo < zi; xo++)
          Qo *= Ni;
        this.imuln(Qo), this.words[0] + Fi < 67108864 ? this.words[0] += Fi : this._iaddn(Fi);
      }
      this._strip();
    }, Ei.prototype.copy = function(Ai) {
      Ai.words = new Array(this.length);
      for (var Ni = 0; Ni < this.length; Ni++)
        Ai.words[Ni] = this.words[Ni];
      Ai.length = this.length, Ai.negative = this.negative, Ai.red = this.red;
    };
    function Oi(Li, Ai) {
      Li.words = Ai.words, Li.length = Ai.length, Li.negative = Ai.negative, Li.red = Ai.red;
    }
    if (Ei.prototype._move = function(Ai) {
      Oi(Ai, this);
    }, Ei.prototype.clone = function() {
      var Ai = new Ei(null);
      return this.copy(Ai), Ai;
    }, Ei.prototype._expand = function(Ai) {
      for (; this.length < Ai; )
        this.words[this.length++] = 0;
      return this;
    }, Ei.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Ei.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Ei.prototype[Symbol.for("nodejs.util.inspect.custom")] = Mi;
      } catch {
        Ei.prototype.inspect = Mi;
      }
    else
      Ei.prototype.inspect = Mi;
    function Mi() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Ii = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ci = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Oo = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Ei.prototype.toString = function(Ai, Ni) {
      Ai = Ai || 10, Ni = Ni | 0 || 1;
      var Ui;
      if (Ai === 16 || Ai === "hex") {
        Ui = "";
        for (var So = 0, $o = 0, Eo = 0; Eo < this.length; Eo++) {
          var zi = this.words[Eo], _o = ((zi << So | $o) & 16777215).toString(16);
          $o = zi >>> 24 - So & 16777215, So += 2, So >= 26 && (So -= 26, Eo--), $o !== 0 || Eo !== this.length - 1 ? Ui = Ii[6 - _o.length] + _o + Ui : Ui = _o + Ui;
        }
        for ($o !== 0 && (Ui = $o.toString(16) + Ui); Ui.length % Ni !== 0; )
          Ui = "0" + Ui;
        return this.negative !== 0 && (Ui = "-" + Ui), Ui;
      }
      if (Ai === (Ai | 0) && Ai >= 2 && Ai <= 36) {
        var Fi = Ci[Ai], xo = Oo[Ai];
        Ui = "";
        var Qo = this.clone();
        for (Qo.negative = 0; !Qo.isZero(); ) {
          var To = Qo.modrn(xo).toString(Ai);
          Qo = Qo.idivn(xo), Qo.isZero() ? Ui = To + Ui : Ui = Ii[Fi - To.length] + To + Ui;
        }
        for (this.isZero() && (Ui = "0" + Ui); Ui.length % Ni !== 0; )
          Ui = "0" + Ui;
        return this.negative !== 0 && (Ui = "-" + Ui), Ui;
      }
      Si(!1, "Base should be between 2 and 36");
    }, Ei.prototype.toNumber = function() {
      var Ai = this.words[0];
      return this.length === 2 ? Ai += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Ai += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Si(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Ai : Ai;
    }, Ei.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, $i && (Ei.prototype.toBuffer = function(Ai, Ni) {
      return this.toArrayLike($i, Ai, Ni);
    }), Ei.prototype.toArray = function(Ai, Ni) {
      return this.toArrayLike(Array, Ai, Ni);
    };
    var Ro = function(Ai, Ni) {
      return Ai.allocUnsafe ? Ai.allocUnsafe(Ni) : new Ai(Ni);
    };
    Ei.prototype.toArrayLike = function(Ai, Ni, Ui) {
      this._strip();
      var So = this.byteLength(), $o = Ui || Math.max(1, So);
      Si(So <= $o, "byte array longer than desired length"), Si($o > 0, "Requested array length <= 0");
      var Eo = Ro(Ai, $o), zi = Ni === "le" ? "LE" : "BE";
      return this["_toArrayLike" + zi](Eo, So), Eo;
    }, Ei.prototype._toArrayLikeLE = function(Ai, Ni) {
      for (var Ui = 0, So = 0, $o = 0, Eo = 0; $o < this.length; $o++) {
        var zi = this.words[$o] << Eo | So;
        Ai[Ui++] = zi & 255, Ui < Ai.length && (Ai[Ui++] = zi >> 8 & 255), Ui < Ai.length && (Ai[Ui++] = zi >> 16 & 255), Eo === 6 ? (Ui < Ai.length && (Ai[Ui++] = zi >> 24 & 255), So = 0, Eo = 0) : (So = zi >>> 24, Eo += 2);
      }
      if (Ui < Ai.length)
        for (Ai[Ui++] = So; Ui < Ai.length; )
          Ai[Ui++] = 0;
    }, Ei.prototype._toArrayLikeBE = function(Ai, Ni) {
      for (var Ui = Ai.length - 1, So = 0, $o = 0, Eo = 0; $o < this.length; $o++) {
        var zi = this.words[$o] << Eo | So;
        Ai[Ui--] = zi & 255, Ui >= 0 && (Ai[Ui--] = zi >> 8 & 255), Ui >= 0 && (Ai[Ui--] = zi >> 16 & 255), Eo === 6 ? (Ui >= 0 && (Ai[Ui--] = zi >> 24 & 255), So = 0, Eo = 0) : (So = zi >>> 24, Eo += 2);
      }
      if (Ui >= 0)
        for (Ai[Ui--] = So; Ui >= 0; )
          Ai[Ui--] = 0;
    }, Math.clz32 ? Ei.prototype._countBits = function(Ai) {
      return 32 - Math.clz32(Ai);
    } : Ei.prototype._countBits = function(Ai) {
      var Ni = Ai, Ui = 0;
      return Ni >= 4096 && (Ui += 13, Ni >>>= 13), Ni >= 64 && (Ui += 7, Ni >>>= 7), Ni >= 8 && (Ui += 4, Ni >>>= 4), Ni >= 2 && (Ui += 2, Ni >>>= 2), Ui + Ni;
    }, Ei.prototype._zeroBits = function(Ai) {
      if (Ai === 0)
        return 26;
      var Ni = Ai, Ui = 0;
      return Ni & 8191 || (Ui += 13, Ni >>>= 13), Ni & 127 || (Ui += 7, Ni >>>= 7), Ni & 15 || (Ui += 4, Ni >>>= 4), Ni & 3 || (Ui += 2, Ni >>>= 2), Ni & 1 || Ui++, Ui;
    }, Ei.prototype.bitLength = function() {
      var Ai = this.words[this.length - 1], Ni = this._countBits(Ai);
      return (this.length - 1) * 26 + Ni;
    };
    function Bo(Li) {
      for (var Ai = new Array(Li.bitLength()), Ni = 0; Ni < Ai.length; Ni++) {
        var Ui = Ni / 26 | 0, So = Ni % 26;
        Ai[Ni] = Li.words[Ui] >>> So & 1;
      }
      return Ai;
    }
    Ei.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var Ai = 0, Ni = 0; Ni < this.length; Ni++) {
        var Ui = this._zeroBits(this.words[Ni]);
        if (Ai += Ui, Ui !== 26)
          break;
      }
      return Ai;
    }, Ei.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ei.prototype.toTwos = function(Ai) {
      return this.negative !== 0 ? this.abs().inotn(Ai).iaddn(1) : this.clone();
    }, Ei.prototype.fromTwos = function(Ai) {
      return this.testn(Ai - 1) ? this.notn(Ai).iaddn(1).ineg() : this.clone();
    }, Ei.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Ei.prototype.neg = function() {
      return this.clone().ineg();
    }, Ei.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Ei.prototype.iuor = function(Ai) {
      for (; this.length < Ai.length; )
        this.words[this.length++] = 0;
      for (var Ni = 0; Ni < Ai.length; Ni++)
        this.words[Ni] = this.words[Ni] | Ai.words[Ni];
      return this._strip();
    }, Ei.prototype.ior = function(Ai) {
      return Si((this.negative | Ai.negative) === 0), this.iuor(Ai);
    }, Ei.prototype.or = function(Ai) {
      return this.length > Ai.length ? this.clone().ior(Ai) : Ai.clone().ior(this);
    }, Ei.prototype.uor = function(Ai) {
      return this.length > Ai.length ? this.clone().iuor(Ai) : Ai.clone().iuor(this);
    }, Ei.prototype.iuand = function(Ai) {
      var Ni;
      this.length > Ai.length ? Ni = Ai : Ni = this;
      for (var Ui = 0; Ui < Ni.length; Ui++)
        this.words[Ui] = this.words[Ui] & Ai.words[Ui];
      return this.length = Ni.length, this._strip();
    }, Ei.prototype.iand = function(Ai) {
      return Si((this.negative | Ai.negative) === 0), this.iuand(Ai);
    }, Ei.prototype.and = function(Ai) {
      return this.length > Ai.length ? this.clone().iand(Ai) : Ai.clone().iand(this);
    }, Ei.prototype.uand = function(Ai) {
      return this.length > Ai.length ? this.clone().iuand(Ai) : Ai.clone().iuand(this);
    }, Ei.prototype.iuxor = function(Ai) {
      var Ni, Ui;
      this.length > Ai.length ? (Ni = this, Ui = Ai) : (Ni = Ai, Ui = this);
      for (var So = 0; So < Ui.length; So++)
        this.words[So] = Ni.words[So] ^ Ui.words[So];
      if (this !== Ni)
        for (; So < Ni.length; So++)
          this.words[So] = Ni.words[So];
      return this.length = Ni.length, this._strip();
    }, Ei.prototype.ixor = function(Ai) {
      return Si((this.negative | Ai.negative) === 0), this.iuxor(Ai);
    }, Ei.prototype.xor = function(Ai) {
      return this.length > Ai.length ? this.clone().ixor(Ai) : Ai.clone().ixor(this);
    }, Ei.prototype.uxor = function(Ai) {
      return this.length > Ai.length ? this.clone().iuxor(Ai) : Ai.clone().iuxor(this);
    }, Ei.prototype.inotn = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Math.ceil(Ai / 26) | 0, Ui = Ai % 26;
      this._expand(Ni), Ui > 0 && Ni--;
      for (var So = 0; So < Ni; So++)
        this.words[So] = ~this.words[So] & 67108863;
      return Ui > 0 && (this.words[So] = ~this.words[So] & 67108863 >> 26 - Ui), this._strip();
    }, Ei.prototype.notn = function(Ai) {
      return this.clone().inotn(Ai);
    }, Ei.prototype.setn = function(Ai, Ni) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ui = Ai / 26 | 0, So = Ai % 26;
      return this._expand(Ui + 1), Ni ? this.words[Ui] = this.words[Ui] | 1 << So : this.words[Ui] = this.words[Ui] & ~(1 << So), this._strip();
    }, Ei.prototype.iadd = function(Ai) {
      var Ni;
      if (this.negative !== 0 && Ai.negative === 0)
        return this.negative = 0, Ni = this.isub(Ai), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Ai.negative !== 0)
        return Ai.negative = 0, Ni = this.isub(Ai), Ai.negative = 1, Ni._normSign();
      var Ui, So;
      this.length > Ai.length ? (Ui = this, So = Ai) : (Ui = Ai, So = this);
      for (var $o = 0, Eo = 0; Eo < So.length; Eo++)
        Ni = (Ui.words[Eo] | 0) + (So.words[Eo] | 0) + $o, this.words[Eo] = Ni & 67108863, $o = Ni >>> 26;
      for (; $o !== 0 && Eo < Ui.length; Eo++)
        Ni = (Ui.words[Eo] | 0) + $o, this.words[Eo] = Ni & 67108863, $o = Ni >>> 26;
      if (this.length = Ui.length, $o !== 0)
        this.words[this.length] = $o, this.length++;
      else if (Ui !== this)
        for (; Eo < Ui.length; Eo++)
          this.words[Eo] = Ui.words[Eo];
      return this;
    }, Ei.prototype.add = function(Ai) {
      var Ni;
      return Ai.negative !== 0 && this.negative === 0 ? (Ai.negative = 0, Ni = this.sub(Ai), Ai.negative ^= 1, Ni) : Ai.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ni = Ai.sub(this), this.negative = 1, Ni) : this.length > Ai.length ? this.clone().iadd(Ai) : Ai.clone().iadd(this);
    }, Ei.prototype.isub = function(Ai) {
      if (Ai.negative !== 0) {
        Ai.negative = 0;
        var Ni = this.iadd(Ai);
        return Ai.negative = 1, Ni._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Ai), this.negative = 1, this._normSign();
      var Ui = this.cmp(Ai);
      if (Ui === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var So, $o;
      Ui > 0 ? (So = this, $o = Ai) : (So = Ai, $o = this);
      for (var Eo = 0, zi = 0; zi < $o.length; zi++)
        Ni = (So.words[zi] | 0) - ($o.words[zi] | 0) + Eo, Eo = Ni >> 26, this.words[zi] = Ni & 67108863;
      for (; Eo !== 0 && zi < So.length; zi++)
        Ni = (So.words[zi] | 0) + Eo, Eo = Ni >> 26, this.words[zi] = Ni & 67108863;
      if (Eo === 0 && zi < So.length && So !== this)
        for (; zi < So.length; zi++)
          this.words[zi] = So.words[zi];
      return this.length = Math.max(this.length, zi), So !== this && (this.negative = 1), this._strip();
    }, Ei.prototype.sub = function(Ai) {
      return this.clone().isub(Ai);
    };
    function Fo(Li, Ai, Ni) {
      Ni.negative = Ai.negative ^ Li.negative;
      var Ui = Li.length + Ai.length | 0;
      Ni.length = Ui, Ui = Ui - 1 | 0;
      var So = Li.words[0] | 0, $o = Ai.words[0] | 0, Eo = So * $o, zi = Eo & 67108863, _o = Eo / 67108864 | 0;
      Ni.words[0] = zi;
      for (var Fi = 1; Fi < Ui; Fi++) {
        for (var xo = _o >>> 26, Qo = _o & 67108863, To = Math.min(Fi, Ai.length - 1), Ko = Math.max(0, Fi - Li.length + 1); Ko <= To; Ko++) {
          var Vo = Fi - Ko | 0;
          So = Li.words[Vo] | 0, $o = Ai.words[Ko] | 0, Eo = So * $o + Qo, xo += Eo / 67108864 | 0, Qo = Eo & 67108863;
        }
        Ni.words[Fi] = Qo | 0, _o = xo | 0;
      }
      return _o !== 0 ? Ni.words[Fi] = _o | 0 : Ni.length--, Ni._strip();
    }
    var Io = function(Ai, Ni, Ui) {
      var So = Ai.words, $o = Ni.words, Eo = Ui.words, zi = 0, _o, Fi, xo, Qo = So[0] | 0, To = Qo & 8191, Ko = Qo >>> 13, Vo = So[1] | 0, Wo = Vo & 8191, jo = Vo >>> 13, Ao = So[2] | 0, Lo = Ao & 8191, Zo = Ao >>> 13, An = So[3] | 0, ra = An & 8191, sa = An >>> 13, Ma = So[4] | 0, ba = Ma & 8191, ma = Ma >>> 13, Va = So[5] | 0, wa = Va & 8191, ha = Va >>> 13, Fa = So[6] | 0, Sa = Fa & 8191, da = Fa >>> 13, Pa = So[7] | 0, va = Pa & 8191, ca = Pa >>> 13, Na = So[8] | 0, Ea = Na & 8191, fa = Na >>> 13, Ca = So[9] | 0, Oa = Ca & 8191, ya = Ca >>> 13, Ua = $o[0] | 0, xa = Ua & 8191, Ra = Ua >>> 13, Ha = $o[1] | 0, ka = Ha & 8191, Aa = Ha >>> 13, Ga = $o[2] | 0, Wa = Ga & 8191, $a = Ga >>> 13, qa = $o[3] | 0, Ia = qa & 8191, Ho = qa >>> 13, qo = $o[4] | 0, Go = qo & 8191, Xo = qo >>> 13, ea = $o[5] | 0, ia = ea & 8191, oa = ea >>> 13, aa = $o[6] | 0, ua = aa & 8191, na = aa >>> 13, _a = $o[7] | 0, pa = _a & 8191, la = _a >>> 13, Ba = $o[8] | 0, Da = Ba & 8191, Ta = Ba >>> 13, Ja = $o[9] | 0, ja = Ja & 8191, za = Ja >>> 13;
      Ui.negative = Ai.negative ^ Ni.negative, Ui.length = 19, _o = Math.imul(To, xa), Fi = Math.imul(To, Ra), Fi = Fi + Math.imul(Ko, xa) | 0, xo = Math.imul(Ko, Ra);
      var Qa = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Qa >>> 26) | 0, Qa &= 67108863, _o = Math.imul(Wo, xa), Fi = Math.imul(Wo, Ra), Fi = Fi + Math.imul(jo, xa) | 0, xo = Math.imul(jo, Ra), _o = _o + Math.imul(To, ka) | 0, Fi = Fi + Math.imul(To, Aa) | 0, Fi = Fi + Math.imul(Ko, ka) | 0, xo = xo + Math.imul(Ko, Aa) | 0;
      var tl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (tl >>> 26) | 0, tl &= 67108863, _o = Math.imul(Lo, xa), Fi = Math.imul(Lo, Ra), Fi = Fi + Math.imul(Zo, xa) | 0, xo = Math.imul(Zo, Ra), _o = _o + Math.imul(Wo, ka) | 0, Fi = Fi + Math.imul(Wo, Aa) | 0, Fi = Fi + Math.imul(jo, ka) | 0, xo = xo + Math.imul(jo, Aa) | 0, _o = _o + Math.imul(To, Wa) | 0, Fi = Fi + Math.imul(To, $a) | 0, Fi = Fi + Math.imul(Ko, Wa) | 0, xo = xo + Math.imul(Ko, $a) | 0;
      var Xa = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, _o = Math.imul(ra, xa), Fi = Math.imul(ra, Ra), Fi = Fi + Math.imul(sa, xa) | 0, xo = Math.imul(sa, Ra), _o = _o + Math.imul(Lo, ka) | 0, Fi = Fi + Math.imul(Lo, Aa) | 0, Fi = Fi + Math.imul(Zo, ka) | 0, xo = xo + Math.imul(Zo, Aa) | 0, _o = _o + Math.imul(Wo, Wa) | 0, Fi = Fi + Math.imul(Wo, $a) | 0, Fi = Fi + Math.imul(jo, Wa) | 0, xo = xo + Math.imul(jo, $a) | 0, _o = _o + Math.imul(To, Ia) | 0, Fi = Fi + Math.imul(To, Ho) | 0, Fi = Fi + Math.imul(Ko, Ia) | 0, xo = xo + Math.imul(Ko, Ho) | 0;
      var ol = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (ol >>> 26) | 0, ol &= 67108863, _o = Math.imul(ba, xa), Fi = Math.imul(ba, Ra), Fi = Fi + Math.imul(ma, xa) | 0, xo = Math.imul(ma, Ra), _o = _o + Math.imul(ra, ka) | 0, Fi = Fi + Math.imul(ra, Aa) | 0, Fi = Fi + Math.imul(sa, ka) | 0, xo = xo + Math.imul(sa, Aa) | 0, _o = _o + Math.imul(Lo, Wa) | 0, Fi = Fi + Math.imul(Lo, $a) | 0, Fi = Fi + Math.imul(Zo, Wa) | 0, xo = xo + Math.imul(Zo, $a) | 0, _o = _o + Math.imul(Wo, Ia) | 0, Fi = Fi + Math.imul(Wo, Ho) | 0, Fi = Fi + Math.imul(jo, Ia) | 0, xo = xo + Math.imul(jo, Ho) | 0, _o = _o + Math.imul(To, Go) | 0, Fi = Fi + Math.imul(To, Xo) | 0, Fi = Fi + Math.imul(Ko, Go) | 0, xo = xo + Math.imul(Ko, Xo) | 0;
      var Za = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, _o = Math.imul(wa, xa), Fi = Math.imul(wa, Ra), Fi = Fi + Math.imul(ha, xa) | 0, xo = Math.imul(ha, Ra), _o = _o + Math.imul(ba, ka) | 0, Fi = Fi + Math.imul(ba, Aa) | 0, Fi = Fi + Math.imul(ma, ka) | 0, xo = xo + Math.imul(ma, Aa) | 0, _o = _o + Math.imul(ra, Wa) | 0, Fi = Fi + Math.imul(ra, $a) | 0, Fi = Fi + Math.imul(sa, Wa) | 0, xo = xo + Math.imul(sa, $a) | 0, _o = _o + Math.imul(Lo, Ia) | 0, Fi = Fi + Math.imul(Lo, Ho) | 0, Fi = Fi + Math.imul(Zo, Ia) | 0, xo = xo + Math.imul(Zo, Ho) | 0, _o = _o + Math.imul(Wo, Go) | 0, Fi = Fi + Math.imul(Wo, Xo) | 0, Fi = Fi + Math.imul(jo, Go) | 0, xo = xo + Math.imul(jo, Xo) | 0, _o = _o + Math.imul(To, ia) | 0, Fi = Fi + Math.imul(To, oa) | 0, Fi = Fi + Math.imul(Ko, ia) | 0, xo = xo + Math.imul(Ko, oa) | 0;
      var ul = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (ul >>> 26) | 0, ul &= 67108863, _o = Math.imul(Sa, xa), Fi = Math.imul(Sa, Ra), Fi = Fi + Math.imul(da, xa) | 0, xo = Math.imul(da, Ra), _o = _o + Math.imul(wa, ka) | 0, Fi = Fi + Math.imul(wa, Aa) | 0, Fi = Fi + Math.imul(ha, ka) | 0, xo = xo + Math.imul(ha, Aa) | 0, _o = _o + Math.imul(ba, Wa) | 0, Fi = Fi + Math.imul(ba, $a) | 0, Fi = Fi + Math.imul(ma, Wa) | 0, xo = xo + Math.imul(ma, $a) | 0, _o = _o + Math.imul(ra, Ia) | 0, Fi = Fi + Math.imul(ra, Ho) | 0, Fi = Fi + Math.imul(sa, Ia) | 0, xo = xo + Math.imul(sa, Ho) | 0, _o = _o + Math.imul(Lo, Go) | 0, Fi = Fi + Math.imul(Lo, Xo) | 0, Fi = Fi + Math.imul(Zo, Go) | 0, xo = xo + Math.imul(Zo, Xo) | 0, _o = _o + Math.imul(Wo, ia) | 0, Fi = Fi + Math.imul(Wo, oa) | 0, Fi = Fi + Math.imul(jo, ia) | 0, xo = xo + Math.imul(jo, oa) | 0, _o = _o + Math.imul(To, ua) | 0, Fi = Fi + Math.imul(To, na) | 0, Fi = Fi + Math.imul(Ko, ua) | 0, xo = xo + Math.imul(Ko, na) | 0;
      var cl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (cl >>> 26) | 0, cl &= 67108863, _o = Math.imul(va, xa), Fi = Math.imul(va, Ra), Fi = Fi + Math.imul(ca, xa) | 0, xo = Math.imul(ca, Ra), _o = _o + Math.imul(Sa, ka) | 0, Fi = Fi + Math.imul(Sa, Aa) | 0, Fi = Fi + Math.imul(da, ka) | 0, xo = xo + Math.imul(da, Aa) | 0, _o = _o + Math.imul(wa, Wa) | 0, Fi = Fi + Math.imul(wa, $a) | 0, Fi = Fi + Math.imul(ha, Wa) | 0, xo = xo + Math.imul(ha, $a) | 0, _o = _o + Math.imul(ba, Ia) | 0, Fi = Fi + Math.imul(ba, Ho) | 0, Fi = Fi + Math.imul(ma, Ia) | 0, xo = xo + Math.imul(ma, Ho) | 0, _o = _o + Math.imul(ra, Go) | 0, Fi = Fi + Math.imul(ra, Xo) | 0, Fi = Fi + Math.imul(sa, Go) | 0, xo = xo + Math.imul(sa, Xo) | 0, _o = _o + Math.imul(Lo, ia) | 0, Fi = Fi + Math.imul(Lo, oa) | 0, Fi = Fi + Math.imul(Zo, ia) | 0, xo = xo + Math.imul(Zo, oa) | 0, _o = _o + Math.imul(Wo, ua) | 0, Fi = Fi + Math.imul(Wo, na) | 0, Fi = Fi + Math.imul(jo, ua) | 0, xo = xo + Math.imul(jo, na) | 0, _o = _o + Math.imul(To, pa) | 0, Fi = Fi + Math.imul(To, la) | 0, Fi = Fi + Math.imul(Ko, pa) | 0, xo = xo + Math.imul(Ko, la) | 0;
      var fl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (fl >>> 26) | 0, fl &= 67108863, _o = Math.imul(Ea, xa), Fi = Math.imul(Ea, Ra), Fi = Fi + Math.imul(fa, xa) | 0, xo = Math.imul(fa, Ra), _o = _o + Math.imul(va, ka) | 0, Fi = Fi + Math.imul(va, Aa) | 0, Fi = Fi + Math.imul(ca, ka) | 0, xo = xo + Math.imul(ca, Aa) | 0, _o = _o + Math.imul(Sa, Wa) | 0, Fi = Fi + Math.imul(Sa, $a) | 0, Fi = Fi + Math.imul(da, Wa) | 0, xo = xo + Math.imul(da, $a) | 0, _o = _o + Math.imul(wa, Ia) | 0, Fi = Fi + Math.imul(wa, Ho) | 0, Fi = Fi + Math.imul(ha, Ia) | 0, xo = xo + Math.imul(ha, Ho) | 0, _o = _o + Math.imul(ba, Go) | 0, Fi = Fi + Math.imul(ba, Xo) | 0, Fi = Fi + Math.imul(ma, Go) | 0, xo = xo + Math.imul(ma, Xo) | 0, _o = _o + Math.imul(ra, ia) | 0, Fi = Fi + Math.imul(ra, oa) | 0, Fi = Fi + Math.imul(sa, ia) | 0, xo = xo + Math.imul(sa, oa) | 0, _o = _o + Math.imul(Lo, ua) | 0, Fi = Fi + Math.imul(Lo, na) | 0, Fi = Fi + Math.imul(Zo, ua) | 0, xo = xo + Math.imul(Zo, na) | 0, _o = _o + Math.imul(Wo, pa) | 0, Fi = Fi + Math.imul(Wo, la) | 0, Fi = Fi + Math.imul(jo, pa) | 0, xo = xo + Math.imul(jo, la) | 0, _o = _o + Math.imul(To, Da) | 0, Fi = Fi + Math.imul(To, Ta) | 0, Fi = Fi + Math.imul(Ko, Da) | 0, xo = xo + Math.imul(Ko, Ta) | 0;
      var pl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (pl >>> 26) | 0, pl &= 67108863, _o = Math.imul(Oa, xa), Fi = Math.imul(Oa, Ra), Fi = Fi + Math.imul(ya, xa) | 0, xo = Math.imul(ya, Ra), _o = _o + Math.imul(Ea, ka) | 0, Fi = Fi + Math.imul(Ea, Aa) | 0, Fi = Fi + Math.imul(fa, ka) | 0, xo = xo + Math.imul(fa, Aa) | 0, _o = _o + Math.imul(va, Wa) | 0, Fi = Fi + Math.imul(va, $a) | 0, Fi = Fi + Math.imul(ca, Wa) | 0, xo = xo + Math.imul(ca, $a) | 0, _o = _o + Math.imul(Sa, Ia) | 0, Fi = Fi + Math.imul(Sa, Ho) | 0, Fi = Fi + Math.imul(da, Ia) | 0, xo = xo + Math.imul(da, Ho) | 0, _o = _o + Math.imul(wa, Go) | 0, Fi = Fi + Math.imul(wa, Xo) | 0, Fi = Fi + Math.imul(ha, Go) | 0, xo = xo + Math.imul(ha, Xo) | 0, _o = _o + Math.imul(ba, ia) | 0, Fi = Fi + Math.imul(ba, oa) | 0, Fi = Fi + Math.imul(ma, ia) | 0, xo = xo + Math.imul(ma, oa) | 0, _o = _o + Math.imul(ra, ua) | 0, Fi = Fi + Math.imul(ra, na) | 0, Fi = Fi + Math.imul(sa, ua) | 0, xo = xo + Math.imul(sa, na) | 0, _o = _o + Math.imul(Lo, pa) | 0, Fi = Fi + Math.imul(Lo, la) | 0, Fi = Fi + Math.imul(Zo, pa) | 0, xo = xo + Math.imul(Zo, la) | 0, _o = _o + Math.imul(Wo, Da) | 0, Fi = Fi + Math.imul(Wo, Ta) | 0, Fi = Fi + Math.imul(jo, Da) | 0, xo = xo + Math.imul(jo, Ta) | 0, _o = _o + Math.imul(To, ja) | 0, Fi = Fi + Math.imul(To, za) | 0, Fi = Fi + Math.imul(Ko, ja) | 0, xo = xo + Math.imul(Ko, za) | 0;
      var dl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (dl >>> 26) | 0, dl &= 67108863, _o = Math.imul(Oa, ka), Fi = Math.imul(Oa, Aa), Fi = Fi + Math.imul(ya, ka) | 0, xo = Math.imul(ya, Aa), _o = _o + Math.imul(Ea, Wa) | 0, Fi = Fi + Math.imul(Ea, $a) | 0, Fi = Fi + Math.imul(fa, Wa) | 0, xo = xo + Math.imul(fa, $a) | 0, _o = _o + Math.imul(va, Ia) | 0, Fi = Fi + Math.imul(va, Ho) | 0, Fi = Fi + Math.imul(ca, Ia) | 0, xo = xo + Math.imul(ca, Ho) | 0, _o = _o + Math.imul(Sa, Go) | 0, Fi = Fi + Math.imul(Sa, Xo) | 0, Fi = Fi + Math.imul(da, Go) | 0, xo = xo + Math.imul(da, Xo) | 0, _o = _o + Math.imul(wa, ia) | 0, Fi = Fi + Math.imul(wa, oa) | 0, Fi = Fi + Math.imul(ha, ia) | 0, xo = xo + Math.imul(ha, oa) | 0, _o = _o + Math.imul(ba, ua) | 0, Fi = Fi + Math.imul(ba, na) | 0, Fi = Fi + Math.imul(ma, ua) | 0, xo = xo + Math.imul(ma, na) | 0, _o = _o + Math.imul(ra, pa) | 0, Fi = Fi + Math.imul(ra, la) | 0, Fi = Fi + Math.imul(sa, pa) | 0, xo = xo + Math.imul(sa, la) | 0, _o = _o + Math.imul(Lo, Da) | 0, Fi = Fi + Math.imul(Lo, Ta) | 0, Fi = Fi + Math.imul(Zo, Da) | 0, xo = xo + Math.imul(Zo, Ta) | 0, _o = _o + Math.imul(Wo, ja) | 0, Fi = Fi + Math.imul(Wo, za) | 0, Fi = Fi + Math.imul(jo, ja) | 0, xo = xo + Math.imul(jo, za) | 0;
      var al = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (al >>> 26) | 0, al &= 67108863, _o = Math.imul(Oa, Wa), Fi = Math.imul(Oa, $a), Fi = Fi + Math.imul(ya, Wa) | 0, xo = Math.imul(ya, $a), _o = _o + Math.imul(Ea, Ia) | 0, Fi = Fi + Math.imul(Ea, Ho) | 0, Fi = Fi + Math.imul(fa, Ia) | 0, xo = xo + Math.imul(fa, Ho) | 0, _o = _o + Math.imul(va, Go) | 0, Fi = Fi + Math.imul(va, Xo) | 0, Fi = Fi + Math.imul(ca, Go) | 0, xo = xo + Math.imul(ca, Xo) | 0, _o = _o + Math.imul(Sa, ia) | 0, Fi = Fi + Math.imul(Sa, oa) | 0, Fi = Fi + Math.imul(da, ia) | 0, xo = xo + Math.imul(da, oa) | 0, _o = _o + Math.imul(wa, ua) | 0, Fi = Fi + Math.imul(wa, na) | 0, Fi = Fi + Math.imul(ha, ua) | 0, xo = xo + Math.imul(ha, na) | 0, _o = _o + Math.imul(ba, pa) | 0, Fi = Fi + Math.imul(ba, la) | 0, Fi = Fi + Math.imul(ma, pa) | 0, xo = xo + Math.imul(ma, la) | 0, _o = _o + Math.imul(ra, Da) | 0, Fi = Fi + Math.imul(ra, Ta) | 0, Fi = Fi + Math.imul(sa, Da) | 0, xo = xo + Math.imul(sa, Ta) | 0, _o = _o + Math.imul(Lo, ja) | 0, Fi = Fi + Math.imul(Lo, za) | 0, Fi = Fi + Math.imul(Zo, ja) | 0, xo = xo + Math.imul(Zo, za) | 0;
      var hl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (hl >>> 26) | 0, hl &= 67108863, _o = Math.imul(Oa, Ia), Fi = Math.imul(Oa, Ho), Fi = Fi + Math.imul(ya, Ia) | 0, xo = Math.imul(ya, Ho), _o = _o + Math.imul(Ea, Go) | 0, Fi = Fi + Math.imul(Ea, Xo) | 0, Fi = Fi + Math.imul(fa, Go) | 0, xo = xo + Math.imul(fa, Xo) | 0, _o = _o + Math.imul(va, ia) | 0, Fi = Fi + Math.imul(va, oa) | 0, Fi = Fi + Math.imul(ca, ia) | 0, xo = xo + Math.imul(ca, oa) | 0, _o = _o + Math.imul(Sa, ua) | 0, Fi = Fi + Math.imul(Sa, na) | 0, Fi = Fi + Math.imul(da, ua) | 0, xo = xo + Math.imul(da, na) | 0, _o = _o + Math.imul(wa, pa) | 0, Fi = Fi + Math.imul(wa, la) | 0, Fi = Fi + Math.imul(ha, pa) | 0, xo = xo + Math.imul(ha, la) | 0, _o = _o + Math.imul(ba, Da) | 0, Fi = Fi + Math.imul(ba, Ta) | 0, Fi = Fi + Math.imul(ma, Da) | 0, xo = xo + Math.imul(ma, Ta) | 0, _o = _o + Math.imul(ra, ja) | 0, Fi = Fi + Math.imul(ra, za) | 0, Fi = Fi + Math.imul(sa, ja) | 0, xo = xo + Math.imul(sa, za) | 0;
      var gl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (gl >>> 26) | 0, gl &= 67108863, _o = Math.imul(Oa, Go), Fi = Math.imul(Oa, Xo), Fi = Fi + Math.imul(ya, Go) | 0, xo = Math.imul(ya, Xo), _o = _o + Math.imul(Ea, ia) | 0, Fi = Fi + Math.imul(Ea, oa) | 0, Fi = Fi + Math.imul(fa, ia) | 0, xo = xo + Math.imul(fa, oa) | 0, _o = _o + Math.imul(va, ua) | 0, Fi = Fi + Math.imul(va, na) | 0, Fi = Fi + Math.imul(ca, ua) | 0, xo = xo + Math.imul(ca, na) | 0, _o = _o + Math.imul(Sa, pa) | 0, Fi = Fi + Math.imul(Sa, la) | 0, Fi = Fi + Math.imul(da, pa) | 0, xo = xo + Math.imul(da, la) | 0, _o = _o + Math.imul(wa, Da) | 0, Fi = Fi + Math.imul(wa, Ta) | 0, Fi = Fi + Math.imul(ha, Da) | 0, xo = xo + Math.imul(ha, Ta) | 0, _o = _o + Math.imul(ba, ja) | 0, Fi = Fi + Math.imul(ba, za) | 0, Fi = Fi + Math.imul(ma, ja) | 0, xo = xo + Math.imul(ma, za) | 0;
      var il = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (il >>> 26) | 0, il &= 67108863, _o = Math.imul(Oa, ia), Fi = Math.imul(Oa, oa), Fi = Fi + Math.imul(ya, ia) | 0, xo = Math.imul(ya, oa), _o = _o + Math.imul(Ea, ua) | 0, Fi = Fi + Math.imul(Ea, na) | 0, Fi = Fi + Math.imul(fa, ua) | 0, xo = xo + Math.imul(fa, na) | 0, _o = _o + Math.imul(va, pa) | 0, Fi = Fi + Math.imul(va, la) | 0, Fi = Fi + Math.imul(ca, pa) | 0, xo = xo + Math.imul(ca, la) | 0, _o = _o + Math.imul(Sa, Da) | 0, Fi = Fi + Math.imul(Sa, Ta) | 0, Fi = Fi + Math.imul(da, Da) | 0, xo = xo + Math.imul(da, Ta) | 0, _o = _o + Math.imul(wa, ja) | 0, Fi = Fi + Math.imul(wa, za) | 0, Fi = Fi + Math.imul(ha, ja) | 0, xo = xo + Math.imul(ha, za) | 0;
      var yl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (yl >>> 26) | 0, yl &= 67108863, _o = Math.imul(Oa, ua), Fi = Math.imul(Oa, na), Fi = Fi + Math.imul(ya, ua) | 0, xo = Math.imul(ya, na), _o = _o + Math.imul(Ea, pa) | 0, Fi = Fi + Math.imul(Ea, la) | 0, Fi = Fi + Math.imul(fa, pa) | 0, xo = xo + Math.imul(fa, la) | 0, _o = _o + Math.imul(va, Da) | 0, Fi = Fi + Math.imul(va, Ta) | 0, Fi = Fi + Math.imul(ca, Da) | 0, xo = xo + Math.imul(ca, Ta) | 0, _o = _o + Math.imul(Sa, ja) | 0, Fi = Fi + Math.imul(Sa, za) | 0, Fi = Fi + Math.imul(da, ja) | 0, xo = xo + Math.imul(da, za) | 0;
      var bl = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (bl >>> 26) | 0, bl &= 67108863, _o = Math.imul(Oa, pa), Fi = Math.imul(Oa, la), Fi = Fi + Math.imul(ya, pa) | 0, xo = Math.imul(ya, la), _o = _o + Math.imul(Ea, Da) | 0, Fi = Fi + Math.imul(Ea, Ta) | 0, Fi = Fi + Math.imul(fa, Da) | 0, xo = xo + Math.imul(fa, Ta) | 0, _o = _o + Math.imul(va, ja) | 0, Fi = Fi + Math.imul(va, za) | 0, Fi = Fi + Math.imul(ca, ja) | 0, xo = xo + Math.imul(ca, za) | 0;
      var ml = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (ml >>> 26) | 0, ml &= 67108863, _o = Math.imul(Oa, Da), Fi = Math.imul(Oa, Ta), Fi = Fi + Math.imul(ya, Da) | 0, xo = Math.imul(ya, Ta), _o = _o + Math.imul(Ea, ja) | 0, Fi = Fi + Math.imul(Ea, za) | 0, Fi = Fi + Math.imul(fa, ja) | 0, xo = xo + Math.imul(fa, za) | 0;
      var Ol = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      zi = (xo + (Fi >>> 13) | 0) + (Ol >>> 26) | 0, Ol &= 67108863, _o = Math.imul(Oa, ja), Fi = Math.imul(Oa, za), Fi = Fi + Math.imul(ya, ja) | 0, xo = Math.imul(ya, za);
      var $l = (zi + _o | 0) + ((Fi & 8191) << 13) | 0;
      return zi = (xo + (Fi >>> 13) | 0) + ($l >>> 26) | 0, $l &= 67108863, Eo[0] = Qa, Eo[1] = tl, Eo[2] = Xa, Eo[3] = ol, Eo[4] = Za, Eo[5] = ul, Eo[6] = cl, Eo[7] = fl, Eo[8] = pl, Eo[9] = dl, Eo[10] = al, Eo[11] = hl, Eo[12] = gl, Eo[13] = il, Eo[14] = yl, Eo[15] = bl, Eo[16] = ml, Eo[17] = Ol, Eo[18] = $l, zi !== 0 && (Eo[19] = zi, Ui.length++), Ui;
    };
    Math.imul || (Io = Fo);
    function Uo(Li, Ai, Ni) {
      Ni.negative = Ai.negative ^ Li.negative, Ni.length = Li.length + Ai.length;
      for (var Ui = 0, So = 0, $o = 0; $o < Ni.length - 1; $o++) {
        var Eo = So;
        So = 0;
        for (var zi = Ui & 67108863, _o = Math.min($o, Ai.length - 1), Fi = Math.max(0, $o - Li.length + 1); Fi <= _o; Fi++) {
          var xo = $o - Fi, Qo = Li.words[xo] | 0, To = Ai.words[Fi] | 0, Ko = Qo * To, Vo = Ko & 67108863;
          Eo = Eo + (Ko / 67108864 | 0) | 0, Vo = Vo + zi | 0, zi = Vo & 67108863, Eo = Eo + (Vo >>> 26) | 0, So += Eo >>> 26, Eo &= 67108863;
        }
        Ni.words[$o] = zi, Ui = Eo, Eo = So;
      }
      return Ui !== 0 ? Ni.words[$o] = Ui : Ni.length--, Ni._strip();
    }
    function Co(Li, Ai, Ni) {
      return Uo(Li, Ai, Ni);
    }
    Ei.prototype.mulTo = function(Ai, Ni) {
      var Ui, So = this.length + Ai.length;
      return this.length === 10 && Ai.length === 10 ? Ui = Io(this, Ai, Ni) : So < 63 ? Ui = Fo(this, Ai, Ni) : So < 1024 ? Ui = Uo(this, Ai, Ni) : Ui = Co(this, Ai, Ni), Ui;
    }, Ei.prototype.mul = function(Ai) {
      var Ni = new Ei(null);
      return Ni.words = new Array(this.length + Ai.length), this.mulTo(Ai, Ni);
    }, Ei.prototype.mulf = function(Ai) {
      var Ni = new Ei(null);
      return Ni.words = new Array(this.length + Ai.length), Co(this, Ai, Ni);
    }, Ei.prototype.imul = function(Ai) {
      return this.clone().mulTo(Ai, this);
    }, Ei.prototype.imuln = function(Ai) {
      var Ni = Ai < 0;
      Ni && (Ai = -Ai), Si(typeof Ai == "number"), Si(Ai < 67108864);
      for (var Ui = 0, So = 0; So < this.length; So++) {
        var $o = (this.words[So] | 0) * Ai, Eo = ($o & 67108863) + (Ui & 67108863);
        Ui >>= 26, Ui += $o / 67108864 | 0, Ui += Eo >>> 26, this.words[So] = Eo & 67108863;
      }
      return Ui !== 0 && (this.words[So] = Ui, this.length++), Ni ? this.ineg() : this;
    }, Ei.prototype.muln = function(Ai) {
      return this.clone().imuln(Ai);
    }, Ei.prototype.sqr = function() {
      return this.mul(this);
    }, Ei.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ei.prototype.pow = function(Ai) {
      var Ni = Bo(Ai);
      if (Ni.length === 0)
        return new Ei(1);
      for (var Ui = this, So = 0; So < Ni.length && Ni[So] === 0; So++, Ui = Ui.sqr())
        ;
      if (++So < Ni.length)
        for (var $o = Ui.sqr(); So < Ni.length; So++, $o = $o.sqr())
          Ni[So] !== 0 && (Ui = Ui.mul($o));
      return Ui;
    }, Ei.prototype.iushln = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26, So = 67108863 >>> 26 - Ni << 26 - Ni, $o;
      if (Ni !== 0) {
        var Eo = 0;
        for ($o = 0; $o < this.length; $o++) {
          var zi = this.words[$o] & So, _o = (this.words[$o] | 0) - zi << Ni;
          this.words[$o] = _o | Eo, Eo = zi >>> 26 - Ni;
        }
        Eo && (this.words[$o] = Eo, this.length++);
      }
      if (Ui !== 0) {
        for ($o = this.length - 1; $o >= 0; $o--)
          this.words[$o + Ui] = this.words[$o];
        for ($o = 0; $o < Ui; $o++)
          this.words[$o] = 0;
        this.length += Ui;
      }
      return this._strip();
    }, Ei.prototype.ishln = function(Ai) {
      return Si(this.negative === 0), this.iushln(Ai);
    }, Ei.prototype.iushrn = function(Ai, Ni, Ui) {
      Si(typeof Ai == "number" && Ai >= 0);
      var So;
      Ni ? So = (Ni - Ni % 26) / 26 : So = 0;
      var $o = Ai % 26, Eo = Math.min((Ai - $o) / 26, this.length), zi = 67108863 ^ 67108863 >>> $o << $o, _o = Ui;
      if (So -= Eo, So = Math.max(0, So), _o) {
        for (var Fi = 0; Fi < Eo; Fi++)
          _o.words[Fi] = this.words[Fi];
        _o.length = Eo;
      }
      if (Eo !== 0)
        if (this.length > Eo)
          for (this.length -= Eo, Fi = 0; Fi < this.length; Fi++)
            this.words[Fi] = this.words[Fi + Eo];
        else
          this.words[0] = 0, this.length = 1;
      var xo = 0;
      for (Fi = this.length - 1; Fi >= 0 && (xo !== 0 || Fi >= So); Fi--) {
        var Qo = this.words[Fi] | 0;
        this.words[Fi] = xo << 26 - $o | Qo >>> $o, xo = Qo & zi;
      }
      return _o && xo !== 0 && (_o.words[_o.length++] = xo), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, Ei.prototype.ishrn = function(Ai, Ni, Ui) {
      return Si(this.negative === 0), this.iushrn(Ai, Ni, Ui);
    }, Ei.prototype.shln = function(Ai) {
      return this.clone().ishln(Ai);
    }, Ei.prototype.ushln = function(Ai) {
      return this.clone().iushln(Ai);
    }, Ei.prototype.shrn = function(Ai) {
      return this.clone().ishrn(Ai);
    }, Ei.prototype.ushrn = function(Ai) {
      return this.clone().iushrn(Ai);
    }, Ei.prototype.testn = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26, So = 1 << Ni;
      if (this.length <= Ui)
        return !1;
      var $o = this.words[Ui];
      return !!($o & So);
    }, Ei.prototype.imaskn = function(Ai) {
      Si(typeof Ai == "number" && Ai >= 0);
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26;
      if (Si(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ui)
        return this;
      if (Ni !== 0 && Ui++, this.length = Math.min(Ui, this.length), Ni !== 0) {
        var So = 67108863 ^ 67108863 >>> Ni << Ni;
        this.words[this.length - 1] &= So;
      }
      return this._strip();
    }, Ei.prototype.maskn = function(Ai) {
      return this.clone().imaskn(Ai);
    }, Ei.prototype.iaddn = function(Ai) {
      return Si(typeof Ai == "number"), Si(Ai < 67108864), Ai < 0 ? this.isubn(-Ai) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= Ai ? (this.words[0] = Ai - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Ai), this.negative = 1, this) : this._iaddn(Ai);
    }, Ei.prototype._iaddn = function(Ai) {
      this.words[0] += Ai;
      for (var Ni = 0; Ni < this.length && this.words[Ni] >= 67108864; Ni++)
        this.words[Ni] -= 67108864, Ni === this.length - 1 ? this.words[Ni + 1] = 1 : this.words[Ni + 1]++;
      return this.length = Math.max(this.length, Ni + 1), this;
    }, Ei.prototype.isubn = function(Ai) {
      if (Si(typeof Ai == "number"), Si(Ai < 67108864), Ai < 0)
        return this.iaddn(-Ai);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Ai), this.negative = 1, this;
      if (this.words[0] -= Ai, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ni = 0; Ni < this.length && this.words[Ni] < 0; Ni++)
          this.words[Ni] += 67108864, this.words[Ni + 1] -= 1;
      return this._strip();
    }, Ei.prototype.addn = function(Ai) {
      return this.clone().iaddn(Ai);
    }, Ei.prototype.subn = function(Ai) {
      return this.clone().isubn(Ai);
    }, Ei.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Ei.prototype.abs = function() {
      return this.clone().iabs();
    }, Ei.prototype._ishlnsubmul = function(Ai, Ni, Ui) {
      var So = Ai.length + Ui, $o;
      this._expand(So);
      var Eo, zi = 0;
      for ($o = 0; $o < Ai.length; $o++) {
        Eo = (this.words[$o + Ui] | 0) + zi;
        var _o = (Ai.words[$o] | 0) * Ni;
        Eo -= _o & 67108863, zi = (Eo >> 26) - (_o / 67108864 | 0), this.words[$o + Ui] = Eo & 67108863;
      }
      for (; $o < this.length - Ui; $o++)
        Eo = (this.words[$o + Ui] | 0) + zi, zi = Eo >> 26, this.words[$o + Ui] = Eo & 67108863;
      if (zi === 0)
        return this._strip();
      for (Si(zi === -1), zi = 0, $o = 0; $o < this.length; $o++)
        Eo = -(this.words[$o] | 0) + zi, zi = Eo >> 26, this.words[$o] = Eo & 67108863;
      return this.negative = 1, this._strip();
    }, Ei.prototype._wordDiv = function(Ai, Ni) {
      var Ui = this.length - Ai.length, So = this.clone(), $o = Ai, Eo = $o.words[$o.length - 1] | 0, zi = this._countBits(Eo);
      Ui = 26 - zi, Ui !== 0 && ($o = $o.ushln(Ui), So.iushln(Ui), Eo = $o.words[$o.length - 1] | 0);
      var _o = So.length - $o.length, Fi;
      if (Ni !== "mod") {
        Fi = new Ei(null), Fi.length = _o + 1, Fi.words = new Array(Fi.length);
        for (var xo = 0; xo < Fi.length; xo++)
          Fi.words[xo] = 0;
      }
      var Qo = So.clone()._ishlnsubmul($o, 1, _o);
      Qo.negative === 0 && (So = Qo, Fi && (Fi.words[_o] = 1));
      for (var To = _o - 1; To >= 0; To--) {
        var Ko = (So.words[$o.length + To] | 0) * 67108864 + (So.words[$o.length + To - 1] | 0);
        for (Ko = Math.min(Ko / Eo | 0, 67108863), So._ishlnsubmul($o, Ko, To); So.negative !== 0; )
          Ko--, So.negative = 0, So._ishlnsubmul($o, 1, To), So.isZero() || (So.negative ^= 1);
        Fi && (Fi.words[To] = Ko);
      }
      return Fi && Fi._strip(), So._strip(), Ni !== "div" && Ui !== 0 && So.iushrn(Ui), {
        div: Fi || null,
        mod: So
      };
    }, Ei.prototype.divmod = function(Ai, Ni, Ui) {
      if (Si(!Ai.isZero()), this.isZero())
        return {
          div: new Ei(0),
          mod: new Ei(0)
        };
      var So, $o, Eo;
      return this.negative !== 0 && Ai.negative === 0 ? (Eo = this.neg().divmod(Ai, Ni), Ni !== "mod" && (So = Eo.div.neg()), Ni !== "div" && ($o = Eo.mod.neg(), Ui && $o.negative !== 0 && $o.iadd(Ai)), {
        div: So,
        mod: $o
      }) : this.negative === 0 && Ai.negative !== 0 ? (Eo = this.divmod(Ai.neg(), Ni), Ni !== "mod" && (So = Eo.div.neg()), {
        div: So,
        mod: Eo.mod
      }) : this.negative & Ai.negative ? (Eo = this.neg().divmod(Ai.neg(), Ni), Ni !== "div" && ($o = Eo.mod.neg(), Ui && $o.negative !== 0 && $o.isub(Ai)), {
        div: Eo.div,
        mod: $o
      }) : Ai.length > this.length || this.cmp(Ai) < 0 ? {
        div: new Ei(0),
        mod: this
      } : Ai.length === 1 ? Ni === "div" ? {
        div: this.divn(Ai.words[0]),
        mod: null
      } : Ni === "mod" ? {
        div: null,
        mod: new Ei(this.modrn(Ai.words[0]))
      } : {
        div: this.divn(Ai.words[0]),
        mod: new Ei(this.modrn(Ai.words[0]))
      } : this._wordDiv(Ai, Ni);
    }, Ei.prototype.div = function(Ai) {
      return this.divmod(Ai, "div", !1).div;
    }, Ei.prototype.mod = function(Ai) {
      return this.divmod(Ai, "mod", !1).mod;
    }, Ei.prototype.umod = function(Ai) {
      return this.divmod(Ai, "mod", !0).mod;
    }, Ei.prototype.divRound = function(Ai) {
      var Ni = this.divmod(Ai);
      if (Ni.mod.isZero())
        return Ni.div;
      var Ui = Ni.div.negative !== 0 ? Ni.mod.isub(Ai) : Ni.mod, So = Ai.ushrn(1), $o = Ai.andln(1), Eo = Ui.cmp(So);
      return Eo < 0 || $o === 1 && Eo === 0 ? Ni.div : Ni.div.negative !== 0 ? Ni.div.isubn(1) : Ni.div.iaddn(1);
    }, Ei.prototype.modrn = function(Ai) {
      var Ni = Ai < 0;
      Ni && (Ai = -Ai), Si(Ai <= 67108863);
      for (var Ui = (1 << 26) % Ai, So = 0, $o = this.length - 1; $o >= 0; $o--)
        So = (Ui * So + (this.words[$o] | 0)) % Ai;
      return Ni ? -So : So;
    }, Ei.prototype.modn = function(Ai) {
      return this.modrn(Ai);
    }, Ei.prototype.idivn = function(Ai) {
      var Ni = Ai < 0;
      Ni && (Ai = -Ai), Si(Ai <= 67108863);
      for (var Ui = 0, So = this.length - 1; So >= 0; So--) {
        var $o = (this.words[So] | 0) + Ui * 67108864;
        this.words[So] = $o / Ai | 0, Ui = $o % Ai;
      }
      return this._strip(), Ni ? this.ineg() : this;
    }, Ei.prototype.divn = function(Ai) {
      return this.clone().idivn(Ai);
    }, Ei.prototype.egcd = function(Ai) {
      Si(Ai.negative === 0), Si(!Ai.isZero());
      var Ni = this, Ui = Ai.clone();
      Ni.negative !== 0 ? Ni = Ni.umod(Ai) : Ni = Ni.clone();
      for (var So = new Ei(1), $o = new Ei(0), Eo = new Ei(0), zi = new Ei(1), _o = 0; Ni.isEven() && Ui.isEven(); )
        Ni.iushrn(1), Ui.iushrn(1), ++_o;
      for (var Fi = Ui.clone(), xo = Ni.clone(); !Ni.isZero(); ) {
        for (var Qo = 0, To = 1; !(Ni.words[0] & To) && Qo < 26; ++Qo, To <<= 1)
          ;
        if (Qo > 0)
          for (Ni.iushrn(Qo); Qo-- > 0; )
            (So.isOdd() || $o.isOdd()) && (So.iadd(Fi), $o.isub(xo)), So.iushrn(1), $o.iushrn(1);
        for (var Ko = 0, Vo = 1; !(Ui.words[0] & Vo) && Ko < 26; ++Ko, Vo <<= 1)
          ;
        if (Ko > 0)
          for (Ui.iushrn(Ko); Ko-- > 0; )
            (Eo.isOdd() || zi.isOdd()) && (Eo.iadd(Fi), zi.isub(xo)), Eo.iushrn(1), zi.iushrn(1);
        Ni.cmp(Ui) >= 0 ? (Ni.isub(Ui), So.isub(Eo), $o.isub(zi)) : (Ui.isub(Ni), Eo.isub(So), zi.isub($o));
      }
      return {
        a: Eo,
        b: zi,
        gcd: Ui.iushln(_o)
      };
    }, Ei.prototype._invmp = function(Ai) {
      Si(Ai.negative === 0), Si(!Ai.isZero());
      var Ni = this, Ui = Ai.clone();
      Ni.negative !== 0 ? Ni = Ni.umod(Ai) : Ni = Ni.clone();
      for (var So = new Ei(1), $o = new Ei(0), Eo = Ui.clone(); Ni.cmpn(1) > 0 && Ui.cmpn(1) > 0; ) {
        for (var zi = 0, _o = 1; !(Ni.words[0] & _o) && zi < 26; ++zi, _o <<= 1)
          ;
        if (zi > 0)
          for (Ni.iushrn(zi); zi-- > 0; )
            So.isOdd() && So.iadd(Eo), So.iushrn(1);
        for (var Fi = 0, xo = 1; !(Ui.words[0] & xo) && Fi < 26; ++Fi, xo <<= 1)
          ;
        if (Fi > 0)
          for (Ui.iushrn(Fi); Fi-- > 0; )
            $o.isOdd() && $o.iadd(Eo), $o.iushrn(1);
        Ni.cmp(Ui) >= 0 ? (Ni.isub(Ui), So.isub($o)) : (Ui.isub(Ni), $o.isub(So));
      }
      var Qo;
      return Ni.cmpn(1) === 0 ? Qo = So : Qo = $o, Qo.cmpn(0) < 0 && Qo.iadd(Ai), Qo;
    }, Ei.prototype.gcd = function(Ai) {
      if (this.isZero())
        return Ai.abs();
      if (Ai.isZero())
        return this.abs();
      var Ni = this.clone(), Ui = Ai.clone();
      Ni.negative = 0, Ui.negative = 0;
      for (var So = 0; Ni.isEven() && Ui.isEven(); So++)
        Ni.iushrn(1), Ui.iushrn(1);
      do {
        for (; Ni.isEven(); )
          Ni.iushrn(1);
        for (; Ui.isEven(); )
          Ui.iushrn(1);
        var $o = Ni.cmp(Ui);
        if ($o < 0) {
          var Eo = Ni;
          Ni = Ui, Ui = Eo;
        } else if ($o === 0 || Ui.cmpn(1) === 0)
          break;
        Ni.isub(Ui);
      } while (!0);
      return Ui.iushln(So);
    }, Ei.prototype.invm = function(Ai) {
      return this.egcd(Ai).a.umod(Ai);
    }, Ei.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Ei.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Ei.prototype.andln = function(Ai) {
      return this.words[0] & Ai;
    }, Ei.prototype.bincn = function(Ai) {
      Si(typeof Ai == "number");
      var Ni = Ai % 26, Ui = (Ai - Ni) / 26, So = 1 << Ni;
      if (this.length <= Ui)
        return this._expand(Ui + 1), this.words[Ui] |= So, this;
      for (var $o = So, Eo = Ui; $o !== 0 && Eo < this.length; Eo++) {
        var zi = this.words[Eo] | 0;
        zi += $o, $o = zi >>> 26, zi &= 67108863, this.words[Eo] = zi;
      }
      return $o !== 0 && (this.words[Eo] = $o, this.length++), this;
    }, Ei.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Ei.prototype.cmpn = function(Ai) {
      var Ni = Ai < 0;
      if (this.negative !== 0 && !Ni)
        return -1;
      if (this.negative === 0 && Ni)
        return 1;
      this._strip();
      var Ui;
      if (this.length > 1)
        Ui = 1;
      else {
        Ni && (Ai = -Ai), Si(Ai <= 67108863, "Number is too big");
        var So = this.words[0] | 0;
        Ui = So === Ai ? 0 : So < Ai ? -1 : 1;
      }
      return this.negative !== 0 ? -Ui | 0 : Ui;
    }, Ei.prototype.cmp = function(Ai) {
      if (this.negative !== 0 && Ai.negative === 0)
        return -1;
      if (this.negative === 0 && Ai.negative !== 0)
        return 1;
      var Ni = this.ucmp(Ai);
      return this.negative !== 0 ? -Ni | 0 : Ni;
    }, Ei.prototype.ucmp = function(Ai) {
      if (this.length > Ai.length)
        return 1;
      if (this.length < Ai.length)
        return -1;
      for (var Ni = 0, Ui = this.length - 1; Ui >= 0; Ui--) {
        var So = this.words[Ui] | 0, $o = Ai.words[Ui] | 0;
        if (So !== $o) {
          So < $o ? Ni = -1 : So > $o && (Ni = 1);
          break;
        }
      }
      return Ni;
    }, Ei.prototype.gtn = function(Ai) {
      return this.cmpn(Ai) === 1;
    }, Ei.prototype.gt = function(Ai) {
      return this.cmp(Ai) === 1;
    }, Ei.prototype.gten = function(Ai) {
      return this.cmpn(Ai) >= 0;
    }, Ei.prototype.gte = function(Ai) {
      return this.cmp(Ai) >= 0;
    }, Ei.prototype.ltn = function(Ai) {
      return this.cmpn(Ai) === -1;
    }, Ei.prototype.lt = function(Ai) {
      return this.cmp(Ai) === -1;
    }, Ei.prototype.lten = function(Ai) {
      return this.cmpn(Ai) <= 0;
    }, Ei.prototype.lte = function(Ai) {
      return this.cmp(Ai) <= 0;
    }, Ei.prototype.eqn = function(Ai) {
      return this.cmpn(Ai) === 0;
    }, Ei.prototype.eq = function(Ai) {
      return this.cmp(Ai) === 0;
    }, Ei.red = function(Ai) {
      return new Do(Ai);
    }, Ei.prototype.toRed = function(Ai) {
      return Si(!this.red, "Already a number in reduction context"), Si(this.negative === 0, "red works only with positives"), Ai.convertTo(this)._forceRed(Ai);
    }, Ei.prototype.fromRed = function() {
      return Si(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Ei.prototype._forceRed = function(Ai) {
      return this.red = Ai, this;
    }, Ei.prototype.forceRed = function(Ai) {
      return Si(!this.red, "Already a number in reduction context"), this._forceRed(Ai);
    }, Ei.prototype.redAdd = function(Ai) {
      return Si(this.red, "redAdd works only with red numbers"), this.red.add(this, Ai);
    }, Ei.prototype.redIAdd = function(Ai) {
      return Si(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Ai);
    }, Ei.prototype.redSub = function(Ai) {
      return Si(this.red, "redSub works only with red numbers"), this.red.sub(this, Ai);
    }, Ei.prototype.redISub = function(Ai) {
      return Si(this.red, "redISub works only with red numbers"), this.red.isub(this, Ai);
    }, Ei.prototype.redShl = function(Ai) {
      return Si(this.red, "redShl works only with red numbers"), this.red.shl(this, Ai);
    }, Ei.prototype.redMul = function(Ai) {
      return Si(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ai), this.red.mul(this, Ai);
    }, Ei.prototype.redIMul = function(Ai) {
      return Si(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ai), this.red.imul(this, Ai);
    }, Ei.prototype.redSqr = function() {
      return Si(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Ei.prototype.redISqr = function() {
      return Si(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Ei.prototype.redSqrt = function() {
      return Si(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Ei.prototype.redInvm = function() {
      return Si(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Ei.prototype.redNeg = function() {
      return Si(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Ei.prototype.redPow = function(Ai) {
      return Si(this.red && !Ai.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Ai);
    };
    var ko = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Po(Li, Ai) {
      this.name = Li, this.p = new Ei(Ai, 16), this.n = this.p.bitLength(), this.k = new Ei(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Po.prototype._tmp = function() {
      var Ai = new Ei(null);
      return Ai.words = new Array(Math.ceil(this.n / 13)), Ai;
    }, Po.prototype.ireduce = function(Ai) {
      var Ni = Ai, Ui;
      do
        this.split(Ni, this.tmp), Ni = this.imulK(Ni), Ni = Ni.iadd(this.tmp), Ui = Ni.bitLength();
      while (Ui > this.n);
      var So = Ui < this.n ? -1 : Ni.ucmp(this.p);
      return So === 0 ? (Ni.words[0] = 0, Ni.length = 1) : So > 0 ? Ni.isub(this.p) : Ni.strip !== void 0 ? Ni.strip() : Ni._strip(), Ni;
    }, Po.prototype.split = function(Ai, Ni) {
      Ai.iushrn(this.n, 0, Ni);
    }, Po.prototype.imulK = function(Ai) {
      return Ai.imul(this.k);
    };
    function Mo() {
      Po.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    wi(Mo, Po), Mo.prototype.split = function(Ai, Ni) {
      for (var Ui = 4194303, So = Math.min(Ai.length, 9), $o = 0; $o < So; $o++)
        Ni.words[$o] = Ai.words[$o];
      if (Ni.length = So, Ai.length <= 9) {
        Ai.words[0] = 0, Ai.length = 1;
        return;
      }
      var Eo = Ai.words[9];
      for (Ni.words[Ni.length++] = Eo & Ui, $o = 10; $o < Ai.length; $o++) {
        var zi = Ai.words[$o] | 0;
        Ai.words[$o - 10] = (zi & Ui) << 4 | Eo >>> 22, Eo = zi;
      }
      Eo >>>= 22, Ai.words[$o - 10] = Eo, Eo === 0 && Ai.length > 10 ? Ai.length -= 10 : Ai.length -= 9;
    }, Mo.prototype.imulK = function(Ai) {
      Ai.words[Ai.length] = 0, Ai.words[Ai.length + 1] = 0, Ai.length += 2;
      for (var Ni = 0, Ui = 0; Ui < Ai.length; Ui++) {
        var So = Ai.words[Ui] | 0;
        Ni += So * 977, Ai.words[Ui] = Ni & 67108863, Ni = So * 64 + (Ni / 67108864 | 0);
      }
      return Ai.words[Ai.length - 1] === 0 && (Ai.length--, Ai.words[Ai.length - 1] === 0 && Ai.length--), Ai;
    };
    function No() {
      Po.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    wi(No, Po);
    function Jo() {
      Po.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    wi(Jo, Po);
    function zo() {
      Po.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    wi(zo, Po), zo.prototype.imulK = function(Ai) {
      for (var Ni = 0, Ui = 0; Ui < Ai.length; Ui++) {
        var So = (Ai.words[Ui] | 0) * 19 + Ni, $o = So & 67108863;
        So >>>= 26, Ai.words[Ui] = $o, Ni = So;
      }
      return Ni !== 0 && (Ai.words[Ai.length++] = Ni), Ai;
    }, Ei._prime = function(Ai) {
      if (ko[Ai])
        return ko[Ai];
      var Ni;
      if (Ai === "k256")
        Ni = new Mo();
      else if (Ai === "p224")
        Ni = new No();
      else if (Ai === "p192")
        Ni = new Jo();
      else if (Ai === "p25519")
        Ni = new zo();
      else
        throw new Error("Unknown prime " + Ai);
      return ko[Ai] = Ni, Ni;
    };
    function Do(Li) {
      if (typeof Li == "string") {
        var Ai = Ei._prime(Li);
        this.m = Ai.p, this.prime = Ai;
      } else
        Si(Li.gtn(1), "modulus must be greater than 1"), this.m = Li, this.prime = null;
    }
    Do.prototype._verify1 = function(Ai) {
      Si(Ai.negative === 0, "red works only with positives"), Si(Ai.red, "red works only with red numbers");
    }, Do.prototype._verify2 = function(Ai, Ni) {
      Si((Ai.negative | Ni.negative) === 0, "red works only with positives"), Si(
        Ai.red && Ai.red === Ni.red,
        "red works only with red numbers"
      );
    }, Do.prototype.imod = function(Ai) {
      return this.prime ? this.prime.ireduce(Ai)._forceRed(this) : (Oi(Ai, Ai.umod(this.m)._forceRed(this)), Ai);
    }, Do.prototype.neg = function(Ai) {
      return Ai.isZero() ? Ai.clone() : this.m.sub(Ai)._forceRed(this);
    }, Do.prototype.add = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.add(Ni);
      return Ui.cmp(this.m) >= 0 && Ui.isub(this.m), Ui._forceRed(this);
    }, Do.prototype.iadd = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.iadd(Ni);
      return Ui.cmp(this.m) >= 0 && Ui.isub(this.m), Ui;
    }, Do.prototype.sub = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.sub(Ni);
      return Ui.cmpn(0) < 0 && Ui.iadd(this.m), Ui._forceRed(this);
    }, Do.prototype.isub = function(Ai, Ni) {
      this._verify2(Ai, Ni);
      var Ui = Ai.isub(Ni);
      return Ui.cmpn(0) < 0 && Ui.iadd(this.m), Ui;
    }, Do.prototype.shl = function(Ai, Ni) {
      return this._verify1(Ai), this.imod(Ai.ushln(Ni));
    }, Do.prototype.imul = function(Ai, Ni) {
      return this._verify2(Ai, Ni), this.imod(Ai.imul(Ni));
    }, Do.prototype.mul = function(Ai, Ni) {
      return this._verify2(Ai, Ni), this.imod(Ai.mul(Ni));
    }, Do.prototype.isqr = function(Ai) {
      return this.imul(Ai, Ai.clone());
    }, Do.prototype.sqr = function(Ai) {
      return this.mul(Ai, Ai);
    }, Do.prototype.sqrt = function(Ai) {
      if (Ai.isZero())
        return Ai.clone();
      var Ni = this.m.andln(3);
      if (Si(Ni % 2 === 1), Ni === 3) {
        var Ui = this.m.add(new Ei(1)).iushrn(2);
        return this.pow(Ai, Ui);
      }
      for (var So = this.m.subn(1), $o = 0; !So.isZero() && So.andln(1) === 0; )
        $o++, So.iushrn(1);
      Si(!So.isZero());
      var Eo = new Ei(1).toRed(this), zi = Eo.redNeg(), _o = this.m.subn(1).iushrn(1), Fi = this.m.bitLength();
      for (Fi = new Ei(2 * Fi * Fi).toRed(this); this.pow(Fi, _o).cmp(zi) !== 0; )
        Fi.redIAdd(zi);
      for (var xo = this.pow(Fi, So), Qo = this.pow(Ai, So.addn(1).iushrn(1)), To = this.pow(Ai, So), Ko = $o; To.cmp(Eo) !== 0; ) {
        for (var Vo = To, Wo = 0; Vo.cmp(Eo) !== 0; Wo++)
          Vo = Vo.redSqr();
        Si(Wo < Ko);
        var jo = this.pow(xo, new Ei(1).iushln(Ko - Wo - 1));
        Qo = Qo.redMul(jo), xo = jo.redSqr(), To = To.redMul(xo), Ko = Wo;
      }
      return Qo;
    }, Do.prototype.invm = function(Ai) {
      var Ni = Ai._invmp(this.m);
      return Ni.negative !== 0 ? (Ni.negative = 0, this.imod(Ni).redNeg()) : this.imod(Ni);
    }, Do.prototype.pow = function(Ai, Ni) {
      if (Ni.isZero())
        return new Ei(1).toRed(this);
      if (Ni.cmpn(1) === 0)
        return Ai.clone();
      var Ui = 4, So = new Array(1 << Ui);
      So[0] = new Ei(1).toRed(this), So[1] = Ai;
      for (var $o = 2; $o < So.length; $o++)
        So[$o] = this.mul(So[$o - 1], Ai);
      var Eo = So[0], zi = 0, _o = 0, Fi = Ni.bitLength() % 26;
      for (Fi === 0 && (Fi = 26), $o = Ni.length - 1; $o >= 0; $o--) {
        for (var xo = Ni.words[$o], Qo = Fi - 1; Qo >= 0; Qo--) {
          var To = xo >> Qo & 1;
          if (Eo !== So[0] && (Eo = this.sqr(Eo)), To === 0 && zi === 0) {
            _o = 0;
            continue;
          }
          zi <<= 1, zi |= To, _o++, !(_o !== Ui && ($o !== 0 || Qo !== 0)) && (Eo = this.mul(Eo, So[zi]), _o = 0, zi = 0);
        }
        Fi = 26;
      }
      return Eo;
    }, Do.prototype.convertTo = function(Ai) {
      var Ni = Ai.umod(this.m);
      return Ni === Ai ? Ni.clone() : Ni;
    }, Do.prototype.convertFrom = function(Ai) {
      var Ni = Ai.clone();
      return Ni.red = null, Ni;
    }, Ei.mont = function(Ai) {
      return new wo(Ai);
    };
    function wo(Li) {
      Do.call(this, Li), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Ei(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    wi(wo, Do), wo.prototype.convertTo = function(Ai) {
      return this.imod(Ai.ushln(this.shift));
    }, wo.prototype.convertFrom = function(Ai) {
      var Ni = this.imod(Ai.mul(this.rinv));
      return Ni.red = null, Ni;
    }, wo.prototype.imul = function(Ai, Ni) {
      if (Ai.isZero() || Ni.isZero())
        return Ai.words[0] = 0, Ai.length = 1, Ai;
      var Ui = Ai.imul(Ni), So = Ui.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $o = Ui.isub(So).iushrn(this.shift), Eo = $o;
      return $o.cmp(this.m) >= 0 ? Eo = $o.isub(this.m) : $o.cmpn(0) < 0 && (Eo = $o.iadd(this.m)), Eo._forceRed(this);
    }, wo.prototype.mul = function(Ai, Ni) {
      if (Ai.isZero() || Ni.isZero())
        return new Ei(0)._forceRed(this);
      var Ui = Ai.mul(Ni), So = Ui.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $o = Ui.isub(So).iushrn(this.shift), Eo = $o;
      return $o.cmp(this.m) >= 0 ? Eo = $o.isub(this.m) : $o.cmpn(0) < 0 && (Eo = $o.iadd(this.m)), Eo._forceRed(this);
    }, wo.prototype.invm = function(Ai) {
      var Ni = this.imod(Ai._invmp(this.m).mul(this.r2));
      return Ni._forceRed(this);
    };
  })(se, commonjsGlobal);
})(bn$3);
var bnExports$1 = bn$3.exports;
const BN$8 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports$1);
var hash$4 = {}, utils$o = {}, minimalisticAssert$1 = assert$h;
function assert$h(se, e) {
  if (!se)
    throw new Error(e || "Assertion failed");
}
assert$h.equal = function(e, Oe, Si) {
  if (e != Oe)
    throw new Error(Si || "Assertion failed: " + e + " != " + Oe);
};
var inherits_browser$1 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$1.exports = function(e, Oe) {
  Oe && (e.super_ = Oe, e.prototype = Object.create(Oe.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$1.exports = function(e, Oe) {
  if (Oe) {
    e.super_ = Oe;
    var Si = function() {
    };
    Si.prototype = Oe.prototype, e.prototype = new Si(), e.prototype.constructor = e;
  }
};
var inherits_browserExports = inherits_browser$1.exports, assert$g = minimalisticAssert$1, inherits$3 = inherits_browserExports;
utils$o.inherits = inherits$3;
function isSurrogatePair(se, e) {
  return (se.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= se.length ? !1 : (se.charCodeAt(e + 1) & 64512) === 56320;
}
function toArray(se, e) {
  if (Array.isArray(se))
    return se.slice();
  if (!se)
    return [];
  var Oe = [];
  if (typeof se == "string")
    if (e) {
      if (e === "hex")
        for (se = se.replace(/[^a-z0-9]+/ig, ""), se.length % 2 !== 0 && (se = "0" + se), wi = 0; wi < se.length; wi += 2)
          Oe.push(parseInt(se[wi] + se[wi + 1], 16));
    } else
      for (var Si = 0, wi = 0; wi < se.length; wi++) {
        var Ei = se.charCodeAt(wi);
        Ei < 128 ? Oe[Si++] = Ei : Ei < 2048 ? (Oe[Si++] = Ei >> 6 | 192, Oe[Si++] = Ei & 63 | 128) : isSurrogatePair(se, wi) ? (Ei = 65536 + ((Ei & 1023) << 10) + (se.charCodeAt(++wi) & 1023), Oe[Si++] = Ei >> 18 | 240, Oe[Si++] = Ei >> 12 & 63 | 128, Oe[Si++] = Ei >> 6 & 63 | 128, Oe[Si++] = Ei & 63 | 128) : (Oe[Si++] = Ei >> 12 | 224, Oe[Si++] = Ei >> 6 & 63 | 128, Oe[Si++] = Ei & 63 | 128);
      }
  else
    for (wi = 0; wi < se.length; wi++)
      Oe[wi] = se[wi] | 0;
  return Oe;
}
utils$o.toArray = toArray;
function toHex(se) {
  for (var e = "", Oe = 0; Oe < se.length; Oe++)
    e += zero2(se[Oe].toString(16));
  return e;
}
utils$o.toHex = toHex;
function htonl(se) {
  var e = se >>> 24 | se >>> 8 & 65280 | se << 8 & 16711680 | (se & 255) << 24;
  return e >>> 0;
}
utils$o.htonl = htonl;
function toHex32(se, e) {
  for (var Oe = "", Si = 0; Si < se.length; Si++) {
    var wi = se[Si];
    e === "little" && (wi = htonl(wi)), Oe += zero8(wi.toString(16));
  }
  return Oe;
}
utils$o.toHex32 = toHex32;
function zero2(se) {
  return se.length === 1 ? "0" + se : se;
}
utils$o.zero2 = zero2;
function zero8(se) {
  return se.length === 7 ? "0" + se : se.length === 6 ? "00" + se : se.length === 5 ? "000" + se : se.length === 4 ? "0000" + se : se.length === 3 ? "00000" + se : se.length === 2 ? "000000" + se : se.length === 1 ? "0000000" + se : se;
}
utils$o.zero8 = zero8;
function join32(se, e, Oe, Si) {
  var wi = Oe - e;
  assert$g(wi % 4 === 0);
  for (var Ei = new Array(wi / 4), $i = 0, xi = e; $i < Ei.length; $i++, xi += 4) {
    var Ri;
    Si === "big" ? Ri = se[xi] << 24 | se[xi + 1] << 16 | se[xi + 2] << 8 | se[xi + 3] : Ri = se[xi + 3] << 24 | se[xi + 2] << 16 | se[xi + 1] << 8 | se[xi], Ei[$i] = Ri >>> 0;
  }
  return Ei;
}
utils$o.join32 = join32;
function split32(se, e) {
  for (var Oe = new Array(se.length * 4), Si = 0, wi = 0; Si < se.length; Si++, wi += 4) {
    var Ei = se[Si];
    e === "big" ? (Oe[wi] = Ei >>> 24, Oe[wi + 1] = Ei >>> 16 & 255, Oe[wi + 2] = Ei >>> 8 & 255, Oe[wi + 3] = Ei & 255) : (Oe[wi + 3] = Ei >>> 24, Oe[wi + 2] = Ei >>> 16 & 255, Oe[wi + 1] = Ei >>> 8 & 255, Oe[wi] = Ei & 255);
  }
  return Oe;
}
utils$o.split32 = split32;
function rotr32$1(se, e) {
  return se >>> e | se << 32 - e;
}
utils$o.rotr32 = rotr32$1;
function rotl32$2(se, e) {
  return se << e | se >>> 32 - e;
}
utils$o.rotl32 = rotl32$2;
function sum32$3(se, e) {
  return se + e >>> 0;
}
utils$o.sum32 = sum32$3;
function sum32_3$1(se, e, Oe) {
  return se + e + Oe >>> 0;
}
utils$o.sum32_3 = sum32_3$1;
function sum32_4$2(se, e, Oe, Si) {
  return se + e + Oe + Si >>> 0;
}
utils$o.sum32_4 = sum32_4$2;
function sum32_5$2(se, e, Oe, Si, wi) {
  return se + e + Oe + Si + wi >>> 0;
}
utils$o.sum32_5 = sum32_5$2;
function sum64$1(se, e, Oe, Si) {
  var wi = se[e], Ei = se[e + 1], $i = Si + Ei >>> 0, xi = ($i < Si ? 1 : 0) + Oe + wi;
  se[e] = xi >>> 0, se[e + 1] = $i;
}
utils$o.sum64 = sum64$1;
function sum64_hi$1(se, e, Oe, Si) {
  var wi = e + Si >>> 0, Ei = (wi < e ? 1 : 0) + se + Oe;
  return Ei >>> 0;
}
utils$o.sum64_hi = sum64_hi$1;
function sum64_lo$1(se, e, Oe, Si) {
  var wi = e + Si;
  return wi >>> 0;
}
utils$o.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(se, e, Oe, Si, wi, Ei, $i, xi) {
  var Ri = 0, Ti = e;
  Ti = Ti + Si >>> 0, Ri += Ti < e ? 1 : 0, Ti = Ti + Ei >>> 0, Ri += Ti < Ei ? 1 : 0, Ti = Ti + xi >>> 0, Ri += Ti < xi ? 1 : 0;
  var Oi = se + Oe + wi + $i + Ri;
  return Oi >>> 0;
}
utils$o.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(se, e, Oe, Si, wi, Ei, $i, xi) {
  var Ri = e + Si + Ei + xi;
  return Ri >>> 0;
}
utils$o.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(se, e, Oe, Si, wi, Ei, $i, xi, Ri, Ti) {
  var Oi = 0, Mi = e;
  Mi = Mi + Si >>> 0, Oi += Mi < e ? 1 : 0, Mi = Mi + Ei >>> 0, Oi += Mi < Ei ? 1 : 0, Mi = Mi + xi >>> 0, Oi += Mi < xi ? 1 : 0, Mi = Mi + Ti >>> 0, Oi += Mi < Ti ? 1 : 0;
  var Ii = se + Oe + wi + $i + Ri + Oi;
  return Ii >>> 0;
}
utils$o.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(se, e, Oe, Si, wi, Ei, $i, xi, Ri, Ti) {
  var Oi = e + Si + Ei + xi + Ti;
  return Oi >>> 0;
}
utils$o.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(se, e, Oe) {
  var Si = e << 32 - Oe | se >>> Oe;
  return Si >>> 0;
}
utils$o.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(se, e, Oe) {
  var Si = se << 32 - Oe | e >>> Oe;
  return Si >>> 0;
}
utils$o.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(se, e, Oe) {
  return se >>> Oe;
}
utils$o.shr64_hi = shr64_hi$1;
function shr64_lo$1(se, e, Oe) {
  var Si = se << 32 - Oe | e >>> Oe;
  return Si >>> 0;
}
utils$o.shr64_lo = shr64_lo$1;
var common$6 = {}, utils$n = utils$o, assert$f = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$6.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(e, Oe) {
  if (e = utils$n.toArray(e, Oe), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var Si = e.length % this._delta8;
    this.pending = e.slice(e.length - Si, e.length), this.pending.length === 0 && (this.pending = null), e = utils$n.join32(e, 0, e.length - Si, this.endian);
    for (var wi = 0; wi < e.length; wi += this._delta32)
      this._update(e, wi, wi + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(e) {
  return this.update(this._pad()), assert$f(this.pending === null), this._digest(e);
};
BlockHash$4.prototype._pad = function() {
  var e = this.pendingTotal, Oe = this._delta8, Si = Oe - (e + this.padLength) % Oe, wi = new Array(Si + this.padLength);
  wi[0] = 128;
  for (var Ei = 1; Ei < Si; Ei++)
    wi[Ei] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var $i = 8; $i < this.padLength; $i++)
      wi[Ei++] = 0;
    wi[Ei++] = 0, wi[Ei++] = 0, wi[Ei++] = 0, wi[Ei++] = 0, wi[Ei++] = e >>> 24 & 255, wi[Ei++] = e >>> 16 & 255, wi[Ei++] = e >>> 8 & 255, wi[Ei++] = e & 255;
  } else
    for (wi[Ei++] = e & 255, wi[Ei++] = e >>> 8 & 255, wi[Ei++] = e >>> 16 & 255, wi[Ei++] = e >>> 24 & 255, wi[Ei++] = 0, wi[Ei++] = 0, wi[Ei++] = 0, wi[Ei++] = 0, $i = 8; $i < this.padLength; $i++)
      wi[Ei++] = 0;
  return wi;
};
var sha = {}, common$5 = {}, utils$m = utils$o, rotr32 = utils$m.rotr32;
function ft_1$1(se, e, Oe, Si) {
  if (se === 0)
    return ch32$1(e, Oe, Si);
  if (se === 1 || se === 3)
    return p32(e, Oe, Si);
  if (se === 2)
    return maj32$1(e, Oe, Si);
}
common$5.ft_1 = ft_1$1;
function ch32$1(se, e, Oe) {
  return se & e ^ ~se & Oe;
}
common$5.ch32 = ch32$1;
function maj32$1(se, e, Oe) {
  return se & e ^ se & Oe ^ e & Oe;
}
common$5.maj32 = maj32$1;
function p32(se, e, Oe) {
  return se ^ e ^ Oe;
}
common$5.p32 = p32;
function s0_256$1(se) {
  return rotr32(se, 2) ^ rotr32(se, 13) ^ rotr32(se, 22);
}
common$5.s0_256 = s0_256$1;
function s1_256$1(se) {
  return rotr32(se, 6) ^ rotr32(se, 11) ^ rotr32(se, 25);
}
common$5.s1_256 = s1_256$1;
function g0_256$1(se) {
  return rotr32(se, 7) ^ rotr32(se, 18) ^ se >>> 3;
}
common$5.g0_256 = g0_256$1;
function g1_256$1(se) {
  return rotr32(se, 17) ^ rotr32(se, 19) ^ se >>> 10;
}
common$5.g1_256 = g1_256$1;
var utils$l = utils$o, common$4 = common$6, shaCommon$1 = common$5, rotl32$1 = utils$l.rotl32, sum32$2 = utils$l.sum32, sum32_5$1 = utils$l.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$4.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$l.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(e, Oe) {
  for (var Si = this.W, wi = 0; wi < 16; wi++)
    Si[wi] = e[Oe + wi];
  for (; wi < Si.length; wi++)
    Si[wi] = rotl32$1(Si[wi - 3] ^ Si[wi - 8] ^ Si[wi - 14] ^ Si[wi - 16], 1);
  var Ei = this.h[0], $i = this.h[1], xi = this.h[2], Ri = this.h[3], Ti = this.h[4];
  for (wi = 0; wi < Si.length; wi++) {
    var Oi = ~~(wi / 20), Mi = sum32_5$1(rotl32$1(Ei, 5), ft_1(Oi, $i, xi, Ri), Ti, Si[wi], sha1_K[Oi]);
    Ti = Ri, Ri = xi, xi = rotl32$1($i, 30), $i = Ei, Ei = Mi;
  }
  this.h[0] = sum32$2(this.h[0], Ei), this.h[1] = sum32$2(this.h[1], $i), this.h[2] = sum32$2(this.h[2], xi), this.h[3] = sum32$2(this.h[3], Ri), this.h[4] = sum32$2(this.h[4], Ti);
};
SHA1.prototype._digest = function(e) {
  return e === "hex" ? utils$l.toHex32(this.h, "big") : utils$l.split32(this.h, "big");
};
var utils$k = utils$o, common$3 = common$6, shaCommon = common$5, assert$e = minimalisticAssert$1, sum32$1 = utils$k.sum32, sum32_4$1 = utils$k.sum32_4, sum32_5 = utils$k.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$3.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$2() {
  if (!(this instanceof SHA256$2))
    return new SHA256$2();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$k.inherits(SHA256$2, BlockHash$2);
var _256 = SHA256$2;
SHA256$2.blockSize = 512;
SHA256$2.outSize = 256;
SHA256$2.hmacStrength = 192;
SHA256$2.padLength = 64;
SHA256$2.prototype._update = function(e, Oe) {
  for (var Si = this.W, wi = 0; wi < 16; wi++)
    Si[wi] = e[Oe + wi];
  for (; wi < Si.length; wi++)
    Si[wi] = sum32_4$1(g1_256(Si[wi - 2]), Si[wi - 7], g0_256(Si[wi - 15]), Si[wi - 16]);
  var Ei = this.h[0], $i = this.h[1], xi = this.h[2], Ri = this.h[3], Ti = this.h[4], Oi = this.h[5], Mi = this.h[6], Ii = this.h[7];
  for (assert$e(this.k.length === Si.length), wi = 0; wi < Si.length; wi++) {
    var Ci = sum32_5(Ii, s1_256(Ti), ch32(Ti, Oi, Mi), this.k[wi], Si[wi]), Oo = sum32$1(s0_256(Ei), maj32(Ei, $i, xi));
    Ii = Mi, Mi = Oi, Oi = Ti, Ti = sum32$1(Ri, Ci), Ri = xi, xi = $i, $i = Ei, Ei = sum32$1(Ci, Oo);
  }
  this.h[0] = sum32$1(this.h[0], Ei), this.h[1] = sum32$1(this.h[1], $i), this.h[2] = sum32$1(this.h[2], xi), this.h[3] = sum32$1(this.h[3], Ri), this.h[4] = sum32$1(this.h[4], Ti), this.h[5] = sum32$1(this.h[5], Oi), this.h[6] = sum32$1(this.h[6], Mi), this.h[7] = sum32$1(this.h[7], Ii);
};
SHA256$2.prototype._digest = function(e) {
  return e === "hex" ? utils$k.toHex32(this.h, "big") : utils$k.split32(this.h, "big");
};
var utils$j = utils$o, SHA256$1 = _256;
function SHA224$1() {
  if (!(this instanceof SHA224$1))
    return new SHA224$1();
  SHA256$1.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$j.inherits(SHA224$1, SHA256$1);
var _224 = SHA224$1;
SHA224$1.blockSize = 512;
SHA224$1.outSize = 224;
SHA224$1.hmacStrength = 192;
SHA224$1.padLength = 64;
SHA224$1.prototype._digest = function(e) {
  return e === "hex" ? utils$j.toHex32(this.h.slice(0, 7), "big") : utils$j.split32(this.h.slice(0, 7), "big");
};
var utils$i = utils$o, common$2 = common$6, assert$d = minimalisticAssert$1, rotr64_hi = utils$i.rotr64_hi, rotr64_lo = utils$i.rotr64_lo, shr64_hi = utils$i.shr64_hi, shr64_lo = utils$i.shr64_lo, sum64 = utils$i.sum64, sum64_hi = utils$i.sum64_hi, sum64_lo = utils$i.sum64_lo, sum64_4_hi = utils$i.sum64_4_hi, sum64_4_lo = utils$i.sum64_4_lo, sum64_5_hi = utils$i.sum64_5_hi, sum64_5_lo = utils$i.sum64_5_lo, BlockHash$1 = common$2.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$i.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(e, Oe) {
  for (var Si = this.W, wi = 0; wi < 32; wi++)
    Si[wi] = e[Oe + wi];
  for (; wi < Si.length; wi += 2) {
    var Ei = g1_512_hi(Si[wi - 4], Si[wi - 3]), $i = g1_512_lo(Si[wi - 4], Si[wi - 3]), xi = Si[wi - 14], Ri = Si[wi - 13], Ti = g0_512_hi(Si[wi - 30], Si[wi - 29]), Oi = g0_512_lo(Si[wi - 30], Si[wi - 29]), Mi = Si[wi - 32], Ii = Si[wi - 31];
    Si[wi] = sum64_4_hi(
      Ei,
      $i,
      xi,
      Ri,
      Ti,
      Oi,
      Mi,
      Ii
    ), Si[wi + 1] = sum64_4_lo(
      Ei,
      $i,
      xi,
      Ri,
      Ti,
      Oi,
      Mi,
      Ii
    );
  }
};
SHA512$1.prototype._update = function(e, Oe) {
  this._prepareBlock(e, Oe);
  var Si = this.W, wi = this.h[0], Ei = this.h[1], $i = this.h[2], xi = this.h[3], Ri = this.h[4], Ti = this.h[5], Oi = this.h[6], Mi = this.h[7], Ii = this.h[8], Ci = this.h[9], Oo = this.h[10], Ro = this.h[11], Bo = this.h[12], Fo = this.h[13], Io = this.h[14], Uo = this.h[15];
  assert$d(this.k.length === Si.length);
  for (var Co = 0; Co < Si.length; Co += 2) {
    var ko = Io, Po = Uo, Mo = s1_512_hi(Ii, Ci), No = s1_512_lo(Ii, Ci), Jo = ch64_hi(Ii, Ci, Oo, Ro, Bo), zo = ch64_lo(Ii, Ci, Oo, Ro, Bo, Fo), Do = this.k[Co], wo = this.k[Co + 1], Li = Si[Co], Ai = Si[Co + 1], Ni = sum64_5_hi(
      ko,
      Po,
      Mo,
      No,
      Jo,
      zo,
      Do,
      wo,
      Li,
      Ai
    ), Ui = sum64_5_lo(
      ko,
      Po,
      Mo,
      No,
      Jo,
      zo,
      Do,
      wo,
      Li,
      Ai
    );
    ko = s0_512_hi(wi, Ei), Po = s0_512_lo(wi, Ei), Mo = maj64_hi(wi, Ei, $i, xi, Ri), No = maj64_lo(wi, Ei, $i, xi, Ri, Ti);
    var So = sum64_hi(ko, Po, Mo, No), $o = sum64_lo(ko, Po, Mo, No);
    Io = Bo, Uo = Fo, Bo = Oo, Fo = Ro, Oo = Ii, Ro = Ci, Ii = sum64_hi(Oi, Mi, Ni, Ui), Ci = sum64_lo(Mi, Mi, Ni, Ui), Oi = Ri, Mi = Ti, Ri = $i, Ti = xi, $i = wi, xi = Ei, wi = sum64_hi(Ni, Ui, So, $o), Ei = sum64_lo(Ni, Ui, So, $o);
  }
  sum64(this.h, 0, wi, Ei), sum64(this.h, 2, $i, xi), sum64(this.h, 4, Ri, Ti), sum64(this.h, 6, Oi, Mi), sum64(this.h, 8, Ii, Ci), sum64(this.h, 10, Oo, Ro), sum64(this.h, 12, Bo, Fo), sum64(this.h, 14, Io, Uo);
};
SHA512$1.prototype._digest = function(e) {
  return e === "hex" ? utils$i.toHex32(this.h, "big") : utils$i.split32(this.h, "big");
};
function ch64_hi(se, e, Oe, Si, wi) {
  var Ei = se & Oe ^ ~se & wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function ch64_lo(se, e, Oe, Si, wi, Ei) {
  var $i = e & Si ^ ~e & Ei;
  return $i < 0 && ($i += 4294967296), $i;
}
function maj64_hi(se, e, Oe, Si, wi) {
  var Ei = se & Oe ^ se & wi ^ Oe & wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function maj64_lo(se, e, Oe, Si, wi, Ei) {
  var $i = e & Si ^ e & Ei ^ Si & Ei;
  return $i < 0 && ($i += 4294967296), $i;
}
function s0_512_hi(se, e) {
  var Oe = rotr64_hi(se, e, 28), Si = rotr64_hi(e, se, 2), wi = rotr64_hi(e, se, 7), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function s0_512_lo(se, e) {
  var Oe = rotr64_lo(se, e, 28), Si = rotr64_lo(e, se, 2), wi = rotr64_lo(e, se, 7), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function s1_512_hi(se, e) {
  var Oe = rotr64_hi(se, e, 14), Si = rotr64_hi(se, e, 18), wi = rotr64_hi(e, se, 9), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function s1_512_lo(se, e) {
  var Oe = rotr64_lo(se, e, 14), Si = rotr64_lo(se, e, 18), wi = rotr64_lo(e, se, 9), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function g0_512_hi(se, e) {
  var Oe = rotr64_hi(se, e, 1), Si = rotr64_hi(se, e, 8), wi = shr64_hi(se, e, 7), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function g0_512_lo(se, e) {
  var Oe = rotr64_lo(se, e, 1), Si = rotr64_lo(se, e, 8), wi = shr64_lo(se, e, 7), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function g1_512_hi(se, e) {
  var Oe = rotr64_hi(se, e, 19), Si = rotr64_hi(e, se, 29), wi = shr64_hi(se, e, 6), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
function g1_512_lo(se, e) {
  var Oe = rotr64_lo(se, e, 19), Si = rotr64_lo(e, se, 29), wi = shr64_lo(se, e, 6), Ei = Oe ^ Si ^ wi;
  return Ei < 0 && (Ei += 4294967296), Ei;
}
var utils$h = utils$o, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$h.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(e) {
  return e === "hex" ? utils$h.toHex32(this.h.slice(0, 12), "big") : utils$h.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$g = utils$o, common$1 = common$6, rotl32 = utils$g.rotl32, sum32 = utils$g.sum32, sum32_3 = utils$g.sum32_3, sum32_4 = utils$g.sum32_4, BlockHash = common$1.BlockHash;
function RIPEMD160$1() {
  if (!(this instanceof RIPEMD160$1))
    return new RIPEMD160$1();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$g.inherits(RIPEMD160$1, BlockHash);
ripemd.ripemd160 = RIPEMD160$1;
RIPEMD160$1.blockSize = 512;
RIPEMD160$1.outSize = 160;
RIPEMD160$1.hmacStrength = 192;
RIPEMD160$1.padLength = 64;
RIPEMD160$1.prototype._update = function(e, Oe) {
  for (var Si = this.h[0], wi = this.h[1], Ei = this.h[2], $i = this.h[3], xi = this.h[4], Ri = Si, Ti = wi, Oi = Ei, Mi = $i, Ii = xi, Ci = 0; Ci < 80; Ci++) {
    var Oo = sum32(
      rotl32(
        sum32_4(Si, f$4(Ci, wi, Ei, $i), e[r$2[Ci] + Oe], K$2(Ci)),
        s$1[Ci]
      ),
      xi
    );
    Si = xi, xi = $i, $i = rotl32(Ei, 10), Ei = wi, wi = Oo, Oo = sum32(
      rotl32(
        sum32_4(Ri, f$4(79 - Ci, Ti, Oi, Mi), e[rh[Ci] + Oe], Kh(Ci)),
        sh[Ci]
      ),
      Ii
    ), Ri = Ii, Ii = Mi, Mi = rotl32(Oi, 10), Oi = Ti, Ti = Oo;
  }
  Oo = sum32_3(this.h[1], Ei, Mi), this.h[1] = sum32_3(this.h[2], $i, Ii), this.h[2] = sum32_3(this.h[3], xi, Ri), this.h[3] = sum32_3(this.h[4], Si, Ti), this.h[4] = sum32_3(this.h[0], wi, Oi), this.h[0] = Oo;
};
RIPEMD160$1.prototype._digest = function(e) {
  return e === "hex" ? utils$g.toHex32(this.h, "little") : utils$g.split32(this.h, "little");
};
function f$4(se, e, Oe, Si) {
  return se <= 15 ? e ^ Oe ^ Si : se <= 31 ? e & Oe | ~e & Si : se <= 47 ? (e | ~Oe) ^ Si : se <= 63 ? e & Si | Oe & ~Si : e ^ (Oe | ~Si);
}
function K$2(se) {
  return se <= 15 ? 0 : se <= 31 ? 1518500249 : se <= 47 ? 1859775393 : se <= 63 ? 2400959708 : 2840853838;
}
function Kh(se) {
  return se <= 15 ? 1352829926 : se <= 31 ? 1548603684 : se <= 47 ? 1836072691 : se <= 63 ? 2053994217 : 0;
}
var r$2 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$f = utils$o, assert$c = minimalisticAssert$1;
function Hmac(se, e, Oe) {
  if (!(this instanceof Hmac))
    return new Hmac(se, e, Oe);
  this.Hash = se, this.blockSize = se.blockSize / 8, this.outSize = se.outSize / 8, this.inner = null, this.outer = null, this._init(utils$f.toArray(e, Oe));
}
var hmac = Hmac;
Hmac.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), assert$c(e.length <= this.blockSize);
  for (var Oe = e.length; Oe < this.blockSize; Oe++)
    e.push(0);
  for (Oe = 0; Oe < e.length; Oe++)
    e[Oe] ^= 54;
  for (this.inner = new this.Hash().update(e), Oe = 0; Oe < e.length; Oe++)
    e[Oe] ^= 106;
  this.outer = new this.Hash().update(e);
};
Hmac.prototype.update = function(e, Oe) {
  return this.inner.update(e, Oe), this;
};
Hmac.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(se) {
  var e = se;
  e.utils = utils$o, e.common = common$6, e.sha = sha, e.ripemd = ripemd, e.hmac = hmac, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(hash$4);
const hash$3 = /* @__PURE__ */ getDefaultExportFromCjs(hash$4);
function createCommonjsModule(se, e, Oe) {
  return Oe = {
    path: e,
    exports: {},
    require: function(Si, wi) {
      return commonjsRequire(Si, wi ?? Oe.path);
    }
  }, se(Oe, Oe.exports), Oe.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$b;
function assert$b(se, e) {
  if (!se)
    throw new Error(e || "Assertion failed");
}
assert$b.equal = function(e, Oe, Si) {
  if (e != Oe)
    throw new Error(Si || "Assertion failed: " + e + " != " + Oe);
};
var utils_1$5 = createCommonjsModule(function(se, e) {
  var Oe = e;
  function Si($i, xi) {
    if (Array.isArray($i))
      return $i.slice();
    if (!$i)
      return [];
    var Ri = [];
    if (typeof $i != "string") {
      for (var Ti = 0; Ti < $i.length; Ti++)
        Ri[Ti] = $i[Ti] | 0;
      return Ri;
    }
    if (xi === "hex") {
      $i = $i.replace(/[^a-z0-9]+/ig, ""), $i.length % 2 !== 0 && ($i = "0" + $i);
      for (var Ti = 0; Ti < $i.length; Ti += 2)
        Ri.push(parseInt($i[Ti] + $i[Ti + 1], 16));
    } else
      for (var Ti = 0; Ti < $i.length; Ti++) {
        var Oi = $i.charCodeAt(Ti), Mi = Oi >> 8, Ii = Oi & 255;
        Mi ? Ri.push(Mi, Ii) : Ri.push(Ii);
      }
    return Ri;
  }
  Oe.toArray = Si;
  function wi($i) {
    return $i.length === 1 ? "0" + $i : $i;
  }
  Oe.zero2 = wi;
  function Ei($i) {
    for (var xi = "", Ri = 0; Ri < $i.length; Ri++)
      xi += wi($i[Ri].toString(16));
    return xi;
  }
  Oe.toHex = Ei, Oe.encode = function(xi, Ri) {
    return Ri === "hex" ? Ei(xi) : xi;
  };
}), utils_1$1$1 = createCommonjsModule(function(se, e) {
  var Oe = e;
  Oe.assert = minimalisticAssert, Oe.toArray = utils_1$5.toArray, Oe.zero2 = utils_1$5.zero2, Oe.toHex = utils_1$5.toHex, Oe.encode = utils_1$5.encode;
  function Si(Ri, Ti, Oi) {
    var Mi = new Array(Math.max(Ri.bitLength(), Oi) + 1);
    Mi.fill(0);
    for (var Ii = 1 << Ti + 1, Ci = Ri.clone(), Oo = 0; Oo < Mi.length; Oo++) {
      var Ro, Bo = Ci.andln(Ii - 1);
      Ci.isOdd() ? (Bo > (Ii >> 1) - 1 ? Ro = (Ii >> 1) - Bo : Ro = Bo, Ci.isubn(Ro)) : Ro = 0, Mi[Oo] = Ro, Ci.iushrn(1);
    }
    return Mi;
  }
  Oe.getNAF = Si;
  function wi(Ri, Ti) {
    var Oi = [
      [],
      []
    ];
    Ri = Ri.clone(), Ti = Ti.clone();
    for (var Mi = 0, Ii = 0, Ci; Ri.cmpn(-Mi) > 0 || Ti.cmpn(-Ii) > 0; ) {
      var Oo = Ri.andln(3) + Mi & 3, Ro = Ti.andln(3) + Ii & 3;
      Oo === 3 && (Oo = -1), Ro === 3 && (Ro = -1);
      var Bo;
      Oo & 1 ? (Ci = Ri.andln(7) + Mi & 7, (Ci === 3 || Ci === 5) && Ro === 2 ? Bo = -Oo : Bo = Oo) : Bo = 0, Oi[0].push(Bo);
      var Fo;
      Ro & 1 ? (Ci = Ti.andln(7) + Ii & 7, (Ci === 3 || Ci === 5) && Oo === 2 ? Fo = -Ro : Fo = Ro) : Fo = 0, Oi[1].push(Fo), 2 * Mi === Bo + 1 && (Mi = 1 - Mi), 2 * Ii === Fo + 1 && (Ii = 1 - Ii), Ri.iushrn(1), Ti.iushrn(1);
    }
    return Oi;
  }
  Oe.getJSF = wi;
  function Ei(Ri, Ti, Oi) {
    var Mi = "_" + Ti;
    Ri.prototype[Ti] = function() {
      return this[Mi] !== void 0 ? this[Mi] : this[Mi] = Oi.call(this);
    };
  }
  Oe.cachedProperty = Ei;
  function $i(Ri) {
    return typeof Ri == "string" ? Oe.toArray(Ri, "hex") : Ri;
  }
  Oe.parseBytes = $i;
  function xi(Ri) {
    return new BN$8(Ri, "hex", "le");
  }
  Oe.intFromLE = xi;
}), getNAF$1 = utils_1$1$1.getNAF, getJSF$1 = utils_1$1$1.getJSF, assert$1$1 = utils_1$1$1.assert;
function BaseCurve$1(se, e) {
  this.type = se, this.p = new BN$8(e.p, 16), this.red = e.prime ? BN$8.red(e.prime) : BN$8.mont(this.p), this.zero = new BN$8(0).toRed(this.red), this.one = new BN$8(1).toRed(this.red), this.two = new BN$8(2).toRed(this.red), this.n = e.n && new BN$8(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Oe = this.n && this.p.div(this.n);
  !Oe || Oe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$3 = BaseCurve$1;
BaseCurve$1.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function(e, Oe) {
  assert$1$1(e.precomputed);
  var Si = e._getDoubles(), wi = getNAF$1(Oe, 1, this._bitLength), Ei = (1 << Si.step + 1) - (Si.step % 2 === 0 ? 2 : 1);
  Ei /= 3;
  var $i = [], xi, Ri;
  for (xi = 0; xi < wi.length; xi += Si.step) {
    Ri = 0;
    for (var Ti = xi + Si.step - 1; Ti >= xi; Ti--)
      Ri = (Ri << 1) + wi[Ti];
    $i.push(Ri);
  }
  for (var Oi = this.jpoint(null, null, null), Mi = this.jpoint(null, null, null), Ii = Ei; Ii > 0; Ii--) {
    for (xi = 0; xi < $i.length; xi++)
      Ri = $i[xi], Ri === Ii ? Mi = Mi.mixedAdd(Si.points[xi]) : Ri === -Ii && (Mi = Mi.mixedAdd(Si.points[xi].neg()));
    Oi = Oi.add(Mi);
  }
  return Oi.toP();
};
BaseCurve$1.prototype._wnafMul = function(e, Oe) {
  var Si = 4, wi = e._getNAFPoints(Si);
  Si = wi.wnd;
  for (var Ei = wi.points, $i = getNAF$1(Oe, Si, this._bitLength), xi = this.jpoint(null, null, null), Ri = $i.length - 1; Ri >= 0; Ri--) {
    for (var Ti = 0; Ri >= 0 && $i[Ri] === 0; Ri--)
      Ti++;
    if (Ri >= 0 && Ti++, xi = xi.dblp(Ti), Ri < 0)
      break;
    var Oi = $i[Ri];
    assert$1$1(Oi !== 0), e.type === "affine" ? Oi > 0 ? xi = xi.mixedAdd(Ei[Oi - 1 >> 1]) : xi = xi.mixedAdd(Ei[-Oi - 1 >> 1].neg()) : Oi > 0 ? xi = xi.add(Ei[Oi - 1 >> 1]) : xi = xi.add(Ei[-Oi - 1 >> 1].neg());
  }
  return e.type === "affine" ? xi.toP() : xi;
};
BaseCurve$1.prototype._wnafMulAdd = function(e, Oe, Si, wi, Ei) {
  var $i = this._wnafT1, xi = this._wnafT2, Ri = this._wnafT3, Ti = 0, Oi, Mi, Ii;
  for (Oi = 0; Oi < wi; Oi++) {
    Ii = Oe[Oi];
    var Ci = Ii._getNAFPoints(e);
    $i[Oi] = Ci.wnd, xi[Oi] = Ci.points;
  }
  for (Oi = wi - 1; Oi >= 1; Oi -= 2) {
    var Oo = Oi - 1, Ro = Oi;
    if ($i[Oo] !== 1 || $i[Ro] !== 1) {
      Ri[Oo] = getNAF$1(Si[Oo], $i[Oo], this._bitLength), Ri[Ro] = getNAF$1(Si[Ro], $i[Ro], this._bitLength), Ti = Math.max(Ri[Oo].length, Ti), Ti = Math.max(Ri[Ro].length, Ti);
      continue;
    }
    var Bo = [
      Oe[Oo],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Oe[Ro]
      /* 7 */
    ];
    Oe[Oo].y.cmp(Oe[Ro].y) === 0 ? (Bo[1] = Oe[Oo].add(Oe[Ro]), Bo[2] = Oe[Oo].toJ().mixedAdd(Oe[Ro].neg())) : Oe[Oo].y.cmp(Oe[Ro].y.redNeg()) === 0 ? (Bo[1] = Oe[Oo].toJ().mixedAdd(Oe[Ro]), Bo[2] = Oe[Oo].add(Oe[Ro].neg())) : (Bo[1] = Oe[Oo].toJ().mixedAdd(Oe[Ro]), Bo[2] = Oe[Oo].toJ().mixedAdd(Oe[Ro].neg()));
    var Fo = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Io = getJSF$1(Si[Oo], Si[Ro]);
    for (Ti = Math.max(Io[0].length, Ti), Ri[Oo] = new Array(Ti), Ri[Ro] = new Array(Ti), Mi = 0; Mi < Ti; Mi++) {
      var Uo = Io[0][Mi] | 0, Co = Io[1][Mi] | 0;
      Ri[Oo][Mi] = Fo[(Uo + 1) * 3 + (Co + 1)], Ri[Ro][Mi] = 0, xi[Oo] = Bo;
    }
  }
  var ko = this.jpoint(null, null, null), Po = this._wnafT4;
  for (Oi = Ti; Oi >= 0; Oi--) {
    for (var Mo = 0; Oi >= 0; ) {
      var No = !0;
      for (Mi = 0; Mi < wi; Mi++)
        Po[Mi] = Ri[Mi][Oi] | 0, Po[Mi] !== 0 && (No = !1);
      if (!No)
        break;
      Mo++, Oi--;
    }
    if (Oi >= 0 && Mo++, ko = ko.dblp(Mo), Oi < 0)
      break;
    for (Mi = 0; Mi < wi; Mi++) {
      var Jo = Po[Mi];
      Jo !== 0 && (Jo > 0 ? Ii = xi[Mi][Jo - 1 >> 1] : Jo < 0 && (Ii = xi[Mi][-Jo - 1 >> 1].neg()), Ii.type === "affine" ? ko = ko.mixedAdd(Ii) : ko = ko.add(Ii));
    }
  }
  for (Oi = 0; Oi < wi; Oi++)
    xi[Oi] = null;
  return Ei ? ko : ko.toP();
};
function BasePoint$1(se, e) {
  this.curve = se, this.type = e, this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function(e, Oe) {
  e = utils_1$1$1.toArray(e, Oe);
  var Si = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * Si) {
    e[0] === 6 ? assert$1$1(e[e.length - 1] % 2 === 0) : e[0] === 7 && assert$1$1(e[e.length - 1] % 2 === 1);
    var wi = this.point(
      e.slice(1, 1 + Si),
      e.slice(1 + Si, 1 + 2 * Si)
    );
    return wi;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === Si)
    return this.pointFromX(e.slice(1, 1 + Si), e[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
BasePoint$1.prototype._encode = function(e) {
  var Oe = this.curve.p.byteLength(), Si = this.getX().toArray("be", Oe);
  return e ? [this.getY().isEven() ? 2 : 3].concat(Si) : [4].concat(Si, this.getY().toArray("be", Oe));
};
BasePoint$1.prototype.encode = function(e, Oe) {
  return utils_1$1$1.encode(this._encode(Oe), e);
};
BasePoint$1.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var Oe = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Oe.naf = this._getNAFPoints(8), Oe.doubles = this._getDoubles(4, e), Oe.beta = this._getBeta(), this.precomputed = Oe, this;
};
BasePoint$1.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var Oe = this.precomputed.doubles;
  return Oe ? Oe.points.length >= Math.ceil((e.bitLength() + 1) / Oe.step) : !1;
};
BasePoint$1.prototype._getDoubles = function(e, Oe) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Si = [this], wi = this, Ei = 0; Ei < Oe; Ei += e) {
    for (var $i = 0; $i < e; $i++)
      wi = wi.dbl();
    Si.push(wi);
  }
  return {
    step: e,
    points: Si
  };
};
BasePoint$1.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Oe = [this], Si = (1 << e) - 1, wi = Si === 1 ? null : this.dbl(), Ei = 1; Ei < Si; Ei++)
    Oe[Ei] = Oe[Ei - 1].add(wi);
  return {
    wnd: e,
    points: Oe
  };
};
BasePoint$1.prototype._getBeta = function() {
  return null;
};
BasePoint$1.prototype.dblp = function(e) {
  for (var Oe = this, Si = 0; Si < e; Si++)
    Oe = Oe.dbl();
  return Oe;
};
var inherits_browser = createCommonjsModule(function(se) {
  typeof Object.create == "function" ? se.exports = function(Oe, Si) {
    Si && (Oe.super_ = Si, Oe.prototype = Object.create(Si.prototype, {
      constructor: {
        value: Oe,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : se.exports = function(Oe, Si) {
    if (Si) {
      Oe.super_ = Si;
      var wi = function() {
      };
      wi.prototype = Si.prototype, Oe.prototype = new wi(), Oe.prototype.constructor = Oe;
    }
  };
}), assert$2$1 = utils_1$1$1.assert;
function ShortCurve$1(se) {
  base$3.call(this, "short", se), this.a = new BN$8(se.a, 16).toRed(this.red), this.b = new BN$8(se.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(se), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve$1, base$3);
var short_1 = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Oe, Si;
    if (e.beta)
      Oe = new BN$8(e.beta, 16).toRed(this.red);
    else {
      var wi = this._getEndoRoots(this.p);
      Oe = wi[0].cmp(wi[1]) < 0 ? wi[0] : wi[1], Oe = Oe.toRed(this.red);
    }
    if (e.lambda)
      Si = new BN$8(e.lambda, 16);
    else {
      var Ei = this._getEndoRoots(this.n);
      this.g.mul(Ei[0]).x.cmp(this.g.x.redMul(Oe)) === 0 ? Si = Ei[0] : (Si = Ei[1], assert$2$1(this.g.mul(Si).x.cmp(this.g.x.redMul(Oe)) === 0));
    }
    var $i;
    return e.basis ? $i = e.basis.map(function(xi) {
      return {
        a: new BN$8(xi.a, 16),
        b: new BN$8(xi.b, 16)
      };
    }) : $i = this._getEndoBasis(Si), {
      beta: Oe,
      lambda: Si,
      basis: $i
    };
  }
};
ShortCurve$1.prototype._getEndoRoots = function(e) {
  var Oe = e === this.p ? this.red : BN$8.mont(e), Si = new BN$8(2).toRed(Oe).redInvm(), wi = Si.redNeg(), Ei = new BN$8(3).toRed(Oe).redNeg().redSqrt().redMul(Si), $i = wi.redAdd(Ei).fromRed(), xi = wi.redSub(Ei).fromRed();
  return [$i, xi];
};
ShortCurve$1.prototype._getEndoBasis = function(e) {
  for (var Oe = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Si = e, wi = this.n.clone(), Ei = new BN$8(1), $i = new BN$8(0), xi = new BN$8(0), Ri = new BN$8(1), Ti, Oi, Mi, Ii, Ci, Oo, Ro, Bo = 0, Fo, Io; Si.cmpn(0) !== 0; ) {
    var Uo = wi.div(Si);
    Fo = wi.sub(Uo.mul(Si)), Io = xi.sub(Uo.mul(Ei));
    var Co = Ri.sub(Uo.mul($i));
    if (!Mi && Fo.cmp(Oe) < 0)
      Ti = Ro.neg(), Oi = Ei, Mi = Fo.neg(), Ii = Io;
    else if (Mi && ++Bo === 2)
      break;
    Ro = Fo, wi = Si, Si = Fo, xi = Ei, Ei = Io, Ri = $i, $i = Co;
  }
  Ci = Fo.neg(), Oo = Io;
  var ko = Mi.sqr().add(Ii.sqr()), Po = Ci.sqr().add(Oo.sqr());
  return Po.cmp(ko) >= 0 && (Ci = Ti, Oo = Oi), Mi.negative && (Mi = Mi.neg(), Ii = Ii.neg()), Ci.negative && (Ci = Ci.neg(), Oo = Oo.neg()), [
    { a: Mi, b: Ii },
    { a: Ci, b: Oo }
  ];
};
ShortCurve$1.prototype._endoSplit = function(e) {
  var Oe = this.endo.basis, Si = Oe[0], wi = Oe[1], Ei = wi.b.mul(e).divRound(this.n), $i = Si.b.neg().mul(e).divRound(this.n), xi = Ei.mul(Si.a), Ri = $i.mul(wi.a), Ti = Ei.mul(Si.b), Oi = $i.mul(wi.b), Mi = e.sub(xi).sub(Ri), Ii = Ti.add(Oi).neg();
  return { k1: Mi, k2: Ii };
};
ShortCurve$1.prototype.pointFromX = function(e, Oe) {
  e = new BN$8(e, 16), e.red || (e = e.toRed(this.red));
  var Si = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), wi = Si.redSqrt();
  if (wi.redSqr().redSub(Si).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Ei = wi.fromRed().isOdd();
  return (Oe && !Ei || !Oe && Ei) && (wi = wi.redNeg()), this.point(e, wi);
};
ShortCurve$1.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var Oe = e.x, Si = e.y, wi = this.a.redMul(Oe), Ei = Oe.redSqr().redMul(Oe).redIAdd(wi).redIAdd(this.b);
  return Si.redSqr().redISub(Ei).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function(e, Oe, Si) {
  for (var wi = this._endoWnafT1, Ei = this._endoWnafT2, $i = 0; $i < e.length; $i++) {
    var xi = this._endoSplit(Oe[$i]), Ri = e[$i], Ti = Ri._getBeta();
    xi.k1.negative && (xi.k1.ineg(), Ri = Ri.neg(!0)), xi.k2.negative && (xi.k2.ineg(), Ti = Ti.neg(!0)), wi[$i * 2] = Ri, wi[$i * 2 + 1] = Ti, Ei[$i * 2] = xi.k1, Ei[$i * 2 + 1] = xi.k2;
  }
  for (var Oi = this._wnafMulAdd(1, wi, Ei, $i * 2, Si), Mi = 0; Mi < $i * 2; Mi++)
    wi[Mi] = null, Ei[Mi] = null;
  return Oi;
};
function Point$3(se, e, Oe, Si) {
  base$3.BasePoint.call(this, se, "affine"), e === null && Oe === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(e, 16), this.y = new BN$8(Oe, 16), Si && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point$3, base$3.BasePoint);
ShortCurve$1.prototype.point = function(e, Oe, Si) {
  return new Point$3(this, e, Oe, Si);
};
ShortCurve$1.prototype.pointFromJSON = function(e, Oe) {
  return Point$3.fromJSON(this, e, Oe);
};
Point$3.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var Oe = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var Si = this.curve, wi = function(Ei) {
        return Si.point(Ei.x.redMul(Si.endo.beta), Ei.y);
      };
      e.beta = Oe, Oe.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(wi)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(wi)
        }
      };
    }
    return Oe;
  }
};
Point$3.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$3.fromJSON = function(e, Oe, Si) {
  typeof Oe == "string" && (Oe = JSON.parse(Oe));
  var wi = e.point(Oe[0], Oe[1], Si);
  if (!Oe[2])
    return wi;
  function Ei(xi) {
    return e.point(xi[0], xi[1], Si);
  }
  var $i = Oe[2];
  return wi.precomputed = {
    beta: null,
    doubles: $i.doubles && {
      step: $i.doubles.step,
      points: [wi].concat($i.doubles.points.map(Ei))
    },
    naf: $i.naf && {
      wnd: $i.naf.wnd,
      points: [wi].concat($i.naf.points.map(Ei))
    }
  }, wi;
};
Point$3.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function() {
  return this.inf;
};
Point$3.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var Oe = this.y.redSub(e.y);
  Oe.cmpn(0) !== 0 && (Oe = Oe.redMul(this.x.redSub(e.x).redInvm()));
  var Si = Oe.redSqr().redISub(this.x).redISub(e.x), wi = Oe.redMul(this.x.redSub(Si)).redISub(this.y);
  return this.curve.point(Si, wi);
};
Point$3.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Oe = this.curve.a, Si = this.x.redSqr(), wi = e.redInvm(), Ei = Si.redAdd(Si).redIAdd(Si).redIAdd(Oe).redMul(wi), $i = Ei.redSqr().redISub(this.x.redAdd(this.x)), xi = Ei.redMul(this.x.redSub($i)).redISub(this.y);
  return this.curve.point($i, xi);
};
Point$3.prototype.getX = function() {
  return this.x.fromRed();
};
Point$3.prototype.getY = function() {
  return this.y.fromRed();
};
Point$3.prototype.mul = function(e) {
  return e = new BN$8(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Point$3.prototype.mulAdd = function(e, Oe, Si) {
  var wi = [this, Oe], Ei = [e, Si];
  return this.curve.endo ? this.curve._endoWnafMulAdd(wi, Ei) : this.curve._wnafMulAdd(1, wi, Ei, 2);
};
Point$3.prototype.jmulAdd = function(e, Oe, Si) {
  var wi = [this, Oe], Ei = [e, Si];
  return this.curve.endo ? this.curve._endoWnafMulAdd(wi, Ei, !0) : this.curve._wnafMulAdd(1, wi, Ei, 2, !0);
};
Point$3.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Point$3.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var Oe = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var Si = this.precomputed, wi = function(Ei) {
      return Ei.neg();
    };
    Oe.precomputed = {
      naf: Si.naf && {
        wnd: Si.naf.wnd,
        points: Si.naf.points.map(wi)
      },
      doubles: Si.doubles && {
        step: Si.doubles.step,
        points: Si.doubles.points.map(wi)
      }
    };
  }
  return Oe;
};
Point$3.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function JPoint$1(se, e, Oe, Si) {
  base$3.BasePoint.call(this, se, "jacobian"), e === null && Oe === null && Si === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(e, 16), this.y = new BN$8(Oe, 16), this.z = new BN$8(Si, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint$1, base$3.BasePoint);
ShortCurve$1.prototype.jpoint = function(e, Oe, Si) {
  return new JPoint$1(this, e, Oe, Si);
};
JPoint$1.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), Oe = e.redSqr(), Si = this.x.redMul(Oe), wi = this.y.redMul(Oe).redMul(e);
  return this.curve.point(Si, wi);
};
JPoint$1.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var Oe = e.z.redSqr(), Si = this.z.redSqr(), wi = this.x.redMul(Oe), Ei = e.x.redMul(Si), $i = this.y.redMul(Oe.redMul(e.z)), xi = e.y.redMul(Si.redMul(this.z)), Ri = wi.redSub(Ei), Ti = $i.redSub(xi);
  if (Ri.cmpn(0) === 0)
    return Ti.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Oi = Ri.redSqr(), Mi = Oi.redMul(Ri), Ii = wi.redMul(Oi), Ci = Ti.redSqr().redIAdd(Mi).redISub(Ii).redISub(Ii), Oo = Ti.redMul(Ii.redISub(Ci)).redISub($i.redMul(Mi)), Ro = this.z.redMul(e.z).redMul(Ri);
  return this.curve.jpoint(Ci, Oo, Ro);
};
JPoint$1.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var Oe = this.z.redSqr(), Si = this.x, wi = e.x.redMul(Oe), Ei = this.y, $i = e.y.redMul(Oe).redMul(this.z), xi = Si.redSub(wi), Ri = Ei.redSub($i);
  if (xi.cmpn(0) === 0)
    return Ri.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ti = xi.redSqr(), Oi = Ti.redMul(xi), Mi = Si.redMul(Ti), Ii = Ri.redSqr().redIAdd(Oi).redISub(Mi).redISub(Mi), Ci = Ri.redMul(Mi.redISub(Ii)).redISub(Ei.redMul(Oi)), Oo = this.z.redMul(xi);
  return this.curve.jpoint(Ii, Ci, Oo);
};
JPoint$1.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var Oe;
  if (this.curve.zeroA || this.curve.threeA) {
    var Si = this;
    for (Oe = 0; Oe < e; Oe++)
      Si = Si.dbl();
    return Si;
  }
  var wi = this.curve.a, Ei = this.curve.tinv, $i = this.x, xi = this.y, Ri = this.z, Ti = Ri.redSqr().redSqr(), Oi = xi.redAdd(xi);
  for (Oe = 0; Oe < e; Oe++) {
    var Mi = $i.redSqr(), Ii = Oi.redSqr(), Ci = Ii.redSqr(), Oo = Mi.redAdd(Mi).redIAdd(Mi).redIAdd(wi.redMul(Ti)), Ro = $i.redMul(Ii), Bo = Oo.redSqr().redISub(Ro.redAdd(Ro)), Fo = Ro.redISub(Bo), Io = Oo.redMul(Fo);
    Io = Io.redIAdd(Io).redISub(Ci);
    var Uo = Oi.redMul(Ri);
    Oe + 1 < e && (Ti = Ti.redMul(Ci)), $i = Bo, Ri = Uo, Oi = Io;
  }
  return this.curve.jpoint($i, Oi.redMul(Ei), Ri);
};
JPoint$1.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint$1.prototype._zeroDbl = function() {
  var e, Oe, Si;
  if (this.zOne) {
    var wi = this.x.redSqr(), Ei = this.y.redSqr(), $i = Ei.redSqr(), xi = this.x.redAdd(Ei).redSqr().redISub(wi).redISub($i);
    xi = xi.redIAdd(xi);
    var Ri = wi.redAdd(wi).redIAdd(wi), Ti = Ri.redSqr().redISub(xi).redISub(xi), Oi = $i.redIAdd($i);
    Oi = Oi.redIAdd(Oi), Oi = Oi.redIAdd(Oi), e = Ti, Oe = Ri.redMul(xi.redISub(Ti)).redISub(Oi), Si = this.y.redAdd(this.y);
  } else {
    var Mi = this.x.redSqr(), Ii = this.y.redSqr(), Ci = Ii.redSqr(), Oo = this.x.redAdd(Ii).redSqr().redISub(Mi).redISub(Ci);
    Oo = Oo.redIAdd(Oo);
    var Ro = Mi.redAdd(Mi).redIAdd(Mi), Bo = Ro.redSqr(), Fo = Ci.redIAdd(Ci);
    Fo = Fo.redIAdd(Fo), Fo = Fo.redIAdd(Fo), e = Bo.redISub(Oo).redISub(Oo), Oe = Ro.redMul(Oo.redISub(e)).redISub(Fo), Si = this.y.redMul(this.z), Si = Si.redIAdd(Si);
  }
  return this.curve.jpoint(e, Oe, Si);
};
JPoint$1.prototype._threeDbl = function() {
  var e, Oe, Si;
  if (this.zOne) {
    var wi = this.x.redSqr(), Ei = this.y.redSqr(), $i = Ei.redSqr(), xi = this.x.redAdd(Ei).redSqr().redISub(wi).redISub($i);
    xi = xi.redIAdd(xi);
    var Ri = wi.redAdd(wi).redIAdd(wi).redIAdd(this.curve.a), Ti = Ri.redSqr().redISub(xi).redISub(xi);
    e = Ti;
    var Oi = $i.redIAdd($i);
    Oi = Oi.redIAdd(Oi), Oi = Oi.redIAdd(Oi), Oe = Ri.redMul(xi.redISub(Ti)).redISub(Oi), Si = this.y.redAdd(this.y);
  } else {
    var Mi = this.z.redSqr(), Ii = this.y.redSqr(), Ci = this.x.redMul(Ii), Oo = this.x.redSub(Mi).redMul(this.x.redAdd(Mi));
    Oo = Oo.redAdd(Oo).redIAdd(Oo);
    var Ro = Ci.redIAdd(Ci);
    Ro = Ro.redIAdd(Ro);
    var Bo = Ro.redAdd(Ro);
    e = Oo.redSqr().redISub(Bo), Si = this.y.redAdd(this.z).redSqr().redISub(Ii).redISub(Mi);
    var Fo = Ii.redSqr();
    Fo = Fo.redIAdd(Fo), Fo = Fo.redIAdd(Fo), Fo = Fo.redIAdd(Fo), Oe = Oo.redMul(Ro.redISub(e)).redISub(Fo);
  }
  return this.curve.jpoint(e, Oe, Si);
};
JPoint$1.prototype._dbl = function() {
  var e = this.curve.a, Oe = this.x, Si = this.y, wi = this.z, Ei = wi.redSqr().redSqr(), $i = Oe.redSqr(), xi = Si.redSqr(), Ri = $i.redAdd($i).redIAdd($i).redIAdd(e.redMul(Ei)), Ti = Oe.redAdd(Oe);
  Ti = Ti.redIAdd(Ti);
  var Oi = Ti.redMul(xi), Mi = Ri.redSqr().redISub(Oi.redAdd(Oi)), Ii = Oi.redISub(Mi), Ci = xi.redSqr();
  Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci);
  var Oo = Ri.redMul(Ii).redISub(Ci), Ro = Si.redAdd(Si).redMul(wi);
  return this.curve.jpoint(Mi, Oo, Ro);
};
JPoint$1.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), Oe = this.y.redSqr(), Si = this.z.redSqr(), wi = Oe.redSqr(), Ei = e.redAdd(e).redIAdd(e), $i = Ei.redSqr(), xi = this.x.redAdd(Oe).redSqr().redISub(e).redISub(wi);
  xi = xi.redIAdd(xi), xi = xi.redAdd(xi).redIAdd(xi), xi = xi.redISub($i);
  var Ri = xi.redSqr(), Ti = wi.redIAdd(wi);
  Ti = Ti.redIAdd(Ti), Ti = Ti.redIAdd(Ti), Ti = Ti.redIAdd(Ti);
  var Oi = Ei.redIAdd(xi).redSqr().redISub($i).redISub(Ri).redISub(Ti), Mi = Oe.redMul(Oi);
  Mi = Mi.redIAdd(Mi), Mi = Mi.redIAdd(Mi);
  var Ii = this.x.redMul(Ri).redISub(Mi);
  Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii);
  var Ci = this.y.redMul(Oi.redMul(Ti.redISub(Oi)).redISub(xi.redMul(Ri)));
  Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci);
  var Oo = this.z.redAdd(xi).redSqr().redISub(Si).redISub(Ri);
  return this.curve.jpoint(Ii, Ci, Oo);
};
JPoint$1.prototype.mul = function(e, Oe) {
  return e = new BN$8(e, Oe), this.curve._wnafMul(this, e);
};
JPoint$1.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var Oe = this.z.redSqr(), Si = e.z.redSqr();
  if (this.x.redMul(Si).redISub(e.x.redMul(Oe)).cmpn(0) !== 0)
    return !1;
  var wi = Oe.redMul(this.z), Ei = Si.redMul(e.z);
  return this.y.redMul(Ei).redISub(e.y.redMul(wi)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function(e) {
  var Oe = this.z.redSqr(), Si = e.toRed(this.curve.red).redMul(Oe);
  if (this.x.cmp(Si) === 0)
    return !0;
  for (var wi = e.clone(), Ei = this.curve.redN.redMul(Oe); ; ) {
    if (wi.iadd(this.curve.n), wi.cmp(this.curve.p) >= 0)
      return !1;
    if (Si.redIAdd(Ei), this.x.cmp(Si) === 0)
      return !0;
  }
};
JPoint$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(se, e) {
  var Oe = e;
  Oe.base = base$3, Oe.short = short_1, Oe.mont = /*RicMoo:ethers:require(./mont)*/
  null, Oe.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), curves_1 = createCommonjsModule(function(se, e) {
  var Oe = e, Si = utils_1$1$1.assert;
  function wi(xi) {
    xi.type === "short" ? this.curve = new curve_1.short(xi) : xi.type === "edwards" ? this.curve = new curve_1.edwards(xi) : this.curve = new curve_1.mont(xi), this.g = this.curve.g, this.n = this.curve.n, this.hash = xi.hash, Si(this.g.validate(), "Invalid curve"), Si(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  Oe.PresetCurve = wi;
  function Ei(xi, Ri) {
    Object.defineProperty(Oe, xi, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Ti = new wi(Ri);
        return Object.defineProperty(Oe, xi, {
          configurable: !0,
          enumerable: !0,
          value: Ti
        }), Ti;
      }
    });
  }
  Ei("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), Ei("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), Ei("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), Ei("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$3.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), Ei("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$3.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), Ei("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), Ei("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var $i;
  try {
    $i = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    $i = void 0;
  }
  Ei("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      $i
    ]
  });
});
function HmacDRBG$2(se) {
  if (!(this instanceof HmacDRBG$2))
    return new HmacDRBG$2(se);
  this.hash = se.hash, this.predResist = !!se.predResist, this.outLen = this.hash.outSize, this.minEntropy = se.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = utils_1$5.toArray(se.entropy, se.entropyEnc || "hex"), Oe = utils_1$5.toArray(se.nonce, se.nonceEnc || "hex"), Si = utils_1$5.toArray(se.pers, se.persEnc || "hex");
  minimalisticAssert(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, Oe, Si);
}
var hmacDrbg$1 = HmacDRBG$2;
HmacDRBG$2.prototype._init = function(e, Oe, Si) {
  var wi = e.concat(Oe).concat(Si);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Ei = 0; Ei < this.V.length; Ei++)
    this.K[Ei] = 0, this.V[Ei] = 1;
  this._update(wi), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG$2.prototype._hmac = function() {
  return new hash$3.hmac(this.hash, this.K);
};
HmacDRBG$2.prototype._update = function(e) {
  var Oe = this._hmac().update(this.V).update([0]);
  e && (Oe = Oe.update(e)), this.K = Oe.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG$2.prototype.reseed = function(e, Oe, Si, wi) {
  typeof Oe != "string" && (wi = Si, Si = Oe, Oe = null), e = utils_1$5.toArray(e, Oe), Si = utils_1$5.toArray(Si, wi), minimalisticAssert(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(Si || [])), this._reseed = 1;
};
HmacDRBG$2.prototype.generate = function(e, Oe, Si, wi) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Oe != "string" && (wi = Si, Si = Oe, Oe = null), Si && (Si = utils_1$5.toArray(Si, wi || "hex"), this._update(Si));
  for (var Ei = []; Ei.length < e; )
    this.V = this._hmac().update(this.V).digest(), Ei = Ei.concat(this.V);
  var $i = Ei.slice(0, e);
  return this._update(Si), this._reseed++, utils_1$5.encode($i, Oe);
};
var assert$3$1 = utils_1$1$1.assert;
function KeyPair$4(se, e) {
  this.ec = se, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var key$2 = KeyPair$4;
KeyPair$4.fromPublic = function(e, Oe, Si) {
  return Oe instanceof KeyPair$4 ? Oe : new KeyPair$4(e, {
    pub: Oe,
    pubEnc: Si
  });
};
KeyPair$4.fromPrivate = function(e, Oe, Si) {
  return Oe instanceof KeyPair$4 ? Oe : new KeyPair$4(e, {
    priv: Oe,
    privEnc: Si
  });
};
KeyPair$4.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$4.prototype.getPublic = function(e, Oe) {
  return typeof e == "string" && (Oe = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Oe ? this.pub.encode(Oe, e) : this.pub;
};
KeyPair$4.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$4.prototype._importPrivate = function(e, Oe) {
  this.priv = new BN$8(e, Oe || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$4.prototype._importPublic = function(e, Oe) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? assert$3$1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3$1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, Oe);
};
KeyPair$4.prototype.derive = function(e) {
  return e.validate() || assert$3$1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
KeyPair$4.prototype.sign = function(e, Oe, Si) {
  return this.ec.sign(e, this, Oe, Si);
};
KeyPair$4.prototype.verify = function(e, Oe) {
  return this.ec.verify(e, Oe, this);
};
KeyPair$4.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4$1 = utils_1$1$1.assert;
function Signature$4(se, e) {
  if (se instanceof Signature$4)
    return se;
  this._importDER(se, e) || (assert$4$1(se.r && se.s, "Signature without r or s"), this.r = new BN$8(se.r, 16), this.s = new BN$8(se.s, 16), se.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = se.recoveryParam);
}
var signature$2 = Signature$4;
function Position$1() {
  this.place = 0;
}
function getLength$1(se, e) {
  var Oe = se[e.place++];
  if (!(Oe & 128))
    return Oe;
  var Si = Oe & 15;
  if (Si === 0 || Si > 4)
    return !1;
  for (var wi = 0, Ei = 0, $i = e.place; Ei < Si; Ei++, $i++)
    wi <<= 8, wi |= se[$i], wi >>>= 0;
  return wi <= 127 ? !1 : (e.place = $i, wi);
}
function rmPadding$1(se) {
  for (var e = 0, Oe = se.length - 1; !se[e] && !(se[e + 1] & 128) && e < Oe; )
    e++;
  return e === 0 ? se : se.slice(e);
}
Signature$4.prototype._importDER = function(e, Oe) {
  e = utils_1$1$1.toArray(e, Oe);
  var Si = new Position$1();
  if (e[Si.place++] !== 48)
    return !1;
  var wi = getLength$1(e, Si);
  if (wi === !1 || wi + Si.place !== e.length || e[Si.place++] !== 2)
    return !1;
  var Ei = getLength$1(e, Si);
  if (Ei === !1)
    return !1;
  var $i = e.slice(Si.place, Ei + Si.place);
  if (Si.place += Ei, e[Si.place++] !== 2)
    return !1;
  var xi = getLength$1(e, Si);
  if (xi === !1 || e.length !== xi + Si.place)
    return !1;
  var Ri = e.slice(Si.place, xi + Si.place);
  if ($i[0] === 0)
    if ($i[1] & 128)
      $i = $i.slice(1);
    else
      return !1;
  if (Ri[0] === 0)
    if (Ri[1] & 128)
      Ri = Ri.slice(1);
    else
      return !1;
  return this.r = new BN$8($i), this.s = new BN$8(Ri), this.recoveryParam = null, !0;
};
function constructLength$1(se, e) {
  if (e < 128) {
    se.push(e);
    return;
  }
  var Oe = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (se.push(Oe | 128); --Oe; )
    se.push(e >>> (Oe << 3) & 255);
  se.push(e);
}
Signature$4.prototype.toDER = function(e) {
  var Oe = this.r.toArray(), Si = this.s.toArray();
  for (Oe[0] & 128 && (Oe = [0].concat(Oe)), Si[0] & 128 && (Si = [0].concat(Si)), Oe = rmPadding$1(Oe), Si = rmPadding$1(Si); !Si[0] && !(Si[1] & 128); )
    Si = Si.slice(1);
  var wi = [2];
  constructLength$1(wi, Oe.length), wi = wi.concat(Oe), wi.push(2), constructLength$1(wi, Si.length);
  var Ei = wi.concat(Si), $i = [48];
  return constructLength$1($i, Ei.length), $i = $i.concat(Ei), utils_1$1$1.encode($i, e);
};
var rand$1 = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), assert$5$1 = utils_1$1$1.assert;
function EC$1(se) {
  if (!(this instanceof EC$1))
    return new EC$1(se);
  typeof se == "string" && (assert$5$1(
    Object.prototype.hasOwnProperty.call(curves_1, se),
    "Unknown curve " + se
  ), se = curves_1[se]), se instanceof curves_1.PresetCurve && (se = { curve: se }), this.curve = se.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = se.curve.g, this.g.precompute(se.curve.n.bitLength() + 1), this.hash = se.hash || se.curve.hash;
}
var ec$1 = EC$1;
EC$1.prototype.keyPair = function(e) {
  return new key$2(this, e);
};
EC$1.prototype.keyFromPrivate = function(e, Oe) {
  return key$2.fromPrivate(this, e, Oe);
};
EC$1.prototype.keyFromPublic = function(e, Oe) {
  return key$2.fromPublic(this, e, Oe);
};
EC$1.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var Oe = new hmacDrbg$1({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || rand$1(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), Si = this.n.byteLength(), wi = this.n.sub(new BN$8(2)); ; ) {
    var Ei = new BN$8(Oe.generate(Si));
    if (!(Ei.cmp(wi) > 0))
      return Ei.iaddn(1), this.keyFromPrivate(Ei);
  }
};
EC$1.prototype._truncateToN = function(e, Oe) {
  var Si = e.byteLength() * 8 - this.n.bitLength();
  return Si > 0 && (e = e.ushrn(Si)), !Oe && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
EC$1.prototype.sign = function(e, Oe, Si, wi) {
  typeof Si == "object" && (wi = Si, Si = null), wi || (wi = {}), Oe = this.keyFromPrivate(Oe, Si), e = this._truncateToN(new BN$8(e, 16));
  for (var Ei = this.n.byteLength(), $i = Oe.getPrivate().toArray("be", Ei), xi = e.toArray("be", Ei), Ri = new hmacDrbg$1({
    hash: this.hash,
    entropy: $i,
    nonce: xi,
    pers: wi.pers,
    persEnc: wi.persEnc || "utf8"
  }), Ti = this.n.sub(new BN$8(1)), Oi = 0; ; Oi++) {
    var Mi = wi.k ? wi.k(Oi) : new BN$8(Ri.generate(this.n.byteLength()));
    if (Mi = this._truncateToN(Mi, !0), !(Mi.cmpn(1) <= 0 || Mi.cmp(Ti) >= 0)) {
      var Ii = this.g.mul(Mi);
      if (!Ii.isInfinity()) {
        var Ci = Ii.getX(), Oo = Ci.umod(this.n);
        if (Oo.cmpn(0) !== 0) {
          var Ro = Mi.invm(this.n).mul(Oo.mul(Oe.getPrivate()).iadd(e));
          if (Ro = Ro.umod(this.n), Ro.cmpn(0) !== 0) {
            var Bo = (Ii.getY().isOdd() ? 1 : 0) | (Ci.cmp(Oo) !== 0 ? 2 : 0);
            return wi.canonical && Ro.cmp(this.nh) > 0 && (Ro = this.n.sub(Ro), Bo ^= 1), new signature$2({ r: Oo, s: Ro, recoveryParam: Bo });
          }
        }
      }
    }
  }
};
EC$1.prototype.verify = function(e, Oe, Si, wi) {
  e = this._truncateToN(new BN$8(e, 16)), Si = this.keyFromPublic(Si, wi), Oe = new signature$2(Oe, "hex");
  var Ei = Oe.r, $i = Oe.s;
  if (Ei.cmpn(1) < 0 || Ei.cmp(this.n) >= 0 || $i.cmpn(1) < 0 || $i.cmp(this.n) >= 0)
    return !1;
  var xi = $i.invm(this.n), Ri = xi.mul(e).umod(this.n), Ti = xi.mul(Ei).umod(this.n), Oi;
  return this.curve._maxwellTrick ? (Oi = this.g.jmulAdd(Ri, Si.getPublic(), Ti), Oi.isInfinity() ? !1 : Oi.eqXToP(Ei)) : (Oi = this.g.mulAdd(Ri, Si.getPublic(), Ti), Oi.isInfinity() ? !1 : Oi.getX().umod(this.n).cmp(Ei) === 0);
};
EC$1.prototype.recoverPubKey = function(se, e, Oe, Si) {
  assert$5$1((3 & Oe) === Oe, "The recovery param is more than two bits"), e = new signature$2(e, Si);
  var wi = this.n, Ei = new BN$8(se), $i = e.r, xi = e.s, Ri = Oe & 1, Ti = Oe >> 1;
  if ($i.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ti)
    throw new Error("Unable to find sencond key candinate");
  Ti ? $i = this.curve.pointFromX($i.add(this.curve.n), Ri) : $i = this.curve.pointFromX($i, Ri);
  var Oi = e.r.invm(wi), Mi = wi.sub(Ei).mul(Oi).umod(wi), Ii = xi.mul(Oi).umod(wi);
  return this.g.mulAdd(Mi, $i, Ii);
};
EC$1.prototype.getKeyRecoveryParam = function(se, e, Oe, Si) {
  if (e = new signature$2(e, Si), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var wi = 0; wi < 4; wi++) {
    var Ei;
    try {
      Ei = this.recoverPubKey(se, e, wi);
    } catch {
      continue;
    }
    if (Ei.eq(Oe))
      return wi;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(se, e) {
  var Oe = e;
  Oe.version = "6.5.4", Oe.utils = utils_1$1$1, Oe.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, Oe.curve = curve_1, Oe.curves = curves_1, Oe.ec = ec$1, Oe.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EC$1$1 = elliptic_1.ec;
const version$1 = "signing-key/5.7.0", logger = new Logger(version$1);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(e) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(e)), hexDataLength(this.privateKey) !== 32 && logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const Oe = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + Oe.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + Oe.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const Oe = getCurve().keyFromPublic(arrayify(this.publicKey)), Si = getCurve().keyFromPublic(arrayify(e));
    return "0x" + Oe.pub.add(Si.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const Oe = getCurve().keyFromPrivate(arrayify(this.privateKey)), Si = arrayify(e);
    Si.length !== 32 && logger.throwArgumentError("bad digest length", "digest", e);
    const wi = Oe.sign(Si, { canonical: !0 });
    return splitSignature({
      recoveryParam: wi.recoveryParam,
      r: hexZeroPad("0x" + wi.r.toString(16), 32),
      s: hexZeroPad("0x" + wi.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const Oe = getCurve().keyFromPrivate(arrayify(this.privateKey)), Si = getCurve().keyFromPublic(arrayify(computePublicKey(e)));
    return hexZeroPad("0x" + Oe.derive(Si.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function recoverPublicKey(se, e) {
  const Oe = splitSignature(e), Si = { r: arrayify(Oe.r), s: arrayify(Oe.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(se), Si, Oe.recoveryParam).encode("hex", !1);
}
function computePublicKey(se, e) {
  const Oe = arrayify(se);
  if (Oe.length === 32) {
    const Si = new SigningKey(Oe);
    return e ? "0x" + getCurve().keyFromPrivate(Oe).getPublic(!0, "hex") : Si.publicKey;
  } else {
    if (Oe.length === 33)
      return e ? hexlify(Oe) : "0x" + getCurve().keyFromPublic(Oe).getPublic(!1, "hex");
    if (Oe.length === 65)
      return e ? "0x" + getCurve().keyFromPublic(Oe).getPublic(!0, "hex") : hexlify(Oe);
  }
  return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var TransactionTypes;
(function(se) {
  se[se.legacy = 0] = "legacy", se[se.eip2930 = 1] = "eip2930", se[se.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function computeAddress(se) {
  const e = computePublicKey(se);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(e, 1)), 12));
}
function recoverAddress(se, e) {
  return computeAddress(recoverPublicKey(arrayify(se), e));
}
function allocUnsafe$1(se = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(se) : new Uint8Array(se);
}
function concat$1(se, e) {
  e || (e = se.reduce((wi, Ei) => wi + Ei.length, 0));
  const Oe = allocUnsafe$1(e);
  let Si = 0;
  for (const wi of se)
    Oe.set(wi, Si), Si += wi.length;
  return Oe;
}
function createCodec$1(se, e, Oe, Si) {
  return {
    name: se,
    prefix: e,
    encoder: {
      name: se,
      prefix: e,
      encode: Oe
    },
    decoder: { decode: Si }
  };
}
const string$1 = createCodec$1("utf8", "u", (se) => "u" + new TextDecoder("utf8").decode(se), (se) => new TextEncoder().encode(se.substring(1))), ascii$1 = createCodec$1("ascii", "a", (se) => {
  let e = "a";
  for (let Oe = 0; Oe < se.length; Oe++)
    e += String.fromCharCode(se[Oe]);
  return e;
}, (se) => {
  se = se.substring(1);
  const e = allocUnsafe$1(se.length);
  for (let Oe = 0; Oe < se.length; Oe++)
    e[Oe] = se.charCodeAt(Oe);
  return e;
}), BASES$1 = {
  utf8: string$1,
  "utf-8": string$1,
  hex: bases.base16,
  latin1: ascii$1,
  ascii: ascii$1,
  binary: ascii$1,
  ...bases
};
function fromString(se, e = "utf8") {
  const Oe = BASES$1[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(se, "utf8") : Oe.decoder.decode(`${Oe.prefix}${se}`);
}
function toString$1(se, e = "utf8") {
  const Oe = BASES$1[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(se.buffer, se.byteOffset, se.byteLength).toString("utf8") : Oe.encoder.encode(se).substring(1);
}
var elliptic = {};
const name = "elliptic", version = "6.6.1", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$e = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(se) {
  (function(e, Oe) {
    function Si(Do, wo) {
      if (!Do)
        throw new Error(wo || "Assertion failed");
    }
    function wi(Do, wo) {
      Do.super_ = wo;
      var Li = function() {
      };
      Li.prototype = wo.prototype, Do.prototype = new Li(), Do.prototype.constructor = Do;
    }
    function Ei(Do, wo, Li) {
      if (Ei.isBN(Do))
        return Do;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Do !== null && ((wo === "le" || wo === "be") && (Li = wo, wo = 10), this._init(Do || 0, wo || 10, Li || "be"));
    }
    typeof e == "object" ? e.exports = Ei : Oe.BN = Ei, Ei.BN = Ei, Ei.wordSize = 26;
    var $i;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? $i = window.Buffer : $i = require("buffer").Buffer;
    } catch {
    }
    Ei.isBN = function(wo) {
      return wo instanceof Ei ? !0 : wo !== null && typeof wo == "object" && wo.constructor.wordSize === Ei.wordSize && Array.isArray(wo.words);
    }, Ei.max = function(wo, Li) {
      return wo.cmp(Li) > 0 ? wo : Li;
    }, Ei.min = function(wo, Li) {
      return wo.cmp(Li) < 0 ? wo : Li;
    }, Ei.prototype._init = function(wo, Li, Ai) {
      if (typeof wo == "number")
        return this._initNumber(wo, Li, Ai);
      if (typeof wo == "object")
        return this._initArray(wo, Li, Ai);
      Li === "hex" && (Li = 16), Si(Li === (Li | 0) && Li >= 2 && Li <= 36), wo = wo.toString().replace(/\s+/g, "");
      var Ni = 0;
      wo[0] === "-" && (Ni++, this.negative = 1), Ni < wo.length && (Li === 16 ? this._parseHex(wo, Ni, Ai) : (this._parseBase(wo, Li, Ni), Ai === "le" && this._initArray(this.toArray(), Li, Ai)));
    }, Ei.prototype._initNumber = function(wo, Li, Ai) {
      wo < 0 && (this.negative = 1, wo = -wo), wo < 67108864 ? (this.words = [wo & 67108863], this.length = 1) : wo < 4503599627370496 ? (this.words = [
        wo & 67108863,
        wo / 67108864 & 67108863
      ], this.length = 2) : (Si(wo < 9007199254740992), this.words = [
        wo & 67108863,
        wo / 67108864 & 67108863,
        1
      ], this.length = 3), Ai === "le" && this._initArray(this.toArray(), Li, Ai);
    }, Ei.prototype._initArray = function(wo, Li, Ai) {
      if (Si(typeof wo.length == "number"), wo.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(wo.length / 3), this.words = new Array(this.length);
      for (var Ni = 0; Ni < this.length; Ni++)
        this.words[Ni] = 0;
      var Ui, So, $o = 0;
      if (Ai === "be")
        for (Ni = wo.length - 1, Ui = 0; Ni >= 0; Ni -= 3)
          So = wo[Ni] | wo[Ni - 1] << 8 | wo[Ni - 2] << 16, this.words[Ui] |= So << $o & 67108863, this.words[Ui + 1] = So >>> 26 - $o & 67108863, $o += 24, $o >= 26 && ($o -= 26, Ui++);
      else if (Ai === "le")
        for (Ni = 0, Ui = 0; Ni < wo.length; Ni += 3)
          So = wo[Ni] | wo[Ni + 1] << 8 | wo[Ni + 2] << 16, this.words[Ui] |= So << $o & 67108863, this.words[Ui + 1] = So >>> 26 - $o & 67108863, $o += 24, $o >= 26 && ($o -= 26, Ui++);
      return this.strip();
    };
    function xi(Do, wo) {
      var Li = Do.charCodeAt(wo);
      return Li >= 65 && Li <= 70 ? Li - 55 : Li >= 97 && Li <= 102 ? Li - 87 : Li - 48 & 15;
    }
    function Ri(Do, wo, Li) {
      var Ai = xi(Do, Li);
      return Li - 1 >= wo && (Ai |= xi(Do, Li - 1) << 4), Ai;
    }
    Ei.prototype._parseHex = function(wo, Li, Ai) {
      this.length = Math.ceil((wo.length - Li) / 6), this.words = new Array(this.length);
      for (var Ni = 0; Ni < this.length; Ni++)
        this.words[Ni] = 0;
      var Ui = 0, So = 0, $o;
      if (Ai === "be")
        for (Ni = wo.length - 1; Ni >= Li; Ni -= 2)
          $o = Ri(wo, Li, Ni) << Ui, this.words[So] |= $o & 67108863, Ui >= 18 ? (Ui -= 18, So += 1, this.words[So] |= $o >>> 26) : Ui += 8;
      else {
        var Eo = wo.length - Li;
        for (Ni = Eo % 2 === 0 ? Li + 1 : Li; Ni < wo.length; Ni += 2)
          $o = Ri(wo, Li, Ni) << Ui, this.words[So] |= $o & 67108863, Ui >= 18 ? (Ui -= 18, So += 1, this.words[So] |= $o >>> 26) : Ui += 8;
      }
      this.strip();
    };
    function Ti(Do, wo, Li, Ai) {
      for (var Ni = 0, Ui = Math.min(Do.length, Li), So = wo; So < Ui; So++) {
        var $o = Do.charCodeAt(So) - 48;
        Ni *= Ai, $o >= 49 ? Ni += $o - 49 + 10 : $o >= 17 ? Ni += $o - 17 + 10 : Ni += $o;
      }
      return Ni;
    }
    Ei.prototype._parseBase = function(wo, Li, Ai) {
      this.words = [0], this.length = 1;
      for (var Ni = 0, Ui = 1; Ui <= 67108863; Ui *= Li)
        Ni++;
      Ni--, Ui = Ui / Li | 0;
      for (var So = wo.length - Ai, $o = So % Ni, Eo = Math.min(So, So - $o) + Ai, zi = 0, _o = Ai; _o < Eo; _o += Ni)
        zi = Ti(wo, _o, _o + Ni, Li), this.imuln(Ui), this.words[0] + zi < 67108864 ? this.words[0] += zi : this._iaddn(zi);
      if ($o !== 0) {
        var Fi = 1;
        for (zi = Ti(wo, _o, wo.length, Li), _o = 0; _o < $o; _o++)
          Fi *= Li;
        this.imuln(Fi), this.words[0] + zi < 67108864 ? this.words[0] += zi : this._iaddn(zi);
      }
      this.strip();
    }, Ei.prototype.copy = function(wo) {
      wo.words = new Array(this.length);
      for (var Li = 0; Li < this.length; Li++)
        wo.words[Li] = this.words[Li];
      wo.length = this.length, wo.negative = this.negative, wo.red = this.red;
    }, Ei.prototype.clone = function() {
      var wo = new Ei(null);
      return this.copy(wo), wo;
    }, Ei.prototype._expand = function(wo) {
      for (; this.length < wo; )
        this.words[this.length++] = 0;
      return this;
    }, Ei.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Ei.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, Ei.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Oi = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Mi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Ii = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Ei.prototype.toString = function(wo, Li) {
      wo = wo || 10, Li = Li | 0 || 1;
      var Ai;
      if (wo === 16 || wo === "hex") {
        Ai = "";
        for (var Ni = 0, Ui = 0, So = 0; So < this.length; So++) {
          var $o = this.words[So], Eo = (($o << Ni | Ui) & 16777215).toString(16);
          Ui = $o >>> 24 - Ni & 16777215, Ni += 2, Ni >= 26 && (Ni -= 26, So--), Ui !== 0 || So !== this.length - 1 ? Ai = Oi[6 - Eo.length] + Eo + Ai : Ai = Eo + Ai;
        }
        for (Ui !== 0 && (Ai = Ui.toString(16) + Ai); Ai.length % Li !== 0; )
          Ai = "0" + Ai;
        return this.negative !== 0 && (Ai = "-" + Ai), Ai;
      }
      if (wo === (wo | 0) && wo >= 2 && wo <= 36) {
        var zi = Mi[wo], _o = Ii[wo];
        Ai = "";
        var Fi = this.clone();
        for (Fi.negative = 0; !Fi.isZero(); ) {
          var xo = Fi.modn(_o).toString(wo);
          Fi = Fi.idivn(_o), Fi.isZero() ? Ai = xo + Ai : Ai = Oi[zi - xo.length] + xo + Ai;
        }
        for (this.isZero() && (Ai = "0" + Ai); Ai.length % Li !== 0; )
          Ai = "0" + Ai;
        return this.negative !== 0 && (Ai = "-" + Ai), Ai;
      }
      Si(!1, "Base should be between 2 and 36");
    }, Ei.prototype.toNumber = function() {
      var wo = this.words[0];
      return this.length === 2 ? wo += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? wo += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Si(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -wo : wo;
    }, Ei.prototype.toJSON = function() {
      return this.toString(16);
    }, Ei.prototype.toBuffer = function(wo, Li) {
      return Si(typeof $i < "u"), this.toArrayLike($i, wo, Li);
    }, Ei.prototype.toArray = function(wo, Li) {
      return this.toArrayLike(Array, wo, Li);
    }, Ei.prototype.toArrayLike = function(wo, Li, Ai) {
      var Ni = this.byteLength(), Ui = Ai || Math.max(1, Ni);
      Si(Ni <= Ui, "byte array longer than desired length"), Si(Ui > 0, "Requested array length <= 0"), this.strip();
      var So = Li === "le", $o = new wo(Ui), Eo, zi, _o = this.clone();
      if (So) {
        for (zi = 0; !_o.isZero(); zi++)
          Eo = _o.andln(255), _o.iushrn(8), $o[zi] = Eo;
        for (; zi < Ui; zi++)
          $o[zi] = 0;
      } else {
        for (zi = 0; zi < Ui - Ni; zi++)
          $o[zi] = 0;
        for (zi = 0; !_o.isZero(); zi++)
          Eo = _o.andln(255), _o.iushrn(8), $o[Ui - zi - 1] = Eo;
      }
      return $o;
    }, Math.clz32 ? Ei.prototype._countBits = function(wo) {
      return 32 - Math.clz32(wo);
    } : Ei.prototype._countBits = function(wo) {
      var Li = wo, Ai = 0;
      return Li >= 4096 && (Ai += 13, Li >>>= 13), Li >= 64 && (Ai += 7, Li >>>= 7), Li >= 8 && (Ai += 4, Li >>>= 4), Li >= 2 && (Ai += 2, Li >>>= 2), Ai + Li;
    }, Ei.prototype._zeroBits = function(wo) {
      if (wo === 0)
        return 26;
      var Li = wo, Ai = 0;
      return Li & 8191 || (Ai += 13, Li >>>= 13), Li & 127 || (Ai += 7, Li >>>= 7), Li & 15 || (Ai += 4, Li >>>= 4), Li & 3 || (Ai += 2, Li >>>= 2), Li & 1 || Ai++, Ai;
    }, Ei.prototype.bitLength = function() {
      var wo = this.words[this.length - 1], Li = this._countBits(wo);
      return (this.length - 1) * 26 + Li;
    };
    function Ci(Do) {
      for (var wo = new Array(Do.bitLength()), Li = 0; Li < wo.length; Li++) {
        var Ai = Li / 26 | 0, Ni = Li % 26;
        wo[Li] = (Do.words[Ai] & 1 << Ni) >>> Ni;
      }
      return wo;
    }
    Ei.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var wo = 0, Li = 0; Li < this.length; Li++) {
        var Ai = this._zeroBits(this.words[Li]);
        if (wo += Ai, Ai !== 26)
          break;
      }
      return wo;
    }, Ei.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ei.prototype.toTwos = function(wo) {
      return this.negative !== 0 ? this.abs().inotn(wo).iaddn(1) : this.clone();
    }, Ei.prototype.fromTwos = function(wo) {
      return this.testn(wo - 1) ? this.notn(wo).iaddn(1).ineg() : this.clone();
    }, Ei.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Ei.prototype.neg = function() {
      return this.clone().ineg();
    }, Ei.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Ei.prototype.iuor = function(wo) {
      for (; this.length < wo.length; )
        this.words[this.length++] = 0;
      for (var Li = 0; Li < wo.length; Li++)
        this.words[Li] = this.words[Li] | wo.words[Li];
      return this.strip();
    }, Ei.prototype.ior = function(wo) {
      return Si((this.negative | wo.negative) === 0), this.iuor(wo);
    }, Ei.prototype.or = function(wo) {
      return this.length > wo.length ? this.clone().ior(wo) : wo.clone().ior(this);
    }, Ei.prototype.uor = function(wo) {
      return this.length > wo.length ? this.clone().iuor(wo) : wo.clone().iuor(this);
    }, Ei.prototype.iuand = function(wo) {
      var Li;
      this.length > wo.length ? Li = wo : Li = this;
      for (var Ai = 0; Ai < Li.length; Ai++)
        this.words[Ai] = this.words[Ai] & wo.words[Ai];
      return this.length = Li.length, this.strip();
    }, Ei.prototype.iand = function(wo) {
      return Si((this.negative | wo.negative) === 0), this.iuand(wo);
    }, Ei.prototype.and = function(wo) {
      return this.length > wo.length ? this.clone().iand(wo) : wo.clone().iand(this);
    }, Ei.prototype.uand = function(wo) {
      return this.length > wo.length ? this.clone().iuand(wo) : wo.clone().iuand(this);
    }, Ei.prototype.iuxor = function(wo) {
      var Li, Ai;
      this.length > wo.length ? (Li = this, Ai = wo) : (Li = wo, Ai = this);
      for (var Ni = 0; Ni < Ai.length; Ni++)
        this.words[Ni] = Li.words[Ni] ^ Ai.words[Ni];
      if (this !== Li)
        for (; Ni < Li.length; Ni++)
          this.words[Ni] = Li.words[Ni];
      return this.length = Li.length, this.strip();
    }, Ei.prototype.ixor = function(wo) {
      return Si((this.negative | wo.negative) === 0), this.iuxor(wo);
    }, Ei.prototype.xor = function(wo) {
      return this.length > wo.length ? this.clone().ixor(wo) : wo.clone().ixor(this);
    }, Ei.prototype.uxor = function(wo) {
      return this.length > wo.length ? this.clone().iuxor(wo) : wo.clone().iuxor(this);
    }, Ei.prototype.inotn = function(wo) {
      Si(typeof wo == "number" && wo >= 0);
      var Li = Math.ceil(wo / 26) | 0, Ai = wo % 26;
      this._expand(Li), Ai > 0 && Li--;
      for (var Ni = 0; Ni < Li; Ni++)
        this.words[Ni] = ~this.words[Ni] & 67108863;
      return Ai > 0 && (this.words[Ni] = ~this.words[Ni] & 67108863 >> 26 - Ai), this.strip();
    }, Ei.prototype.notn = function(wo) {
      return this.clone().inotn(wo);
    }, Ei.prototype.setn = function(wo, Li) {
      Si(typeof wo == "number" && wo >= 0);
      var Ai = wo / 26 | 0, Ni = wo % 26;
      return this._expand(Ai + 1), Li ? this.words[Ai] = this.words[Ai] | 1 << Ni : this.words[Ai] = this.words[Ai] & ~(1 << Ni), this.strip();
    }, Ei.prototype.iadd = function(wo) {
      var Li;
      if (this.negative !== 0 && wo.negative === 0)
        return this.negative = 0, Li = this.isub(wo), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && wo.negative !== 0)
        return wo.negative = 0, Li = this.isub(wo), wo.negative = 1, Li._normSign();
      var Ai, Ni;
      this.length > wo.length ? (Ai = this, Ni = wo) : (Ai = wo, Ni = this);
      for (var Ui = 0, So = 0; So < Ni.length; So++)
        Li = (Ai.words[So] | 0) + (Ni.words[So] | 0) + Ui, this.words[So] = Li & 67108863, Ui = Li >>> 26;
      for (; Ui !== 0 && So < Ai.length; So++)
        Li = (Ai.words[So] | 0) + Ui, this.words[So] = Li & 67108863, Ui = Li >>> 26;
      if (this.length = Ai.length, Ui !== 0)
        this.words[this.length] = Ui, this.length++;
      else if (Ai !== this)
        for (; So < Ai.length; So++)
          this.words[So] = Ai.words[So];
      return this;
    }, Ei.prototype.add = function(wo) {
      var Li;
      return wo.negative !== 0 && this.negative === 0 ? (wo.negative = 0, Li = this.sub(wo), wo.negative ^= 1, Li) : wo.negative === 0 && this.negative !== 0 ? (this.negative = 0, Li = wo.sub(this), this.negative = 1, Li) : this.length > wo.length ? this.clone().iadd(wo) : wo.clone().iadd(this);
    }, Ei.prototype.isub = function(wo) {
      if (wo.negative !== 0) {
        wo.negative = 0;
        var Li = this.iadd(wo);
        return wo.negative = 1, Li._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(wo), this.negative = 1, this._normSign();
      var Ai = this.cmp(wo);
      if (Ai === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Ni, Ui;
      Ai > 0 ? (Ni = this, Ui = wo) : (Ni = wo, Ui = this);
      for (var So = 0, $o = 0; $o < Ui.length; $o++)
        Li = (Ni.words[$o] | 0) - (Ui.words[$o] | 0) + So, So = Li >> 26, this.words[$o] = Li & 67108863;
      for (; So !== 0 && $o < Ni.length; $o++)
        Li = (Ni.words[$o] | 0) + So, So = Li >> 26, this.words[$o] = Li & 67108863;
      if (So === 0 && $o < Ni.length && Ni !== this)
        for (; $o < Ni.length; $o++)
          this.words[$o] = Ni.words[$o];
      return this.length = Math.max(this.length, $o), Ni !== this && (this.negative = 1), this.strip();
    }, Ei.prototype.sub = function(wo) {
      return this.clone().isub(wo);
    };
    function Oo(Do, wo, Li) {
      Li.negative = wo.negative ^ Do.negative;
      var Ai = Do.length + wo.length | 0;
      Li.length = Ai, Ai = Ai - 1 | 0;
      var Ni = Do.words[0] | 0, Ui = wo.words[0] | 0, So = Ni * Ui, $o = So & 67108863, Eo = So / 67108864 | 0;
      Li.words[0] = $o;
      for (var zi = 1; zi < Ai; zi++) {
        for (var _o = Eo >>> 26, Fi = Eo & 67108863, xo = Math.min(zi, wo.length - 1), Qo = Math.max(0, zi - Do.length + 1); Qo <= xo; Qo++) {
          var To = zi - Qo | 0;
          Ni = Do.words[To] | 0, Ui = wo.words[Qo] | 0, So = Ni * Ui + Fi, _o += So / 67108864 | 0, Fi = So & 67108863;
        }
        Li.words[zi] = Fi | 0, Eo = _o | 0;
      }
      return Eo !== 0 ? Li.words[zi] = Eo | 0 : Li.length--, Li.strip();
    }
    var Ro = function(wo, Li, Ai) {
      var Ni = wo.words, Ui = Li.words, So = Ai.words, $o = 0, Eo, zi, _o, Fi = Ni[0] | 0, xo = Fi & 8191, Qo = Fi >>> 13, To = Ni[1] | 0, Ko = To & 8191, Vo = To >>> 13, Wo = Ni[2] | 0, jo = Wo & 8191, Ao = Wo >>> 13, Lo = Ni[3] | 0, Zo = Lo & 8191, An = Lo >>> 13, ra = Ni[4] | 0, sa = ra & 8191, Ma = ra >>> 13, ba = Ni[5] | 0, ma = ba & 8191, Va = ba >>> 13, wa = Ni[6] | 0, ha = wa & 8191, Fa = wa >>> 13, Sa = Ni[7] | 0, da = Sa & 8191, Pa = Sa >>> 13, va = Ni[8] | 0, ca = va & 8191, Na = va >>> 13, Ea = Ni[9] | 0, fa = Ea & 8191, Ca = Ea >>> 13, Oa = Ui[0] | 0, ya = Oa & 8191, Ua = Oa >>> 13, xa = Ui[1] | 0, Ra = xa & 8191, Ha = xa >>> 13, ka = Ui[2] | 0, Aa = ka & 8191, Ga = ka >>> 13, Wa = Ui[3] | 0, $a = Wa & 8191, qa = Wa >>> 13, Ia = Ui[4] | 0, Ho = Ia & 8191, qo = Ia >>> 13, Go = Ui[5] | 0, Xo = Go & 8191, ea = Go >>> 13, ia = Ui[6] | 0, oa = ia & 8191, aa = ia >>> 13, ua = Ui[7] | 0, na = ua & 8191, _a = ua >>> 13, pa = Ui[8] | 0, la = pa & 8191, Ba = pa >>> 13, Da = Ui[9] | 0, Ta = Da & 8191, Ja = Da >>> 13;
      Ai.negative = wo.negative ^ Li.negative, Ai.length = 19, Eo = Math.imul(xo, ya), zi = Math.imul(xo, Ua), zi = zi + Math.imul(Qo, ya) | 0, _o = Math.imul(Qo, Ua);
      var ja = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (ja >>> 26) | 0, ja &= 67108863, Eo = Math.imul(Ko, ya), zi = Math.imul(Ko, Ua), zi = zi + Math.imul(Vo, ya) | 0, _o = Math.imul(Vo, Ua), Eo = Eo + Math.imul(xo, Ra) | 0, zi = zi + Math.imul(xo, Ha) | 0, zi = zi + Math.imul(Qo, Ra) | 0, _o = _o + Math.imul(Qo, Ha) | 0;
      var za = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (za >>> 26) | 0, za &= 67108863, Eo = Math.imul(jo, ya), zi = Math.imul(jo, Ua), zi = zi + Math.imul(Ao, ya) | 0, _o = Math.imul(Ao, Ua), Eo = Eo + Math.imul(Ko, Ra) | 0, zi = zi + Math.imul(Ko, Ha) | 0, zi = zi + Math.imul(Vo, Ra) | 0, _o = _o + Math.imul(Vo, Ha) | 0, Eo = Eo + Math.imul(xo, Aa) | 0, zi = zi + Math.imul(xo, Ga) | 0, zi = zi + Math.imul(Qo, Aa) | 0, _o = _o + Math.imul(Qo, Ga) | 0;
      var Qa = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (Qa >>> 26) | 0, Qa &= 67108863, Eo = Math.imul(Zo, ya), zi = Math.imul(Zo, Ua), zi = zi + Math.imul(An, ya) | 0, _o = Math.imul(An, Ua), Eo = Eo + Math.imul(jo, Ra) | 0, zi = zi + Math.imul(jo, Ha) | 0, zi = zi + Math.imul(Ao, Ra) | 0, _o = _o + Math.imul(Ao, Ha) | 0, Eo = Eo + Math.imul(Ko, Aa) | 0, zi = zi + Math.imul(Ko, Ga) | 0, zi = zi + Math.imul(Vo, Aa) | 0, _o = _o + Math.imul(Vo, Ga) | 0, Eo = Eo + Math.imul(xo, $a) | 0, zi = zi + Math.imul(xo, qa) | 0, zi = zi + Math.imul(Qo, $a) | 0, _o = _o + Math.imul(Qo, qa) | 0;
      var tl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (tl >>> 26) | 0, tl &= 67108863, Eo = Math.imul(sa, ya), zi = Math.imul(sa, Ua), zi = zi + Math.imul(Ma, ya) | 0, _o = Math.imul(Ma, Ua), Eo = Eo + Math.imul(Zo, Ra) | 0, zi = zi + Math.imul(Zo, Ha) | 0, zi = zi + Math.imul(An, Ra) | 0, _o = _o + Math.imul(An, Ha) | 0, Eo = Eo + Math.imul(jo, Aa) | 0, zi = zi + Math.imul(jo, Ga) | 0, zi = zi + Math.imul(Ao, Aa) | 0, _o = _o + Math.imul(Ao, Ga) | 0, Eo = Eo + Math.imul(Ko, $a) | 0, zi = zi + Math.imul(Ko, qa) | 0, zi = zi + Math.imul(Vo, $a) | 0, _o = _o + Math.imul(Vo, qa) | 0, Eo = Eo + Math.imul(xo, Ho) | 0, zi = zi + Math.imul(xo, qo) | 0, zi = zi + Math.imul(Qo, Ho) | 0, _o = _o + Math.imul(Qo, qo) | 0;
      var Xa = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, Eo = Math.imul(ma, ya), zi = Math.imul(ma, Ua), zi = zi + Math.imul(Va, ya) | 0, _o = Math.imul(Va, Ua), Eo = Eo + Math.imul(sa, Ra) | 0, zi = zi + Math.imul(sa, Ha) | 0, zi = zi + Math.imul(Ma, Ra) | 0, _o = _o + Math.imul(Ma, Ha) | 0, Eo = Eo + Math.imul(Zo, Aa) | 0, zi = zi + Math.imul(Zo, Ga) | 0, zi = zi + Math.imul(An, Aa) | 0, _o = _o + Math.imul(An, Ga) | 0, Eo = Eo + Math.imul(jo, $a) | 0, zi = zi + Math.imul(jo, qa) | 0, zi = zi + Math.imul(Ao, $a) | 0, _o = _o + Math.imul(Ao, qa) | 0, Eo = Eo + Math.imul(Ko, Ho) | 0, zi = zi + Math.imul(Ko, qo) | 0, zi = zi + Math.imul(Vo, Ho) | 0, _o = _o + Math.imul(Vo, qo) | 0, Eo = Eo + Math.imul(xo, Xo) | 0, zi = zi + Math.imul(xo, ea) | 0, zi = zi + Math.imul(Qo, Xo) | 0, _o = _o + Math.imul(Qo, ea) | 0;
      var ol = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (ol >>> 26) | 0, ol &= 67108863, Eo = Math.imul(ha, ya), zi = Math.imul(ha, Ua), zi = zi + Math.imul(Fa, ya) | 0, _o = Math.imul(Fa, Ua), Eo = Eo + Math.imul(ma, Ra) | 0, zi = zi + Math.imul(ma, Ha) | 0, zi = zi + Math.imul(Va, Ra) | 0, _o = _o + Math.imul(Va, Ha) | 0, Eo = Eo + Math.imul(sa, Aa) | 0, zi = zi + Math.imul(sa, Ga) | 0, zi = zi + Math.imul(Ma, Aa) | 0, _o = _o + Math.imul(Ma, Ga) | 0, Eo = Eo + Math.imul(Zo, $a) | 0, zi = zi + Math.imul(Zo, qa) | 0, zi = zi + Math.imul(An, $a) | 0, _o = _o + Math.imul(An, qa) | 0, Eo = Eo + Math.imul(jo, Ho) | 0, zi = zi + Math.imul(jo, qo) | 0, zi = zi + Math.imul(Ao, Ho) | 0, _o = _o + Math.imul(Ao, qo) | 0, Eo = Eo + Math.imul(Ko, Xo) | 0, zi = zi + Math.imul(Ko, ea) | 0, zi = zi + Math.imul(Vo, Xo) | 0, _o = _o + Math.imul(Vo, ea) | 0, Eo = Eo + Math.imul(xo, oa) | 0, zi = zi + Math.imul(xo, aa) | 0, zi = zi + Math.imul(Qo, oa) | 0, _o = _o + Math.imul(Qo, aa) | 0;
      var Za = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, Eo = Math.imul(da, ya), zi = Math.imul(da, Ua), zi = zi + Math.imul(Pa, ya) | 0, _o = Math.imul(Pa, Ua), Eo = Eo + Math.imul(ha, Ra) | 0, zi = zi + Math.imul(ha, Ha) | 0, zi = zi + Math.imul(Fa, Ra) | 0, _o = _o + Math.imul(Fa, Ha) | 0, Eo = Eo + Math.imul(ma, Aa) | 0, zi = zi + Math.imul(ma, Ga) | 0, zi = zi + Math.imul(Va, Aa) | 0, _o = _o + Math.imul(Va, Ga) | 0, Eo = Eo + Math.imul(sa, $a) | 0, zi = zi + Math.imul(sa, qa) | 0, zi = zi + Math.imul(Ma, $a) | 0, _o = _o + Math.imul(Ma, qa) | 0, Eo = Eo + Math.imul(Zo, Ho) | 0, zi = zi + Math.imul(Zo, qo) | 0, zi = zi + Math.imul(An, Ho) | 0, _o = _o + Math.imul(An, qo) | 0, Eo = Eo + Math.imul(jo, Xo) | 0, zi = zi + Math.imul(jo, ea) | 0, zi = zi + Math.imul(Ao, Xo) | 0, _o = _o + Math.imul(Ao, ea) | 0, Eo = Eo + Math.imul(Ko, oa) | 0, zi = zi + Math.imul(Ko, aa) | 0, zi = zi + Math.imul(Vo, oa) | 0, _o = _o + Math.imul(Vo, aa) | 0, Eo = Eo + Math.imul(xo, na) | 0, zi = zi + Math.imul(xo, _a) | 0, zi = zi + Math.imul(Qo, na) | 0, _o = _o + Math.imul(Qo, _a) | 0;
      var ul = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (ul >>> 26) | 0, ul &= 67108863, Eo = Math.imul(ca, ya), zi = Math.imul(ca, Ua), zi = zi + Math.imul(Na, ya) | 0, _o = Math.imul(Na, Ua), Eo = Eo + Math.imul(da, Ra) | 0, zi = zi + Math.imul(da, Ha) | 0, zi = zi + Math.imul(Pa, Ra) | 0, _o = _o + Math.imul(Pa, Ha) | 0, Eo = Eo + Math.imul(ha, Aa) | 0, zi = zi + Math.imul(ha, Ga) | 0, zi = zi + Math.imul(Fa, Aa) | 0, _o = _o + Math.imul(Fa, Ga) | 0, Eo = Eo + Math.imul(ma, $a) | 0, zi = zi + Math.imul(ma, qa) | 0, zi = zi + Math.imul(Va, $a) | 0, _o = _o + Math.imul(Va, qa) | 0, Eo = Eo + Math.imul(sa, Ho) | 0, zi = zi + Math.imul(sa, qo) | 0, zi = zi + Math.imul(Ma, Ho) | 0, _o = _o + Math.imul(Ma, qo) | 0, Eo = Eo + Math.imul(Zo, Xo) | 0, zi = zi + Math.imul(Zo, ea) | 0, zi = zi + Math.imul(An, Xo) | 0, _o = _o + Math.imul(An, ea) | 0, Eo = Eo + Math.imul(jo, oa) | 0, zi = zi + Math.imul(jo, aa) | 0, zi = zi + Math.imul(Ao, oa) | 0, _o = _o + Math.imul(Ao, aa) | 0, Eo = Eo + Math.imul(Ko, na) | 0, zi = zi + Math.imul(Ko, _a) | 0, zi = zi + Math.imul(Vo, na) | 0, _o = _o + Math.imul(Vo, _a) | 0, Eo = Eo + Math.imul(xo, la) | 0, zi = zi + Math.imul(xo, Ba) | 0, zi = zi + Math.imul(Qo, la) | 0, _o = _o + Math.imul(Qo, Ba) | 0;
      var cl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (cl >>> 26) | 0, cl &= 67108863, Eo = Math.imul(fa, ya), zi = Math.imul(fa, Ua), zi = zi + Math.imul(Ca, ya) | 0, _o = Math.imul(Ca, Ua), Eo = Eo + Math.imul(ca, Ra) | 0, zi = zi + Math.imul(ca, Ha) | 0, zi = zi + Math.imul(Na, Ra) | 0, _o = _o + Math.imul(Na, Ha) | 0, Eo = Eo + Math.imul(da, Aa) | 0, zi = zi + Math.imul(da, Ga) | 0, zi = zi + Math.imul(Pa, Aa) | 0, _o = _o + Math.imul(Pa, Ga) | 0, Eo = Eo + Math.imul(ha, $a) | 0, zi = zi + Math.imul(ha, qa) | 0, zi = zi + Math.imul(Fa, $a) | 0, _o = _o + Math.imul(Fa, qa) | 0, Eo = Eo + Math.imul(ma, Ho) | 0, zi = zi + Math.imul(ma, qo) | 0, zi = zi + Math.imul(Va, Ho) | 0, _o = _o + Math.imul(Va, qo) | 0, Eo = Eo + Math.imul(sa, Xo) | 0, zi = zi + Math.imul(sa, ea) | 0, zi = zi + Math.imul(Ma, Xo) | 0, _o = _o + Math.imul(Ma, ea) | 0, Eo = Eo + Math.imul(Zo, oa) | 0, zi = zi + Math.imul(Zo, aa) | 0, zi = zi + Math.imul(An, oa) | 0, _o = _o + Math.imul(An, aa) | 0, Eo = Eo + Math.imul(jo, na) | 0, zi = zi + Math.imul(jo, _a) | 0, zi = zi + Math.imul(Ao, na) | 0, _o = _o + Math.imul(Ao, _a) | 0, Eo = Eo + Math.imul(Ko, la) | 0, zi = zi + Math.imul(Ko, Ba) | 0, zi = zi + Math.imul(Vo, la) | 0, _o = _o + Math.imul(Vo, Ba) | 0, Eo = Eo + Math.imul(xo, Ta) | 0, zi = zi + Math.imul(xo, Ja) | 0, zi = zi + Math.imul(Qo, Ta) | 0, _o = _o + Math.imul(Qo, Ja) | 0;
      var fl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (fl >>> 26) | 0, fl &= 67108863, Eo = Math.imul(fa, Ra), zi = Math.imul(fa, Ha), zi = zi + Math.imul(Ca, Ra) | 0, _o = Math.imul(Ca, Ha), Eo = Eo + Math.imul(ca, Aa) | 0, zi = zi + Math.imul(ca, Ga) | 0, zi = zi + Math.imul(Na, Aa) | 0, _o = _o + Math.imul(Na, Ga) | 0, Eo = Eo + Math.imul(da, $a) | 0, zi = zi + Math.imul(da, qa) | 0, zi = zi + Math.imul(Pa, $a) | 0, _o = _o + Math.imul(Pa, qa) | 0, Eo = Eo + Math.imul(ha, Ho) | 0, zi = zi + Math.imul(ha, qo) | 0, zi = zi + Math.imul(Fa, Ho) | 0, _o = _o + Math.imul(Fa, qo) | 0, Eo = Eo + Math.imul(ma, Xo) | 0, zi = zi + Math.imul(ma, ea) | 0, zi = zi + Math.imul(Va, Xo) | 0, _o = _o + Math.imul(Va, ea) | 0, Eo = Eo + Math.imul(sa, oa) | 0, zi = zi + Math.imul(sa, aa) | 0, zi = zi + Math.imul(Ma, oa) | 0, _o = _o + Math.imul(Ma, aa) | 0, Eo = Eo + Math.imul(Zo, na) | 0, zi = zi + Math.imul(Zo, _a) | 0, zi = zi + Math.imul(An, na) | 0, _o = _o + Math.imul(An, _a) | 0, Eo = Eo + Math.imul(jo, la) | 0, zi = zi + Math.imul(jo, Ba) | 0, zi = zi + Math.imul(Ao, la) | 0, _o = _o + Math.imul(Ao, Ba) | 0, Eo = Eo + Math.imul(Ko, Ta) | 0, zi = zi + Math.imul(Ko, Ja) | 0, zi = zi + Math.imul(Vo, Ta) | 0, _o = _o + Math.imul(Vo, Ja) | 0;
      var pl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (pl >>> 26) | 0, pl &= 67108863, Eo = Math.imul(fa, Aa), zi = Math.imul(fa, Ga), zi = zi + Math.imul(Ca, Aa) | 0, _o = Math.imul(Ca, Ga), Eo = Eo + Math.imul(ca, $a) | 0, zi = zi + Math.imul(ca, qa) | 0, zi = zi + Math.imul(Na, $a) | 0, _o = _o + Math.imul(Na, qa) | 0, Eo = Eo + Math.imul(da, Ho) | 0, zi = zi + Math.imul(da, qo) | 0, zi = zi + Math.imul(Pa, Ho) | 0, _o = _o + Math.imul(Pa, qo) | 0, Eo = Eo + Math.imul(ha, Xo) | 0, zi = zi + Math.imul(ha, ea) | 0, zi = zi + Math.imul(Fa, Xo) | 0, _o = _o + Math.imul(Fa, ea) | 0, Eo = Eo + Math.imul(ma, oa) | 0, zi = zi + Math.imul(ma, aa) | 0, zi = zi + Math.imul(Va, oa) | 0, _o = _o + Math.imul(Va, aa) | 0, Eo = Eo + Math.imul(sa, na) | 0, zi = zi + Math.imul(sa, _a) | 0, zi = zi + Math.imul(Ma, na) | 0, _o = _o + Math.imul(Ma, _a) | 0, Eo = Eo + Math.imul(Zo, la) | 0, zi = zi + Math.imul(Zo, Ba) | 0, zi = zi + Math.imul(An, la) | 0, _o = _o + Math.imul(An, Ba) | 0, Eo = Eo + Math.imul(jo, Ta) | 0, zi = zi + Math.imul(jo, Ja) | 0, zi = zi + Math.imul(Ao, Ta) | 0, _o = _o + Math.imul(Ao, Ja) | 0;
      var dl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (dl >>> 26) | 0, dl &= 67108863, Eo = Math.imul(fa, $a), zi = Math.imul(fa, qa), zi = zi + Math.imul(Ca, $a) | 0, _o = Math.imul(Ca, qa), Eo = Eo + Math.imul(ca, Ho) | 0, zi = zi + Math.imul(ca, qo) | 0, zi = zi + Math.imul(Na, Ho) | 0, _o = _o + Math.imul(Na, qo) | 0, Eo = Eo + Math.imul(da, Xo) | 0, zi = zi + Math.imul(da, ea) | 0, zi = zi + Math.imul(Pa, Xo) | 0, _o = _o + Math.imul(Pa, ea) | 0, Eo = Eo + Math.imul(ha, oa) | 0, zi = zi + Math.imul(ha, aa) | 0, zi = zi + Math.imul(Fa, oa) | 0, _o = _o + Math.imul(Fa, aa) | 0, Eo = Eo + Math.imul(ma, na) | 0, zi = zi + Math.imul(ma, _a) | 0, zi = zi + Math.imul(Va, na) | 0, _o = _o + Math.imul(Va, _a) | 0, Eo = Eo + Math.imul(sa, la) | 0, zi = zi + Math.imul(sa, Ba) | 0, zi = zi + Math.imul(Ma, la) | 0, _o = _o + Math.imul(Ma, Ba) | 0, Eo = Eo + Math.imul(Zo, Ta) | 0, zi = zi + Math.imul(Zo, Ja) | 0, zi = zi + Math.imul(An, Ta) | 0, _o = _o + Math.imul(An, Ja) | 0;
      var al = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (al >>> 26) | 0, al &= 67108863, Eo = Math.imul(fa, Ho), zi = Math.imul(fa, qo), zi = zi + Math.imul(Ca, Ho) | 0, _o = Math.imul(Ca, qo), Eo = Eo + Math.imul(ca, Xo) | 0, zi = zi + Math.imul(ca, ea) | 0, zi = zi + Math.imul(Na, Xo) | 0, _o = _o + Math.imul(Na, ea) | 0, Eo = Eo + Math.imul(da, oa) | 0, zi = zi + Math.imul(da, aa) | 0, zi = zi + Math.imul(Pa, oa) | 0, _o = _o + Math.imul(Pa, aa) | 0, Eo = Eo + Math.imul(ha, na) | 0, zi = zi + Math.imul(ha, _a) | 0, zi = zi + Math.imul(Fa, na) | 0, _o = _o + Math.imul(Fa, _a) | 0, Eo = Eo + Math.imul(ma, la) | 0, zi = zi + Math.imul(ma, Ba) | 0, zi = zi + Math.imul(Va, la) | 0, _o = _o + Math.imul(Va, Ba) | 0, Eo = Eo + Math.imul(sa, Ta) | 0, zi = zi + Math.imul(sa, Ja) | 0, zi = zi + Math.imul(Ma, Ta) | 0, _o = _o + Math.imul(Ma, Ja) | 0;
      var hl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (hl >>> 26) | 0, hl &= 67108863, Eo = Math.imul(fa, Xo), zi = Math.imul(fa, ea), zi = zi + Math.imul(Ca, Xo) | 0, _o = Math.imul(Ca, ea), Eo = Eo + Math.imul(ca, oa) | 0, zi = zi + Math.imul(ca, aa) | 0, zi = zi + Math.imul(Na, oa) | 0, _o = _o + Math.imul(Na, aa) | 0, Eo = Eo + Math.imul(da, na) | 0, zi = zi + Math.imul(da, _a) | 0, zi = zi + Math.imul(Pa, na) | 0, _o = _o + Math.imul(Pa, _a) | 0, Eo = Eo + Math.imul(ha, la) | 0, zi = zi + Math.imul(ha, Ba) | 0, zi = zi + Math.imul(Fa, la) | 0, _o = _o + Math.imul(Fa, Ba) | 0, Eo = Eo + Math.imul(ma, Ta) | 0, zi = zi + Math.imul(ma, Ja) | 0, zi = zi + Math.imul(Va, Ta) | 0, _o = _o + Math.imul(Va, Ja) | 0;
      var gl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (gl >>> 26) | 0, gl &= 67108863, Eo = Math.imul(fa, oa), zi = Math.imul(fa, aa), zi = zi + Math.imul(Ca, oa) | 0, _o = Math.imul(Ca, aa), Eo = Eo + Math.imul(ca, na) | 0, zi = zi + Math.imul(ca, _a) | 0, zi = zi + Math.imul(Na, na) | 0, _o = _o + Math.imul(Na, _a) | 0, Eo = Eo + Math.imul(da, la) | 0, zi = zi + Math.imul(da, Ba) | 0, zi = zi + Math.imul(Pa, la) | 0, _o = _o + Math.imul(Pa, Ba) | 0, Eo = Eo + Math.imul(ha, Ta) | 0, zi = zi + Math.imul(ha, Ja) | 0, zi = zi + Math.imul(Fa, Ta) | 0, _o = _o + Math.imul(Fa, Ja) | 0;
      var il = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (il >>> 26) | 0, il &= 67108863, Eo = Math.imul(fa, na), zi = Math.imul(fa, _a), zi = zi + Math.imul(Ca, na) | 0, _o = Math.imul(Ca, _a), Eo = Eo + Math.imul(ca, la) | 0, zi = zi + Math.imul(ca, Ba) | 0, zi = zi + Math.imul(Na, la) | 0, _o = _o + Math.imul(Na, Ba) | 0, Eo = Eo + Math.imul(da, Ta) | 0, zi = zi + Math.imul(da, Ja) | 0, zi = zi + Math.imul(Pa, Ta) | 0, _o = _o + Math.imul(Pa, Ja) | 0;
      var yl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (yl >>> 26) | 0, yl &= 67108863, Eo = Math.imul(fa, la), zi = Math.imul(fa, Ba), zi = zi + Math.imul(Ca, la) | 0, _o = Math.imul(Ca, Ba), Eo = Eo + Math.imul(ca, Ta) | 0, zi = zi + Math.imul(ca, Ja) | 0, zi = zi + Math.imul(Na, Ta) | 0, _o = _o + Math.imul(Na, Ja) | 0;
      var bl = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      $o = (_o + (zi >>> 13) | 0) + (bl >>> 26) | 0, bl &= 67108863, Eo = Math.imul(fa, Ta), zi = Math.imul(fa, Ja), zi = zi + Math.imul(Ca, Ta) | 0, _o = Math.imul(Ca, Ja);
      var ml = ($o + Eo | 0) + ((zi & 8191) << 13) | 0;
      return $o = (_o + (zi >>> 13) | 0) + (ml >>> 26) | 0, ml &= 67108863, So[0] = ja, So[1] = za, So[2] = Qa, So[3] = tl, So[4] = Xa, So[5] = ol, So[6] = Za, So[7] = ul, So[8] = cl, So[9] = fl, So[10] = pl, So[11] = dl, So[12] = al, So[13] = hl, So[14] = gl, So[15] = il, So[16] = yl, So[17] = bl, So[18] = ml, $o !== 0 && (So[19] = $o, Ai.length++), Ai;
    };
    Math.imul || (Ro = Oo);
    function Bo(Do, wo, Li) {
      Li.negative = wo.negative ^ Do.negative, Li.length = Do.length + wo.length;
      for (var Ai = 0, Ni = 0, Ui = 0; Ui < Li.length - 1; Ui++) {
        var So = Ni;
        Ni = 0;
        for (var $o = Ai & 67108863, Eo = Math.min(Ui, wo.length - 1), zi = Math.max(0, Ui - Do.length + 1); zi <= Eo; zi++) {
          var _o = Ui - zi, Fi = Do.words[_o] | 0, xo = wo.words[zi] | 0, Qo = Fi * xo, To = Qo & 67108863;
          So = So + (Qo / 67108864 | 0) | 0, To = To + $o | 0, $o = To & 67108863, So = So + (To >>> 26) | 0, Ni += So >>> 26, So &= 67108863;
        }
        Li.words[Ui] = $o, Ai = So, So = Ni;
      }
      return Ai !== 0 ? Li.words[Ui] = Ai : Li.length--, Li.strip();
    }
    function Fo(Do, wo, Li) {
      var Ai = new Io();
      return Ai.mulp(Do, wo, Li);
    }
    Ei.prototype.mulTo = function(wo, Li) {
      var Ai, Ni = this.length + wo.length;
      return this.length === 10 && wo.length === 10 ? Ai = Ro(this, wo, Li) : Ni < 63 ? Ai = Oo(this, wo, Li) : Ni < 1024 ? Ai = Bo(this, wo, Li) : Ai = Fo(this, wo, Li), Ai;
    };
    function Io(Do, wo) {
      this.x = Do, this.y = wo;
    }
    Io.prototype.makeRBT = function(wo) {
      for (var Li = new Array(wo), Ai = Ei.prototype._countBits(wo) - 1, Ni = 0; Ni < wo; Ni++)
        Li[Ni] = this.revBin(Ni, Ai, wo);
      return Li;
    }, Io.prototype.revBin = function(wo, Li, Ai) {
      if (wo === 0 || wo === Ai - 1)
        return wo;
      for (var Ni = 0, Ui = 0; Ui < Li; Ui++)
        Ni |= (wo & 1) << Li - Ui - 1, wo >>= 1;
      return Ni;
    }, Io.prototype.permute = function(wo, Li, Ai, Ni, Ui, So) {
      for (var $o = 0; $o < So; $o++)
        Ni[$o] = Li[wo[$o]], Ui[$o] = Ai[wo[$o]];
    }, Io.prototype.transform = function(wo, Li, Ai, Ni, Ui, So) {
      this.permute(So, wo, Li, Ai, Ni, Ui);
      for (var $o = 1; $o < Ui; $o <<= 1)
        for (var Eo = $o << 1, zi = Math.cos(2 * Math.PI / Eo), _o = Math.sin(2 * Math.PI / Eo), Fi = 0; Fi < Ui; Fi += Eo)
          for (var xo = zi, Qo = _o, To = 0; To < $o; To++) {
            var Ko = Ai[Fi + To], Vo = Ni[Fi + To], Wo = Ai[Fi + To + $o], jo = Ni[Fi + To + $o], Ao = xo * Wo - Qo * jo;
            jo = xo * jo + Qo * Wo, Wo = Ao, Ai[Fi + To] = Ko + Wo, Ni[Fi + To] = Vo + jo, Ai[Fi + To + $o] = Ko - Wo, Ni[Fi + To + $o] = Vo - jo, To !== Eo && (Ao = zi * xo - _o * Qo, Qo = zi * Qo + _o * xo, xo = Ao);
          }
    }, Io.prototype.guessLen13b = function(wo, Li) {
      var Ai = Math.max(Li, wo) | 1, Ni = Ai & 1, Ui = 0;
      for (Ai = Ai / 2 | 0; Ai; Ai = Ai >>> 1)
        Ui++;
      return 1 << Ui + 1 + Ni;
    }, Io.prototype.conjugate = function(wo, Li, Ai) {
      if (!(Ai <= 1))
        for (var Ni = 0; Ni < Ai / 2; Ni++) {
          var Ui = wo[Ni];
          wo[Ni] = wo[Ai - Ni - 1], wo[Ai - Ni - 1] = Ui, Ui = Li[Ni], Li[Ni] = -Li[Ai - Ni - 1], Li[Ai - Ni - 1] = -Ui;
        }
    }, Io.prototype.normalize13b = function(wo, Li) {
      for (var Ai = 0, Ni = 0; Ni < Li / 2; Ni++) {
        var Ui = Math.round(wo[2 * Ni + 1] / Li) * 8192 + Math.round(wo[2 * Ni] / Li) + Ai;
        wo[Ni] = Ui & 67108863, Ui < 67108864 ? Ai = 0 : Ai = Ui / 67108864 | 0;
      }
      return wo;
    }, Io.prototype.convert13b = function(wo, Li, Ai, Ni) {
      for (var Ui = 0, So = 0; So < Li; So++)
        Ui = Ui + (wo[So] | 0), Ai[2 * So] = Ui & 8191, Ui = Ui >>> 13, Ai[2 * So + 1] = Ui & 8191, Ui = Ui >>> 13;
      for (So = 2 * Li; So < Ni; ++So)
        Ai[So] = 0;
      Si(Ui === 0), Si((Ui & -8192) === 0);
    }, Io.prototype.stub = function(wo) {
      for (var Li = new Array(wo), Ai = 0; Ai < wo; Ai++)
        Li[Ai] = 0;
      return Li;
    }, Io.prototype.mulp = function(wo, Li, Ai) {
      var Ni = 2 * this.guessLen13b(wo.length, Li.length), Ui = this.makeRBT(Ni), So = this.stub(Ni), $o = new Array(Ni), Eo = new Array(Ni), zi = new Array(Ni), _o = new Array(Ni), Fi = new Array(Ni), xo = new Array(Ni), Qo = Ai.words;
      Qo.length = Ni, this.convert13b(wo.words, wo.length, $o, Ni), this.convert13b(Li.words, Li.length, _o, Ni), this.transform($o, So, Eo, zi, Ni, Ui), this.transform(_o, So, Fi, xo, Ni, Ui);
      for (var To = 0; To < Ni; To++) {
        var Ko = Eo[To] * Fi[To] - zi[To] * xo[To];
        zi[To] = Eo[To] * xo[To] + zi[To] * Fi[To], Eo[To] = Ko;
      }
      return this.conjugate(Eo, zi, Ni), this.transform(Eo, zi, Qo, So, Ni, Ui), this.conjugate(Qo, So, Ni), this.normalize13b(Qo, Ni), Ai.negative = wo.negative ^ Li.negative, Ai.length = wo.length + Li.length, Ai.strip();
    }, Ei.prototype.mul = function(wo) {
      var Li = new Ei(null);
      return Li.words = new Array(this.length + wo.length), this.mulTo(wo, Li);
    }, Ei.prototype.mulf = function(wo) {
      var Li = new Ei(null);
      return Li.words = new Array(this.length + wo.length), Fo(this, wo, Li);
    }, Ei.prototype.imul = function(wo) {
      return this.clone().mulTo(wo, this);
    }, Ei.prototype.imuln = function(wo) {
      Si(typeof wo == "number"), Si(wo < 67108864);
      for (var Li = 0, Ai = 0; Ai < this.length; Ai++) {
        var Ni = (this.words[Ai] | 0) * wo, Ui = (Ni & 67108863) + (Li & 67108863);
        Li >>= 26, Li += Ni / 67108864 | 0, Li += Ui >>> 26, this.words[Ai] = Ui & 67108863;
      }
      return Li !== 0 && (this.words[Ai] = Li, this.length++), this;
    }, Ei.prototype.muln = function(wo) {
      return this.clone().imuln(wo);
    }, Ei.prototype.sqr = function() {
      return this.mul(this);
    }, Ei.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ei.prototype.pow = function(wo) {
      var Li = Ci(wo);
      if (Li.length === 0)
        return new Ei(1);
      for (var Ai = this, Ni = 0; Ni < Li.length && Li[Ni] === 0; Ni++, Ai = Ai.sqr())
        ;
      if (++Ni < Li.length)
        for (var Ui = Ai.sqr(); Ni < Li.length; Ni++, Ui = Ui.sqr())
          Li[Ni] !== 0 && (Ai = Ai.mul(Ui));
      return Ai;
    }, Ei.prototype.iushln = function(wo) {
      Si(typeof wo == "number" && wo >= 0);
      var Li = wo % 26, Ai = (wo - Li) / 26, Ni = 67108863 >>> 26 - Li << 26 - Li, Ui;
      if (Li !== 0) {
        var So = 0;
        for (Ui = 0; Ui < this.length; Ui++) {
          var $o = this.words[Ui] & Ni, Eo = (this.words[Ui] | 0) - $o << Li;
          this.words[Ui] = Eo | So, So = $o >>> 26 - Li;
        }
        So && (this.words[Ui] = So, this.length++);
      }
      if (Ai !== 0) {
        for (Ui = this.length - 1; Ui >= 0; Ui--)
          this.words[Ui + Ai] = this.words[Ui];
        for (Ui = 0; Ui < Ai; Ui++)
          this.words[Ui] = 0;
        this.length += Ai;
      }
      return this.strip();
    }, Ei.prototype.ishln = function(wo) {
      return Si(this.negative === 0), this.iushln(wo);
    }, Ei.prototype.iushrn = function(wo, Li, Ai) {
      Si(typeof wo == "number" && wo >= 0);
      var Ni;
      Li ? Ni = (Li - Li % 26) / 26 : Ni = 0;
      var Ui = wo % 26, So = Math.min((wo - Ui) / 26, this.length), $o = 67108863 ^ 67108863 >>> Ui << Ui, Eo = Ai;
      if (Ni -= So, Ni = Math.max(0, Ni), Eo) {
        for (var zi = 0; zi < So; zi++)
          Eo.words[zi] = this.words[zi];
        Eo.length = So;
      }
      if (So !== 0)
        if (this.length > So)
          for (this.length -= So, zi = 0; zi < this.length; zi++)
            this.words[zi] = this.words[zi + So];
        else
          this.words[0] = 0, this.length = 1;
      var _o = 0;
      for (zi = this.length - 1; zi >= 0 && (_o !== 0 || zi >= Ni); zi--) {
        var Fi = this.words[zi] | 0;
        this.words[zi] = _o << 26 - Ui | Fi >>> Ui, _o = Fi & $o;
      }
      return Eo && _o !== 0 && (Eo.words[Eo.length++] = _o), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, Ei.prototype.ishrn = function(wo, Li, Ai) {
      return Si(this.negative === 0), this.iushrn(wo, Li, Ai);
    }, Ei.prototype.shln = function(wo) {
      return this.clone().ishln(wo);
    }, Ei.prototype.ushln = function(wo) {
      return this.clone().iushln(wo);
    }, Ei.prototype.shrn = function(wo) {
      return this.clone().ishrn(wo);
    }, Ei.prototype.ushrn = function(wo) {
      return this.clone().iushrn(wo);
    }, Ei.prototype.testn = function(wo) {
      Si(typeof wo == "number" && wo >= 0);
      var Li = wo % 26, Ai = (wo - Li) / 26, Ni = 1 << Li;
      if (this.length <= Ai)
        return !1;
      var Ui = this.words[Ai];
      return !!(Ui & Ni);
    }, Ei.prototype.imaskn = function(wo) {
      Si(typeof wo == "number" && wo >= 0);
      var Li = wo % 26, Ai = (wo - Li) / 26;
      if (Si(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ai)
        return this;
      if (Li !== 0 && Ai++, this.length = Math.min(Ai, this.length), Li !== 0) {
        var Ni = 67108863 ^ 67108863 >>> Li << Li;
        this.words[this.length - 1] &= Ni;
      }
      return this.strip();
    }, Ei.prototype.maskn = function(wo) {
      return this.clone().imaskn(wo);
    }, Ei.prototype.iaddn = function(wo) {
      return Si(typeof wo == "number"), Si(wo < 67108864), wo < 0 ? this.isubn(-wo) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < wo ? (this.words[0] = wo - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(wo), this.negative = 1, this) : this._iaddn(wo);
    }, Ei.prototype._iaddn = function(wo) {
      this.words[0] += wo;
      for (var Li = 0; Li < this.length && this.words[Li] >= 67108864; Li++)
        this.words[Li] -= 67108864, Li === this.length - 1 ? this.words[Li + 1] = 1 : this.words[Li + 1]++;
      return this.length = Math.max(this.length, Li + 1), this;
    }, Ei.prototype.isubn = function(wo) {
      if (Si(typeof wo == "number"), Si(wo < 67108864), wo < 0)
        return this.iaddn(-wo);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(wo), this.negative = 1, this;
      if (this.words[0] -= wo, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Li = 0; Li < this.length && this.words[Li] < 0; Li++)
          this.words[Li] += 67108864, this.words[Li + 1] -= 1;
      return this.strip();
    }, Ei.prototype.addn = function(wo) {
      return this.clone().iaddn(wo);
    }, Ei.prototype.subn = function(wo) {
      return this.clone().isubn(wo);
    }, Ei.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Ei.prototype.abs = function() {
      return this.clone().iabs();
    }, Ei.prototype._ishlnsubmul = function(wo, Li, Ai) {
      var Ni = wo.length + Ai, Ui;
      this._expand(Ni);
      var So, $o = 0;
      for (Ui = 0; Ui < wo.length; Ui++) {
        So = (this.words[Ui + Ai] | 0) + $o;
        var Eo = (wo.words[Ui] | 0) * Li;
        So -= Eo & 67108863, $o = (So >> 26) - (Eo / 67108864 | 0), this.words[Ui + Ai] = So & 67108863;
      }
      for (; Ui < this.length - Ai; Ui++)
        So = (this.words[Ui + Ai] | 0) + $o, $o = So >> 26, this.words[Ui + Ai] = So & 67108863;
      if ($o === 0)
        return this.strip();
      for (Si($o === -1), $o = 0, Ui = 0; Ui < this.length; Ui++)
        So = -(this.words[Ui] | 0) + $o, $o = So >> 26, this.words[Ui] = So & 67108863;
      return this.negative = 1, this.strip();
    }, Ei.prototype._wordDiv = function(wo, Li) {
      var Ai = this.length - wo.length, Ni = this.clone(), Ui = wo, So = Ui.words[Ui.length - 1] | 0, $o = this._countBits(So);
      Ai = 26 - $o, Ai !== 0 && (Ui = Ui.ushln(Ai), Ni.iushln(Ai), So = Ui.words[Ui.length - 1] | 0);
      var Eo = Ni.length - Ui.length, zi;
      if (Li !== "mod") {
        zi = new Ei(null), zi.length = Eo + 1, zi.words = new Array(zi.length);
        for (var _o = 0; _o < zi.length; _o++)
          zi.words[_o] = 0;
      }
      var Fi = Ni.clone()._ishlnsubmul(Ui, 1, Eo);
      Fi.negative === 0 && (Ni = Fi, zi && (zi.words[Eo] = 1));
      for (var xo = Eo - 1; xo >= 0; xo--) {
        var Qo = (Ni.words[Ui.length + xo] | 0) * 67108864 + (Ni.words[Ui.length + xo - 1] | 0);
        for (Qo = Math.min(Qo / So | 0, 67108863), Ni._ishlnsubmul(Ui, Qo, xo); Ni.negative !== 0; )
          Qo--, Ni.negative = 0, Ni._ishlnsubmul(Ui, 1, xo), Ni.isZero() || (Ni.negative ^= 1);
        zi && (zi.words[xo] = Qo);
      }
      return zi && zi.strip(), Ni.strip(), Li !== "div" && Ai !== 0 && Ni.iushrn(Ai), {
        div: zi || null,
        mod: Ni
      };
    }, Ei.prototype.divmod = function(wo, Li, Ai) {
      if (Si(!wo.isZero()), this.isZero())
        return {
          div: new Ei(0),
          mod: new Ei(0)
        };
      var Ni, Ui, So;
      return this.negative !== 0 && wo.negative === 0 ? (So = this.neg().divmod(wo, Li), Li !== "mod" && (Ni = So.div.neg()), Li !== "div" && (Ui = So.mod.neg(), Ai && Ui.negative !== 0 && Ui.iadd(wo)), {
        div: Ni,
        mod: Ui
      }) : this.negative === 0 && wo.negative !== 0 ? (So = this.divmod(wo.neg(), Li), Li !== "mod" && (Ni = So.div.neg()), {
        div: Ni,
        mod: So.mod
      }) : this.negative & wo.negative ? (So = this.neg().divmod(wo.neg(), Li), Li !== "div" && (Ui = So.mod.neg(), Ai && Ui.negative !== 0 && Ui.isub(wo)), {
        div: So.div,
        mod: Ui
      }) : wo.length > this.length || this.cmp(wo) < 0 ? {
        div: new Ei(0),
        mod: this
      } : wo.length === 1 ? Li === "div" ? {
        div: this.divn(wo.words[0]),
        mod: null
      } : Li === "mod" ? {
        div: null,
        mod: new Ei(this.modn(wo.words[0]))
      } : {
        div: this.divn(wo.words[0]),
        mod: new Ei(this.modn(wo.words[0]))
      } : this._wordDiv(wo, Li);
    }, Ei.prototype.div = function(wo) {
      return this.divmod(wo, "div", !1).div;
    }, Ei.prototype.mod = function(wo) {
      return this.divmod(wo, "mod", !1).mod;
    }, Ei.prototype.umod = function(wo) {
      return this.divmod(wo, "mod", !0).mod;
    }, Ei.prototype.divRound = function(wo) {
      var Li = this.divmod(wo);
      if (Li.mod.isZero())
        return Li.div;
      var Ai = Li.div.negative !== 0 ? Li.mod.isub(wo) : Li.mod, Ni = wo.ushrn(1), Ui = wo.andln(1), So = Ai.cmp(Ni);
      return So < 0 || Ui === 1 && So === 0 ? Li.div : Li.div.negative !== 0 ? Li.div.isubn(1) : Li.div.iaddn(1);
    }, Ei.prototype.modn = function(wo) {
      Si(wo <= 67108863);
      for (var Li = (1 << 26) % wo, Ai = 0, Ni = this.length - 1; Ni >= 0; Ni--)
        Ai = (Li * Ai + (this.words[Ni] | 0)) % wo;
      return Ai;
    }, Ei.prototype.idivn = function(wo) {
      Si(wo <= 67108863);
      for (var Li = 0, Ai = this.length - 1; Ai >= 0; Ai--) {
        var Ni = (this.words[Ai] | 0) + Li * 67108864;
        this.words[Ai] = Ni / wo | 0, Li = Ni % wo;
      }
      return this.strip();
    }, Ei.prototype.divn = function(wo) {
      return this.clone().idivn(wo);
    }, Ei.prototype.egcd = function(wo) {
      Si(wo.negative === 0), Si(!wo.isZero());
      var Li = this, Ai = wo.clone();
      Li.negative !== 0 ? Li = Li.umod(wo) : Li = Li.clone();
      for (var Ni = new Ei(1), Ui = new Ei(0), So = new Ei(0), $o = new Ei(1), Eo = 0; Li.isEven() && Ai.isEven(); )
        Li.iushrn(1), Ai.iushrn(1), ++Eo;
      for (var zi = Ai.clone(), _o = Li.clone(); !Li.isZero(); ) {
        for (var Fi = 0, xo = 1; !(Li.words[0] & xo) && Fi < 26; ++Fi, xo <<= 1)
          ;
        if (Fi > 0)
          for (Li.iushrn(Fi); Fi-- > 0; )
            (Ni.isOdd() || Ui.isOdd()) && (Ni.iadd(zi), Ui.isub(_o)), Ni.iushrn(1), Ui.iushrn(1);
        for (var Qo = 0, To = 1; !(Ai.words[0] & To) && Qo < 26; ++Qo, To <<= 1)
          ;
        if (Qo > 0)
          for (Ai.iushrn(Qo); Qo-- > 0; )
            (So.isOdd() || $o.isOdd()) && (So.iadd(zi), $o.isub(_o)), So.iushrn(1), $o.iushrn(1);
        Li.cmp(Ai) >= 0 ? (Li.isub(Ai), Ni.isub(So), Ui.isub($o)) : (Ai.isub(Li), So.isub(Ni), $o.isub(Ui));
      }
      return {
        a: So,
        b: $o,
        gcd: Ai.iushln(Eo)
      };
    }, Ei.prototype._invmp = function(wo) {
      Si(wo.negative === 0), Si(!wo.isZero());
      var Li = this, Ai = wo.clone();
      Li.negative !== 0 ? Li = Li.umod(wo) : Li = Li.clone();
      for (var Ni = new Ei(1), Ui = new Ei(0), So = Ai.clone(); Li.cmpn(1) > 0 && Ai.cmpn(1) > 0; ) {
        for (var $o = 0, Eo = 1; !(Li.words[0] & Eo) && $o < 26; ++$o, Eo <<= 1)
          ;
        if ($o > 0)
          for (Li.iushrn($o); $o-- > 0; )
            Ni.isOdd() && Ni.iadd(So), Ni.iushrn(1);
        for (var zi = 0, _o = 1; !(Ai.words[0] & _o) && zi < 26; ++zi, _o <<= 1)
          ;
        if (zi > 0)
          for (Ai.iushrn(zi); zi-- > 0; )
            Ui.isOdd() && Ui.iadd(So), Ui.iushrn(1);
        Li.cmp(Ai) >= 0 ? (Li.isub(Ai), Ni.isub(Ui)) : (Ai.isub(Li), Ui.isub(Ni));
      }
      var Fi;
      return Li.cmpn(1) === 0 ? Fi = Ni : Fi = Ui, Fi.cmpn(0) < 0 && Fi.iadd(wo), Fi;
    }, Ei.prototype.gcd = function(wo) {
      if (this.isZero())
        return wo.abs();
      if (wo.isZero())
        return this.abs();
      var Li = this.clone(), Ai = wo.clone();
      Li.negative = 0, Ai.negative = 0;
      for (var Ni = 0; Li.isEven() && Ai.isEven(); Ni++)
        Li.iushrn(1), Ai.iushrn(1);
      do {
        for (; Li.isEven(); )
          Li.iushrn(1);
        for (; Ai.isEven(); )
          Ai.iushrn(1);
        var Ui = Li.cmp(Ai);
        if (Ui < 0) {
          var So = Li;
          Li = Ai, Ai = So;
        } else if (Ui === 0 || Ai.cmpn(1) === 0)
          break;
        Li.isub(Ai);
      } while (!0);
      return Ai.iushln(Ni);
    }, Ei.prototype.invm = function(wo) {
      return this.egcd(wo).a.umod(wo);
    }, Ei.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Ei.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Ei.prototype.andln = function(wo) {
      return this.words[0] & wo;
    }, Ei.prototype.bincn = function(wo) {
      Si(typeof wo == "number");
      var Li = wo % 26, Ai = (wo - Li) / 26, Ni = 1 << Li;
      if (this.length <= Ai)
        return this._expand(Ai + 1), this.words[Ai] |= Ni, this;
      for (var Ui = Ni, So = Ai; Ui !== 0 && So < this.length; So++) {
        var $o = this.words[So] | 0;
        $o += Ui, Ui = $o >>> 26, $o &= 67108863, this.words[So] = $o;
      }
      return Ui !== 0 && (this.words[So] = Ui, this.length++), this;
    }, Ei.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Ei.prototype.cmpn = function(wo) {
      var Li = wo < 0;
      if (this.negative !== 0 && !Li)
        return -1;
      if (this.negative === 0 && Li)
        return 1;
      this.strip();
      var Ai;
      if (this.length > 1)
        Ai = 1;
      else {
        Li && (wo = -wo), Si(wo <= 67108863, "Number is too big");
        var Ni = this.words[0] | 0;
        Ai = Ni === wo ? 0 : Ni < wo ? -1 : 1;
      }
      return this.negative !== 0 ? -Ai | 0 : Ai;
    }, Ei.prototype.cmp = function(wo) {
      if (this.negative !== 0 && wo.negative === 0)
        return -1;
      if (this.negative === 0 && wo.negative !== 0)
        return 1;
      var Li = this.ucmp(wo);
      return this.negative !== 0 ? -Li | 0 : Li;
    }, Ei.prototype.ucmp = function(wo) {
      if (this.length > wo.length)
        return 1;
      if (this.length < wo.length)
        return -1;
      for (var Li = 0, Ai = this.length - 1; Ai >= 0; Ai--) {
        var Ni = this.words[Ai] | 0, Ui = wo.words[Ai] | 0;
        if (Ni !== Ui) {
          Ni < Ui ? Li = -1 : Ni > Ui && (Li = 1);
          break;
        }
      }
      return Li;
    }, Ei.prototype.gtn = function(wo) {
      return this.cmpn(wo) === 1;
    }, Ei.prototype.gt = function(wo) {
      return this.cmp(wo) === 1;
    }, Ei.prototype.gten = function(wo) {
      return this.cmpn(wo) >= 0;
    }, Ei.prototype.gte = function(wo) {
      return this.cmp(wo) >= 0;
    }, Ei.prototype.ltn = function(wo) {
      return this.cmpn(wo) === -1;
    }, Ei.prototype.lt = function(wo) {
      return this.cmp(wo) === -1;
    }, Ei.prototype.lten = function(wo) {
      return this.cmpn(wo) <= 0;
    }, Ei.prototype.lte = function(wo) {
      return this.cmp(wo) <= 0;
    }, Ei.prototype.eqn = function(wo) {
      return this.cmpn(wo) === 0;
    }, Ei.prototype.eq = function(wo) {
      return this.cmp(wo) === 0;
    }, Ei.red = function(wo) {
      return new Jo(wo);
    }, Ei.prototype.toRed = function(wo) {
      return Si(!this.red, "Already a number in reduction context"), Si(this.negative === 0, "red works only with positives"), wo.convertTo(this)._forceRed(wo);
    }, Ei.prototype.fromRed = function() {
      return Si(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Ei.prototype._forceRed = function(wo) {
      return this.red = wo, this;
    }, Ei.prototype.forceRed = function(wo) {
      return Si(!this.red, "Already a number in reduction context"), this._forceRed(wo);
    }, Ei.prototype.redAdd = function(wo) {
      return Si(this.red, "redAdd works only with red numbers"), this.red.add(this, wo);
    }, Ei.prototype.redIAdd = function(wo) {
      return Si(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, wo);
    }, Ei.prototype.redSub = function(wo) {
      return Si(this.red, "redSub works only with red numbers"), this.red.sub(this, wo);
    }, Ei.prototype.redISub = function(wo) {
      return Si(this.red, "redISub works only with red numbers"), this.red.isub(this, wo);
    }, Ei.prototype.redShl = function(wo) {
      return Si(this.red, "redShl works only with red numbers"), this.red.shl(this, wo);
    }, Ei.prototype.redMul = function(wo) {
      return Si(this.red, "redMul works only with red numbers"), this.red._verify2(this, wo), this.red.mul(this, wo);
    }, Ei.prototype.redIMul = function(wo) {
      return Si(this.red, "redMul works only with red numbers"), this.red._verify2(this, wo), this.red.imul(this, wo);
    }, Ei.prototype.redSqr = function() {
      return Si(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Ei.prototype.redISqr = function() {
      return Si(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Ei.prototype.redSqrt = function() {
      return Si(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Ei.prototype.redInvm = function() {
      return Si(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Ei.prototype.redNeg = function() {
      return Si(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Ei.prototype.redPow = function(wo) {
      return Si(this.red && !wo.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, wo);
    };
    var Uo = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Co(Do, wo) {
      this.name = Do, this.p = new Ei(wo, 16), this.n = this.p.bitLength(), this.k = new Ei(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Co.prototype._tmp = function() {
      var wo = new Ei(null);
      return wo.words = new Array(Math.ceil(this.n / 13)), wo;
    }, Co.prototype.ireduce = function(wo) {
      var Li = wo, Ai;
      do
        this.split(Li, this.tmp), Li = this.imulK(Li), Li = Li.iadd(this.tmp), Ai = Li.bitLength();
      while (Ai > this.n);
      var Ni = Ai < this.n ? -1 : Li.ucmp(this.p);
      return Ni === 0 ? (Li.words[0] = 0, Li.length = 1) : Ni > 0 ? Li.isub(this.p) : Li.strip !== void 0 ? Li.strip() : Li._strip(), Li;
    }, Co.prototype.split = function(wo, Li) {
      wo.iushrn(this.n, 0, Li);
    }, Co.prototype.imulK = function(wo) {
      return wo.imul(this.k);
    };
    function ko() {
      Co.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    wi(ko, Co), ko.prototype.split = function(wo, Li) {
      for (var Ai = 4194303, Ni = Math.min(wo.length, 9), Ui = 0; Ui < Ni; Ui++)
        Li.words[Ui] = wo.words[Ui];
      if (Li.length = Ni, wo.length <= 9) {
        wo.words[0] = 0, wo.length = 1;
        return;
      }
      var So = wo.words[9];
      for (Li.words[Li.length++] = So & Ai, Ui = 10; Ui < wo.length; Ui++) {
        var $o = wo.words[Ui] | 0;
        wo.words[Ui - 10] = ($o & Ai) << 4 | So >>> 22, So = $o;
      }
      So >>>= 22, wo.words[Ui - 10] = So, So === 0 && wo.length > 10 ? wo.length -= 10 : wo.length -= 9;
    }, ko.prototype.imulK = function(wo) {
      wo.words[wo.length] = 0, wo.words[wo.length + 1] = 0, wo.length += 2;
      for (var Li = 0, Ai = 0; Ai < wo.length; Ai++) {
        var Ni = wo.words[Ai] | 0;
        Li += Ni * 977, wo.words[Ai] = Li & 67108863, Li = Ni * 64 + (Li / 67108864 | 0);
      }
      return wo.words[wo.length - 1] === 0 && (wo.length--, wo.words[wo.length - 1] === 0 && wo.length--), wo;
    };
    function Po() {
      Co.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    wi(Po, Co);
    function Mo() {
      Co.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    wi(Mo, Co);
    function No() {
      Co.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    wi(No, Co), No.prototype.imulK = function(wo) {
      for (var Li = 0, Ai = 0; Ai < wo.length; Ai++) {
        var Ni = (wo.words[Ai] | 0) * 19 + Li, Ui = Ni & 67108863;
        Ni >>>= 26, wo.words[Ai] = Ui, Li = Ni;
      }
      return Li !== 0 && (wo.words[wo.length++] = Li), wo;
    }, Ei._prime = function(wo) {
      if (Uo[wo])
        return Uo[wo];
      var Li;
      if (wo === "k256")
        Li = new ko();
      else if (wo === "p224")
        Li = new Po();
      else if (wo === "p192")
        Li = new Mo();
      else if (wo === "p25519")
        Li = new No();
      else
        throw new Error("Unknown prime " + wo);
      return Uo[wo] = Li, Li;
    };
    function Jo(Do) {
      if (typeof Do == "string") {
        var wo = Ei._prime(Do);
        this.m = wo.p, this.prime = wo;
      } else
        Si(Do.gtn(1), "modulus must be greater than 1"), this.m = Do, this.prime = null;
    }
    Jo.prototype._verify1 = function(wo) {
      Si(wo.negative === 0, "red works only with positives"), Si(wo.red, "red works only with red numbers");
    }, Jo.prototype._verify2 = function(wo, Li) {
      Si((wo.negative | Li.negative) === 0, "red works only with positives"), Si(
        wo.red && wo.red === Li.red,
        "red works only with red numbers"
      );
    }, Jo.prototype.imod = function(wo) {
      return this.prime ? this.prime.ireduce(wo)._forceRed(this) : wo.umod(this.m)._forceRed(this);
    }, Jo.prototype.neg = function(wo) {
      return wo.isZero() ? wo.clone() : this.m.sub(wo)._forceRed(this);
    }, Jo.prototype.add = function(wo, Li) {
      this._verify2(wo, Li);
      var Ai = wo.add(Li);
      return Ai.cmp(this.m) >= 0 && Ai.isub(this.m), Ai._forceRed(this);
    }, Jo.prototype.iadd = function(wo, Li) {
      this._verify2(wo, Li);
      var Ai = wo.iadd(Li);
      return Ai.cmp(this.m) >= 0 && Ai.isub(this.m), Ai;
    }, Jo.prototype.sub = function(wo, Li) {
      this._verify2(wo, Li);
      var Ai = wo.sub(Li);
      return Ai.cmpn(0) < 0 && Ai.iadd(this.m), Ai._forceRed(this);
    }, Jo.prototype.isub = function(wo, Li) {
      this._verify2(wo, Li);
      var Ai = wo.isub(Li);
      return Ai.cmpn(0) < 0 && Ai.iadd(this.m), Ai;
    }, Jo.prototype.shl = function(wo, Li) {
      return this._verify1(wo), this.imod(wo.ushln(Li));
    }, Jo.prototype.imul = function(wo, Li) {
      return this._verify2(wo, Li), this.imod(wo.imul(Li));
    }, Jo.prototype.mul = function(wo, Li) {
      return this._verify2(wo, Li), this.imod(wo.mul(Li));
    }, Jo.prototype.isqr = function(wo) {
      return this.imul(wo, wo.clone());
    }, Jo.prototype.sqr = function(wo) {
      return this.mul(wo, wo);
    }, Jo.prototype.sqrt = function(wo) {
      if (wo.isZero())
        return wo.clone();
      var Li = this.m.andln(3);
      if (Si(Li % 2 === 1), Li === 3) {
        var Ai = this.m.add(new Ei(1)).iushrn(2);
        return this.pow(wo, Ai);
      }
      for (var Ni = this.m.subn(1), Ui = 0; !Ni.isZero() && Ni.andln(1) === 0; )
        Ui++, Ni.iushrn(1);
      Si(!Ni.isZero());
      var So = new Ei(1).toRed(this), $o = So.redNeg(), Eo = this.m.subn(1).iushrn(1), zi = this.m.bitLength();
      for (zi = new Ei(2 * zi * zi).toRed(this); this.pow(zi, Eo).cmp($o) !== 0; )
        zi.redIAdd($o);
      for (var _o = this.pow(zi, Ni), Fi = this.pow(wo, Ni.addn(1).iushrn(1)), xo = this.pow(wo, Ni), Qo = Ui; xo.cmp(So) !== 0; ) {
        for (var To = xo, Ko = 0; To.cmp(So) !== 0; Ko++)
          To = To.redSqr();
        Si(Ko < Qo);
        var Vo = this.pow(_o, new Ei(1).iushln(Qo - Ko - 1));
        Fi = Fi.redMul(Vo), _o = Vo.redSqr(), xo = xo.redMul(_o), Qo = Ko;
      }
      return Fi;
    }, Jo.prototype.invm = function(wo) {
      var Li = wo._invmp(this.m);
      return Li.negative !== 0 ? (Li.negative = 0, this.imod(Li).redNeg()) : this.imod(Li);
    }, Jo.prototype.pow = function(wo, Li) {
      if (Li.isZero())
        return new Ei(1).toRed(this);
      if (Li.cmpn(1) === 0)
        return wo.clone();
      var Ai = 4, Ni = new Array(1 << Ai);
      Ni[0] = new Ei(1).toRed(this), Ni[1] = wo;
      for (var Ui = 2; Ui < Ni.length; Ui++)
        Ni[Ui] = this.mul(Ni[Ui - 1], wo);
      var So = Ni[0], $o = 0, Eo = 0, zi = Li.bitLength() % 26;
      for (zi === 0 && (zi = 26), Ui = Li.length - 1; Ui >= 0; Ui--) {
        for (var _o = Li.words[Ui], Fi = zi - 1; Fi >= 0; Fi--) {
          var xo = _o >> Fi & 1;
          if (So !== Ni[0] && (So = this.sqr(So)), xo === 0 && $o === 0) {
            Eo = 0;
            continue;
          }
          $o <<= 1, $o |= xo, Eo++, !(Eo !== Ai && (Ui !== 0 || Fi !== 0)) && (So = this.mul(So, Ni[$o]), Eo = 0, $o = 0);
        }
        zi = 26;
      }
      return So;
    }, Jo.prototype.convertTo = function(wo) {
      var Li = wo.umod(this.m);
      return Li === wo ? Li.clone() : Li;
    }, Jo.prototype.convertFrom = function(wo) {
      var Li = wo.clone();
      return Li.red = null, Li;
    }, Ei.mont = function(wo) {
      return new zo(wo);
    };
    function zo(Do) {
      Jo.call(this, Do), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Ei(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    wi(zo, Jo), zo.prototype.convertTo = function(wo) {
      return this.imod(wo.ushln(this.shift));
    }, zo.prototype.convertFrom = function(wo) {
      var Li = this.imod(wo.mul(this.rinv));
      return Li.red = null, Li;
    }, zo.prototype.imul = function(wo, Li) {
      if (wo.isZero() || Li.isZero())
        return wo.words[0] = 0, wo.length = 1, wo;
      var Ai = wo.imul(Li), Ni = Ai.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ui = Ai.isub(Ni).iushrn(this.shift), So = Ui;
      return Ui.cmp(this.m) >= 0 ? So = Ui.isub(this.m) : Ui.cmpn(0) < 0 && (So = Ui.iadd(this.m)), So._forceRed(this);
    }, zo.prototype.mul = function(wo, Li) {
      if (wo.isZero() || Li.isZero())
        return new Ei(0)._forceRed(this);
      var Ai = wo.mul(Li), Ni = Ai.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ui = Ai.isub(Ni).iushrn(this.shift), So = Ui;
      return Ui.cmp(this.m) >= 0 ? So = Ui.isub(this.m) : Ui.cmpn(0) < 0 && (So = Ui.iadd(this.m)), So._forceRed(this);
    }, zo.prototype.invm = function(wo) {
      var Li = this.imod(wo._invmp(this.m).mul(this.r2));
      return Li._forceRed(this);
    };
  })(se, commonjsGlobal);
})(bn$2);
var bnExports = bn$2.exports, utils$d = {};
(function(se) {
  var e = se;
  function Oe(Ei, $i) {
    if (Array.isArray(Ei))
      return Ei.slice();
    if (!Ei)
      return [];
    var xi = [];
    if (typeof Ei != "string") {
      for (var Ri = 0; Ri < Ei.length; Ri++)
        xi[Ri] = Ei[Ri] | 0;
      return xi;
    }
    if ($i === "hex") {
      Ei = Ei.replace(/[^a-z0-9]+/ig, ""), Ei.length % 2 !== 0 && (Ei = "0" + Ei);
      for (var Ri = 0; Ri < Ei.length; Ri += 2)
        xi.push(parseInt(Ei[Ri] + Ei[Ri + 1], 16));
    } else
      for (var Ri = 0; Ri < Ei.length; Ri++) {
        var Ti = Ei.charCodeAt(Ri), Oi = Ti >> 8, Mi = Ti & 255;
        Oi ? xi.push(Oi, Mi) : xi.push(Mi);
      }
    return xi;
  }
  e.toArray = Oe;
  function Si(Ei) {
    return Ei.length === 1 ? "0" + Ei : Ei;
  }
  e.zero2 = Si;
  function wi(Ei) {
    for (var $i = "", xi = 0; xi < Ei.length; xi++)
      $i += Si(Ei[xi].toString(16));
    return $i;
  }
  e.toHex = wi, e.encode = function($i, xi) {
    return xi === "hex" ? wi($i) : $i;
  };
})(utils$d);
(function(se) {
  var e = se, Oe = bnExports, Si = minimalisticAssert$1, wi = utils$d;
  e.assert = Si, e.toArray = wi.toArray, e.zero2 = wi.zero2, e.toHex = wi.toHex, e.encode = wi.encode;
  function Ei(Oi, Mi, Ii) {
    var Ci = new Array(Math.max(Oi.bitLength(), Ii) + 1), Oo;
    for (Oo = 0; Oo < Ci.length; Oo += 1)
      Ci[Oo] = 0;
    var Ro = 1 << Mi + 1, Bo = Oi.clone();
    for (Oo = 0; Oo < Ci.length; Oo++) {
      var Fo, Io = Bo.andln(Ro - 1);
      Bo.isOdd() ? (Io > (Ro >> 1) - 1 ? Fo = (Ro >> 1) - Io : Fo = Io, Bo.isubn(Fo)) : Fo = 0, Ci[Oo] = Fo, Bo.iushrn(1);
    }
    return Ci;
  }
  e.getNAF = Ei;
  function $i(Oi, Mi) {
    var Ii = [
      [],
      []
    ];
    Oi = Oi.clone(), Mi = Mi.clone();
    for (var Ci = 0, Oo = 0, Ro; Oi.cmpn(-Ci) > 0 || Mi.cmpn(-Oo) > 0; ) {
      var Bo = Oi.andln(3) + Ci & 3, Fo = Mi.andln(3) + Oo & 3;
      Bo === 3 && (Bo = -1), Fo === 3 && (Fo = -1);
      var Io;
      Bo & 1 ? (Ro = Oi.andln(7) + Ci & 7, (Ro === 3 || Ro === 5) && Fo === 2 ? Io = -Bo : Io = Bo) : Io = 0, Ii[0].push(Io);
      var Uo;
      Fo & 1 ? (Ro = Mi.andln(7) + Oo & 7, (Ro === 3 || Ro === 5) && Bo === 2 ? Uo = -Fo : Uo = Fo) : Uo = 0, Ii[1].push(Uo), 2 * Ci === Io + 1 && (Ci = 1 - Ci), 2 * Oo === Uo + 1 && (Oo = 1 - Oo), Oi.iushrn(1), Mi.iushrn(1);
    }
    return Ii;
  }
  e.getJSF = $i;
  function xi(Oi, Mi, Ii) {
    var Ci = "_" + Mi;
    Oi.prototype[Mi] = function() {
      return this[Ci] !== void 0 ? this[Ci] : this[Ci] = Ii.call(this);
    };
  }
  e.cachedProperty = xi;
  function Ri(Oi) {
    return typeof Oi == "string" ? e.toArray(Oi, "hex") : Oi;
  }
  e.parseBytes = Ri;
  function Ti(Oi) {
    return new Oe(Oi, "hex", "le");
  }
  e.intFromLE = Ti;
})(utils$e);
var brorand = { exports: {} }, r$1;
brorand.exports = function(e) {
  return r$1 || (r$1 = new Rand(null)), r$1.generate(e);
};
function Rand(se) {
  this.rand = se;
}
brorand.exports.Rand = Rand;
Rand.prototype.generate = function(e) {
  return this._rand(e);
};
Rand.prototype._rand = function(e) {
  if (this.rand.getBytes)
    return this.rand.getBytes(e);
  for (var Oe = new Uint8Array(e), Si = 0; Si < Oe.length; Si++)
    Oe[Si] = this.rand.getByte();
  return Oe;
};
if (typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? Rand.prototype._rand = function(e) {
    var Oe = new Uint8Array(e);
    return self.crypto.getRandomValues(Oe), Oe;
  } : self.msCrypto && self.msCrypto.getRandomValues ? Rand.prototype._rand = function(e) {
    var Oe = new Uint8Array(e);
    return self.msCrypto.getRandomValues(Oe), Oe;
  } : typeof window == "object" && (Rand.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var crypto$2 = require("crypto");
    if (typeof crypto$2.randomBytes != "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function(e) {
      return crypto$2.randomBytes(e);
    };
  } catch {
  }
var brorandExports = brorand.exports, curve = {}, BN$7 = bnExports, utils$c = utils$e, getNAF = utils$c.getNAF, getJSF = utils$c.getJSF, assert$a = utils$c.assert;
function BaseCurve(se, e) {
  this.type = se, this.p = new BN$7(e.p, 16), this.red = e.prime ? BN$7.red(e.prime) : BN$7.mont(this.p), this.zero = new BN$7(0).toRed(this.red), this.one = new BN$7(1).toRed(this.red), this.two = new BN$7(2).toRed(this.red), this.n = e.n && new BN$7(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Oe = this.n && this.p.div(this.n);
  !Oe || Oe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$2 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(e, Oe) {
  assert$a(e.precomputed);
  var Si = e._getDoubles(), wi = getNAF(Oe, 1, this._bitLength), Ei = (1 << Si.step + 1) - (Si.step % 2 === 0 ? 2 : 1);
  Ei /= 3;
  var $i = [], xi, Ri;
  for (xi = 0; xi < wi.length; xi += Si.step) {
    Ri = 0;
    for (var Ti = xi + Si.step - 1; Ti >= xi; Ti--)
      Ri = (Ri << 1) + wi[Ti];
    $i.push(Ri);
  }
  for (var Oi = this.jpoint(null, null, null), Mi = this.jpoint(null, null, null), Ii = Ei; Ii > 0; Ii--) {
    for (xi = 0; xi < $i.length; xi++)
      Ri = $i[xi], Ri === Ii ? Mi = Mi.mixedAdd(Si.points[xi]) : Ri === -Ii && (Mi = Mi.mixedAdd(Si.points[xi].neg()));
    Oi = Oi.add(Mi);
  }
  return Oi.toP();
};
BaseCurve.prototype._wnafMul = function(e, Oe) {
  var Si = 4, wi = e._getNAFPoints(Si);
  Si = wi.wnd;
  for (var Ei = wi.points, $i = getNAF(Oe, Si, this._bitLength), xi = this.jpoint(null, null, null), Ri = $i.length - 1; Ri >= 0; Ri--) {
    for (var Ti = 0; Ri >= 0 && $i[Ri] === 0; Ri--)
      Ti++;
    if (Ri >= 0 && Ti++, xi = xi.dblp(Ti), Ri < 0)
      break;
    var Oi = $i[Ri];
    assert$a(Oi !== 0), e.type === "affine" ? Oi > 0 ? xi = xi.mixedAdd(Ei[Oi - 1 >> 1]) : xi = xi.mixedAdd(Ei[-Oi - 1 >> 1].neg()) : Oi > 0 ? xi = xi.add(Ei[Oi - 1 >> 1]) : xi = xi.add(Ei[-Oi - 1 >> 1].neg());
  }
  return e.type === "affine" ? xi.toP() : xi;
};
BaseCurve.prototype._wnafMulAdd = function(e, Oe, Si, wi, Ei) {
  var $i = this._wnafT1, xi = this._wnafT2, Ri = this._wnafT3, Ti = 0, Oi, Mi, Ii;
  for (Oi = 0; Oi < wi; Oi++) {
    Ii = Oe[Oi];
    var Ci = Ii._getNAFPoints(e);
    $i[Oi] = Ci.wnd, xi[Oi] = Ci.points;
  }
  for (Oi = wi - 1; Oi >= 1; Oi -= 2) {
    var Oo = Oi - 1, Ro = Oi;
    if ($i[Oo] !== 1 || $i[Ro] !== 1) {
      Ri[Oo] = getNAF(Si[Oo], $i[Oo], this._bitLength), Ri[Ro] = getNAF(Si[Ro], $i[Ro], this._bitLength), Ti = Math.max(Ri[Oo].length, Ti), Ti = Math.max(Ri[Ro].length, Ti);
      continue;
    }
    var Bo = [
      Oe[Oo],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Oe[Ro]
      /* 7 */
    ];
    Oe[Oo].y.cmp(Oe[Ro].y) === 0 ? (Bo[1] = Oe[Oo].add(Oe[Ro]), Bo[2] = Oe[Oo].toJ().mixedAdd(Oe[Ro].neg())) : Oe[Oo].y.cmp(Oe[Ro].y.redNeg()) === 0 ? (Bo[1] = Oe[Oo].toJ().mixedAdd(Oe[Ro]), Bo[2] = Oe[Oo].add(Oe[Ro].neg())) : (Bo[1] = Oe[Oo].toJ().mixedAdd(Oe[Ro]), Bo[2] = Oe[Oo].toJ().mixedAdd(Oe[Ro].neg()));
    var Fo = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Io = getJSF(Si[Oo], Si[Ro]);
    for (Ti = Math.max(Io[0].length, Ti), Ri[Oo] = new Array(Ti), Ri[Ro] = new Array(Ti), Mi = 0; Mi < Ti; Mi++) {
      var Uo = Io[0][Mi] | 0, Co = Io[1][Mi] | 0;
      Ri[Oo][Mi] = Fo[(Uo + 1) * 3 + (Co + 1)], Ri[Ro][Mi] = 0, xi[Oo] = Bo;
    }
  }
  var ko = this.jpoint(null, null, null), Po = this._wnafT4;
  for (Oi = Ti; Oi >= 0; Oi--) {
    for (var Mo = 0; Oi >= 0; ) {
      var No = !0;
      for (Mi = 0; Mi < wi; Mi++)
        Po[Mi] = Ri[Mi][Oi] | 0, Po[Mi] !== 0 && (No = !1);
      if (!No)
        break;
      Mo++, Oi--;
    }
    if (Oi >= 0 && Mo++, ko = ko.dblp(Mo), Oi < 0)
      break;
    for (Mi = 0; Mi < wi; Mi++) {
      var Jo = Po[Mi];
      Jo !== 0 && (Jo > 0 ? Ii = xi[Mi][Jo - 1 >> 1] : Jo < 0 && (Ii = xi[Mi][-Jo - 1 >> 1].neg()), Ii.type === "affine" ? ko = ko.mixedAdd(Ii) : ko = ko.add(Ii));
    }
  }
  for (Oi = 0; Oi < wi; Oi++)
    xi[Oi] = null;
  return Ei ? ko : ko.toP();
};
function BasePoint(se, e) {
  this.curve = se, this.type = e, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(e, Oe) {
  e = utils$c.toArray(e, Oe);
  var Si = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * Si) {
    e[0] === 6 ? assert$a(e[e.length - 1] % 2 === 0) : e[0] === 7 && assert$a(e[e.length - 1] % 2 === 1);
    var wi = this.point(
      e.slice(1, 1 + Si),
      e.slice(1 + Si, 1 + 2 * Si)
    );
    return wi;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === Si)
    return this.pointFromX(e.slice(1, 1 + Si), e[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
BasePoint.prototype._encode = function(e) {
  var Oe = this.curve.p.byteLength(), Si = this.getX().toArray("be", Oe);
  return e ? [this.getY().isEven() ? 2 : 3].concat(Si) : [4].concat(Si, this.getY().toArray("be", Oe));
};
BasePoint.prototype.encode = function(e, Oe) {
  return utils$c.encode(this._encode(Oe), e);
};
BasePoint.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var Oe = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Oe.naf = this._getNAFPoints(8), Oe.doubles = this._getDoubles(4, e), Oe.beta = this._getBeta(), this.precomputed = Oe, this;
};
BasePoint.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var Oe = this.precomputed.doubles;
  return Oe ? Oe.points.length >= Math.ceil((e.bitLength() + 1) / Oe.step) : !1;
};
BasePoint.prototype._getDoubles = function(e, Oe) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Si = [this], wi = this, Ei = 0; Ei < Oe; Ei += e) {
    for (var $i = 0; $i < e; $i++)
      wi = wi.dbl();
    Si.push(wi);
  }
  return {
    step: e,
    points: Si
  };
};
BasePoint.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Oe = [this], Si = (1 << e) - 1, wi = Si === 1 ? null : this.dbl(), Ei = 1; Ei < Si; Ei++)
    Oe[Ei] = Oe[Ei - 1].add(wi);
  return {
    wnd: e,
    points: Oe
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(e) {
  for (var Oe = this, Si = 0; Si < e; Si++)
    Oe = Oe.dbl();
  return Oe;
};
var utils$b = utils$e, BN$6 = bnExports, inherits$2 = inherits_browserExports, Base$4 = base$2, assert$9 = utils$b.assert;
function ShortCurve(se) {
  Base$4.call(this, "short", se), this.a = new BN$6(se.a, 16).toRed(this.red), this.b = new BN$6(se.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(se), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$2(ShortCurve, Base$4);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Oe, Si;
    if (e.beta)
      Oe = new BN$6(e.beta, 16).toRed(this.red);
    else {
      var wi = this._getEndoRoots(this.p);
      Oe = wi[0].cmp(wi[1]) < 0 ? wi[0] : wi[1], Oe = Oe.toRed(this.red);
    }
    if (e.lambda)
      Si = new BN$6(e.lambda, 16);
    else {
      var Ei = this._getEndoRoots(this.n);
      this.g.mul(Ei[0]).x.cmp(this.g.x.redMul(Oe)) === 0 ? Si = Ei[0] : (Si = Ei[1], assert$9(this.g.mul(Si).x.cmp(this.g.x.redMul(Oe)) === 0));
    }
    var $i;
    return e.basis ? $i = e.basis.map(function(xi) {
      return {
        a: new BN$6(xi.a, 16),
        b: new BN$6(xi.b, 16)
      };
    }) : $i = this._getEndoBasis(Si), {
      beta: Oe,
      lambda: Si,
      basis: $i
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(e) {
  var Oe = e === this.p ? this.red : BN$6.mont(e), Si = new BN$6(2).toRed(Oe).redInvm(), wi = Si.redNeg(), Ei = new BN$6(3).toRed(Oe).redNeg().redSqrt().redMul(Si), $i = wi.redAdd(Ei).fromRed(), xi = wi.redSub(Ei).fromRed();
  return [$i, xi];
};
ShortCurve.prototype._getEndoBasis = function(e) {
  for (var Oe = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Si = e, wi = this.n.clone(), Ei = new BN$6(1), $i = new BN$6(0), xi = new BN$6(0), Ri = new BN$6(1), Ti, Oi, Mi, Ii, Ci, Oo, Ro, Bo = 0, Fo, Io; Si.cmpn(0) !== 0; ) {
    var Uo = wi.div(Si);
    Fo = wi.sub(Uo.mul(Si)), Io = xi.sub(Uo.mul(Ei));
    var Co = Ri.sub(Uo.mul($i));
    if (!Mi && Fo.cmp(Oe) < 0)
      Ti = Ro.neg(), Oi = Ei, Mi = Fo.neg(), Ii = Io;
    else if (Mi && ++Bo === 2)
      break;
    Ro = Fo, wi = Si, Si = Fo, xi = Ei, Ei = Io, Ri = $i, $i = Co;
  }
  Ci = Fo.neg(), Oo = Io;
  var ko = Mi.sqr().add(Ii.sqr()), Po = Ci.sqr().add(Oo.sqr());
  return Po.cmp(ko) >= 0 && (Ci = Ti, Oo = Oi), Mi.negative && (Mi = Mi.neg(), Ii = Ii.neg()), Ci.negative && (Ci = Ci.neg(), Oo = Oo.neg()), [
    { a: Mi, b: Ii },
    { a: Ci, b: Oo }
  ];
};
ShortCurve.prototype._endoSplit = function(e) {
  var Oe = this.endo.basis, Si = Oe[0], wi = Oe[1], Ei = wi.b.mul(e).divRound(this.n), $i = Si.b.neg().mul(e).divRound(this.n), xi = Ei.mul(Si.a), Ri = $i.mul(wi.a), Ti = Ei.mul(Si.b), Oi = $i.mul(wi.b), Mi = e.sub(xi).sub(Ri), Ii = Ti.add(Oi).neg();
  return { k1: Mi, k2: Ii };
};
ShortCurve.prototype.pointFromX = function(e, Oe) {
  e = new BN$6(e, 16), e.red || (e = e.toRed(this.red));
  var Si = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), wi = Si.redSqrt();
  if (wi.redSqr().redSub(Si).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Ei = wi.fromRed().isOdd();
  return (Oe && !Ei || !Oe && Ei) && (wi = wi.redNeg()), this.point(e, wi);
};
ShortCurve.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var Oe = e.x, Si = e.y, wi = this.a.redMul(Oe), Ei = Oe.redSqr().redMul(Oe).redIAdd(wi).redIAdd(this.b);
  return Si.redSqr().redISub(Ei).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(e, Oe, Si) {
  for (var wi = this._endoWnafT1, Ei = this._endoWnafT2, $i = 0; $i < e.length; $i++) {
    var xi = this._endoSplit(Oe[$i]), Ri = e[$i], Ti = Ri._getBeta();
    xi.k1.negative && (xi.k1.ineg(), Ri = Ri.neg(!0)), xi.k2.negative && (xi.k2.ineg(), Ti = Ti.neg(!0)), wi[$i * 2] = Ri, wi[$i * 2 + 1] = Ti, Ei[$i * 2] = xi.k1, Ei[$i * 2 + 1] = xi.k2;
  }
  for (var Oi = this._wnafMulAdd(1, wi, Ei, $i * 2, Si), Mi = 0; Mi < $i * 2; Mi++)
    wi[Mi] = null, Ei[Mi] = null;
  return Oi;
};
function Point$2(se, e, Oe, Si) {
  Base$4.BasePoint.call(this, se, "affine"), e === null && Oe === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$6(e, 16), this.y = new BN$6(Oe, 16), Si && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$2(Point$2, Base$4.BasePoint);
ShortCurve.prototype.point = function(e, Oe, Si) {
  return new Point$2(this, e, Oe, Si);
};
ShortCurve.prototype.pointFromJSON = function(e, Oe) {
  return Point$2.fromJSON(this, e, Oe);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var Oe = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var Si = this.curve, wi = function(Ei) {
        return Si.point(Ei.x.redMul(Si.endo.beta), Ei.y);
      };
      e.beta = Oe, Oe.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(wi)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(wi)
        }
      };
    }
    return Oe;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(e, Oe, Si) {
  typeof Oe == "string" && (Oe = JSON.parse(Oe));
  var wi = e.point(Oe[0], Oe[1], Si);
  if (!Oe[2])
    return wi;
  function Ei(xi) {
    return e.point(xi[0], xi[1], Si);
  }
  var $i = Oe[2];
  return wi.precomputed = {
    beta: null,
    doubles: $i.doubles && {
      step: $i.doubles.step,
      points: [wi].concat($i.doubles.points.map(Ei))
    },
    naf: $i.naf && {
      wnd: $i.naf.wnd,
      points: [wi].concat($i.naf.points.map(Ei))
    }
  }, wi;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var Oe = this.y.redSub(e.y);
  Oe.cmpn(0) !== 0 && (Oe = Oe.redMul(this.x.redSub(e.x).redInvm()));
  var Si = Oe.redSqr().redISub(this.x).redISub(e.x), wi = Oe.redMul(this.x.redSub(Si)).redISub(this.y);
  return this.curve.point(Si, wi);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Oe = this.curve.a, Si = this.x.redSqr(), wi = e.redInvm(), Ei = Si.redAdd(Si).redIAdd(Si).redIAdd(Oe).redMul(wi), $i = Ei.redSqr().redISub(this.x.redAdd(this.x)), xi = Ei.redMul(this.x.redSub($i)).redISub(this.y);
  return this.curve.point($i, xi);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(e) {
  return e = new BN$6(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Point$2.prototype.mulAdd = function(e, Oe, Si) {
  var wi = [this, Oe], Ei = [e, Si];
  return this.curve.endo ? this.curve._endoWnafMulAdd(wi, Ei) : this.curve._wnafMulAdd(1, wi, Ei, 2);
};
Point$2.prototype.jmulAdd = function(e, Oe, Si) {
  var wi = [this, Oe], Ei = [e, Si];
  return this.curve.endo ? this.curve._endoWnafMulAdd(wi, Ei, !0) : this.curve._wnafMulAdd(1, wi, Ei, 2, !0);
};
Point$2.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Point$2.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var Oe = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var Si = this.precomputed, wi = function(Ei) {
      return Ei.neg();
    };
    Oe.precomputed = {
      naf: Si.naf && {
        wnd: Si.naf.wnd,
        points: Si.naf.points.map(wi)
      },
      doubles: Si.doubles && {
        step: Si.doubles.step,
        points: Si.doubles.points.map(wi)
      }
    };
  }
  return Oe;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function JPoint(se, e, Oe, Si) {
  Base$4.BasePoint.call(this, se, "jacobian"), e === null && Oe === null && Si === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$6(0)) : (this.x = new BN$6(e, 16), this.y = new BN$6(Oe, 16), this.z = new BN$6(Si, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$2(JPoint, Base$4.BasePoint);
ShortCurve.prototype.jpoint = function(e, Oe, Si) {
  return new JPoint(this, e, Oe, Si);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), Oe = e.redSqr(), Si = this.x.redMul(Oe), wi = this.y.redMul(Oe).redMul(e);
  return this.curve.point(Si, wi);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var Oe = e.z.redSqr(), Si = this.z.redSqr(), wi = this.x.redMul(Oe), Ei = e.x.redMul(Si), $i = this.y.redMul(Oe.redMul(e.z)), xi = e.y.redMul(Si.redMul(this.z)), Ri = wi.redSub(Ei), Ti = $i.redSub(xi);
  if (Ri.cmpn(0) === 0)
    return Ti.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Oi = Ri.redSqr(), Mi = Oi.redMul(Ri), Ii = wi.redMul(Oi), Ci = Ti.redSqr().redIAdd(Mi).redISub(Ii).redISub(Ii), Oo = Ti.redMul(Ii.redISub(Ci)).redISub($i.redMul(Mi)), Ro = this.z.redMul(e.z).redMul(Ri);
  return this.curve.jpoint(Ci, Oo, Ro);
};
JPoint.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var Oe = this.z.redSqr(), Si = this.x, wi = e.x.redMul(Oe), Ei = this.y, $i = e.y.redMul(Oe).redMul(this.z), xi = Si.redSub(wi), Ri = Ei.redSub($i);
  if (xi.cmpn(0) === 0)
    return Ri.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ti = xi.redSqr(), Oi = Ti.redMul(xi), Mi = Si.redMul(Ti), Ii = Ri.redSqr().redIAdd(Oi).redISub(Mi).redISub(Mi), Ci = Ri.redMul(Mi.redISub(Ii)).redISub(Ei.redMul(Oi)), Oo = this.z.redMul(xi);
  return this.curve.jpoint(Ii, Ci, Oo);
};
JPoint.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var Oe;
  if (this.curve.zeroA || this.curve.threeA) {
    var Si = this;
    for (Oe = 0; Oe < e; Oe++)
      Si = Si.dbl();
    return Si;
  }
  var wi = this.curve.a, Ei = this.curve.tinv, $i = this.x, xi = this.y, Ri = this.z, Ti = Ri.redSqr().redSqr(), Oi = xi.redAdd(xi);
  for (Oe = 0; Oe < e; Oe++) {
    var Mi = $i.redSqr(), Ii = Oi.redSqr(), Ci = Ii.redSqr(), Oo = Mi.redAdd(Mi).redIAdd(Mi).redIAdd(wi.redMul(Ti)), Ro = $i.redMul(Ii), Bo = Oo.redSqr().redISub(Ro.redAdd(Ro)), Fo = Ro.redISub(Bo), Io = Oo.redMul(Fo);
    Io = Io.redIAdd(Io).redISub(Ci);
    var Uo = Oi.redMul(Ri);
    Oe + 1 < e && (Ti = Ti.redMul(Ci)), $i = Bo, Ri = Uo, Oi = Io;
  }
  return this.curve.jpoint($i, Oi.redMul(Ei), Ri);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var e, Oe, Si;
  if (this.zOne) {
    var wi = this.x.redSqr(), Ei = this.y.redSqr(), $i = Ei.redSqr(), xi = this.x.redAdd(Ei).redSqr().redISub(wi).redISub($i);
    xi = xi.redIAdd(xi);
    var Ri = wi.redAdd(wi).redIAdd(wi), Ti = Ri.redSqr().redISub(xi).redISub(xi), Oi = $i.redIAdd($i);
    Oi = Oi.redIAdd(Oi), Oi = Oi.redIAdd(Oi), e = Ti, Oe = Ri.redMul(xi.redISub(Ti)).redISub(Oi), Si = this.y.redAdd(this.y);
  } else {
    var Mi = this.x.redSqr(), Ii = this.y.redSqr(), Ci = Ii.redSqr(), Oo = this.x.redAdd(Ii).redSqr().redISub(Mi).redISub(Ci);
    Oo = Oo.redIAdd(Oo);
    var Ro = Mi.redAdd(Mi).redIAdd(Mi), Bo = Ro.redSqr(), Fo = Ci.redIAdd(Ci);
    Fo = Fo.redIAdd(Fo), Fo = Fo.redIAdd(Fo), e = Bo.redISub(Oo).redISub(Oo), Oe = Ro.redMul(Oo.redISub(e)).redISub(Fo), Si = this.y.redMul(this.z), Si = Si.redIAdd(Si);
  }
  return this.curve.jpoint(e, Oe, Si);
};
JPoint.prototype._threeDbl = function() {
  var e, Oe, Si;
  if (this.zOne) {
    var wi = this.x.redSqr(), Ei = this.y.redSqr(), $i = Ei.redSqr(), xi = this.x.redAdd(Ei).redSqr().redISub(wi).redISub($i);
    xi = xi.redIAdd(xi);
    var Ri = wi.redAdd(wi).redIAdd(wi).redIAdd(this.curve.a), Ti = Ri.redSqr().redISub(xi).redISub(xi);
    e = Ti;
    var Oi = $i.redIAdd($i);
    Oi = Oi.redIAdd(Oi), Oi = Oi.redIAdd(Oi), Oe = Ri.redMul(xi.redISub(Ti)).redISub(Oi), Si = this.y.redAdd(this.y);
  } else {
    var Mi = this.z.redSqr(), Ii = this.y.redSqr(), Ci = this.x.redMul(Ii), Oo = this.x.redSub(Mi).redMul(this.x.redAdd(Mi));
    Oo = Oo.redAdd(Oo).redIAdd(Oo);
    var Ro = Ci.redIAdd(Ci);
    Ro = Ro.redIAdd(Ro);
    var Bo = Ro.redAdd(Ro);
    e = Oo.redSqr().redISub(Bo), Si = this.y.redAdd(this.z).redSqr().redISub(Ii).redISub(Mi);
    var Fo = Ii.redSqr();
    Fo = Fo.redIAdd(Fo), Fo = Fo.redIAdd(Fo), Fo = Fo.redIAdd(Fo), Oe = Oo.redMul(Ro.redISub(e)).redISub(Fo);
  }
  return this.curve.jpoint(e, Oe, Si);
};
JPoint.prototype._dbl = function() {
  var e = this.curve.a, Oe = this.x, Si = this.y, wi = this.z, Ei = wi.redSqr().redSqr(), $i = Oe.redSqr(), xi = Si.redSqr(), Ri = $i.redAdd($i).redIAdd($i).redIAdd(e.redMul(Ei)), Ti = Oe.redAdd(Oe);
  Ti = Ti.redIAdd(Ti);
  var Oi = Ti.redMul(xi), Mi = Ri.redSqr().redISub(Oi.redAdd(Oi)), Ii = Oi.redISub(Mi), Ci = xi.redSqr();
  Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci);
  var Oo = Ri.redMul(Ii).redISub(Ci), Ro = Si.redAdd(Si).redMul(wi);
  return this.curve.jpoint(Mi, Oo, Ro);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), Oe = this.y.redSqr(), Si = this.z.redSqr(), wi = Oe.redSqr(), Ei = e.redAdd(e).redIAdd(e), $i = Ei.redSqr(), xi = this.x.redAdd(Oe).redSqr().redISub(e).redISub(wi);
  xi = xi.redIAdd(xi), xi = xi.redAdd(xi).redIAdd(xi), xi = xi.redISub($i);
  var Ri = xi.redSqr(), Ti = wi.redIAdd(wi);
  Ti = Ti.redIAdd(Ti), Ti = Ti.redIAdd(Ti), Ti = Ti.redIAdd(Ti);
  var Oi = Ei.redIAdd(xi).redSqr().redISub($i).redISub(Ri).redISub(Ti), Mi = Oe.redMul(Oi);
  Mi = Mi.redIAdd(Mi), Mi = Mi.redIAdd(Mi);
  var Ii = this.x.redMul(Ri).redISub(Mi);
  Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii);
  var Ci = this.y.redMul(Oi.redMul(Ti.redISub(Oi)).redISub(xi.redMul(Ri)));
  Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci), Ci = Ci.redIAdd(Ci);
  var Oo = this.z.redAdd(xi).redSqr().redISub(Si).redISub(Ri);
  return this.curve.jpoint(Ii, Ci, Oo);
};
JPoint.prototype.mul = function(e, Oe) {
  return e = new BN$6(e, Oe), this.curve._wnafMul(this, e);
};
JPoint.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var Oe = this.z.redSqr(), Si = e.z.redSqr();
  if (this.x.redMul(Si).redISub(e.x.redMul(Oe)).cmpn(0) !== 0)
    return !1;
  var wi = Oe.redMul(this.z), Ei = Si.redMul(e.z);
  return this.y.redMul(Ei).redISub(e.y.redMul(wi)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(e) {
  var Oe = this.z.redSqr(), Si = e.toRed(this.curve.red).redMul(Oe);
  if (this.x.cmp(Si) === 0)
    return !0;
  for (var wi = e.clone(), Ei = this.curve.redN.redMul(Oe); ; ) {
    if (wi.iadd(this.curve.n), wi.cmp(this.curve.p) >= 0)
      return !1;
    if (Si.redIAdd(Ei), this.x.cmp(Si) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$5 = bnExports, inherits$1 = inherits_browserExports, Base$3 = base$2, utils$a = utils$e;
function MontCurve(se) {
  Base$3.call(this, "mont", se), this.a = new BN$5(se.a, 16).toRed(this.red), this.b = new BN$5(se.b, 16).toRed(this.red), this.i4 = new BN$5(4).toRed(this.red).redInvm(), this.two = new BN$5(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$1(MontCurve, Base$3);
var mont = MontCurve;
MontCurve.prototype.validate = function(e) {
  var Oe = e.normalize().x, Si = Oe.redSqr(), wi = Si.redMul(Oe).redAdd(Si.redMul(this.a)).redAdd(Oe), Ei = wi.redSqrt();
  return Ei.redSqr().cmp(wi) === 0;
};
function Point$1(se, e, Oe) {
  Base$3.BasePoint.call(this, se, "projective"), e === null && Oe === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$5(e, 16), this.z = new BN$5(Oe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$1(Point$1, Base$3.BasePoint);
MontCurve.prototype.decodePoint = function(e, Oe) {
  return this.point(utils$a.toArray(e, Oe), 1);
};
MontCurve.prototype.point = function(e, Oe) {
  return new Point$1(this, e, Oe);
};
MontCurve.prototype.pointFromJSON = function(e) {
  return Point$1.fromJSON(this, e);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(e, Oe) {
  return new Point$1(e, Oe[0], Oe[1] || e.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), Oe = e.redSqr(), Si = this.x.redSub(this.z), wi = Si.redSqr(), Ei = Oe.redSub(wi), $i = Oe.redMul(wi), xi = Ei.redMul(wi.redAdd(this.curve.a24.redMul(Ei)));
  return this.curve.point($i, xi);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(e, Oe) {
  var Si = this.x.redAdd(this.z), wi = this.x.redSub(this.z), Ei = e.x.redAdd(e.z), $i = e.x.redSub(e.z), xi = $i.redMul(Si), Ri = Ei.redMul(wi), Ti = Oe.z.redMul(xi.redAdd(Ri).redSqr()), Oi = Oe.x.redMul(xi.redISub(Ri).redSqr());
  return this.curve.point(Ti, Oi);
};
Point$1.prototype.mul = function(e) {
  for (var Oe = e.clone(), Si = this, wi = this.curve.point(null, null), Ei = this, $i = []; Oe.cmpn(0) !== 0; Oe.iushrn(1))
    $i.push(Oe.andln(1));
  for (var xi = $i.length - 1; xi >= 0; xi--)
    $i[xi] === 0 ? (Si = Si.diffAdd(wi, Ei), wi = wi.dbl()) : (wi = Si.diffAdd(wi, Ei), Si = Si.dbl());
  return wi;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$9 = utils$e, BN$4 = bnExports, inherits = inherits_browserExports, Base$2 = base$2, assert$8 = utils$9.assert;
function EdwardsCurve(se) {
  this.twisted = (se.a | 0) !== 1, this.mOneA = this.twisted && (se.a | 0) === -1, this.extended = this.mOneA, Base$2.call(this, "edwards", se), this.a = new BN$4(se.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$4(se.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$4(se.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$8(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (se.c | 0) === 1;
}
inherits(EdwardsCurve, Base$2);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
EdwardsCurve.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
EdwardsCurve.prototype.jpoint = function(e, Oe, Si, wi) {
  return this.point(e, Oe, Si, wi);
};
EdwardsCurve.prototype.pointFromX = function(e, Oe) {
  e = new BN$4(e, 16), e.red || (e = e.toRed(this.red));
  var Si = e.redSqr(), wi = this.c2.redSub(this.a.redMul(Si)), Ei = this.one.redSub(this.c2.redMul(this.d).redMul(Si)), $i = wi.redMul(Ei.redInvm()), xi = $i.redSqrt();
  if (xi.redSqr().redSub($i).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Ri = xi.fromRed().isOdd();
  return (Oe && !Ri || !Oe && Ri) && (xi = xi.redNeg()), this.point(e, xi);
};
EdwardsCurve.prototype.pointFromY = function(e, Oe) {
  e = new BN$4(e, 16), e.red || (e = e.toRed(this.red));
  var Si = e.redSqr(), wi = Si.redSub(this.c2), Ei = Si.redMul(this.d).redMul(this.c2).redSub(this.a), $i = wi.redMul(Ei.redInvm());
  if ($i.cmp(this.zero) === 0) {
    if (Oe)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var xi = $i.redSqrt();
  if (xi.redSqr().redSub($i).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return xi.fromRed().isOdd() !== Oe && (xi = xi.redNeg()), this.point(xi, e);
};
EdwardsCurve.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var Oe = e.x.redSqr(), Si = e.y.redSqr(), wi = Oe.redMul(this.a).redAdd(Si), Ei = this.c2.redMul(this.one.redAdd(this.d.redMul(Oe).redMul(Si)));
  return wi.cmp(Ei) === 0;
};
function Point(se, e, Oe, Si, wi) {
  Base$2.BasePoint.call(this, se, "projective"), e === null && Oe === null && Si === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$4(e, 16), this.y = new BN$4(Oe, 16), this.z = Si ? new BN$4(Si, 16) : this.curve.one, this.t = wi && new BN$4(wi, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits(Point, Base$2.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(e) {
  return Point.fromJSON(this, e);
};
EdwardsCurve.prototype.point = function(e, Oe, Si, wi) {
  return new Point(this, e, Oe, Si, wi);
};
Point.fromJSON = function(e, Oe) {
  return new Point(e, Oe[0], Oe[1], Oe[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var e = this.x.redSqr(), Oe = this.y.redSqr(), Si = this.z.redSqr();
  Si = Si.redIAdd(Si);
  var wi = this.curve._mulA(e), Ei = this.x.redAdd(this.y).redSqr().redISub(e).redISub(Oe), $i = wi.redAdd(Oe), xi = $i.redSub(Si), Ri = wi.redSub(Oe), Ti = Ei.redMul(xi), Oi = $i.redMul(Ri), Mi = Ei.redMul(Ri), Ii = xi.redMul($i);
  return this.curve.point(Ti, Oi, Ii, Mi);
};
Point.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), Oe = this.x.redSqr(), Si = this.y.redSqr(), wi, Ei, $i, xi, Ri, Ti;
  if (this.curve.twisted) {
    xi = this.curve._mulA(Oe);
    var Oi = xi.redAdd(Si);
    this.zOne ? (wi = e.redSub(Oe).redSub(Si).redMul(Oi.redSub(this.curve.two)), Ei = Oi.redMul(xi.redSub(Si)), $i = Oi.redSqr().redSub(Oi).redSub(Oi)) : (Ri = this.z.redSqr(), Ti = Oi.redSub(Ri).redISub(Ri), wi = e.redSub(Oe).redISub(Si).redMul(Ti), Ei = Oi.redMul(xi.redSub(Si)), $i = Oi.redMul(Ti));
  } else
    xi = Oe.redAdd(Si), Ri = this.curve._mulC(this.z).redSqr(), Ti = xi.redSub(Ri).redSub(Ri), wi = this.curve._mulC(e.redISub(xi)).redMul(Ti), Ei = this.curve._mulC(xi).redMul(Oe.redISub(Si)), $i = xi.redMul(Ti);
  return this.curve.point(wi, Ei, $i);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(e) {
  var Oe = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), Si = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), wi = this.t.redMul(this.curve.dd).redMul(e.t), Ei = this.z.redMul(e.z.redAdd(e.z)), $i = Si.redSub(Oe), xi = Ei.redSub(wi), Ri = Ei.redAdd(wi), Ti = Si.redAdd(Oe), Oi = $i.redMul(xi), Mi = Ri.redMul(Ti), Ii = $i.redMul(Ti), Ci = xi.redMul(Ri);
  return this.curve.point(Oi, Mi, Ci, Ii);
};
Point.prototype._projAdd = function(e) {
  var Oe = this.z.redMul(e.z), Si = Oe.redSqr(), wi = this.x.redMul(e.x), Ei = this.y.redMul(e.y), $i = this.curve.d.redMul(wi).redMul(Ei), xi = Si.redSub($i), Ri = Si.redAdd($i), Ti = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(wi).redISub(Ei), Oi = Oe.redMul(xi).redMul(Ti), Mi, Ii;
  return this.curve.twisted ? (Mi = Oe.redMul(Ri).redMul(Ei.redSub(this.curve._mulA(wi))), Ii = xi.redMul(Ri)) : (Mi = Oe.redMul(Ri).redMul(Ei.redSub(wi)), Ii = this.curve._mulC(xi).redMul(Ri)), this.curve.point(Oi, Mi, Ii);
};
Point.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Point.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Point.prototype.mulAdd = function(e, Oe, Si) {
  return this.curve._wnafMulAdd(1, [this, Oe], [e, Si], 2, !1);
};
Point.prototype.jmulAdd = function(e, Oe, Si) {
  return this.curve._wnafMulAdd(1, [this, Oe], [e, Si], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Point.prototype.eqXToP = function(e) {
  var Oe = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(Oe) === 0)
    return !0;
  for (var Si = e.clone(), wi = this.curve.redN.redMul(this.z); ; ) {
    if (Si.iadd(this.curve.n), Si.cmp(this.curve.p) >= 0)
      return !1;
    if (Oe.redIAdd(wi), this.x.cmp(Oe) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(se) {
  var e = se;
  e.base = base$2, e.short = short, e.mont = mont, e.edwards = edwards;
})(curve);
var curves$2 = {}, secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(se) {
  var e = se, Oe = hash$4, Si = curve, wi = utils$e, Ei = wi.assert;
  function $i(Ti) {
    Ti.type === "short" ? this.curve = new Si.short(Ti) : Ti.type === "edwards" ? this.curve = new Si.edwards(Ti) : this.curve = new Si.mont(Ti), this.g = this.curve.g, this.n = this.curve.n, this.hash = Ti.hash, Ei(this.g.validate(), "Invalid curve"), Ei(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = $i;
  function xi(Ti, Oi) {
    Object.defineProperty(e, Ti, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Mi = new $i(Oi);
        return Object.defineProperty(e, Ti, {
          configurable: !0,
          enumerable: !0,
          value: Mi
        }), Mi;
      }
    });
  }
  xi("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Oe.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), xi("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Oe.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), xi("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Oe.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), xi("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Oe.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), xi("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Oe.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), xi("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Oe.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), xi("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Oe.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Ri;
  try {
    Ri = requireSecp256k1();
  } catch {
    Ri = void 0;
  }
  xi("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Oe.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Ri
    ]
  });
})(curves$2);
var hash$2 = hash$4, utils$8 = utils$d, assert$7 = minimalisticAssert$1;
function HmacDRBG$1(se) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(se);
  this.hash = se.hash, this.predResist = !!se.predResist, this.outLen = this.hash.outSize, this.minEntropy = se.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = utils$8.toArray(se.entropy, se.entropyEnc || "hex"), Oe = utils$8.toArray(se.nonce, se.nonceEnc || "hex"), Si = utils$8.toArray(se.pers, se.persEnc || "hex");
  assert$7(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, Oe, Si);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function(e, Oe, Si) {
  var wi = e.concat(Oe).concat(Si);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Ei = 0; Ei < this.V.length; Ei++)
    this.K[Ei] = 0, this.V[Ei] = 1;
  this._update(wi), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function(e) {
  var Oe = this._hmac().update(this.V).update([0]);
  e && (Oe = Oe.update(e)), this.K = Oe.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG$1.prototype.reseed = function(e, Oe, Si, wi) {
  typeof Oe != "string" && (wi = Si, Si = Oe, Oe = null), e = utils$8.toArray(e, Oe), Si = utils$8.toArray(Si, wi), assert$7(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(Si || [])), this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function(e, Oe, Si, wi) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Oe != "string" && (wi = Si, Si = Oe, Oe = null), Si && (Si = utils$8.toArray(Si, wi || "hex"), this._update(Si));
  for (var Ei = []; Ei.length < e; )
    this.V = this._hmac().update(this.V).digest(), Ei = Ei.concat(this.V);
  var $i = Ei.slice(0, e);
  return this._update(Si), this._reseed++, utils$8.encode($i, Oe);
};
var BN$3 = bnExports, utils$7 = utils$e, assert$6 = utils$7.assert;
function KeyPair$3(se, e) {
  this.ec = se, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var key$1 = KeyPair$3;
KeyPair$3.fromPublic = function(e, Oe, Si) {
  return Oe instanceof KeyPair$3 ? Oe : new KeyPair$3(e, {
    pub: Oe,
    pubEnc: Si
  });
};
KeyPair$3.fromPrivate = function(e, Oe, Si) {
  return Oe instanceof KeyPair$3 ? Oe : new KeyPair$3(e, {
    priv: Oe,
    privEnc: Si
  });
};
KeyPair$3.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$3.prototype.getPublic = function(e, Oe) {
  return typeof e == "string" && (Oe = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Oe ? this.pub.encode(Oe, e) : this.pub;
};
KeyPair$3.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$3.prototype._importPrivate = function(e, Oe) {
  this.priv = new BN$3(e, Oe || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function(e, Oe) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? assert$6(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$6(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, Oe);
};
KeyPair$3.prototype.derive = function(e) {
  return e.validate() || assert$6(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function(e, Oe, Si) {
  return this.ec.sign(e, this, Oe, Si);
};
KeyPair$3.prototype.verify = function(e, Oe, Si) {
  return this.ec.verify(e, Oe, this, void 0, Si);
};
KeyPair$3.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$2 = bnExports, utils$6 = utils$e, assert$5 = utils$6.assert;
function Signature$3(se, e) {
  if (se instanceof Signature$3)
    return se;
  this._importDER(se, e) || (assert$5(se.r && se.s, "Signature without r or s"), this.r = new BN$2(se.r, 16), this.s = new BN$2(se.s, 16), se.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = se.recoveryParam);
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(se, e) {
  var Oe = se[e.place++];
  if (!(Oe & 128))
    return Oe;
  var Si = Oe & 15;
  if (Si === 0 || Si > 4 || se[e.place] === 0)
    return !1;
  for (var wi = 0, Ei = 0, $i = e.place; Ei < Si; Ei++, $i++)
    wi <<= 8, wi |= se[$i], wi >>>= 0;
  return wi <= 127 ? !1 : (e.place = $i, wi);
}
function rmPadding(se) {
  for (var e = 0, Oe = se.length - 1; !se[e] && !(se[e + 1] & 128) && e < Oe; )
    e++;
  return e === 0 ? se : se.slice(e);
}
Signature$3.prototype._importDER = function(e, Oe) {
  e = utils$6.toArray(e, Oe);
  var Si = new Position();
  if (e[Si.place++] !== 48)
    return !1;
  var wi = getLength(e, Si);
  if (wi === !1 || wi + Si.place !== e.length || e[Si.place++] !== 2)
    return !1;
  var Ei = getLength(e, Si);
  if (Ei === !1 || e[Si.place] & 128)
    return !1;
  var $i = e.slice(Si.place, Ei + Si.place);
  if (Si.place += Ei, e[Si.place++] !== 2)
    return !1;
  var xi = getLength(e, Si);
  if (xi === !1 || e.length !== xi + Si.place || e[Si.place] & 128)
    return !1;
  var Ri = e.slice(Si.place, xi + Si.place);
  if ($i[0] === 0)
    if ($i[1] & 128)
      $i = $i.slice(1);
    else
      return !1;
  if (Ri[0] === 0)
    if (Ri[1] & 128)
      Ri = Ri.slice(1);
    else
      return !1;
  return this.r = new BN$2($i), this.s = new BN$2(Ri), this.recoveryParam = null, !0;
};
function constructLength(se, e) {
  if (e < 128) {
    se.push(e);
    return;
  }
  var Oe = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (se.push(Oe | 128); --Oe; )
    se.push(e >>> (Oe << 3) & 255);
  se.push(e);
}
Signature$3.prototype.toDER = function(e) {
  var Oe = this.r.toArray(), Si = this.s.toArray();
  for (Oe[0] & 128 && (Oe = [0].concat(Oe)), Si[0] & 128 && (Si = [0].concat(Si)), Oe = rmPadding(Oe), Si = rmPadding(Si); !Si[0] && !(Si[1] & 128); )
    Si = Si.slice(1);
  var wi = [2];
  constructLength(wi, Oe.length), wi = wi.concat(Oe), wi.push(2), constructLength(wi, Si.length);
  var Ei = wi.concat(Si), $i = [48];
  return constructLength($i, Ei.length), $i = $i.concat(Ei), utils$6.encode($i, e);
};
var BN$1 = bnExports, HmacDRBG = hmacDrbg, utils$5 = utils$e, curves$1 = curves$2, rand = brorandExports, assert$4 = utils$5.assert, KeyPair$2 = key$1, Signature$2 = signature$1;
function EC(se) {
  if (!(this instanceof EC))
    return new EC(se);
  typeof se == "string" && (assert$4(
    Object.prototype.hasOwnProperty.call(curves$1, se),
    "Unknown curve " + se
  ), se = curves$1[se]), se instanceof curves$1.PresetCurve && (se = { curve: se }), this.curve = se.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = se.curve.g, this.g.precompute(se.curve.n.bitLength() + 1), this.hash = se.hash || se.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function(e) {
  return new KeyPair$2(this, e);
};
EC.prototype.keyFromPrivate = function(e, Oe) {
  return KeyPair$2.fromPrivate(this, e, Oe);
};
EC.prototype.keyFromPublic = function(e, Oe) {
  return KeyPair$2.fromPublic(this, e, Oe);
};
EC.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var Oe = new HmacDRBG({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || rand(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), Si = this.n.byteLength(), wi = this.n.sub(new BN$1(2)); ; ) {
    var Ei = new BN$1(Oe.generate(Si));
    if (!(Ei.cmp(wi) > 0))
      return Ei.iaddn(1), this.keyFromPrivate(Ei);
  }
};
EC.prototype._truncateToN = function(e, Oe, Si) {
  var wi;
  if (BN$1.isBN(e) || typeof e == "number")
    e = new BN$1(e, 16), wi = e.byteLength();
  else if (typeof e == "object")
    wi = e.length, e = new BN$1(e, 16);
  else {
    var Ei = e.toString();
    wi = Ei.length + 1 >>> 1, e = new BN$1(Ei, 16);
  }
  typeof Si != "number" && (Si = wi * 8);
  var $i = Si - this.n.bitLength();
  return $i > 0 && (e = e.ushrn($i)), !Oe && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
EC.prototype.sign = function(e, Oe, Si, wi) {
  if (typeof Si == "object" && (wi = Si, Si = null), wi || (wi = {}), typeof e != "string" && typeof e != "number" && !BN$1.isBN(e)) {
    assert$4(
      typeof e == "object" && e && typeof e.length == "number",
      "Expected message to be an array-like, a hex string, or a BN instance"
    ), assert$4(e.length >>> 0 === e.length);
    for (var Ei = 0; Ei < e.length; Ei++)
      assert$4((e[Ei] & 255) === e[Ei]);
  }
  Oe = this.keyFromPrivate(Oe, Si), e = this._truncateToN(e, !1, wi.msgBitLength), assert$4(!e.isNeg(), "Can not sign a negative message");
  var $i = this.n.byteLength(), xi = Oe.getPrivate().toArray("be", $i), Ri = e.toArray("be", $i);
  assert$4(new BN$1(Ri).eq(e), "Can not sign message");
  for (var Ti = new HmacDRBG({
    hash: this.hash,
    entropy: xi,
    nonce: Ri,
    pers: wi.pers,
    persEnc: wi.persEnc || "utf8"
  }), Oi = this.n.sub(new BN$1(1)), Mi = 0; ; Mi++) {
    var Ii = wi.k ? wi.k(Mi) : new BN$1(Ti.generate(this.n.byteLength()));
    if (Ii = this._truncateToN(Ii, !0), !(Ii.cmpn(1) <= 0 || Ii.cmp(Oi) >= 0)) {
      var Ci = this.g.mul(Ii);
      if (!Ci.isInfinity()) {
        var Oo = Ci.getX(), Ro = Oo.umod(this.n);
        if (Ro.cmpn(0) !== 0) {
          var Bo = Ii.invm(this.n).mul(Ro.mul(Oe.getPrivate()).iadd(e));
          if (Bo = Bo.umod(this.n), Bo.cmpn(0) !== 0) {
            var Fo = (Ci.getY().isOdd() ? 1 : 0) | (Oo.cmp(Ro) !== 0 ? 2 : 0);
            return wi.canonical && Bo.cmp(this.nh) > 0 && (Bo = this.n.sub(Bo), Fo ^= 1), new Signature$2({ r: Ro, s: Bo, recoveryParam: Fo });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function(e, Oe, Si, wi, Ei) {
  Ei || (Ei = {}), e = this._truncateToN(e, !1, Ei.msgBitLength), Si = this.keyFromPublic(Si, wi), Oe = new Signature$2(Oe, "hex");
  var $i = Oe.r, xi = Oe.s;
  if ($i.cmpn(1) < 0 || $i.cmp(this.n) >= 0 || xi.cmpn(1) < 0 || xi.cmp(this.n) >= 0)
    return !1;
  var Ri = xi.invm(this.n), Ti = Ri.mul(e).umod(this.n), Oi = Ri.mul($i).umod(this.n), Mi;
  return this.curve._maxwellTrick ? (Mi = this.g.jmulAdd(Ti, Si.getPublic(), Oi), Mi.isInfinity() ? !1 : Mi.eqXToP($i)) : (Mi = this.g.mulAdd(Ti, Si.getPublic(), Oi), Mi.isInfinity() ? !1 : Mi.getX().umod(this.n).cmp($i) === 0);
};
EC.prototype.recoverPubKey = function(se, e, Oe, Si) {
  assert$4((3 & Oe) === Oe, "The recovery param is more than two bits"), e = new Signature$2(e, Si);
  var wi = this.n, Ei = new BN$1(se), $i = e.r, xi = e.s, Ri = Oe & 1, Ti = Oe >> 1;
  if ($i.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ti)
    throw new Error("Unable to find sencond key candinate");
  Ti ? $i = this.curve.pointFromX($i.add(this.curve.n), Ri) : $i = this.curve.pointFromX($i, Ri);
  var Oi = e.r.invm(wi), Mi = wi.sub(Ei).mul(Oi).umod(wi), Ii = xi.mul(Oi).umod(wi);
  return this.g.mulAdd(Mi, $i, Ii);
};
EC.prototype.getKeyRecoveryParam = function(se, e, Oe, Si) {
  if (e = new Signature$2(e, Si), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var wi = 0; wi < 4; wi++) {
    var Ei;
    try {
      Ei = this.recoverPubKey(se, e, wi);
    } catch {
      continue;
    }
    if (Ei.eq(Oe))
      return wi;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$4 = utils$e, assert$3 = utils$4.assert, parseBytes$2 = utils$4.parseBytes, cachedProperty$1 = utils$4.cachedProperty;
function KeyPair$1(se, e) {
  this.eddsa = se, this._secret = parseBytes$2(e.secret), se.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = parseBytes$2(e.pub);
}
KeyPair$1.fromPublic = function(e, Oe) {
  return Oe instanceof KeyPair$1 ? Oe : new KeyPair$1(e, { pub: Oe });
};
KeyPair$1.fromSecret = function(e, Oe) {
  return Oe instanceof KeyPair$1 ? Oe : new KeyPair$1(e, { secret: Oe });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var e = this.eddsa, Oe = this.hash(), Si = e.encodingLength - 1, wi = Oe.slice(0, e.encodingLength);
  return wi[0] &= 248, wi[Si] &= 127, wi[Si] |= 64, wi;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(e) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
KeyPair$1.prototype.verify = function(e, Oe) {
  return this.eddsa.verify(e, Oe, this);
};
KeyPair$1.prototype.getSecret = function(e) {
  return assert$3(this._secret, "KeyPair is public only"), utils$4.encode(this.secret(), e);
};
KeyPair$1.prototype.getPublic = function(e) {
  return utils$4.encode(this.pubBytes(), e);
};
var key = KeyPair$1, BN = bnExports, utils$3 = utils$e, assert$2 = utils$3.assert, cachedProperty = utils$3.cachedProperty, parseBytes$1 = utils$3.parseBytes;
function Signature$1(se, e) {
  this.eddsa = se, typeof e != "object" && (e = parseBytes$1(e)), Array.isArray(e) && (assert$2(e.length === se.encodingLength * 2, "Signature has invalid size"), e = {
    R: e.slice(0, se.encodingLength),
    S: e.slice(se.encodingLength)
  }), assert$2(e.R && e.S, "Signature without R or S"), se.isPoint(e.R) && (this._R = e.R), e.S instanceof BN && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$3.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash$1 = hash$4, curves = curves$2, utils$2 = utils$e, assert$1 = utils$2.assert, parseBytes = utils$2.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(se) {
  if (assert$1(se === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(se);
  se = curves[se].curve, this.curve = se, this.g = se.g, this.g.precompute(se.n.bitLength() + 1), this.pointClass = se.point().constructor, this.encodingLength = Math.ceil(se.n.bitLength() / 8), this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(e, Oe) {
  e = parseBytes(e);
  var Si = this.keyFromSecret(Oe), wi = this.hashInt(Si.messagePrefix(), e), Ei = this.g.mul(wi), $i = this.encodePoint(Ei), xi = this.hashInt($i, Si.pubBytes(), e).mul(Si.priv()), Ri = wi.add(xi).umod(this.curve.n);
  return this.makeSignature({ R: Ei, S: Ri, Rencoded: $i });
};
EDDSA.prototype.verify = function(e, Oe, Si) {
  if (e = parseBytes(e), Oe = this.makeSignature(Oe), Oe.S().gte(Oe.eddsa.curve.n) || Oe.S().isNeg())
    return !1;
  var wi = this.keyFromPublic(Si), Ei = this.hashInt(Oe.Rencoded(), wi.pubBytes(), e), $i = this.g.mul(Oe.S()), xi = Oe.R().add(wi.pub().mul(Ei));
  return xi.eq($i);
};
EDDSA.prototype.hashInt = function() {
  for (var e = this.hash(), Oe = 0; Oe < arguments.length; Oe++)
    e.update(arguments[Oe]);
  return utils$2.intFromLE(e.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(e) {
  return KeyPair.fromPublic(this, e);
};
EDDSA.prototype.keyFromSecret = function(e) {
  return KeyPair.fromSecret(this, e);
};
EDDSA.prototype.makeSignature = function(e) {
  return e instanceof Signature ? e : new Signature(this, e);
};
EDDSA.prototype.encodePoint = function(e) {
  var Oe = e.getY().toArray("le", this.encodingLength);
  return Oe[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, Oe;
};
EDDSA.prototype.decodePoint = function(e) {
  e = utils$2.parseBytes(e);
  var Oe = e.length - 1, Si = e.slice(0, Oe).concat(e[Oe] & -129), wi = (e[Oe] & 128) !== 0, Ei = utils$2.intFromLE(Si);
  return this.curve.pointFromY(Ei, wi);
};
EDDSA.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(e) {
  return utils$2.intFromLE(e);
};
EDDSA.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
(function(se) {
  var e = se;
  e.version = require$$0.version, e.utils = utils$e, e.rand = brorandExports, e.curve = curve, e.curves = curves$2, e.ec = ec, e.eddsa = eddsa;
})(elliptic);
const C$4 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, H$1 = ":";
function re$1(se) {
  const [e, Oe] = se.split(H$1);
  return { namespace: e, reference: Oe };
}
function W$1(se, e) {
  return se.includes(":") ? [se] : e.chains || [];
}
var gt$2 = Object.defineProperty, Ke = Object.getOwnPropertySymbols, vt$1 = Object.prototype.hasOwnProperty, bt$1 = Object.prototype.propertyIsEnumerable, Le$1 = (se, e, Oe) => e in se ? gt$2(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Fe = (se, e) => {
  for (var Oe in e || (e = {}))
    vt$1.call(e, Oe) && Le$1(se, Oe, e[Oe]);
  if (Ke)
    for (var Oe of Ke(e))
      bt$1.call(e, Oe) && Le$1(se, Oe, e[Oe]);
  return se;
};
const qe = "ReactNative", y$4 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, He = "js";
function ce() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function $$1() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === qe;
}
function Ot$1() {
  return $$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Nt$1() {
  return $$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function V$1() {
  return !ce() && !!getNavigator_1() && !!getDocument_1();
}
function A$2() {
  return $$1() ? y$4.reactNative : ce() ? y$4.node : V$1() ? y$4.browser : y$4.unknown;
}
function St$1() {
  var se;
  try {
    return $$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (se = global.Application) == null ? void 0 : se.applicationId : void 0;
  } catch {
    return;
  }
}
function We$1(se, e) {
  let Oe = queryString.parse(se);
  return Oe = Fe(Fe({}, Oe), e), se = queryString.stringify(Oe), se;
}
function $t$1() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Je() {
  if (A$2() === y$4.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: Oe, Version: Si } = global.Platform;
    return [Oe, Si].join("-");
  }
  const se = detect();
  if (se === null)
    return "unknown";
  const e = se.os ? se.os.replace(" ", "").toLowerCase() : "unknown";
  return se.type === "browser" ? [e, se.name, se.version].join("-") : [e, se.version].join("-");
}
function ze() {
  var se;
  const e = A$2();
  return e === y$4.browser ? [e, ((se = getLocation_1()) == null ? void 0 : se.host) || "unknown"].join(":") : e;
}
function Ge(se, e, Oe) {
  const Si = Je(), wi = ze();
  return [[se, e].join("-"), [He, Oe].join("-"), Si, wi].join("/");
}
function It$1({ protocol: se, version: e, relayUrl: Oe, sdkVersion: Si, auth: wi, projectId: Ei, useOnCloseEvent: $i, bundleId: xi, packageName: Ri }) {
  const Ti = Oe.split("?"), Oi = Ge(se, e, Si), Mi = { auth: wi, ua: Oi, projectId: Ei, useOnCloseEvent: $i || void 0, packageName: Ri || void 0, bundleId: xi || void 0 }, Ii = We$1(Ti[1] || "", Mi);
  return Ti[0] + "?" + Ii;
}
function R$1(se, e) {
  return se.filter((Oe) => e.includes(Oe)).length === se.length;
}
function At$1(se) {
  return Object.fromEntries(se.entries());
}
function Ct$1(se) {
  return new Map(Object.entries(se));
}
function Dt$1(se = cjs$4.FIVE_MINUTES, e) {
  const Oe = cjs$4.toMiliseconds(se || cjs$4.FIVE_MINUTES);
  let Si, wi, Ei, $i;
  return { resolve: (xi) => {
    Ei && Si && (clearTimeout(Ei), Si(xi), $i = Promise.resolve(xi));
  }, reject: (xi) => {
    Ei && wi && (clearTimeout(Ei), wi(xi));
  }, done: () => new Promise((xi, Ri) => {
    if ($i)
      return xi($i);
    Ei = setTimeout(() => {
      const Ti = new Error(e);
      $i = Promise.reject(Ti), Ri(Ti);
    }, Oe), Si = xi, wi = Ri;
  }) };
}
function xt$1(se, e, Oe) {
  return new Promise(async (Si, wi) => {
    const Ei = setTimeout(() => wi(new Error(Oe)), e);
    try {
      const $i = await se;
      Si($i);
    } catch ($i) {
      wi($i);
    }
    clearTimeout(Ei);
  });
}
function ae$1(se, e) {
  if (typeof e == "string" && e.startsWith(`${se}:`))
    return e;
  if (se.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (se.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${se}`);
}
function Vt$1(se) {
  return ae$1("topic", se);
}
function Mt$1(se) {
  return ae$1("id", se);
}
function Kt$1(se) {
  const [e, Oe] = se.split(":"), Si = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof Oe == "string")
    Si.topic = Oe;
  else if (e === "id" && Number.isInteger(Number(Oe)))
    Si.id = Number(Oe);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${Oe}`);
  return Si;
}
function Lt$1(se, e) {
  return cjs$4.fromMiliseconds((e || Date.now()) + cjs$4.toMiliseconds(se));
}
function Ft$1(se) {
  return Date.now() >= cjs$4.toMiliseconds(se);
}
function qt$1(se, e) {
  return `${se}${e ? `:${e}` : ""}`;
}
function N$1(se = [], e = []) {
  return [.../* @__PURE__ */ new Set([...se, ...e])];
}
async function Bt$1({ id: se, topic: e, wcDeepLink: Oe }) {
  var Si;
  try {
    if (!Oe)
      return;
    const wi = typeof Oe == "string" ? JSON.parse(Oe) : Oe, Ei = wi == null ? void 0 : wi.href;
    if (typeof Ei != "string")
      return;
    const $i = Xe$1(Ei, se, e), xi = A$2();
    if (xi === y$4.browser) {
      if (!((Si = getDocument_1()) != null && Si.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      $i.startsWith("https://") || $i.startsWith("http://") ? window.open($i, "_blank", "noreferrer noopener") : window.open($i, en$1() ? "_blank" : "_self", "noreferrer noopener");
    } else
      xi === y$4.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL($i);
  } catch (wi) {
    console.error(wi);
  }
}
function Xe$1(se, e, Oe) {
  const Si = `requestId=${e}&sessionTopic=${Oe}`;
  se.endsWith("/") && (se = se.slice(0, -1));
  let wi = `${se}`;
  if (se.startsWith("https://t.me")) {
    const Ei = se.includes("?") ? "&startapp=" : "?startapp=";
    wi = `${wi}${Ei}${nn$1(Si, !0)}`;
  } else
    wi = `${wi}/wc?${Si}`;
  return wi;
}
async function Ht$1(se, e) {
  let Oe = "";
  try {
    if (V$1() && (Oe = localStorage.getItem(e), Oe))
      return Oe;
    Oe = await se.getItem(e);
  } catch (Si) {
    console.error(Si);
  }
  return Oe;
}
function Wt$1(se, e) {
  if (!se.includes(e))
    return null;
  const Oe = se.split(/([&,?,=])/), Si = Oe.indexOf(e);
  return Oe[Si + 2];
}
function Jt$1() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (se) => {
    const e = Math.random() * 16 | 0;
    return (se === "x" ? e : e & 3 | 8).toString(16);
  });
}
function zt$1() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function en$1() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn$1(se, e = !1) {
  const Oe = Buffer.from(se).toString("base64");
  return e ? Oe.replace(/[=]/g, "") : Oe;
}
function le(se) {
  return Buffer.from(se, "base64").toString("utf-8");
}
function Gt$1(se) {
  return new Promise((e) => setTimeout(e, se));
}
const Yt$1 = "https://rpc.walletconnect.org/v1";
async function tn$1(se, e, Oe, Si, wi, Ei) {
  switch (Oe.t) {
    case "eip191":
      return rn$1(se, e, Oe.s);
    case "eip1271":
      return await on$1(se, e, Oe.s, Si, wi, Ei);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Oe.t}`);
  }
}
function rn$1(se, e, Oe) {
  return recoverAddress(hashMessage(e), Oe).toLowerCase() === se.toLowerCase();
}
async function on$1(se, e, Oe, Si, wi, Ei) {
  const $i = re$1(Si);
  if (!$i.namespace || !$i.reference)
    throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${Si}`);
  try {
    const xi = "0x1626ba7e", Ri = "0000000000000000000000000000000000000000000000000000000000000040", Ti = "0000000000000000000000000000000000000000000000000000000000000041", Oi = Oe.substring(2), Mi = hashMessage(e).substring(2), Ii = xi + Mi + Ri + Ti + Oi, Ci = await fetch(`${Ei || Yt$1}/?chainId=${Si}&projectId=${wi}`, { method: "POST", body: JSON.stringify({ id: Qt$1(), jsonrpc: "2.0", method: "eth_call", params: [{ to: se, data: Ii }, "latest"] }) }), { result: Oo } = await Ci.json();
    return Oo ? Oo.slice(0, xi.length).toLowerCase() === xi.toLowerCase() : !1;
  } catch (xi) {
    return console.error("isValidEip1271Signature: ", xi), !1;
  }
}
function Qt$1() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Zt$1 = Object.defineProperty, Xt$1 = Object.defineProperties, er$1 = Object.getOwnPropertyDescriptors, sn$1 = Object.getOwnPropertySymbols, nr$1 = Object.prototype.hasOwnProperty, tr$1 = Object.prototype.propertyIsEnumerable, cn$1 = (se, e, Oe) => e in se ? Zt$1(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, de = (se, e) => {
  for (var Oe in e || (e = {}))
    nr$1.call(e, Oe) && cn$1(se, Oe, e[Oe]);
  if (sn$1)
    for (var Oe of sn$1(e))
      tr$1.call(e, Oe) && cn$1(se, Oe, e[Oe]);
  return se;
}, an$1 = (se, e) => Xt$1(se, er$1(e));
const rr$1 = "did:pkh:", z$4 = (se) => se == null ? void 0 : se.split(":"), un$1 = (se) => {
  const e = se && z$4(se);
  if (e)
    return se.includes(rr$1) ? e[3] : e[1];
}, ln$1 = (se) => {
  const e = se && z$4(se);
  if (e)
    return e[2] + ":" + e[3];
}, fe$1 = (se) => {
  const e = se && z$4(se);
  if (e)
    return e.pop();
};
async function or$1(se) {
  const { cacao: e, projectId: Oe } = se, { s: Si, p: wi } = e, Ei = dn$1(wi, wi.iss), $i = fe$1(wi.iss);
  return await tn$1($i, Ei, Si, ln$1(wi.iss), Oe);
}
const dn$1 = (se, e) => {
  const Oe = `${se.domain} wants you to sign in with your Ethereum account:`, Si = fe$1(e);
  if (!se.aud && !se.uri)
    throw new Error("Either `aud` or `uri` is required to construct the message");
  let wi = se.statement || void 0;
  const Ei = `URI: ${se.aud || se.uri}`, $i = `Version: ${se.version}`, xi = `Chain ID: ${un$1(e)}`, Ri = `Nonce: ${se.nonce}`, Ti = `Issued At: ${se.iat}`, Oi = se.exp ? `Expiration Time: ${se.exp}` : void 0, Mi = se.nbf ? `Not Before: ${se.nbf}` : void 0, Ii = se.requestId ? `Request ID: ${se.requestId}` : void 0, Ci = se.resources ? `Resources:${se.resources.map((Ro) => `
- ${Ro}`).join("")}` : void 0, Oo = Y(se.resources);
  if (Oo) {
    const Ro = I$2(Oo);
    wi = he(wi, Ro);
  }
  return [Oe, Si, "", wi, "", Ei, $i, xi, Ri, Ti, Oi, Mi, Ii, Ci].filter((Ro) => Ro != null).join(`
`);
};
function hn$1(se) {
  return Buffer.from(JSON.stringify(se)).toString("base64");
}
function yn$1(se) {
  return JSON.parse(Buffer.from(se, "base64").toString("utf-8"));
}
function O$2(se) {
  if (!se)
    throw new Error("No recap provided, value is undefined");
  if (!se.att)
    throw new Error("No `att` property found");
  const e = Object.keys(se.att);
  if (!(e != null && e.length))
    throw new Error("No resources found in `att` property");
  e.forEach((Oe) => {
    const Si = se.att[Oe];
    if (Array.isArray(Si))
      throw new Error(`Resource must be an object: ${Oe}`);
    if (typeof Si != "object")
      throw new Error(`Resource must be an object: ${Oe}`);
    if (!Object.keys(Si).length)
      throw new Error(`Resource object is empty: ${Oe}`);
    Object.keys(Si).forEach((wi) => {
      const Ei = Si[wi];
      if (!Array.isArray(Ei))
        throw new Error(`Ability limits ${wi} must be an array of objects, found: ${Ei}`);
      if (!Ei.length)
        throw new Error(`Value of ${wi} is empty array, must be an array with objects`);
      Ei.forEach(($i) => {
        if (typeof $i != "object")
          throw new Error(`Ability limits (${wi}) must be an array of objects, found: ${$i}`);
      });
    });
  });
}
function gn$1(se, e, Oe, Si = {}) {
  return Oe == null || Oe.sort((wi, Ei) => wi.localeCompare(Ei)), { att: { [se]: pe(e, Oe, Si) } };
}
function pe(se, e, Oe = {}) {
  e = e == null ? void 0 : e.sort((wi, Ei) => wi.localeCompare(Ei));
  const Si = e.map((wi) => ({ [`${se}/${wi}`]: [Oe] }));
  return Object.assign({}, ...Si);
}
function G(se) {
  return O$2(se), `urn:recap:${hn$1(se).replace(/=/g, "")}`;
}
function I$2(se) {
  const e = yn$1(se.replace("urn:recap:", ""));
  return O$2(e), e;
}
function ur$1(se, e, Oe) {
  const Si = gn$1(se, e, Oe);
  return G(Si);
}
function me$2(se) {
  return se && se.includes("urn:recap:");
}
function lr$1(se, e) {
  const Oe = I$2(se), Si = I$2(e), wi = bn$1(Oe, Si);
  return G(wi);
}
function bn$1(se, e) {
  O$2(se), O$2(e);
  const Oe = Object.keys(se.att).concat(Object.keys(e.att)).sort((wi, Ei) => wi.localeCompare(Ei)), Si = { att: {} };
  return Oe.forEach((wi) => {
    var Ei, $i;
    Object.keys(((Ei = se.att) == null ? void 0 : Ei[wi]) || {}).concat(Object.keys((($i = e.att) == null ? void 0 : $i[wi]) || {})).sort((xi, Ri) => xi.localeCompare(Ri)).forEach((xi) => {
      var Ri, Ti;
      Si.att[wi] = an$1(de({}, Si.att[wi]), { [xi]: ((Ri = se.att[wi]) == null ? void 0 : Ri[xi]) || ((Ti = e.att[wi]) == null ? void 0 : Ti[xi]) });
    });
  }), Si;
}
function he(se = "", e) {
  O$2(e);
  const Oe = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (se.includes(Oe))
    return se;
  const Si = [];
  let wi = 0;
  Object.keys(e.att).forEach((xi) => {
    const Ri = Object.keys(e.att[xi]).map((Mi) => ({ ability: Mi.split("/")[0], action: Mi.split("/")[1] }));
    Ri.sort((Mi, Ii) => Mi.action.localeCompare(Ii.action));
    const Ti = {};
    Ri.forEach((Mi) => {
      Ti[Mi.ability] || (Ti[Mi.ability] = []), Ti[Mi.ability].push(Mi.action);
    });
    const Oi = Object.keys(Ti).map((Mi) => (wi++, `(${wi}) '${Mi}': '${Ti[Mi].join("', '")}' for '${xi}'.`));
    Si.push(Oi.join(", ").replace(".,", "."));
  });
  const Ei = Si.join(" "), $i = `${Oe}${Ei}`;
  return `${se ? se + " " : ""}${$i}`;
}
function dr$1(se) {
  var e;
  const Oe = I$2(se);
  O$2(Oe);
  const Si = (e = Oe.att) == null ? void 0 : e.eip155;
  return Si ? Object.keys(Si).map((wi) => wi.split("/")[1]) : [];
}
function fr$1(se) {
  const e = I$2(se);
  O$2(e);
  const Oe = [];
  return Object.values(e.att).forEach((Si) => {
    Object.values(Si).forEach((wi) => {
      var Ei;
      (Ei = wi == null ? void 0 : wi[0]) != null && Ei.chains && Oe.push(wi[0].chains);
    });
  }), [...new Set(Oe.flat())];
}
function Y(se) {
  if (!se)
    return;
  const e = se == null ? void 0 : se[se.length - 1];
  return me$2(e) ? e : void 0;
}
const ye$2 = "base10", g$3 = "base16", ge = "base64pad", pr$1 = "base64url", k$3 = "utf8", ve$1 = 0, D$2 = 1, M$2 = 2, mr$1 = 0, wn$1 = 1, K$1 = 12, be$1 = 32;
function hr$1() {
  const se = x25519.generateKeyPair();
  return { privateKey: toString$1(se.secretKey, g$3), publicKey: toString$1(se.publicKey, g$3) };
}
function yr$1() {
  const se = random.randomBytes(be$1);
  return toString$1(se, g$3);
}
function gr$1(se, e) {
  const Oe = x25519.sharedKey(fromString(se, g$3), fromString(e, g$3), !0), Si = new HKDF_1(sha256$1.SHA256, Oe).expand(be$1);
  return toString$1(Si, g$3);
}
function vr$1(se) {
  const e = sha256$1.hash(fromString(se, g$3));
  return toString$1(e, g$3);
}
function br$1(se) {
  const e = sha256$1.hash(fromString(se, k$3));
  return toString$1(e, g$3);
}
function Ee$1(se) {
  return fromString(`${se}`, ye$2);
}
function C$3(se) {
  return Number(toString$1(se, ye$2));
}
function Er$1(se) {
  const e = Ee$1(typeof se.type < "u" ? se.type : ve$1);
  if (C$3(e) === D$2 && typeof se.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const Oe = typeof se.senderPublicKey < "u" ? fromString(se.senderPublicKey, g$3) : void 0, Si = typeof se.iv < "u" ? fromString(se.iv, g$3) : random.randomBytes(K$1), wi = new chacha20poly1305.ChaCha20Poly1305(fromString(se.symKey, g$3)).seal(Si, fromString(se.message, k$3));
  return we$2({ type: e, sealed: wi, iv: Si, senderPublicKey: Oe, encoding: se.encoding });
}
function wr$1(se, e) {
  const Oe = Ee$1(M$2), Si = random.randomBytes(K$1), wi = fromString(se, k$3);
  return we$2({ type: Oe, sealed: wi, iv: Si, encoding: e });
}
function Or$1(se) {
  const e = new chacha20poly1305.ChaCha20Poly1305(fromString(se.symKey, g$3)), { sealed: Oe, iv: Si } = Q$1({ encoded: se.encoded, encoding: se == null ? void 0 : se.encoding }), wi = e.open(Si, Oe);
  if (wi === null)
    throw new Error("Failed to decrypt");
  return toString$1(wi, k$3);
}
function Nr$1(se, e) {
  const { sealed: Oe } = Q$1({ encoded: se, encoding: e });
  return toString$1(Oe, k$3);
}
function we$2(se) {
  const { encoding: e = ge } = se;
  if (C$3(se.type) === M$2)
    return toString$1(concat$1([se.type, se.sealed]), e);
  if (C$3(se.type) === D$2) {
    if (typeof se.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString$1(concat$1([se.type, se.senderPublicKey, se.iv, se.sealed]), e);
  }
  return toString$1(concat$1([se.type, se.iv, se.sealed]), e);
}
function Q$1(se) {
  const { encoded: e, encoding: Oe = ge } = se, Si = fromString(e, Oe), wi = Si.slice(mr$1, wn$1), Ei = wn$1;
  if (C$3(wi) === D$2) {
    const Ti = Ei + be$1, Oi = Ti + K$1, Mi = Si.slice(Ei, Ti), Ii = Si.slice(Ti, Oi), Ci = Si.slice(Oi);
    return { type: wi, sealed: Ci, iv: Ii, senderPublicKey: Mi };
  }
  if (C$3(wi) === M$2) {
    const Ti = Si.slice(Ei), Oi = random.randomBytes(K$1);
    return { type: wi, sealed: Ti, iv: Oi };
  }
  const $i = Ei + K$1, xi = Si.slice(Ei, $i), Ri = Si.slice($i);
  return { type: wi, sealed: Ri, iv: xi };
}
function Sr$1(se, e) {
  const Oe = Q$1({ encoded: se, encoding: e == null ? void 0 : e.encoding });
  return On({ type: C$3(Oe.type), senderPublicKey: typeof Oe.senderPublicKey < "u" ? toString$1(Oe.senderPublicKey, g$3) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function On(se) {
  const e = (se == null ? void 0 : se.type) || ve$1;
  if (e === D$2) {
    if (typeof (se == null ? void 0 : se.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (se == null ? void 0 : se.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: se == null ? void 0 : se.senderPublicKey, receiverPublicKey: se == null ? void 0 : se.receiverPublicKey };
}
function $r$1(se) {
  return se.type === D$2 && typeof se.senderPublicKey == "string" && typeof se.receiverPublicKey == "string";
}
function Rr$1(se) {
  return se.type === M$2;
}
function Nn(se) {
  return new elliptic.ec("p256").keyFromPublic({ x: Buffer.from(se.x, "base64").toString("hex"), y: Buffer.from(se.y, "base64").toString("hex") }, "hex");
}
function Ir$1(se) {
  let e = se.replace(/-/g, "+").replace(/_/g, "/");
  const Oe = e.length % 4;
  return Oe > 0 && (e += "=".repeat(4 - Oe)), e;
}
function Pr$1(se) {
  return Buffer.from(Ir$1(se), "base64");
}
function jr$1(se, e) {
  const [Oe, Si, wi] = se.split("."), Ei = Pr$1(wi);
  if (Ei.length !== 64)
    throw new Error("Invalid signature length");
  const $i = Ei.slice(0, 32).toString("hex"), xi = Ei.slice(32, 64).toString("hex"), Ri = `${Oe}.${Si}`, Ti = new sha256$1.SHA256().update(Buffer.from(Ri)).digest(), Oi = Nn(e), Mi = Buffer.from(Ti).toString("hex");
  if (!Oi.verify(Mi, { r: $i, s: xi }))
    throw new Error("Invalid signature");
  return decodeJWT(se).payload;
}
const Sn$1 = "irn";
function Tr$1(se) {
  return (se == null ? void 0 : se.relay) || { protocol: Sn$1 };
}
function Ar$1(se) {
  const e = C$4[se];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${se}`);
  return e;
}
var Cr$1 = Object.defineProperty, Ur$1 = Object.defineProperties, _r$1 = Object.getOwnPropertyDescriptors, $n = Object.getOwnPropertySymbols, kr$1 = Object.prototype.hasOwnProperty, Dr$1 = Object.prototype.propertyIsEnumerable, Rn$1 = (se, e, Oe) => e in se ? Cr$1(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, In$1 = (se, e) => {
  for (var Oe in e || (e = {}))
    kr$1.call(e, Oe) && Rn$1(se, Oe, e[Oe]);
  if ($n)
    for (var Oe of $n(e))
      Dr$1.call(e, Oe) && Rn$1(se, Oe, e[Oe]);
  return se;
}, xr$1 = (se, e) => Ur$1(se, _r$1(e));
function Pn$1(se, e = "-") {
  const Oe = {}, Si = "relay" + e;
  return Object.keys(se).forEach((wi) => {
    if (wi.startsWith(Si)) {
      const Ei = wi.replace(Si, ""), $i = se[wi];
      Oe[Ei] = $i;
    }
  }), Oe;
}
function Vr$1(se) {
  if (!se.includes("wc:")) {
    const Ri = le(se);
    Ri != null && Ri.includes("wc:") && (se = Ri);
  }
  se = se.includes("wc://") ? se.replace("wc://", "") : se, se = se.includes("wc:") ? se.replace("wc:", "") : se;
  const e = se.indexOf(":"), Oe = se.indexOf("?") !== -1 ? se.indexOf("?") : void 0, Si = se.substring(0, e), wi = se.substring(e + 1, Oe).split("@"), Ei = typeof Oe < "u" ? se.substring(Oe) : "", $i = queryString.parse(Ei), xi = typeof $i.methods == "string" ? $i.methods.split(",") : void 0;
  return { protocol: Si, topic: jn(wi[0]), version: parseInt(wi[1], 10), symKey: $i.symKey, relay: Pn$1($i), methods: xi, expiryTimestamp: $i.expiryTimestamp ? parseInt($i.expiryTimestamp, 10) : void 0 };
}
function jn(se) {
  return se.startsWith("//") ? se.substring(2) : se;
}
function Tn$1(se, e = "-") {
  const Oe = "relay", Si = {};
  return Object.keys(se).forEach((wi) => {
    const Ei = Oe + e + wi;
    se[wi] && (Si[Ei] = se[wi]);
  }), Si;
}
function Mr$1(se) {
  return `${se.protocol}:${se.topic}@${se.version}?` + queryString.stringify(In$1(xr$1(In$1({ symKey: se.symKey }, Tn$1(se.relay)), { expiryTimestamp: se.expiryTimestamp }), se.methods ? { methods: se.methods.join(",") } : {}));
}
function Kr$2(se, e, Oe) {
  return `${se}?wc_ev=${Oe}&topic=${e}`;
}
function U(se) {
  const e = [];
  return se.forEach((Oe) => {
    const [Si, wi] = Oe.split(":");
    e.push(`${Si}:${wi}`);
  }), e;
}
function Un(se) {
  const e = [];
  return Object.values(se).forEach((Oe) => {
    e.push(...U(Oe.accounts));
  }), e;
}
function _n$1(se, e) {
  const Oe = [];
  return Object.values(se).forEach((Si) => {
    U(Si.accounts).includes(e) && Oe.push(...Si.methods);
  }), Oe;
}
function kn(se, e) {
  const Oe = [];
  return Object.values(se).forEach((Si) => {
    U(Si.accounts).includes(e) && Oe.push(...Si.events);
  }), Oe;
}
function xn(se) {
  const e = {};
  return se == null || se.forEach((Oe) => {
    const [Si, wi] = Oe.split(":");
    e[Si] || (e[Si] = { accounts: [], chains: [], events: [] }), e[Si].accounts.push(Oe), e[Si].chains.push(`${Si}:${wi}`);
  }), e;
}
function Yr$1(se, e) {
  e = e.map((Si) => Si.replace("did:pkh:", ""));
  const Oe = xn(e);
  for (const [Si, wi] of Object.entries(Oe))
    wi.methods ? wi.methods = N$1(wi.methods, se) : wi.methods = se, wi.events = ["chainChanged", "accountsChanged"];
  return Oe;
}
const Vn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Mn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S$3(se, e) {
  const { message: Oe, code: Si } = Mn[se];
  return { message: e ? `${Oe} ${e}` : Oe, code: Si };
}
function _$4(se, e) {
  const { message: Oe, code: Si } = Vn[se];
  return { message: e ? `${Oe} ${e}` : Oe, code: Si };
}
function L$1(se, e) {
  return Array.isArray(se) ? typeof e < "u" && se.length ? se.every(e) : !0 : !1;
}
function Z$1(se) {
  return Object.getPrototypeOf(se) === Object.prototype && Object.keys(se).length;
}
function P(se) {
  return typeof se > "u";
}
function b$3(se, e) {
  return e && P(se) ? !0 : typeof se == "string" && !!se.trim().length;
}
function X$1(se, e) {
  return e && P(se) ? !0 : typeof se == "number" && !isNaN(se);
}
function Qr$1(se, e) {
  const { requiredNamespaces: Oe } = e, Si = Object.keys(se.namespaces), wi = Object.keys(Oe);
  let Ei = !0;
  return R$1(wi, Si) ? (Si.forEach(($i) => {
    const { accounts: xi, methods: Ri, events: Ti } = se.namespaces[$i], Oi = U(xi), Mi = Oe[$i];
    (!R$1(W$1($i, Mi), Oi) || !R$1(Mi.methods, Ri) || !R$1(Mi.events, Ti)) && (Ei = !1);
  }), Ei) : !1;
}
function F(se) {
  return b$3(se, !1) && se.includes(":") ? se.split(":").length === 2 : !1;
}
function Kn(se) {
  if (b$3(se, !1) && se.includes(":")) {
    const e = se.split(":");
    if (e.length === 3) {
      const Oe = e[0] + ":" + e[1];
      return !!e[2] && F(Oe);
    }
  }
  return !1;
}
function Zr$1(se) {
  function e(Oe) {
    try {
      return typeof new URL(Oe) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (b$3(se, !1)) {
      if (e(se))
        return !0;
      const Oe = le(se);
      return e(Oe);
    }
  } catch {
  }
  return !1;
}
function Xr$1(se) {
  var e;
  return (e = se == null ? void 0 : se.proposer) == null ? void 0 : e.publicKey;
}
function eo(se) {
  return se == null ? void 0 : se.topic;
}
function no(se, e) {
  let Oe = null;
  return b$3(se == null ? void 0 : se.publicKey, !1) || (Oe = S$3("MISSING_OR_INVALID", `${e} controller public key should be a string`)), Oe;
}
function Se(se) {
  let e = !0;
  return L$1(se) ? se.length && (e = se.every((Oe) => b$3(Oe, !1))) : e = !1, e;
}
function Ln(se, e, Oe) {
  let Si = null;
  return L$1(e) && e.length ? e.forEach((wi) => {
    Si || F(wi) || (Si = _$4("UNSUPPORTED_CHAINS", `${Oe}, chain ${wi} should be a string and conform to "namespace:chainId" format`));
  }) : F(se) || (Si = _$4("UNSUPPORTED_CHAINS", `${Oe}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), Si;
}
function Fn(se, e, Oe) {
  let Si = null;
  return Object.entries(se).forEach(([wi, Ei]) => {
    if (Si)
      return;
    const $i = Ln(wi, W$1(wi, Ei), `${e} ${Oe}`);
    $i && (Si = $i);
  }), Si;
}
function qn(se, e) {
  let Oe = null;
  return L$1(se) ? se.forEach((Si) => {
    Oe || Kn(Si) || (Oe = _$4("UNSUPPORTED_ACCOUNTS", `${e}, account ${Si} should be a string and conform to "namespace:chainId:address" format`));
  }) : Oe = _$4("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), Oe;
}
function Bn(se, e) {
  let Oe = null;
  return Object.values(se).forEach((Si) => {
    if (Oe)
      return;
    const wi = qn(Si == null ? void 0 : Si.accounts, `${e} namespace`);
    wi && (Oe = wi);
  }), Oe;
}
function Hn(se, e) {
  let Oe = null;
  return Se(se == null ? void 0 : se.methods) ? Se(se == null ? void 0 : se.events) || (Oe = _$4("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : Oe = _$4("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), Oe;
}
function $e(se, e) {
  let Oe = null;
  return Object.values(se).forEach((Si) => {
    if (Oe)
      return;
    const wi = Hn(Si, `${e}, namespace`);
    wi && (Oe = wi);
  }), Oe;
}
function to(se, e, Oe) {
  let Si = null;
  if (se && Z$1(se)) {
    const wi = $e(se, e);
    wi && (Si = wi);
    const Ei = Fn(se, e, Oe);
    Ei && (Si = Ei);
  } else
    Si = S$3("MISSING_OR_INVALID", `${e}, ${Oe} should be an object with data`);
  return Si;
}
function Wn(se, e) {
  let Oe = null;
  if (se && Z$1(se)) {
    const Si = $e(se, e);
    Si && (Oe = Si);
    const wi = Bn(se, e);
    wi && (Oe = wi);
  } else
    Oe = S$3("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return Oe;
}
function Jn(se) {
  return b$3(se.protocol, !0);
}
function ro(se, e) {
  let Oe = !1;
  return e && !se ? Oe = !0 : se && L$1(se) && se.length && se.forEach((Si) => {
    Oe = Jn(Si);
  }), Oe;
}
function oo(se) {
  return typeof se == "number";
}
function so(se) {
  return typeof se < "u" && typeof se !== null;
}
function io(se) {
  return !(!se || typeof se != "object" || !se.code || !X$1(se.code, !1) || !se.message || !b$3(se.message, !1));
}
function co(se) {
  return !(P(se) || !b$3(se.method, !1));
}
function ao(se) {
  return !(P(se) || P(se.result) && P(se.error) || !X$1(se.id, !1) || !b$3(se.jsonrpc, !1));
}
function uo(se) {
  return !(P(se) || !b$3(se.name, !1));
}
function lo(se, e) {
  return !(!F(e) || !Un(se).includes(e));
}
function fo(se, e, Oe) {
  return b$3(Oe, !1) ? _n$1(se, e).includes(Oe) : !1;
}
function po(se, e, Oe) {
  return b$3(Oe, !1) ? kn(se, e).includes(Oe) : !1;
}
function zn(se, e, Oe) {
  let Si = null;
  const wi = mo(se), Ei = ho(e), $i = Object.keys(wi), xi = Object.keys(Ei), Ri = Gn(Object.keys(se)), Ti = Gn(Object.keys(e)), Oi = Ri.filter((Mi) => !Ti.includes(Mi));
  return Oi.length && (Si = S$3("NON_CONFORMING_NAMESPACES", `${Oe} namespaces keys don't satisfy requiredNamespaces.
      Required: ${Oi.toString()}
      Received: ${Object.keys(e).toString()}`)), R$1($i, xi) || (Si = S$3("NON_CONFORMING_NAMESPACES", `${Oe} namespaces chains don't satisfy required namespaces.
      Required: ${$i.toString()}
      Approved: ${xi.toString()}`)), Object.keys(e).forEach((Mi) => {
    if (!Mi.includes(":") || Si)
      return;
    const Ii = U(e[Mi].accounts);
    Ii.includes(Mi) || (Si = S$3("NON_CONFORMING_NAMESPACES", `${Oe} namespaces accounts don't satisfy namespace accounts for ${Mi}
        Required: ${Mi}
        Approved: ${Ii.toString()}`));
  }), $i.forEach((Mi) => {
    Si || (R$1(wi[Mi].methods, Ei[Mi].methods) ? R$1(wi[Mi].events, Ei[Mi].events) || (Si = S$3("NON_CONFORMING_NAMESPACES", `${Oe} namespaces events don't satisfy namespace events for ${Mi}`)) : Si = S$3("NON_CONFORMING_NAMESPACES", `${Oe} namespaces methods don't satisfy namespace methods for ${Mi}`));
  }), Si;
}
function mo(se) {
  const e = {};
  return Object.keys(se).forEach((Oe) => {
    var Si;
    Oe.includes(":") ? e[Oe] = se[Oe] : (Si = se[Oe].chains) == null || Si.forEach((wi) => {
      e[wi] = { methods: se[Oe].methods, events: se[Oe].events };
    });
  }), e;
}
function Gn(se) {
  return [...new Set(se.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function ho(se) {
  const e = {};
  return Object.keys(se).forEach((Oe) => {
    if (Oe.includes(":"))
      e[Oe] = se[Oe];
    else {
      const Si = U(se[Oe].accounts);
      Si == null || Si.forEach((wi) => {
        e[wi] = { accounts: se[Oe].accounts.filter((Ei) => Ei.includes(`${wi}:`)), methods: se[Oe].methods, events: se[Oe].events };
      });
    }
  }), e;
}
function yo(se, e) {
  return X$1(se, !1) && se <= e.max && se >= e.min;
}
function go() {
  const se = A$2();
  return new Promise((e) => {
    switch (se) {
      case y$4.browser:
        e(Yn());
        break;
      case y$4.reactNative:
        e(Qn());
        break;
      case y$4.node:
        e(Zn());
        break;
      default:
        e(!0);
    }
  });
}
function Yn() {
  return V$1() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn() {
  if ($$1() && typeof global < "u" && global != null && global.NetInfo) {
    const se = await (global == null ? void 0 : global.NetInfo.fetch());
    return se == null ? void 0 : se.isConnected;
  }
  return !0;
}
function Zn() {
  return !0;
}
function vo(se) {
  switch (A$2()) {
    case y$4.browser:
      Xn(se);
      break;
    case y$4.reactNative:
      et$1(se);
      break;
  }
}
function Xn(se) {
  !$$1() && V$1() && (window.addEventListener("online", () => se(!0)), window.addEventListener("offline", () => se(!1)));
}
function et$1(se) {
  $$1() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => se(e == null ? void 0 : e.isConnected)));
}
const Re = {};
class bo {
  static get(e) {
    return Re[e];
  }
  static set(e, Oe) {
    Re[e] = Oe;
  }
  static delete(e) {
    delete Re[e];
  }
}
function generateProvider(se, e, Oe) {
  return {
    async call(Si, wi) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.JsonRpcCall,
          params: {
            method: Si,
            params: wi
          }
        }
      });
    },
    async getNonce(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetNonce,
          params: {
            address: Si
          }
        }
      });
    },
    async getNextNonce(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetNextNonce,
          params: {
            address: Si
          }
        }
      });
    },
    async getAccountRc(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetAccountRc,
          params: {
            address: Si
          }
        }
      });
    },
    async getTransactionsById(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetTransactionsById,
          params: {
            transactionIds: Si
          }
        }
      });
    },
    async getBlocksById(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetBlocksById,
          params: {
            blockIds: Si
          }
        }
      });
    },
    async getHeadInfo() {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetHeadInfo,
          params: {}
        }
      });
    },
    async getChainId() {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetChainId,
          params: {}
        }
      });
    },
    async getBlocks(Si, wi = 1, Ei) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetBlocks,
          params: {
            height: Si,
            numBlocks: wi,
            idRef: Ei
          }
        }
      });
    },
    async getBlock(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.GetBlock,
          params: {
            height: Si
          }
        }
      });
    },
    async wait(Si, wi = "byBlock", Ei = 3e4) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.WaitForTransaction,
          params: {
            transactionId: Si,
            type: wi,
            timeout: Ei
          }
        }
      });
    },
    async sendTransaction(Si, wi = !0) {
      const Ei = await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.SendTransaction,
          params: {
            transaction: Si,
            broadcast: wi
          }
        }
      });
      return Ei.wait = async ($i = "byBlock", xi = 6e4) => await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.WaitForTransaction,
          params: {
            transactionId: Ei.id,
            type: $i,
            timeout: xi
          }
        }
      }), Ei;
    },
    async readContract(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.ReadContract,
          params: {
            _: "",
            operation: Si
          }
        }
      });
    },
    async submitBlock(Si) {
      return await Oe.request({
        chainId: se,
        topic: e,
        request: {
          method: Methods.SubmitBlock,
          params: {
            block: Si
          }
        }
      });
    }
  };
}
var lib$2 = {}, indexUtils = {}, utils$1 = {}, src$2 = { exports: {} };
function base$1(se) {
  if (se.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), Oe = 0; Oe < e.length; Oe++)
    e[Oe] = 255;
  for (var Si = 0; Si < se.length; Si++) {
    var wi = se.charAt(Si), Ei = wi.charCodeAt(0);
    if (e[Ei] !== 255)
      throw new TypeError(wi + " is ambiguous");
    e[Ei] = Si;
  }
  var $i = se.length, xi = se.charAt(0), Ri = Math.log($i) / Math.log(256), Ti = Math.log(256) / Math.log($i);
  function Oi(Ci) {
    if (Ci instanceof Uint8Array || (ArrayBuffer.isView(Ci) ? Ci = new Uint8Array(Ci.buffer, Ci.byteOffset, Ci.byteLength) : Array.isArray(Ci) && (Ci = Uint8Array.from(Ci))), !(Ci instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ci.length === 0)
      return "";
    for (var Oo = 0, Ro = 0, Bo = 0, Fo = Ci.length; Bo !== Fo && Ci[Bo] === 0; )
      Bo++, Oo++;
    for (var Io = (Fo - Bo) * Ti + 1 >>> 0, Uo = new Uint8Array(Io); Bo !== Fo; ) {
      for (var Co = Ci[Bo], ko = 0, Po = Io - 1; (Co !== 0 || ko < Ro) && Po !== -1; Po--, ko++)
        Co += 256 * Uo[Po] >>> 0, Uo[Po] = Co % $i >>> 0, Co = Co / $i >>> 0;
      if (Co !== 0)
        throw new Error("Non-zero carry");
      Ro = ko, Bo++;
    }
    for (var Mo = Io - Ro; Mo !== Io && Uo[Mo] === 0; )
      Mo++;
    for (var No = xi.repeat(Oo); Mo < Io; ++Mo)
      No += se.charAt(Uo[Mo]);
    return No;
  }
  function Mi(Ci) {
    if (typeof Ci != "string")
      throw new TypeError("Expected String");
    if (Ci.length === 0)
      return new Uint8Array();
    var Oo = 0;
    if (Ci[Oo] !== " ") {
      for (var Ro = 0, Bo = 0; Ci[Oo] === xi; )
        Ro++, Oo++;
      for (var Fo = (Ci.length - Oo) * Ri + 1 >>> 0, Io = new Uint8Array(Fo); Ci[Oo]; ) {
        var Uo = e[Ci.charCodeAt(Oo)];
        if (Uo === 255)
          return;
        for (var Co = 0, ko = Fo - 1; (Uo !== 0 || Co < Bo) && ko !== -1; ko--, Co++)
          Uo += $i * Io[ko] >>> 0, Io[ko] = Uo % 256 >>> 0, Uo = Uo / 256 >>> 0;
        if (Uo !== 0)
          throw new Error("Non-zero carry");
        Bo = Co, Oo++;
      }
      if (Ci[Oo] !== " ") {
        for (var Po = Fo - Bo; Po !== Fo && Io[Po] === 0; )
          Po++;
        for (var Mo = new Uint8Array(Ro + (Fo - Po)), No = Ro; Po !== Fo; )
          Mo[No++] = Io[Po++];
        return Mo;
      }
    }
  }
  function Ii(Ci) {
    var Oo = Mi(Ci);
    if (Oo)
      return Oo;
    throw new Error("Non-base" + $i + " character");
  }
  return {
    encode: Oi,
    decodeUnsafe: Mi,
    decode: Ii
  };
}
var src$1 = base$1;
const textDecoder = new TextDecoder(), decodeText$1 = (se) => textDecoder.decode(se), textEncoder = new TextEncoder(), encodeText$2 = (se) => textEncoder.encode(se);
function concat(se, e) {
  const Oe = new Uint8Array(e);
  let Si = 0;
  for (const wi of se)
    Oe.set(wi, Si), Si += wi.length;
  return Oe;
}
var util$4 = { decodeText: decodeText$1, encodeText: encodeText$2, concat };
const { encodeText: encodeText$1 } = util$4;
let Base$1 = class {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor(e, Oe, Si, wi) {
    this.name = e, this.code = Oe, this.codeBuf = encodeText$1(this.code), this.alphabet = wi, this.codec = Si(wi);
  }
  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode(e) {
    return this.codec.encode(e);
  }
  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode(e) {
    for (const Oe of e)
      if (this.alphabet && this.alphabet.indexOf(Oe) < 0)
        throw new Error(`invalid character '${Oe}' in '${e}'`);
    return this.codec.decode(e);
  }
};
var base = Base$1;
const decode = (se, e, Oe) => {
  const Si = {};
  for (let Ti = 0; Ti < e.length; ++Ti)
    Si[e[Ti]] = Ti;
  let wi = se.length;
  for (; se[wi - 1] === "="; )
    --wi;
  const Ei = new Uint8Array(wi * Oe / 8 | 0);
  let $i = 0, xi = 0, Ri = 0;
  for (let Ti = 0; Ti < wi; ++Ti) {
    const Oi = Si[se[Ti]];
    if (Oi === void 0)
      throw new SyntaxError("Invalid character " + se[Ti]);
    xi = xi << Oe | Oi, $i += Oe, $i >= 8 && ($i -= 8, Ei[Ri++] = 255 & xi >> $i);
  }
  if ($i >= Oe || 255 & xi << 8 - $i)
    throw new SyntaxError("Unexpected end of data");
  return Ei;
}, encode = (se, e, Oe) => {
  const Si = e[e.length - 1] === "=", wi = (1 << Oe) - 1;
  let Ei = "", $i = 0, xi = 0;
  for (let Ri = 0; Ri < se.length; ++Ri)
    for (xi = xi << 8 | se[Ri], $i += 8; $i > Oe; )
      $i -= Oe, Ei += e[wi & xi >> $i];
  if ($i && (Ei += e[wi & xi << Oe - $i]), Si)
    for (; Ei.length * Oe & 7; )
      Ei += "=";
  return Ei;
}, rfc4648$1 = (se) => (e) => ({
  /**
   * @param {Uint8Array} input
   * @returns {string}
   */
  encode(Oe) {
    return encode(Oe, e, se);
  },
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(Oe) {
    return decode(Oe, e, se);
  }
});
var rfc4648_1 = { rfc4648: rfc4648$1 };
const baseX = src$1, Base = base, { rfc4648 } = rfc4648_1, { decodeText, encodeText } = util$4, identity = () => ({
  encode: decodeText,
  decode: encodeText
}), constants = [
  ["identity", "\0", identity, ""],
  ["base2", "0", rfc4648(1), "01"],
  ["base8", "7", rfc4648(3), "01234567"],
  ["base10", "9", baseX, "0123456789"],
  ["base16", "f", rfc4648(4), "0123456789abcdef"],
  ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
  ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
  ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
  ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
  ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
  ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
  ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
  ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
  ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
  ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
  ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
  ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
  ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
  ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
  ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
  ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
  ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
  ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
], names = constants.reduce(
  (se, e) => (se[e[0]] = new Base(e[0], e[1], e[2], e[3]), se),
  /** @type {Record<BaseName,Base>} */
  {}
), codes = constants.reduce(
  (se, e) => (se[e[1]] = names[e[0]], se),
  /** @type {Record<BaseCode,Base>} */
  {}
);
var constants_1 = {
  names,
  codes
};
(function(se, e) {
  const Oe = constants_1, { encodeText: Si, decodeText: wi, concat: Ei } = util$4;
  function $i(Ro, Bo) {
    if (!Bo)
      throw new Error("requires an encoded Uint8Array");
    const { name: Fo, codeBuf: Io } = Mi(Ro);
    return Oi(Fo, Bo), Ei([Io, Bo], Io.length + Bo.length);
  }
  function xi(Ro, Bo) {
    const Fo = Mi(Ro), Io = Si(Fo.encode(Bo));
    return Ei([Fo.codeBuf, Io], Fo.codeBuf.length + Io.length);
  }
  function Ri(Ro) {
    Ro instanceof Uint8Array && (Ro = wi(Ro));
    const Bo = Ro[0];
    return ["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(Bo) && (Ro = Ro.toLowerCase()), Mi(
      /** @type {BaseCode} */
      Ro[0]
    ).decode(Ro.substring(1));
  }
  function Ti(Ro) {
    if (Ro instanceof Uint8Array && (Ro = wi(Ro)), Object.prototype.toString.call(Ro) !== "[object String]")
      return !1;
    try {
      return Mi(
        /** @type {BaseCode} */
        Ro[0]
      ).name;
    } catch {
      return !1;
    }
  }
  function Oi(Ro, Bo) {
    Mi(Ro).decode(wi(Bo));
  }
  function Mi(Ro) {
    if (Object.prototype.hasOwnProperty.call(
      Oe.names,
      /** @type {BaseName} */
      Ro
    ))
      return Oe.names[
        /** @type {BaseName} */
        Ro
      ];
    if (Object.prototype.hasOwnProperty.call(
      Oe.codes,
      /** @type {BaseCode} */
      Ro
    ))
      return Oe.codes[
        /** @type {BaseCode} */
        Ro
      ];
    throw new Error(`Unsupported encoding: ${Ro}`);
  }
  function Ii(Ro) {
    return Ro instanceof Uint8Array && (Ro = wi(Ro)), Mi(
      /** @type {BaseCode} */
      Ro[0]
    );
  }
  e = se.exports = $i, e.encode = xi, e.decode = Ri, e.isEncoded = Ti, e.encoding = Mi, e.encodingFromData = Ii;
  const Ci = Object.freeze(Oe.names), Oo = Object.freeze(Oe.codes);
  e.names = Ci, e.codes = Oo;
})(src$2, src$2.exports);
var srcExports$1 = src$2.exports, sha256 = {}, _sha2 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number(se) {
  if (!Number.isSafeInteger(se) || se < 0)
    throw new Error(`Wrong positive integer: ${se}`);
}
_assert.number = number;
function bool(se) {
  if (typeof se != "boolean")
    throw new Error(`Expected boolean, not ${se}`);
}
_assert.bool = bool;
function bytes(se, ...e) {
  if (!(se instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(se.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${se.length}`);
}
_assert.bytes = bytes;
function hash(se) {
  if (typeof se != "function" || typeof se.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(se.outputLen), number(se.blockLen);
}
_assert.hash = hash;
function exists(se, e = !0) {
  if (se.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && se.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(se, e) {
  bytes(se);
  const Oe = e.outputLen;
  if (se.length < Oe)
    throw new Error(`digestInto() expects output buffer of length at least ${Oe}`);
}
_assert.output = output;
const assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
_assert.default = assert;
var utils = {}, crypto$1 = {};
Object.defineProperty(crypto$1, "__esModule", { value: !0 });
crypto$1.crypto = void 0;
crypto$1.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(se) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(se, "__esModule", { value: !0 }), se.randomBytes = se.wrapXOFConstructorWithOpts = se.wrapConstructorWithOpts = se.wrapConstructor = se.checkOpts = se.Hash = se.concatBytes = se.toBytes = se.utf8ToBytes = se.asyncLoop = se.nextTick = se.hexToBytes = se.bytesToHex = se.isLE = se.rotr = se.createView = se.u32 = se.u8 = void 0;
  const e = crypto$1, Oe = (Po) => Po instanceof Uint8Array, Si = (Po) => new Uint8Array(Po.buffer, Po.byteOffset, Po.byteLength);
  se.u8 = Si;
  const wi = (Po) => new Uint32Array(Po.buffer, Po.byteOffset, Math.floor(Po.byteLength / 4));
  se.u32 = wi;
  const Ei = (Po) => new DataView(Po.buffer, Po.byteOffset, Po.byteLength);
  se.createView = Ei;
  const $i = (Po, Mo) => Po << 32 - Mo | Po >>> Mo;
  if (se.rotr = $i, se.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !se.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const xi = Array.from({ length: 256 }, (Po, Mo) => Mo.toString(16).padStart(2, "0"));
  function Ri(Po) {
    if (!Oe(Po))
      throw new Error("Uint8Array expected");
    let Mo = "";
    for (let No = 0; No < Po.length; No++)
      Mo += xi[Po[No]];
    return Mo;
  }
  se.bytesToHex = Ri;
  function Ti(Po) {
    if (typeof Po != "string")
      throw new Error("hex string expected, got " + typeof Po);
    const Mo = Po.length;
    if (Mo % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + Mo);
    const No = new Uint8Array(Mo / 2);
    for (let Jo = 0; Jo < No.length; Jo++) {
      const zo = Jo * 2, Do = Po.slice(zo, zo + 2), wo = Number.parseInt(Do, 16);
      if (Number.isNaN(wo) || wo < 0)
        throw new Error("Invalid byte sequence");
      No[Jo] = wo;
    }
    return No;
  }
  se.hexToBytes = Ti;
  const Oi = async () => {
  };
  se.nextTick = Oi;
  async function Mi(Po, Mo, No) {
    let Jo = Date.now();
    for (let zo = 0; zo < Po; zo++) {
      No(zo);
      const Do = Date.now() - Jo;
      Do >= 0 && Do < Mo || (await (0, se.nextTick)(), Jo += Do);
    }
  }
  se.asyncLoop = Mi;
  function Ii(Po) {
    if (typeof Po != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof Po}`);
    return new Uint8Array(new TextEncoder().encode(Po));
  }
  se.utf8ToBytes = Ii;
  function Ci(Po) {
    if (typeof Po == "string" && (Po = Ii(Po)), !Oe(Po))
      throw new Error(`expected Uint8Array, got ${typeof Po}`);
    return Po;
  }
  se.toBytes = Ci;
  function Oo(...Po) {
    const Mo = new Uint8Array(Po.reduce((Jo, zo) => Jo + zo.length, 0));
    let No = 0;
    return Po.forEach((Jo) => {
      if (!Oe(Jo))
        throw new Error("Uint8Array expected");
      Mo.set(Jo, No), No += Jo.length;
    }), Mo;
  }
  se.concatBytes = Oo;
  class Ro {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  se.Hash = Ro;
  const Bo = (Po) => Object.prototype.toString.call(Po) === "[object Object]" && Po.constructor === Object;
  function Fo(Po, Mo) {
    if (Mo !== void 0 && (typeof Mo != "object" || !Bo(Mo)))
      throw new Error("Options should be object or undefined");
    return Object.assign(Po, Mo);
  }
  se.checkOpts = Fo;
  function Io(Po) {
    const Mo = (Jo) => Po().update(Ci(Jo)).digest(), No = Po();
    return Mo.outputLen = No.outputLen, Mo.blockLen = No.blockLen, Mo.create = () => Po(), Mo;
  }
  se.wrapConstructor = Io;
  function Uo(Po) {
    const Mo = (Jo, zo) => Po(zo).update(Ci(Jo)).digest(), No = Po({});
    return Mo.outputLen = No.outputLen, Mo.blockLen = No.blockLen, Mo.create = (Jo) => Po(Jo), Mo;
  }
  se.wrapConstructorWithOpts = Uo;
  function Co(Po) {
    const Mo = (Jo, zo) => Po(zo).update(Ci(Jo)).digest(), No = Po({});
    return Mo.outputLen = No.outputLen, Mo.blockLen = No.blockLen, Mo.create = (Jo) => Po(Jo), Mo;
  }
  se.wrapXOFConstructorWithOpts = Co;
  function ko(Po = 32) {
    if (e.crypto && typeof e.crypto.getRandomValues == "function")
      return e.crypto.getRandomValues(new Uint8Array(Po));
    throw new Error("crypto.getRandomValues must be defined");
  }
  se.randomBytes = ko;
})(utils);
Object.defineProperty(_sha2, "__esModule", { value: !0 });
_sha2.SHA2 = void 0;
const _assert_js_1 = _assert, utils_js_1$2 = utils;
function setBigUint64(se, e, Oe, Si) {
  if (typeof se.setBigUint64 == "function")
    return se.setBigUint64(e, Oe, Si);
  const wi = BigInt(32), Ei = BigInt(4294967295), $i = Number(Oe >> wi & Ei), xi = Number(Oe & Ei), Ri = Si ? 4 : 0, Ti = Si ? 0 : 4;
  se.setUint32(e + Ri, $i, Si), se.setUint32(e + Ti, xi, Si);
}
class SHA2 extends utils_js_1$2.Hash {
  constructor(e, Oe, Si, wi) {
    super(), this.blockLen = e, this.outputLen = Oe, this.padOffset = Si, this.isLE = wi, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, utils_js_1$2.createView)(this.buffer);
  }
  update(e) {
    _assert_js_1.default.exists(this);
    const { view: Oe, buffer: Si, blockLen: wi } = this;
    e = (0, utils_js_1$2.toBytes)(e);
    const Ei = e.length;
    for (let $i = 0; $i < Ei; ) {
      const xi = Math.min(wi - this.pos, Ei - $i);
      if (xi === wi) {
        const Ri = (0, utils_js_1$2.createView)(e);
        for (; wi <= Ei - $i; $i += wi)
          this.process(Ri, $i);
        continue;
      }
      Si.set(e.subarray($i, $i + xi), this.pos), this.pos += xi, $i += xi, this.pos === wi && (this.process(Oe, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    _assert_js_1.default.exists(this), _assert_js_1.default.output(e, this), this.finished = !0;
    const { buffer: Oe, view: Si, blockLen: wi, isLE: Ei } = this;
    let { pos: $i } = this;
    Oe[$i++] = 128, this.buffer.subarray($i).fill(0), this.padOffset > wi - $i && (this.process(Si, 0), $i = 0);
    for (let Mi = $i; Mi < wi; Mi++)
      Oe[Mi] = 0;
    setBigUint64(Si, wi - 8, BigInt(this.length * 8), Ei), this.process(Si, 0);
    const xi = (0, utils_js_1$2.createView)(e), Ri = this.outputLen;
    if (Ri % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const Ti = Ri / 4, Oi = this.get();
    if (Ti > Oi.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Mi = 0; Mi < Ti; Mi++)
      xi.setUint32(4 * Mi, Oi[Mi], Ei);
  }
  digest() {
    const { buffer: e, outputLen: Oe } = this;
    this.digestInto(e);
    const Si = e.slice(0, Oe);
    return this.destroy(), Si;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: Oe, buffer: Si, length: wi, finished: Ei, destroyed: $i, pos: xi } = this;
    return e.length = wi, e.pos = xi, e.finished = Ei, e.destroyed = $i, wi % Oe && e.buffer.set(Si), e;
  }
}
_sha2.SHA2 = SHA2;
Object.defineProperty(sha256, "__esModule", { value: !0 });
sha256.sha224 = sha256.sha256 = void 0;
const _sha2_js_1$1 = _sha2, utils_js_1$1 = utils, Chi = (se, e, Oe) => se & e ^ ~se & Oe, Maj = (se, e, Oe) => se & e ^ se & Oe ^ e & Oe, SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1$1.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: e, B: Oe, C: Si, D: wi, E: Ei, F: $i, G: xi, H: Ri } = this;
    return [e, Oe, Si, wi, Ei, $i, xi, Ri];
  }
  // prettier-ignore
  set(e, Oe, Si, wi, Ei, $i, xi, Ri) {
    this.A = e | 0, this.B = Oe | 0, this.C = Si | 0, this.D = wi | 0, this.E = Ei | 0, this.F = $i | 0, this.G = xi | 0, this.H = Ri | 0;
  }
  process(e, Oe) {
    for (let Mi = 0; Mi < 16; Mi++, Oe += 4)
      SHA256_W[Mi] = e.getUint32(Oe, !1);
    for (let Mi = 16; Mi < 64; Mi++) {
      const Ii = SHA256_W[Mi - 15], Ci = SHA256_W[Mi - 2], Oo = (0, utils_js_1$1.rotr)(Ii, 7) ^ (0, utils_js_1$1.rotr)(Ii, 18) ^ Ii >>> 3, Ro = (0, utils_js_1$1.rotr)(Ci, 17) ^ (0, utils_js_1$1.rotr)(Ci, 19) ^ Ci >>> 10;
      SHA256_W[Mi] = Ro + SHA256_W[Mi - 7] + Oo + SHA256_W[Mi - 16] | 0;
    }
    let { A: Si, B: wi, C: Ei, D: $i, E: xi, F: Ri, G: Ti, H: Oi } = this;
    for (let Mi = 0; Mi < 64; Mi++) {
      const Ii = (0, utils_js_1$1.rotr)(xi, 6) ^ (0, utils_js_1$1.rotr)(xi, 11) ^ (0, utils_js_1$1.rotr)(xi, 25), Ci = Oi + Ii + Chi(xi, Ri, Ti) + SHA256_K[Mi] + SHA256_W[Mi] | 0, Ro = ((0, utils_js_1$1.rotr)(Si, 2) ^ (0, utils_js_1$1.rotr)(Si, 13) ^ (0, utils_js_1$1.rotr)(Si, 22)) + Maj(Si, wi, Ei) | 0;
      Oi = Ti, Ti = Ri, Ri = xi, xi = $i + Ci | 0, $i = Ei, Ei = wi, wi = Si, Si = Ci + Ro | 0;
    }
    Si = Si + this.A | 0, wi = wi + this.B | 0, Ei = Ei + this.C | 0, $i = $i + this.D | 0, xi = xi + this.E | 0, Ri = Ri + this.F | 0, Ti = Ti + this.G | 0, Oi = Oi + this.H | 0, this.set(Si, wi, Ei, $i, xi, Ri, Ti, Oi);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256());
sha256.sha224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA224());
var ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _sha2_js_1 = _sha2, utils_js_1 = utils, Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = Uint8Array.from({ length: 16 }, (se, e) => e), Pi = Id.map((se) => (9 * se + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let se = 0; se < 4; se++)
  for (let e of [idxL, idxR])
    e.push(e[se].map((Oe) => Rho[Oe]));
const shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((se) => new Uint8Array(se)), shiftsL = idxL.map((se, e) => se.map((Oe) => shifts[e][Oe])), shiftsR = idxR.map((se, e) => se.map((Oe) => shifts[e][Oe])), Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), Kr$1 = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), rotl = (se, e) => se << e | se >>> 32 - e;
function f$3(se, e, Oe, Si) {
  return se === 0 ? e ^ Oe ^ Si : se === 1 ? e & Oe | ~e & Si : se === 2 ? (e | ~Oe) ^ Si : se === 3 ? e & Si | Oe & ~Si : e ^ (Oe | ~Si);
}
const BUF = new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e, h1: Oe, h2: Si, h3: wi, h4: Ei } = this;
    return [e, Oe, Si, wi, Ei];
  }
  set(e, Oe, Si, wi, Ei) {
    this.h0 = e | 0, this.h1 = Oe | 0, this.h2 = Si | 0, this.h3 = wi | 0, this.h4 = Ei | 0;
  }
  process(e, Oe) {
    for (let Ci = 0; Ci < 16; Ci++, Oe += 4)
      BUF[Ci] = e.getUint32(Oe, !0);
    let Si = this.h0 | 0, wi = Si, Ei = this.h1 | 0, $i = Ei, xi = this.h2 | 0, Ri = xi, Ti = this.h3 | 0, Oi = Ti, Mi = this.h4 | 0, Ii = Mi;
    for (let Ci = 0; Ci < 5; Ci++) {
      const Oo = 4 - Ci, Ro = Kl[Ci], Bo = Kr$1[Ci], Fo = idxL[Ci], Io = idxR[Ci], Uo = shiftsL[Ci], Co = shiftsR[Ci];
      for (let ko = 0; ko < 16; ko++) {
        const Po = rotl(Si + f$3(Ci, Ei, xi, Ti) + BUF[Fo[ko]] + Ro, Uo[ko]) + Mi | 0;
        Si = Mi, Mi = Ti, Ti = rotl(xi, 10) | 0, xi = Ei, Ei = Po;
      }
      for (let ko = 0; ko < 16; ko++) {
        const Po = rotl(wi + f$3(Oo, $i, Ri, Oi) + BUF[Io[ko]] + Bo, Co[ko]) + Ii | 0;
        wi = Ii, Ii = Oi, Oi = rotl(Ri, 10) | 0, Ri = $i, $i = Po;
      }
    }
    this.set(this.h1 + xi + Oi | 0, this.h2 + Ti + Ii | 0, this.h3 + Mi + wi | 0, this.h4 + Si + $i | 0, this.h0 + Ei + Ri | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
const nested$1 = {
  koinos: {
    nested: {
      contracts: {
        nested: {
          token: {
            options: {
              go_package: "github.com/koinos/koinos-proto-golang/koinos/contracts/token"
            },
            nested: {
              name_arguments: {
                fields: {}
              },
              name_result: {
                fields: {
                  value: {
                    type: "string",
                    id: 1
                  }
                }
              },
              symbol_arguments: {
                fields: {}
              },
              symbol_result: {
                fields: {
                  value: {
                    type: "string",
                    id: 1
                  }
                }
              },
              decimals_arguments: {
                fields: {}
              },
              decimals_result: {
                fields: {
                  value: {
                    type: "uint32",
                    id: 1
                  }
                }
              },
              total_supply_arguments: {
                fields: {}
              },
              total_supply_result: {
                fields: {
                  value: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              balance_of_arguments: {
                fields: {
                  owner: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  }
                }
              },
              balance_of_result: {
                fields: {
                  value: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              transfer_arguments: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  to: {
                    type: "bytes",
                    id: 2,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 3,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              transfer_result: {
                fields: {}
              },
              mint_arguments: {
                fields: {
                  to: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              mint_result: {
                fields: {}
              },
              burn_arguments: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              burn_result: {
                fields: {}
              },
              balance_object: {
                fields: {
                  value: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              mana_balance_object: {
                fields: {
                  balance: {
                    type: "uint64",
                    id: 1,
                    options: {
                      jstype: "JS_STRING"
                    }
                  },
                  mana: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  },
                  last_mana_update: {
                    type: "uint64",
                    id: 3,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              burn_event: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              mint_event: {
                fields: {
                  to: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 2,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              },
              transfer_event: {
                fields: {
                  from: {
                    type: "bytes",
                    id: 1,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  to: {
                    type: "bytes",
                    id: 2,
                    options: {
                      "(btype)": "ADDRESS"
                    }
                  },
                  value: {
                    type: "uint64",
                    id: 3,
                    options: {
                      jstype: "JS_STRING"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, require$$3$1 = {
  nested: nested$1
};
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe);
  var wi = Object.getOwnPropertyDescriptor(e, Oe);
  (!wi || ("get" in wi ? !e.__esModule : wi.writable || wi.configurable)) && (wi = { enumerable: !0, get: function() {
    return e[Oe];
  } }), Object.defineProperty(se, Si, wi);
} : function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe), se[Si] = e[Oe];
}), __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(se, e) {
  Object.defineProperty(se, "default", { enumerable: !0, value: e });
} : function(se, e) {
  se.default = e;
}), __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(se) {
  if (se && se.__esModule)
    return se;
  var e = {};
  if (se != null)
    for (var Oe in se)
      Oe !== "default" && Object.prototype.hasOwnProperty.call(se, Oe) && __createBinding$3(e, se, Oe);
  return __setModuleDefault$3(e, se), e;
}, __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(se) {
  return se && se.__esModule ? se : { default: se };
};
Object.defineProperty(utils$1, "__esModule", { value: !0 });
utils$1.tokenAbi = utils$1.btypeEncode = utils$1.btypeDecode = utils$1.btypeEncodeValue = utils$1.btypeDecodeValue = utils$1.parseUnits = utils$1.formatUnits = utils$1.isChecksumWif = utils$1.isChecksumAddress = utils$1.isChecksum = utils$1.bitcoinAddress = utils$1.bitcoinDecode = utils$1.bitcoinEncode = utils$1.calculateMerkleRoot = utils$1.decodeBase64 = utils$1.multihash = utils$1.encodeBase64 = utils$1.decodeBase64url = utils$1.encodeBase64url = utils$1.decodeBase58 = utils$1.encodeBase58 = utils$1.toHexString = utils$1.toUint8Array = void 0;
const multibase = __importStar$3(srcExports$1), sha256_1$2 = sha256, ripemd160_1 = ripemd160, token_proto_json_1 = __importDefault$2(require$$3$1);
function toUint8Array(se) {
  const e = se.match(/[\dA-F]{2}/gi);
  if (!e)
    throw new Error("Invalid hex");
  return new Uint8Array(
    e.map((Oe) => parseInt(Oe, 16))
    // convert to integers
  );
}
utils$1.toUint8Array = toUint8Array;
function toHexString(se) {
  return Array.from(se).map((e) => `0${Number(e).toString(16)}`.slice(-2)).join("");
}
utils$1.toHexString = toHexString;
function encodeBase58(se) {
  return new TextDecoder().decode(multibase.encode("z", se)).slice(1);
}
utils$1.encodeBase58 = encodeBase58;
function decodeBase58(se) {
  return multibase.decode(`z${se}`);
}
utils$1.decodeBase58 = decodeBase58;
function encodeBase64url(se) {
  return new TextDecoder().decode(multibase.encode("U", se)).slice(1);
}
utils$1.encodeBase64url = encodeBase64url;
function decodeBase64url(se) {
  return multibase.decode(`U${se}`);
}
utils$1.decodeBase64url = decodeBase64url;
function encodeBase64(se) {
  return new TextDecoder().decode(multibase.encode("M", se)).slice(1);
}
utils$1.encodeBase64 = encodeBase64;
function multihash(se, e = "sha2-256") {
  switch (e) {
    case "sha2-256":
      return new Uint8Array([18, se.length, ...se]);
    default:
      throw new Error(`multihash code ${e} not supported`);
  }
}
utils$1.multihash = multihash;
function decodeBase64(se) {
  return multibase.decode(`M${se}`);
}
utils$1.decodeBase64 = decodeBase64;
function calculateMerkleRoot(se) {
  if (!se.length)
    return (0, sha256_1$2.sha256)(new Uint8Array());
  for (; se.length > 1; ) {
    for (let e = 0; e < se.length; e += 2)
      if (e + 1 < se.length) {
        const Oe = se[e], Si = se[e + 1], wi = (0, sha256_1$2.sha256)(new Uint8Array([...Oe, ...Si]));
        se[e / 2] = new Uint8Array(wi);
      } else
        se[e / 2] = se[e];
    se = se.slice(0, Math.ceil(se.length / 2));
  }
  return se[0];
}
utils$1.calculateMerkleRoot = calculateMerkleRoot;
function bitcoinEncode(se, e, Oe = !1) {
  let Si, wi, Ei;
  e === "public" ? (Si = new Uint8Array(25), wi = new Uint8Array(21), Si[0] = 0, wi[0] = 0, Ei = 21) : (Oe ? (Si = new Uint8Array(38), wi = new Uint8Array(34), Ei = 34, Si[33] = 1, wi[33] = 1) : (Si = new Uint8Array(37), wi = new Uint8Array(33), Ei = 33), Si[0] = 128, wi[0] = 128), wi.set(se, 1);
  const $i = (0, sha256_1$2.sha256)(wi), xi = (0, sha256_1$2.sha256)($i), Ri = new Uint8Array(4);
  return Ri.set(xi.slice(0, 4)), Si.set(se, 1), Si.set(Ri, Ei), encodeBase58(Si);
}
utils$1.bitcoinEncode = bitcoinEncode;
function bitcoinDecode(se) {
  const e = decodeBase58(se), Oe = new Uint8Array(32), Si = new Uint8Array(4);
  return Oe.set(e.slice(1, 33)), se[0] !== "5" ? Si.set(e.slice(34, 38)) : Si.set(e.slice(33, 37)), Oe;
}
utils$1.bitcoinDecode = bitcoinDecode;
function bitcoinAddress(se) {
  const e = (0, sha256_1$2.sha256)(se), Oe = (0, ripemd160_1.ripemd160)(e);
  return bitcoinEncode(Oe, "public");
}
utils$1.bitcoinAddress = bitcoinAddress;
function isChecksum(se) {
  const e = se.length - 4, Oe = new Uint8Array(e);
  Oe.set(se.slice(0, e));
  const Si = new Uint8Array(4);
  Si.set(se.slice(e));
  const wi = (0, sha256_1$2.sha256)((0, sha256_1$2.sha256)(Oe));
  for (let Ei = 0; Ei < 4; Ei += 1)
    if (Si[Ei] !== wi[Ei])
      return !1;
  return !0;
}
utils$1.isChecksum = isChecksum;
function isChecksumAddress(se) {
  const e = typeof se == "string" ? decodeBase58(se) : se;
  return e.length !== 25 || e[0] !== 0 ? !1 : isChecksum(e);
}
utils$1.isChecksumAddress = isChecksumAddress;
function isChecksumWif(se) {
  const e = typeof se == "string" ? decodeBase58(se) : se;
  return e.length !== 37 && e.length !== 38 || e.length === 38 && e[33] !== 1 || e[0] !== 128 ? !1 : isChecksum(e);
}
utils$1.isChecksumWif = isChecksumWif;
function formatUnits(se, e) {
  let Oe = typeof se == "string" ? se : BigInt(se).toString();
  const Si = Oe[0] === "-" ? "-" : "";
  Oe = Oe.replace("-", "").padStart(e + 1, "0");
  const wi = Oe.substring(0, Oe.length - e).replace(/^0+(?=\d)/, ""), Ei = Oe.substring(Oe.length - e);
  return `${Si}${wi}.${Ei}`.replace(/(\.0+)?(0+)$/, "");
}
utils$1.formatUnits = formatUnits;
function parseUnits(se, e) {
  const Oe = se[0] === "-" ? "-" : "";
  let [Si, wi] = se.replace("-", "").replace(",", ".").split(".");
  if (wi || (wi = ""), wi = wi.padEnd(e, "0"), wi.length > e) {
    const Ei = wi.substring(e);
    wi = wi.substring(0, e), Ei.startsWith("5") && (wi = (BigInt(wi) + BigInt(1)).toString());
  }
  return `${Oe}${`${Si}${wi}`.replace(/^0+(?=\d)/, "")}`;
}
utils$1.parseUnits = parseUnits;
function copyValue(se) {
  return typeof se == "string" || typeof se == "number" ? se : JSON.parse(JSON.stringify(se));
}
function btypeDecodeValue(se, e, Oe) {
  if (e.type !== "bytes")
    return copyValue(se);
  const Si = se;
  if (!e.btype)
    return decodeBase64url(Si);
  switch (e.btype) {
    case "BASE58":
      return decodeBase58(Si);
    case "CONTRACT_ID":
    case "ADDRESS":
      const wi = decodeBase58(Si);
      if (Oe && !isChecksumAddress(wi))
        throw new Error(`${Si} is an invalid address`);
      return wi;
    case "BASE64":
      return decodeBase64url(Si);
    case "HEX":
    case "BLOCK_ID":
    case "TRANSACTION_ID":
      return toUint8Array(Si.slice(2));
    default:
      throw new Error(`unknown btype ${e.btype}`);
  }
}
utils$1.btypeDecodeValue = btypeDecodeValue;
function btypeEncodeValue(se, e, Oe) {
  if (e.type !== "bytes")
    return copyValue(se);
  const Si = se;
  if (!e.btype)
    return encodeBase64url(Si);
  switch (e.btype) {
    case "BASE58":
      return encodeBase58(Si);
    case "CONTRACT_ID":
    case "ADDRESS":
      const wi = encodeBase58(Si);
      if (Oe && !isChecksumAddress(Si))
        throw new Error(`${wi} is an invalid address`);
      return wi;
    case "BASE64":
      return encodeBase64url(Si);
    case "HEX":
    case "BLOCK_ID":
    case "TRANSACTION_ID":
      return `0x${toHexString(Si)}`;
    default:
      throw new Error(`unknown btype ${e.btype}`);
  }
}
utils$1.btypeEncodeValue = btypeEncodeValue;
function btypeDecode(se, e, Oe) {
  if (typeof se != "object")
    return se;
  const Si = {};
  return Object.keys(e).forEach((wi) => {
    se[wi] && (e[wi].rule === "repeated" ? Si[wi] = se[wi].map((Ei) => e[wi].subtypes ? btypeDecode(Ei, e[wi].subtypes, Oe) : btypeDecodeValue(Ei, e[wi], Oe)) : e[wi].subtypes ? Si[wi] = btypeDecode(se[wi], e[wi].subtypes, Oe) : Si[wi] = btypeDecodeValue(se[wi], e[wi], Oe));
  }), Si;
}
utils$1.btypeDecode = btypeDecode;
function btypeEncode(se, e, Oe) {
  if (typeof se != "object")
    return se;
  const Si = {};
  return Object.keys(e).forEach((wi) => {
    se[wi] && (e[wi].rule === "repeated" ? Si[wi] = se[wi].map((Ei) => e[wi].subtypes ? btypeEncode(Ei, e[wi].subtypes, Oe) : btypeEncodeValue(Ei, e[wi], Oe)) : e[wi].subtypes ? Si[wi] = btypeEncode(se[wi], e[wi].subtypes, Oe) : Si[wi] = btypeEncodeValue(se[wi], e[wi], Oe));
  }), Si;
}
utils$1.btypeEncode = btypeEncode;
utils$1.tokenAbi = {
  methods: {
    name: {
      entry_point: 2191741823,
      argument: "name_arguments",
      return: "name_result",
      read_only: !0
    },
    symbol: {
      entry_point: 3077209249,
      argument: "symbol_arguments",
      return: "symbol_result",
      read_only: !0
    },
    decimals: {
      entry_point: 4001430831,
      argument: "decimals_arguments",
      return: "decimals_result",
      read_only: !0
    },
    totalSupply: {
      entry_point: 2967091508,
      argument: "total_supply_arguments",
      return: "total_supply_result",
      read_only: !0
    },
    balanceOf: {
      entry_point: 1550980247,
      argument: "balance_of_arguments",
      return: "balance_of_result",
      read_only: !0,
      default_output: { value: "0" }
    },
    transfer: {
      entry_point: 670398154,
      argument: "transfer_arguments",
      return: "transfer_result"
    },
    mint: {
      entry_point: 3698268091,
      argument: "mint_arguments",
      return: "mint_result"
    },
    burn: {
      entry_point: 2241834181,
      argument: "burn_arguments",
      return: "burn_result"
    }
  },
  koilib_types: token_proto_json_1.default
};
var utilsNode = {}, Serializer$1 = {}, src = { exports: {} }, indexLight = { exports: {} }, indexMinimal = {}, minimal$1 = {}, aspromise, hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise)
    return aspromise;
  hasRequiredAspromise = 1, aspromise = se;
  function se(e, Oe) {
    for (var Si = new Array(arguments.length - 1), wi = 0, Ei = 2, $i = !0; Ei < arguments.length; )
      Si[wi++] = arguments[Ei++];
    return new Promise(function(Ri, Ti) {
      Si[wi] = function(Mi) {
        if ($i)
          if ($i = !1, Mi)
            Ti(Mi);
          else {
            for (var Ii = new Array(arguments.length - 1), Ci = 0; Ci < Ii.length; )
              Ii[Ci++] = arguments[Ci];
            Ri.apply(null, Ii);
          }
      };
      try {
        e.apply(Oe || null, Si);
      } catch (Oi) {
        $i && ($i = !1, Ti(Oi));
      }
    });
  }
  return aspromise;
}
var base64 = {}, hasRequiredBase64;
function requireBase64() {
  return hasRequiredBase64 || (hasRequiredBase64 = 1, function(se) {
    var e = se;
    e.length = function(xi) {
      var Ri = xi.length;
      if (!Ri)
        return 0;
      for (var Ti = 0; --Ri % 4 > 1 && xi.charAt(Ri) === "="; )
        ++Ti;
      return Math.ceil(xi.length * 3) / 4 - Ti;
    };
    for (var Oe = new Array(64), Si = new Array(123), wi = 0; wi < 64; )
      Si[Oe[wi] = wi < 26 ? wi + 65 : wi < 52 ? wi + 71 : wi < 62 ? wi - 4 : wi - 59 | 43] = wi++;
    e.encode = function(xi, Ri, Ti) {
      for (var Oi = null, Mi = [], Ii = 0, Ci = 0, Oo; Ri < Ti; ) {
        var Ro = xi[Ri++];
        switch (Ci) {
          case 0:
            Mi[Ii++] = Oe[Ro >> 2], Oo = (Ro & 3) << 4, Ci = 1;
            break;
          case 1:
            Mi[Ii++] = Oe[Oo | Ro >> 4], Oo = (Ro & 15) << 2, Ci = 2;
            break;
          case 2:
            Mi[Ii++] = Oe[Oo | Ro >> 6], Mi[Ii++] = Oe[Ro & 63], Ci = 0;
            break;
        }
        Ii > 8191 && ((Oi || (Oi = [])).push(String.fromCharCode.apply(String, Mi)), Ii = 0);
      }
      return Ci && (Mi[Ii++] = Oe[Oo], Mi[Ii++] = 61, Ci === 1 && (Mi[Ii++] = 61)), Oi ? (Ii && Oi.push(String.fromCharCode.apply(String, Mi.slice(0, Ii))), Oi.join("")) : String.fromCharCode.apply(String, Mi.slice(0, Ii));
    };
    var Ei = "invalid encoding";
    e.decode = function(xi, Ri, Ti) {
      for (var Oi = Ti, Mi = 0, Ii, Ci = 0; Ci < xi.length; ) {
        var Oo = xi.charCodeAt(Ci++);
        if (Oo === 61 && Mi > 1)
          break;
        if ((Oo = Si[Oo]) === void 0)
          throw Error(Ei);
        switch (Mi) {
          case 0:
            Ii = Oo, Mi = 1;
            break;
          case 1:
            Ri[Ti++] = Ii << 2 | (Oo & 48) >> 4, Ii = Oo, Mi = 2;
            break;
          case 2:
            Ri[Ti++] = (Ii & 15) << 4 | (Oo & 60) >> 2, Ii = Oo, Mi = 3;
            break;
          case 3:
            Ri[Ti++] = (Ii & 3) << 6 | Oo, Mi = 0;
            break;
        }
      }
      if (Mi === 1)
        throw Error(Ei);
      return Ti - Oi;
    }, e.test = function(xi) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(xi);
    };
  }(base64)), base64;
}
var eventemitter, hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter)
    return eventemitter;
  hasRequiredEventemitter = 1, eventemitter = se;
  function se() {
    this._listeners = {};
  }
  return se.prototype.on = function(Oe, Si, wi) {
    return (this._listeners[Oe] || (this._listeners[Oe] = [])).push({
      fn: Si,
      ctx: wi || this
    }), this;
  }, se.prototype.off = function(Oe, Si) {
    if (Oe === void 0)
      this._listeners = {};
    else if (Si === void 0)
      this._listeners[Oe] = [];
    else
      for (var wi = this._listeners[Oe], Ei = 0; Ei < wi.length; )
        wi[Ei].fn === Si ? wi.splice(Ei, 1) : ++Ei;
    return this;
  }, se.prototype.emit = function(Oe) {
    var Si = this._listeners[Oe];
    if (Si) {
      for (var wi = [], Ei = 1; Ei < arguments.length; )
        wi.push(arguments[Ei++]);
      for (Ei = 0; Ei < Si.length; )
        Si[Ei].fn.apply(Si[Ei++].ctx, wi);
    }
    return this;
  }, eventemitter;
}
var float, hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat)
    return float;
  hasRequiredFloat = 1, float = se(se);
  function se(Ei) {
    return typeof Float32Array < "u" ? function() {
      var $i = new Float32Array([-0]), xi = new Uint8Array($i.buffer), Ri = xi[3] === 128;
      function Ti(Ci, Oo, Ro) {
        $i[0] = Ci, Oo[Ro] = xi[0], Oo[Ro + 1] = xi[1], Oo[Ro + 2] = xi[2], Oo[Ro + 3] = xi[3];
      }
      function Oi(Ci, Oo, Ro) {
        $i[0] = Ci, Oo[Ro] = xi[3], Oo[Ro + 1] = xi[2], Oo[Ro + 2] = xi[1], Oo[Ro + 3] = xi[0];
      }
      Ei.writeFloatLE = Ri ? Ti : Oi, Ei.writeFloatBE = Ri ? Oi : Ti;
      function Mi(Ci, Oo) {
        return xi[0] = Ci[Oo], xi[1] = Ci[Oo + 1], xi[2] = Ci[Oo + 2], xi[3] = Ci[Oo + 3], $i[0];
      }
      function Ii(Ci, Oo) {
        return xi[3] = Ci[Oo], xi[2] = Ci[Oo + 1], xi[1] = Ci[Oo + 2], xi[0] = Ci[Oo + 3], $i[0];
      }
      Ei.readFloatLE = Ri ? Mi : Ii, Ei.readFloatBE = Ri ? Ii : Mi;
    }() : function() {
      function $i(Ri, Ti, Oi, Mi) {
        var Ii = Ti < 0 ? 1 : 0;
        if (Ii && (Ti = -Ti), Ti === 0)
          Ri(1 / Ti > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), Oi, Mi);
        else if (isNaN(Ti))
          Ri(2143289344, Oi, Mi);
        else if (Ti > 34028234663852886e22)
          Ri((Ii << 31 | 2139095040) >>> 0, Oi, Mi);
        else if (Ti < 11754943508222875e-54)
          Ri((Ii << 31 | Math.round(Ti / 1401298464324817e-60)) >>> 0, Oi, Mi);
        else {
          var Ci = Math.floor(Math.log(Ti) / Math.LN2), Oo = Math.round(Ti * Math.pow(2, -Ci) * 8388608) & 8388607;
          Ri((Ii << 31 | Ci + 127 << 23 | Oo) >>> 0, Oi, Mi);
        }
      }
      Ei.writeFloatLE = $i.bind(null, e), Ei.writeFloatBE = $i.bind(null, Oe);
      function xi(Ri, Ti, Oi) {
        var Mi = Ri(Ti, Oi), Ii = (Mi >> 31) * 2 + 1, Ci = Mi >>> 23 & 255, Oo = Mi & 8388607;
        return Ci === 255 ? Oo ? NaN : Ii * (1 / 0) : Ci === 0 ? Ii * 1401298464324817e-60 * Oo : Ii * Math.pow(2, Ci - 150) * (Oo + 8388608);
      }
      Ei.readFloatLE = xi.bind(null, Si), Ei.readFloatBE = xi.bind(null, wi);
    }(), typeof Float64Array < "u" ? function() {
      var $i = new Float64Array([-0]), xi = new Uint8Array($i.buffer), Ri = xi[7] === 128;
      function Ti(Ci, Oo, Ro) {
        $i[0] = Ci, Oo[Ro] = xi[0], Oo[Ro + 1] = xi[1], Oo[Ro + 2] = xi[2], Oo[Ro + 3] = xi[3], Oo[Ro + 4] = xi[4], Oo[Ro + 5] = xi[5], Oo[Ro + 6] = xi[6], Oo[Ro + 7] = xi[7];
      }
      function Oi(Ci, Oo, Ro) {
        $i[0] = Ci, Oo[Ro] = xi[7], Oo[Ro + 1] = xi[6], Oo[Ro + 2] = xi[5], Oo[Ro + 3] = xi[4], Oo[Ro + 4] = xi[3], Oo[Ro + 5] = xi[2], Oo[Ro + 6] = xi[1], Oo[Ro + 7] = xi[0];
      }
      Ei.writeDoubleLE = Ri ? Ti : Oi, Ei.writeDoubleBE = Ri ? Oi : Ti;
      function Mi(Ci, Oo) {
        return xi[0] = Ci[Oo], xi[1] = Ci[Oo + 1], xi[2] = Ci[Oo + 2], xi[3] = Ci[Oo + 3], xi[4] = Ci[Oo + 4], xi[5] = Ci[Oo + 5], xi[6] = Ci[Oo + 6], xi[7] = Ci[Oo + 7], $i[0];
      }
      function Ii(Ci, Oo) {
        return xi[7] = Ci[Oo], xi[6] = Ci[Oo + 1], xi[5] = Ci[Oo + 2], xi[4] = Ci[Oo + 3], xi[3] = Ci[Oo + 4], xi[2] = Ci[Oo + 5], xi[1] = Ci[Oo + 6], xi[0] = Ci[Oo + 7], $i[0];
      }
      Ei.readDoubleLE = Ri ? Mi : Ii, Ei.readDoubleBE = Ri ? Ii : Mi;
    }() : function() {
      function $i(Ri, Ti, Oi, Mi, Ii, Ci) {
        var Oo = Mi < 0 ? 1 : 0;
        if (Oo && (Mi = -Mi), Mi === 0)
          Ri(0, Ii, Ci + Ti), Ri(1 / Mi > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), Ii, Ci + Oi);
        else if (isNaN(Mi))
          Ri(0, Ii, Ci + Ti), Ri(2146959360, Ii, Ci + Oi);
        else if (Mi > 17976931348623157e292)
          Ri(0, Ii, Ci + Ti), Ri((Oo << 31 | 2146435072) >>> 0, Ii, Ci + Oi);
        else {
          var Ro;
          if (Mi < 22250738585072014e-324)
            Ro = Mi / 5e-324, Ri(Ro >>> 0, Ii, Ci + Ti), Ri((Oo << 31 | Ro / 4294967296) >>> 0, Ii, Ci + Oi);
          else {
            var Bo = Math.floor(Math.log(Mi) / Math.LN2);
            Bo === 1024 && (Bo = 1023), Ro = Mi * Math.pow(2, -Bo), Ri(Ro * 4503599627370496 >>> 0, Ii, Ci + Ti), Ri((Oo << 31 | Bo + 1023 << 20 | Ro * 1048576 & 1048575) >>> 0, Ii, Ci + Oi);
          }
        }
      }
      Ei.writeDoubleLE = $i.bind(null, e, 0, 4), Ei.writeDoubleBE = $i.bind(null, Oe, 4, 0);
      function xi(Ri, Ti, Oi, Mi, Ii) {
        var Ci = Ri(Mi, Ii + Ti), Oo = Ri(Mi, Ii + Oi), Ro = (Oo >> 31) * 2 + 1, Bo = Oo >>> 20 & 2047, Fo = 4294967296 * (Oo & 1048575) + Ci;
        return Bo === 2047 ? Fo ? NaN : Ro * (1 / 0) : Bo === 0 ? Ro * 5e-324 * Fo : Ro * Math.pow(2, Bo - 1075) * (Fo + 4503599627370496);
      }
      Ei.readDoubleLE = xi.bind(null, Si, 0, 4), Ei.readDoubleBE = xi.bind(null, wi, 4, 0);
    }(), Ei;
  }
  function e(Ei, $i, xi) {
    $i[xi] = Ei & 255, $i[xi + 1] = Ei >>> 8 & 255, $i[xi + 2] = Ei >>> 16 & 255, $i[xi + 3] = Ei >>> 24;
  }
  function Oe(Ei, $i, xi) {
    $i[xi] = Ei >>> 24, $i[xi + 1] = Ei >>> 16 & 255, $i[xi + 2] = Ei >>> 8 & 255, $i[xi + 3] = Ei & 255;
  }
  function Si(Ei, $i) {
    return (Ei[$i] | Ei[$i + 1] << 8 | Ei[$i + 2] << 16 | Ei[$i + 3] << 24) >>> 0;
  }
  function wi(Ei, $i) {
    return (Ei[$i] << 24 | Ei[$i + 1] << 16 | Ei[$i + 2] << 8 | Ei[$i + 3]) >>> 0;
  }
  return float;
}
var inquire_1, hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire)
    return inquire_1;
  hasRequiredInquire = 1, inquire_1 = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (se) {
    }
    return null;
  }
  return inquire_1;
}
var utf8 = {}, hasRequiredUtf8;
function requireUtf8() {
  return hasRequiredUtf8 || (hasRequiredUtf8 = 1, function(se) {
    var e = se;
    e.length = function(Si) {
      for (var wi = 0, Ei = 0, $i = 0; $i < Si.length; ++$i)
        Ei = Si.charCodeAt($i), Ei < 128 ? wi += 1 : Ei < 2048 ? wi += 2 : (Ei & 64512) === 55296 && (Si.charCodeAt($i + 1) & 64512) === 56320 ? (++$i, wi += 4) : wi += 3;
      return wi;
    }, e.read = function(Si, wi, Ei) {
      var $i = Ei - wi;
      if ($i < 1)
        return "";
      for (var xi = null, Ri = [], Ti = 0, Oi; wi < Ei; )
        Oi = Si[wi++], Oi < 128 ? Ri[Ti++] = Oi : Oi > 191 && Oi < 224 ? Ri[Ti++] = (Oi & 31) << 6 | Si[wi++] & 63 : Oi > 239 && Oi < 365 ? (Oi = ((Oi & 7) << 18 | (Si[wi++] & 63) << 12 | (Si[wi++] & 63) << 6 | Si[wi++] & 63) - 65536, Ri[Ti++] = 55296 + (Oi >> 10), Ri[Ti++] = 56320 + (Oi & 1023)) : Ri[Ti++] = (Oi & 15) << 12 | (Si[wi++] & 63) << 6 | Si[wi++] & 63, Ti > 8191 && ((xi || (xi = [])).push(String.fromCharCode.apply(String, Ri)), Ti = 0);
      return xi ? (Ti && xi.push(String.fromCharCode.apply(String, Ri.slice(0, Ti))), xi.join("")) : String.fromCharCode.apply(String, Ri.slice(0, Ti));
    }, e.write = function(Si, wi, Ei) {
      for (var $i = Ei, xi, Ri, Ti = 0; Ti < Si.length; ++Ti)
        xi = Si.charCodeAt(Ti), xi < 128 ? wi[Ei++] = xi : xi < 2048 ? (wi[Ei++] = xi >> 6 | 192, wi[Ei++] = xi & 63 | 128) : (xi & 64512) === 55296 && ((Ri = Si.charCodeAt(Ti + 1)) & 64512) === 56320 ? (xi = 65536 + ((xi & 1023) << 10) + (Ri & 1023), ++Ti, wi[Ei++] = xi >> 18 | 240, wi[Ei++] = xi >> 12 & 63 | 128, wi[Ei++] = xi >> 6 & 63 | 128, wi[Ei++] = xi & 63 | 128) : (wi[Ei++] = xi >> 12 | 224, wi[Ei++] = xi >> 6 & 63 | 128, wi[Ei++] = xi & 63 | 128);
      return Ei - $i;
    };
  }(utf8)), utf8;
}
var pool_1, hasRequiredPool;
function requirePool() {
  if (hasRequiredPool)
    return pool_1;
  hasRequiredPool = 1, pool_1 = se;
  function se(e, Oe, Si) {
    var wi = Si || 8192, Ei = wi >>> 1, $i = null, xi = wi;
    return function(Ti) {
      if (Ti < 1 || Ti > Ei)
        return e(Ti);
      xi + Ti > wi && ($i = e(wi), xi = 0);
      var Oi = Oe.call($i, xi, xi += Ti);
      return xi & 7 && (xi = (xi | 7) + 1), Oi;
    };
  }
  return pool_1;
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = e;
  var se = requireMinimal$1();
  function e(Ei, $i) {
    this.lo = Ei >>> 0, this.hi = $i >>> 0;
  }
  var Oe = e.zero = new e(0, 0);
  Oe.toNumber = function() {
    return 0;
  }, Oe.zzEncode = Oe.zzDecode = function() {
    return this;
  }, Oe.length = function() {
    return 1;
  };
  var Si = e.zeroHash = "\0\0\0\0\0\0\0\0";
  e.fromNumber = function($i) {
    if ($i === 0)
      return Oe;
    var xi = $i < 0;
    xi && ($i = -$i);
    var Ri = $i >>> 0, Ti = ($i - Ri) / 4294967296 >>> 0;
    return xi && (Ti = ~Ti >>> 0, Ri = ~Ri >>> 0, ++Ri > 4294967295 && (Ri = 0, ++Ti > 4294967295 && (Ti = 0))), new e(Ri, Ti);
  }, e.from = function($i) {
    if (typeof $i == "number")
      return e.fromNumber($i);
    if (se.isString($i))
      if (se.Long)
        $i = se.Long.fromString($i);
      else
        return e.fromNumber(parseInt($i, 10));
    return $i.low || $i.high ? new e($i.low >>> 0, $i.high >>> 0) : Oe;
  }, e.prototype.toNumber = function($i) {
    if (!$i && this.hi >>> 31) {
      var xi = ~this.lo + 1 >>> 0, Ri = ~this.hi >>> 0;
      return xi || (Ri = Ri + 1 >>> 0), -(xi + Ri * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, e.prototype.toLong = function($i) {
    return se.Long ? new se.Long(this.lo | 0, this.hi | 0, !!$i) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!$i };
  };
  var wi = String.prototype.charCodeAt;
  return e.fromHash = function($i) {
    return $i === Si ? Oe : new e(
      (wi.call($i, 0) | wi.call($i, 1) << 8 | wi.call($i, 2) << 16 | wi.call($i, 3) << 24) >>> 0,
      (wi.call($i, 4) | wi.call($i, 5) << 8 | wi.call($i, 6) << 16 | wi.call($i, 7) << 24) >>> 0
    );
  }, e.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, e.prototype.zzEncode = function() {
    var $i = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ $i) >>> 0, this.lo = (this.lo << 1 ^ $i) >>> 0, this;
  }, e.prototype.zzDecode = function() {
    var $i = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ $i) >>> 0, this.hi = (this.hi >>> 1 ^ $i) >>> 0, this;
  }, e.prototype.length = function() {
    var $i = this.lo, xi = (this.lo >>> 28 | this.hi << 4) >>> 0, Ri = this.hi >>> 24;
    return Ri === 0 ? xi === 0 ? $i < 16384 ? $i < 128 ? 1 : 2 : $i < 2097152 ? 3 : 4 : xi < 16384 ? xi < 128 ? 5 : 6 : xi < 2097152 ? 7 : 8 : Ri < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  return hasRequiredMinimal$1 || (hasRequiredMinimal$1 = 1, function(se) {
    var e = se;
    e.asPromise = requireAspromise(), e.base64 = requireBase64(), e.EventEmitter = requireEventemitter(), e.float = requireFloat(), e.inquire = requireInquire(), e.utf8 = requireUtf8(), e.pool = requirePool(), e.LongBits = requireLongbits(), e.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), e.global = e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, e.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), e.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), e.isInteger = Number.isInteger || /* istanbul ignore next */
    function(Ei) {
      return typeof Ei == "number" && isFinite(Ei) && Math.floor(Ei) === Ei;
    }, e.isString = function(Ei) {
      return typeof Ei == "string" || Ei instanceof String;
    }, e.isObject = function(Ei) {
      return Ei && typeof Ei == "object";
    }, e.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    e.isSet = function(Ei, $i) {
      var xi = Ei[$i];
      return xi != null && Ei.hasOwnProperty($i) ? typeof xi != "object" || (Array.isArray(xi) ? xi.length : Object.keys(xi).length) > 0 : !1;
    }, e.Buffer = function() {
      try {
        var wi = e.inquire("buffer").Buffer;
        return wi.prototype.utf8Write ? wi : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), e._Buffer_from = null, e._Buffer_allocUnsafe = null, e.newBuffer = function(Ei) {
      return typeof Ei == "number" ? e.Buffer ? e._Buffer_allocUnsafe(Ei) : new e.Array(Ei) : e.Buffer ? e._Buffer_from(Ei) : typeof Uint8Array > "u" ? Ei : new Uint8Array(Ei);
    }, e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, e.Long = /* istanbul ignore next */
    e.global.dcodeIO && /* istanbul ignore next */
    e.global.dcodeIO.Long || /* istanbul ignore next */
    e.global.Long || e.inquire("long"), e.key2Re = /^true|false|0|1$/, e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, e.longToHash = function(Ei) {
      return Ei ? e.LongBits.from(Ei).toHash() : e.LongBits.zeroHash;
    }, e.longFromHash = function(Ei, $i) {
      var xi = e.LongBits.fromHash(Ei);
      return e.Long ? e.Long.fromBits(xi.lo, xi.hi, $i) : xi.toNumber(!!$i);
    };
    function Oe(wi, Ei, $i) {
      for (var xi = Object.keys(Ei), Ri = 0; Ri < xi.length; ++Ri)
        (wi[xi[Ri]] === void 0 || !$i) && (wi[xi[Ri]] = Ei[xi[Ri]]);
      return wi;
    }
    e.merge = Oe, e.lcFirst = function(Ei) {
      return Ei.charAt(0).toLowerCase() + Ei.substring(1);
    };
    function Si(wi) {
      function Ei($i, xi) {
        if (!(this instanceof Ei))
          return new Ei($i, xi);
        Object.defineProperty(this, "message", { get: function() {
          return $i;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, Ei) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), xi && Oe(this, xi);
      }
      return Ei.prototype = Object.create(Error.prototype, {
        constructor: {
          value: Ei,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return wi;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), Ei;
    }
    e.newError = Si, e.ProtocolError = Si("ProtocolError"), e.oneOfGetter = function(Ei) {
      for (var $i = {}, xi = 0; xi < Ei.length; ++xi)
        $i[Ei[xi]] = 1;
      return function() {
        for (var Ri = Object.keys(this), Ti = Ri.length - 1; Ti > -1; --Ti)
          if ($i[Ri[Ti]] === 1 && this[Ri[Ti]] !== void 0 && this[Ri[Ti]] !== null)
            return Ri[Ti];
      };
    }, e.oneOfSetter = function(Ei) {
      return function($i) {
        for (var xi = 0; xi < Ei.length; ++xi)
          Ei[xi] !== $i && delete this[Ei[xi]];
      };
    }, e.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, e._configure = function() {
      var wi = e.Buffer;
      if (!wi) {
        e._Buffer_from = e._Buffer_allocUnsafe = null;
        return;
      }
      e._Buffer_from = wi.from !== Uint8Array.from && wi.from || /* istanbul ignore next */
      function($i, xi) {
        return new wi($i, xi);
      }, e._Buffer_allocUnsafe = wi.allocUnsafe || /* istanbul ignore next */
      function($i) {
        return new wi($i);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer, hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter)
    return writer;
  hasRequiredWriter = 1, writer = Ri;
  var se = requireMinimal$1(), e, Oe = se.LongBits, Si = se.base64, wi = se.utf8;
  function Ei(Bo, Fo, Io) {
    this.fn = Bo, this.len = Fo, this.next = void 0, this.val = Io;
  }
  function $i() {
  }
  function xi(Bo) {
    this.head = Bo.head, this.tail = Bo.tail, this.len = Bo.len, this.next = Bo.states;
  }
  function Ri() {
    this.len = 0, this.head = new Ei($i, 0, 0), this.tail = this.head, this.states = null;
  }
  var Ti = function() {
    return se.Buffer ? function() {
      return (Ri.create = function() {
        return new e();
      })();
    } : function() {
      return new Ri();
    };
  };
  Ri.create = Ti(), Ri.alloc = function(Fo) {
    return new se.Array(Fo);
  }, se.Array !== Array && (Ri.alloc = se.pool(Ri.alloc, se.Array.prototype.subarray)), Ri.prototype._push = function(Fo, Io, Uo) {
    return this.tail = this.tail.next = new Ei(Fo, Io, Uo), this.len += Io, this;
  };
  function Oi(Bo, Fo, Io) {
    Fo[Io] = Bo & 255;
  }
  function Mi(Bo, Fo, Io) {
    for (; Bo > 127; )
      Fo[Io++] = Bo & 127 | 128, Bo >>>= 7;
    Fo[Io] = Bo;
  }
  function Ii(Bo, Fo) {
    this.len = Bo, this.next = void 0, this.val = Fo;
  }
  Ii.prototype = Object.create(Ei.prototype), Ii.prototype.fn = Mi, Ri.prototype.uint32 = function(Fo) {
    return this.len += (this.tail = this.tail.next = new Ii(
      (Fo = Fo >>> 0) < 128 ? 1 : Fo < 16384 ? 2 : Fo < 2097152 ? 3 : Fo < 268435456 ? 4 : 5,
      Fo
    )).len, this;
  }, Ri.prototype.int32 = function(Fo) {
    return Fo < 0 ? this._push(Ci, 10, Oe.fromNumber(Fo)) : this.uint32(Fo);
  }, Ri.prototype.sint32 = function(Fo) {
    return this.uint32((Fo << 1 ^ Fo >> 31) >>> 0);
  };
  function Ci(Bo, Fo, Io) {
    for (; Bo.hi; )
      Fo[Io++] = Bo.lo & 127 | 128, Bo.lo = (Bo.lo >>> 7 | Bo.hi << 25) >>> 0, Bo.hi >>>= 7;
    for (; Bo.lo > 127; )
      Fo[Io++] = Bo.lo & 127 | 128, Bo.lo = Bo.lo >>> 7;
    Fo[Io++] = Bo.lo;
  }
  Ri.prototype.uint64 = function(Fo) {
    var Io = Oe.from(Fo);
    return this._push(Ci, Io.length(), Io);
  }, Ri.prototype.int64 = Ri.prototype.uint64, Ri.prototype.sint64 = function(Fo) {
    var Io = Oe.from(Fo).zzEncode();
    return this._push(Ci, Io.length(), Io);
  }, Ri.prototype.bool = function(Fo) {
    return this._push(Oi, 1, Fo ? 1 : 0);
  };
  function Oo(Bo, Fo, Io) {
    Fo[Io] = Bo & 255, Fo[Io + 1] = Bo >>> 8 & 255, Fo[Io + 2] = Bo >>> 16 & 255, Fo[Io + 3] = Bo >>> 24;
  }
  Ri.prototype.fixed32 = function(Fo) {
    return this._push(Oo, 4, Fo >>> 0);
  }, Ri.prototype.sfixed32 = Ri.prototype.fixed32, Ri.prototype.fixed64 = function(Fo) {
    var Io = Oe.from(Fo);
    return this._push(Oo, 4, Io.lo)._push(Oo, 4, Io.hi);
  }, Ri.prototype.sfixed64 = Ri.prototype.fixed64, Ri.prototype.float = function(Fo) {
    return this._push(se.float.writeFloatLE, 4, Fo);
  }, Ri.prototype.double = function(Fo) {
    return this._push(se.float.writeDoubleLE, 8, Fo);
  };
  var Ro = se.Array.prototype.set ? function(Fo, Io, Uo) {
    Io.set(Fo, Uo);
  } : function(Fo, Io, Uo) {
    for (var Co = 0; Co < Fo.length; ++Co)
      Io[Uo + Co] = Fo[Co];
  };
  return Ri.prototype.bytes = function(Fo) {
    var Io = Fo.length >>> 0;
    if (!Io)
      return this._push(Oi, 1, 0);
    if (se.isString(Fo)) {
      var Uo = Ri.alloc(Io = Si.length(Fo));
      Si.decode(Fo, Uo, 0), Fo = Uo;
    }
    return this.uint32(Io)._push(Ro, Io, Fo);
  }, Ri.prototype.string = function(Fo) {
    var Io = wi.length(Fo);
    return Io ? this.uint32(Io)._push(wi.write, Io, Fo) : this._push(Oi, 1, 0);
  }, Ri.prototype.fork = function() {
    return this.states = new xi(this), this.head = this.tail = new Ei($i, 0, 0), this.len = 0, this;
  }, Ri.prototype.reset = function() {
    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Ei($i, 0, 0), this.len = 0), this;
  }, Ri.prototype.ldelim = function() {
    var Fo = this.head, Io = this.tail, Uo = this.len;
    return this.reset().uint32(Uo), Uo && (this.tail.next = Fo.next, this.tail = Io, this.len += Uo), this;
  }, Ri.prototype.finish = function() {
    for (var Fo = this.head.next, Io = this.constructor.alloc(this.len), Uo = 0; Fo; )
      Fo.fn(Fo.val, Io, Uo), Uo += Fo.len, Fo = Fo.next;
    return Io;
  }, Ri._configure = function(Bo) {
    e = Bo, Ri.create = Ti(), e._configure();
  }, writer;
}
var writer_buffer, hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer)
    return writer_buffer;
  hasRequiredWriter_buffer = 1, writer_buffer = Oe;
  var se = requireWriter();
  (Oe.prototype = Object.create(se.prototype)).constructor = Oe;
  var e = requireMinimal$1();
  function Oe() {
    se.call(this);
  }
  Oe._configure = function() {
    Oe.alloc = e._Buffer_allocUnsafe, Oe.writeBytesBuffer = e.Buffer && e.Buffer.prototype instanceof Uint8Array && e.Buffer.prototype.set.name === "set" ? function(Ei, $i, xi) {
      $i.set(Ei, xi);
    } : function(Ei, $i, xi) {
      if (Ei.copy)
        Ei.copy($i, xi, 0, Ei.length);
      else
        for (var Ri = 0; Ri < Ei.length; )
          $i[xi++] = Ei[Ri++];
    };
  }, Oe.prototype.bytes = function(Ei) {
    e.isString(Ei) && (Ei = e._Buffer_from(Ei, "base64"));
    var $i = Ei.length >>> 0;
    return this.uint32($i), $i && this._push(Oe.writeBytesBuffer, $i, Ei), this;
  };
  function Si(wi, Ei, $i) {
    wi.length < 40 ? e.utf8.write(wi, Ei, $i) : Ei.utf8Write ? Ei.utf8Write(wi, $i) : Ei.write(wi, $i);
  }
  return Oe.prototype.string = function(Ei) {
    var $i = e.Buffer.byteLength(Ei);
    return this.uint32($i), $i && this._push(Si, $i, Ei), this;
  }, Oe._configure(), writer_buffer;
}
var reader, hasRequiredReader;
function requireReader() {
  if (hasRequiredReader)
    return reader;
  hasRequiredReader = 1, reader = Ei;
  var se = requireMinimal$1(), e, Oe = se.LongBits, Si = se.utf8;
  function wi(Mi, Ii) {
    return RangeError("index out of range: " + Mi.pos + " + " + (Ii || 1) + " > " + Mi.len);
  }
  function Ei(Mi) {
    this.buf = Mi, this.pos = 0, this.len = Mi.length;
  }
  var $i = typeof Uint8Array < "u" ? function(Ii) {
    if (Ii instanceof Uint8Array || Array.isArray(Ii))
      return new Ei(Ii);
    throw Error("illegal buffer");
  } : function(Ii) {
    if (Array.isArray(Ii))
      return new Ei(Ii);
    throw Error("illegal buffer");
  }, xi = function() {
    return se.Buffer ? function(Ci) {
      return (Ei.create = function(Ro) {
        return se.Buffer.isBuffer(Ro) ? new e(Ro) : $i(Ro);
      })(Ci);
    } : $i;
  };
  Ei.create = xi(), Ei.prototype._slice = se.Array.prototype.subarray || /* istanbul ignore next */
  se.Array.prototype.slice, Ei.prototype.uint32 = function() {
    var Ii = 4294967295;
    return function() {
      if (Ii = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (Ii = (Ii | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (Ii = (Ii | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (Ii = (Ii | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (Ii = (Ii | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
        return Ii;
      if ((this.pos += 5) > this.len)
        throw this.pos = this.len, wi(this, 10);
      return Ii;
    };
  }(), Ei.prototype.int32 = function() {
    return this.uint32() | 0;
  }, Ei.prototype.sint32 = function() {
    var Ii = this.uint32();
    return Ii >>> 1 ^ -(Ii & 1) | 0;
  };
  function Ri() {
    var Mi = new Oe(0, 0), Ii = 0;
    if (this.len - this.pos > 4) {
      for (; Ii < 4; ++Ii)
        if (Mi.lo = (Mi.lo | (this.buf[this.pos] & 127) << Ii * 7) >>> 0, this.buf[this.pos++] < 128)
          return Mi;
      if (Mi.lo = (Mi.lo | (this.buf[this.pos] & 127) << 28) >>> 0, Mi.hi = (Mi.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
        return Mi;
      Ii = 0;
    } else {
      for (; Ii < 3; ++Ii) {
        if (this.pos >= this.len)
          throw wi(this);
        if (Mi.lo = (Mi.lo | (this.buf[this.pos] & 127) << Ii * 7) >>> 0, this.buf[this.pos++] < 128)
          return Mi;
      }
      return Mi.lo = (Mi.lo | (this.buf[this.pos++] & 127) << Ii * 7) >>> 0, Mi;
    }
    if (this.len - this.pos > 4) {
      for (; Ii < 5; ++Ii)
        if (Mi.hi = (Mi.hi | (this.buf[this.pos] & 127) << Ii * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
          return Mi;
    } else
      for (; Ii < 5; ++Ii) {
        if (this.pos >= this.len)
          throw wi(this);
        if (Mi.hi = (Mi.hi | (this.buf[this.pos] & 127) << Ii * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
          return Mi;
      }
    throw Error("invalid varint encoding");
  }
  Ei.prototype.bool = function() {
    return this.uint32() !== 0;
  };
  function Ti(Mi, Ii) {
    return (Mi[Ii - 4] | Mi[Ii - 3] << 8 | Mi[Ii - 2] << 16 | Mi[Ii - 1] << 24) >>> 0;
  }
  Ei.prototype.fixed32 = function() {
    if (this.pos + 4 > this.len)
      throw wi(this, 4);
    return Ti(this.buf, this.pos += 4);
  }, Ei.prototype.sfixed32 = function() {
    if (this.pos + 4 > this.len)
      throw wi(this, 4);
    return Ti(this.buf, this.pos += 4) | 0;
  };
  function Oi() {
    if (this.pos + 8 > this.len)
      throw wi(this, 8);
    return new Oe(Ti(this.buf, this.pos += 4), Ti(this.buf, this.pos += 4));
  }
  return Ei.prototype.float = function() {
    if (this.pos + 4 > this.len)
      throw wi(this, 4);
    var Ii = se.float.readFloatLE(this.buf, this.pos);
    return this.pos += 4, Ii;
  }, Ei.prototype.double = function() {
    if (this.pos + 8 > this.len)
      throw wi(this, 4);
    var Ii = se.float.readDoubleLE(this.buf, this.pos);
    return this.pos += 8, Ii;
  }, Ei.prototype.bytes = function() {
    var Ii = this.uint32(), Ci = this.pos, Oo = this.pos + Ii;
    if (Oo > this.len)
      throw wi(this, Ii);
    if (this.pos += Ii, Array.isArray(this.buf))
      return this.buf.slice(Ci, Oo);
    if (Ci === Oo) {
      var Ro = se.Buffer;
      return Ro ? Ro.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, Ci, Oo);
  }, Ei.prototype.string = function() {
    var Ii = this.bytes();
    return Si.read(Ii, 0, Ii.length);
  }, Ei.prototype.skip = function(Ii) {
    if (typeof Ii == "number") {
      if (this.pos + Ii > this.len)
        throw wi(this, Ii);
      this.pos += Ii;
    } else
      do
        if (this.pos >= this.len)
          throw wi(this);
      while (this.buf[this.pos++] & 128);
    return this;
  }, Ei.prototype.skipType = function(Mi) {
    switch (Mi) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        for (; (Mi = this.uint32() & 7) !== 4; )
          this.skipType(Mi);
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + Mi + " at offset " + this.pos);
    }
    return this;
  }, Ei._configure = function(Mi) {
    e = Mi, Ei.create = xi(), e._configure();
    var Ii = se.Long ? "toLong" : (
      /* istanbul ignore next */
      "toNumber"
    );
    se.merge(Ei.prototype, {
      int64: function() {
        return Ri.call(this)[Ii](!1);
      },
      uint64: function() {
        return Ri.call(this)[Ii](!0);
      },
      sint64: function() {
        return Ri.call(this).zzDecode()[Ii](!1);
      },
      fixed64: function() {
        return Oi.call(this)[Ii](!0);
      },
      sfixed64: function() {
        return Oi.call(this)[Ii](!1);
      }
    });
  }, reader;
}
var reader_buffer, hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer)
    return reader_buffer;
  hasRequiredReader_buffer = 1, reader_buffer = Oe;
  var se = requireReader();
  (Oe.prototype = Object.create(se.prototype)).constructor = Oe;
  var e = requireMinimal$1();
  function Oe(Si) {
    se.call(this, Si);
  }
  return Oe._configure = function() {
    e.Buffer && (Oe.prototype._slice = e.Buffer.prototype.slice);
  }, Oe.prototype.string = function() {
    var wi = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + wi, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + wi, this.len));
  }, Oe._configure(), reader_buffer;
}
var rpc = {}, service$1, hasRequiredService$1;
function requireService$1() {
  if (hasRequiredService$1)
    return service$1;
  hasRequiredService$1 = 1, service$1 = e;
  var se = requireMinimal$1();
  (e.prototype = Object.create(se.EventEmitter.prototype)).constructor = e;
  function e(Oe, Si, wi) {
    if (typeof Oe != "function")
      throw TypeError("rpcImpl must be a function");
    se.EventEmitter.call(this), this.rpcImpl = Oe, this.requestDelimited = !!Si, this.responseDelimited = !!wi;
  }
  return e.prototype.rpcCall = function Oe(Si, wi, Ei, $i, xi) {
    if (!$i)
      throw TypeError("request must be specified");
    var Ri = this;
    if (!xi)
      return se.asPromise(Oe, Ri, Si, wi, Ei, $i);
    if (!Ri.rpcImpl) {
      setTimeout(function() {
        xi(Error("already ended"));
      }, 0);
      return;
    }
    try {
      return Ri.rpcImpl(
        Si,
        wi[Ri.requestDelimited ? "encodeDelimited" : "encode"]($i).finish(),
        function(Oi, Mi) {
          if (Oi)
            return Ri.emit("error", Oi, Si), xi(Oi);
          if (Mi === null) {
            Ri.end(
              /* endedByRPC */
              !0
            );
            return;
          }
          if (!(Mi instanceof Ei))
            try {
              Mi = Ei[Ri.responseDelimited ? "decodeDelimited" : "decode"](Mi);
            } catch (Ii) {
              return Ri.emit("error", Ii, Si), xi(Ii);
            }
          return Ri.emit("data", Mi, Si), xi(null, Mi);
        }
      );
    } catch (Ti) {
      Ri.emit("error", Ti, Si), setTimeout(function() {
        xi(Ti);
      }, 0);
      return;
    }
  }, e.prototype.end = function(Si) {
    return this.rpcImpl && (Si || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
  }, service$1;
}
var hasRequiredRpc;
function requireRpc() {
  return hasRequiredRpc || (hasRequiredRpc = 1, function(se) {
    var e = se;
    e.Service = requireService$1();
  }(rpc)), rpc;
}
var roots, hasRequiredRoots;
function requireRoots() {
  return hasRequiredRoots || (hasRequiredRoots = 1, roots = {}), roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  return hasRequiredIndexMinimal || (hasRequiredIndexMinimal = 1, function(se) {
    var e = se;
    e.build = "minimal", e.Writer = requireWriter(), e.BufferWriter = requireWriter_buffer(), e.Reader = requireReader(), e.BufferReader = requireReader_buffer(), e.util = requireMinimal$1(), e.rpc = requireRpc(), e.roots = requireRoots(), e.configure = Oe;
    function Oe() {
      e.util._configure(), e.Writer._configure(e.BufferWriter), e.Reader._configure(e.BufferReader);
    }
    Oe();
  }(indexMinimal)), indexMinimal;
}
var util$3 = { exports: {} }, codegen_1 = codegen;
function codegen(se, e) {
  typeof se == "string" && (e = se, se = void 0);
  var Oe = [];
  function Si(Ei) {
    if (typeof Ei != "string") {
      var $i = wi();
      if (codegen.verbose && console.log("codegen: " + $i), $i = "return " + $i, Ei) {
        for (var xi = Object.keys(Ei), Ri = new Array(xi.length + 1), Ti = new Array(xi.length), Oi = 0; Oi < xi.length; )
          Ri[Oi] = xi[Oi], Ti[Oi] = Ei[xi[Oi++]];
        return Ri[Oi] = $i, Function.apply(null, Ri).apply(null, Ti);
      }
      return Function($i)();
    }
    for (var Mi = new Array(arguments.length - 1), Ii = 0; Ii < Mi.length; )
      Mi[Ii] = arguments[++Ii];
    if (Ii = 0, Ei = Ei.replace(/%([%dfijs])/g, function(Oo, Ro) {
      var Bo = Mi[Ii++];
      switch (Ro) {
        case "d":
        case "f":
          return String(Number(Bo));
        case "i":
          return String(Math.floor(Bo));
        case "j":
          return JSON.stringify(Bo);
        case "s":
          return String(Bo);
      }
      return "%";
    }), Ii !== Mi.length)
      throw Error("parameter count mismatch");
    return Oe.push(Ei), Si;
  }
  function wi(Ei) {
    return "function " + (Ei || e || "") + "(" + (se && se.join(",") || "") + `){
  ` + Oe.join(`
  `) + `
}`;
  }
  return Si.toString = wi, Si;
}
codegen.verbose = !1;
var fetch_1 = fetch$1, asPromise = requireAspromise(), inquire = requireInquire(), fs$1 = inquire("fs");
function fetch$1(se, e, Oe) {
  return typeof e == "function" ? (Oe = e, e = {}) : e || (e = {}), Oe ? !e.xhr && fs$1 && fs$1.readFile ? fs$1.readFile(se, function(wi, Ei) {
    return wi && typeof XMLHttpRequest < "u" ? fetch$1.xhr(se, e, Oe) : wi ? Oe(wi) : Oe(null, e.binary ? Ei : Ei.toString("utf8"));
  }) : fetch$1.xhr(se, e, Oe) : asPromise(fetch$1, this, se, e);
}
fetch$1.xhr = function se(e, Oe, Si) {
  var wi = new XMLHttpRequest();
  wi.onreadystatechange = function() {
    if (wi.readyState === 4) {
      if (wi.status !== 0 && wi.status !== 200)
        return Si(Error("status " + wi.status));
      if (Oe.binary) {
        var $i = wi.response;
        if (!$i) {
          $i = [];
          for (var xi = 0; xi < wi.responseText.length; ++xi)
            $i.push(wi.responseText.charCodeAt(xi) & 255);
        }
        return Si(null, typeof Uint8Array < "u" ? new Uint8Array($i) : $i);
      }
      return Si(null, wi.responseText);
    }
  }, Oe.binary && ("overrideMimeType" in wi && wi.overrideMimeType("text/plain; charset=x-user-defined"), wi.responseType = "arraybuffer"), wi.open("GET", e), wi.send();
};
var path = {};
(function(se) {
  var e = se, Oe = (
    /**
     * Tests if the specified path is absolute.
     * @param {string} path Path to test
     * @returns {boolean} `true` if path is absolute
     */
    e.isAbsolute = function(Ei) {
      return /^(?:\/|\w+:)/.test(Ei);
    }
  ), Si = (
    /**
     * Normalizes the specified path.
     * @param {string} path Path to normalize
     * @returns {string} Normalized path
     */
    e.normalize = function(Ei) {
      Ei = Ei.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var $i = Ei.split("/"), xi = Oe(Ei), Ri = "";
      xi && (Ri = $i.shift() + "/");
      for (var Ti = 0; Ti < $i.length; )
        $i[Ti] === ".." ? Ti > 0 && $i[Ti - 1] !== ".." ? $i.splice(--Ti, 2) : xi ? $i.splice(Ti, 1) : ++Ti : $i[Ti] === "." ? $i.splice(Ti, 1) : ++Ti;
      return Ri + $i.join("/");
    }
  );
  e.resolve = function(Ei, $i, xi) {
    return xi || ($i = Si($i)), Oe($i) ? $i : (xi || (Ei = Si(Ei)), (Ei = Ei.replace(/(?:\/|^)[^/]+$/, "")).length ? Si(Ei + "/" + $i) : $i);
  };
})(path);
var types$1 = {}, hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(se) {
    var e = se, Oe = requireUtil(), Si = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function wi(Ei, $i) {
      var xi = 0, Ri = {};
      for ($i |= 0; xi < Ei.length; )
        Ri[Si[xi + $i]] = Ei[xi++];
      return Ri;
    }
    e.basic = wi([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]), e.defaults = wi([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      !1,
      /* string   */
      "",
      /* bytes    */
      Oe.emptyArray,
      /* message  */
      null
    ]), e.long = wi([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7), e.mapKey = wi([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2), e.packed = wi([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }(types$1)), types$1;
}
var field, hasRequiredField;
function requireField() {
  if (hasRequiredField)
    return field;
  hasRequiredField = 1, field = $i;
  var se = requireObject();
  (($i.prototype = Object.create(se.prototype)).constructor = $i).className = "Field";
  var e = require_enum(), Oe = requireTypes(), Si = requireUtil(), wi, Ei = /^required|optional|repeated$/;
  $i.fromJSON = function(Ri, Ti) {
    return new $i(Ri, Ti.id, Ti.type, Ti.rule, Ti.extend, Ti.options, Ti.comment);
  };
  function $i(xi, Ri, Ti, Oi, Mi, Ii, Ci) {
    if (Si.isObject(Oi) ? (Ci = Mi, Ii = Oi, Oi = Mi = void 0) : Si.isObject(Mi) && (Ci = Ii, Ii = Mi, Mi = void 0), se.call(this, xi, Ii), !Si.isInteger(Ri) || Ri < 0)
      throw TypeError("id must be a non-negative integer");
    if (!Si.isString(Ti))
      throw TypeError("type must be a string");
    if (Oi !== void 0 && !Ei.test(Oi = Oi.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (Mi !== void 0 && !Si.isString(Mi))
      throw TypeError("extend must be a string");
    Oi === "proto3_optional" && (Oi = "optional"), this.rule = Oi && Oi !== "optional" ? Oi : void 0, this.type = Ti, this.id = Ri, this.extend = Mi || void 0, this.required = Oi === "required", this.optional = !this.required, this.repeated = Oi === "repeated", this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = Si.Long ? Oe.long[Ti] !== void 0 : (
      /* istanbul ignore next */
      !1
    ), this.bytes = Ti === "bytes", this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = Ci;
  }
  return Object.defineProperty($i.prototype, "packed", {
    get: function() {
      return this._packed === null && (this._packed = this.getOption("packed") !== !1), this._packed;
    }
  }), $i.prototype.setOption = function(Ri, Ti, Oi) {
    return Ri === "packed" && (this._packed = null), se.prototype.setOption.call(this, Ri, Ti, Oi);
  }, $i.prototype.toJSON = function(Ri) {
    var Ti = Ri ? !!Ri.keepComments : !1;
    return Si.toObject([
      "rule",
      this.rule !== "optional" && this.rule || void 0,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      Ti ? this.comment : void 0
    ]);
  }, $i.prototype.resolve = function() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = Oe.defaults[this.type]) === void 0 ? (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof wi ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]) : this.options && this.options.proto3_optional && (this.typeDefault = null), this.options && this.options.default != null && (this.typeDefault = this.options.default, this.resolvedType instanceof e && typeof this.typeDefault == "string" && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && ((this.options.packed === !0 || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof e)) && delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long)
      this.typeDefault = Si.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u"), Object.freeze && Object.freeze(this.typeDefault);
    else if (this.bytes && typeof this.typeDefault == "string") {
      var Ri;
      Si.base64.test(this.typeDefault) ? Si.base64.decode(this.typeDefault, Ri = Si.newBuffer(Si.base64.length(this.typeDefault)), 0) : Si.utf8.write(this.typeDefault, Ri = Si.newBuffer(Si.utf8.length(this.typeDefault)), 0), this.typeDefault = Ri;
    }
    return this.map ? this.defaultValue = Si.emptyObject : this.repeated ? this.defaultValue = Si.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof wi && (this.parent.ctor.prototype[this.name] = this.defaultValue), se.prototype.resolve.call(this);
  }, $i.d = function(Ri, Ti, Oi, Mi) {
    return typeof Ti == "function" ? Ti = Si.decorateType(Ti).name : Ti && typeof Ti == "object" && (Ti = Si.decorateEnum(Ti).name), function(Ci, Oo) {
      Si.decorateType(Ci.constructor).add(new $i(Oo, Ri, Ti, Oi, { default: Mi }));
    };
  }, $i._configure = function(Ri) {
    wi = Ri;
  }, field;
}
var oneof, hasRequiredOneof;
function requireOneof() {
  if (hasRequiredOneof)
    return oneof;
  hasRequiredOneof = 1, oneof = Si;
  var se = requireObject();
  ((Si.prototype = Object.create(se.prototype)).constructor = Si).className = "OneOf";
  var e = requireField(), Oe = requireUtil();
  function Si(Ei, $i, xi, Ri) {
    if (Array.isArray($i) || (xi = $i, $i = void 0), se.call(this, Ei, xi), !($i === void 0 || Array.isArray($i)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = $i || [], this.fieldsArray = [], this.comment = Ri;
  }
  Si.fromJSON = function($i, xi) {
    return new Si($i, xi.oneof, xi.options, xi.comment);
  }, Si.prototype.toJSON = function($i) {
    var xi = $i ? !!$i.keepComments : !1;
    return Oe.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      xi ? this.comment : void 0
    ]);
  };
  function wi(Ei) {
    if (Ei.parent)
      for (var $i = 0; $i < Ei.fieldsArray.length; ++$i)
        Ei.fieldsArray[$i].parent || Ei.parent.add(Ei.fieldsArray[$i]);
  }
  return Si.prototype.add = function($i) {
    if (!($i instanceof e))
      throw TypeError("field must be a Field");
    return $i.parent && $i.parent !== this.parent && $i.parent.remove($i), this.oneof.push($i.name), this.fieldsArray.push($i), $i.partOf = this, wi(this), this;
  }, Si.prototype.remove = function($i) {
    if (!($i instanceof e))
      throw TypeError("field must be a Field");
    var xi = this.fieldsArray.indexOf($i);
    if (xi < 0)
      throw Error($i + " is not a member of " + this);
    return this.fieldsArray.splice(xi, 1), xi = this.oneof.indexOf($i.name), xi > -1 && this.oneof.splice(xi, 1), $i.partOf = null, this;
  }, Si.prototype.onAdd = function($i) {
    se.prototype.onAdd.call(this, $i);
    for (var xi = this, Ri = 0; Ri < this.oneof.length; ++Ri) {
      var Ti = $i.get(this.oneof[Ri]);
      Ti && !Ti.partOf && (Ti.partOf = xi, xi.fieldsArray.push(Ti));
    }
    wi(this);
  }, Si.prototype.onRemove = function($i) {
    for (var xi = 0, Ri; xi < this.fieldsArray.length; ++xi)
      (Ri = this.fieldsArray[xi]).parent && Ri.parent.remove(Ri);
    se.prototype.onRemove.call(this, $i);
  }, Si.d = function() {
    for (var $i = new Array(arguments.length), xi = 0; xi < arguments.length; )
      $i[xi] = arguments[xi++];
    return function(Ti, Oi) {
      Oe.decorateType(Ti.constructor).add(new Si(Oi, $i)), Object.defineProperty(Ti, Oi, {
        get: Oe.oneOfGetter($i),
        set: Oe.oneOfSetter($i)
      });
    };
  }, oneof;
}
var namespace, hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace)
    return namespace;
  hasRequiredNamespace = 1, namespace = Ri;
  var se = requireObject();
  ((Ri.prototype = Object.create(se.prototype)).constructor = Ri).className = "Namespace";
  var e = requireField(), Oe = requireUtil(), Si = requireOneof(), wi, Ei, $i;
  Ri.fromJSON = function(Mi, Ii) {
    return new Ri(Mi, Ii.options).addJSON(Ii.nested);
  };
  function xi(Oi, Mi) {
    if (Oi && Oi.length) {
      for (var Ii = {}, Ci = 0; Ci < Oi.length; ++Ci)
        Ii[Oi[Ci].name] = Oi[Ci].toJSON(Mi);
      return Ii;
    }
  }
  Ri.arrayToJSON = xi, Ri.isReservedId = function(Mi, Ii) {
    if (Mi) {
      for (var Ci = 0; Ci < Mi.length; ++Ci)
        if (typeof Mi[Ci] != "string" && Mi[Ci][0] <= Ii && Mi[Ci][1] > Ii)
          return !0;
    }
    return !1;
  }, Ri.isReservedName = function(Mi, Ii) {
    if (Mi) {
      for (var Ci = 0; Ci < Mi.length; ++Ci)
        if (Mi[Ci] === Ii)
          return !0;
    }
    return !1;
  };
  function Ri(Oi, Mi) {
    se.call(this, Oi, Mi), this.nested = void 0, this._nestedArray = null;
  }
  function Ti(Oi) {
    return Oi._nestedArray = null, Oi;
  }
  return Object.defineProperty(Ri.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = Oe.toArray(this.nested));
    }
  }), Ri.prototype.toJSON = function(Mi) {
    return Oe.toObject([
      "options",
      this.options,
      "nested",
      xi(this.nestedArray, Mi)
    ]);
  }, Ri.prototype.addJSON = function(Mi) {
    var Ii = this;
    if (Mi)
      for (var Ci = Object.keys(Mi), Oo = 0, Ro; Oo < Ci.length; ++Oo)
        Ro = Mi[Ci[Oo]], Ii.add(
          // most to least likely
          (Ro.fields !== void 0 ? wi.fromJSON : Ro.values !== void 0 ? $i.fromJSON : Ro.methods !== void 0 ? Ei.fromJSON : Ro.id !== void 0 ? e.fromJSON : Ri.fromJSON)(Ci[Oo], Ro)
        );
    return this;
  }, Ri.prototype.get = function(Mi) {
    return this.nested && this.nested[Mi] || null;
  }, Ri.prototype.getEnum = function(Mi) {
    if (this.nested && this.nested[Mi] instanceof $i)
      return this.nested[Mi].values;
    throw Error("no such enum: " + Mi);
  }, Ri.prototype.add = function(Mi) {
    if (!(Mi instanceof e && Mi.extend !== void 0 || Mi instanceof wi || Mi instanceof Si || Mi instanceof $i || Mi instanceof Ei || Mi instanceof Ri))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var Ii = this.get(Mi.name);
      if (Ii)
        if (Ii instanceof Ri && Mi instanceof Ri && !(Ii instanceof wi || Ii instanceof Ei)) {
          for (var Ci = Ii.nestedArray, Oo = 0; Oo < Ci.length; ++Oo)
            Mi.add(Ci[Oo]);
          this.remove(Ii), this.nested || (this.nested = {}), Mi.setOptions(Ii.options, !0);
        } else
          throw Error("duplicate name '" + Mi.name + "' in " + this);
    }
    return this.nested[Mi.name] = Mi, Mi.onAdd(this), Ti(this);
  }, Ri.prototype.remove = function(Mi) {
    if (!(Mi instanceof se))
      throw TypeError("object must be a ReflectionObject");
    if (Mi.parent !== this)
      throw Error(Mi + " is not a member of " + this);
    return delete this.nested[Mi.name], Object.keys(this.nested).length || (this.nested = void 0), Mi.onRemove(this), Ti(this);
  }, Ri.prototype.define = function(Mi, Ii) {
    if (Oe.isString(Mi))
      Mi = Mi.split(".");
    else if (!Array.isArray(Mi))
      throw TypeError("illegal path");
    if (Mi && Mi.length && Mi[0] === "")
      throw Error("path must be relative");
    for (var Ci = this; Mi.length > 0; ) {
      var Oo = Mi.shift();
      if (Ci.nested && Ci.nested[Oo]) {
        if (Ci = Ci.nested[Oo], !(Ci instanceof Ri))
          throw Error("path conflicts with non-namespace objects");
      } else
        Ci.add(Ci = new Ri(Oo));
    }
    return Ii && Ci.addJSON(Ii), Ci;
  }, Ri.prototype.resolveAll = function() {
    for (var Mi = this.nestedArray, Ii = 0; Ii < Mi.length; )
      Mi[Ii] instanceof Ri ? Mi[Ii++].resolveAll() : Mi[Ii++].resolve();
    return this.resolve();
  }, Ri.prototype.lookup = function(Mi, Ii, Ci) {
    if (typeof Ii == "boolean" ? (Ci = Ii, Ii = void 0) : Ii && !Array.isArray(Ii) && (Ii = [Ii]), Oe.isString(Mi) && Mi.length) {
      if (Mi === ".")
        return this.root;
      Mi = Mi.split(".");
    } else if (!Mi.length)
      return this;
    if (Mi[0] === "")
      return this.root.lookup(Mi.slice(1), Ii);
    var Oo = this.get(Mi[0]);
    if (Oo) {
      if (Mi.length === 1) {
        if (!Ii || Ii.indexOf(Oo.constructor) > -1)
          return Oo;
      } else if (Oo instanceof Ri && (Oo = Oo.lookup(Mi.slice(1), Ii, !0)))
        return Oo;
    } else
      for (var Ro = 0; Ro < this.nestedArray.length; ++Ro)
        if (this._nestedArray[Ro] instanceof Ri && (Oo = this._nestedArray[Ro].lookup(Mi, Ii, !0)))
          return Oo;
    return this.parent === null || Ci ? null : this.parent.lookup(Mi, Ii);
  }, Ri.prototype.lookupType = function(Mi) {
    var Ii = this.lookup(Mi, [wi]);
    if (!Ii)
      throw Error("no such type: " + Mi);
    return Ii;
  }, Ri.prototype.lookupEnum = function(Mi) {
    var Ii = this.lookup(Mi, [$i]);
    if (!Ii)
      throw Error("no such Enum '" + Mi + "' in " + this);
    return Ii;
  }, Ri.prototype.lookupTypeOrEnum = function(Mi) {
    var Ii = this.lookup(Mi, [wi, $i]);
    if (!Ii)
      throw Error("no such Type or Enum '" + Mi + "' in " + this);
    return Ii;
  }, Ri.prototype.lookupService = function(Mi) {
    var Ii = this.lookup(Mi, [Ei]);
    if (!Ii)
      throw Error("no such Service '" + Mi + "' in " + this);
    return Ii;
  }, Ri._configure = function(Oi, Mi, Ii) {
    wi = Oi, Ei = Mi, $i = Ii;
  }, namespace;
}
var mapfield, hasRequiredMapfield;
function requireMapfield() {
  if (hasRequiredMapfield)
    return mapfield;
  hasRequiredMapfield = 1, mapfield = Si;
  var se = requireField();
  ((Si.prototype = Object.create(se.prototype)).constructor = Si).className = "MapField";
  var e = requireTypes(), Oe = requireUtil();
  function Si(wi, Ei, $i, xi, Ri, Ti) {
    if (se.call(this, wi, Ei, xi, void 0, void 0, Ri, Ti), !Oe.isString($i))
      throw TypeError("keyType must be a string");
    this.keyType = $i, this.resolvedKeyType = null, this.map = !0;
  }
  return Si.fromJSON = function(Ei, $i) {
    return new Si(Ei, $i.id, $i.keyType, $i.type, $i.options, $i.comment);
  }, Si.prototype.toJSON = function(Ei) {
    var $i = Ei ? !!Ei.keepComments : !1;
    return Oe.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      $i ? this.comment : void 0
    ]);
  }, Si.prototype.resolve = function() {
    if (this.resolved)
      return this;
    if (e.mapKey[this.keyType] === void 0)
      throw Error("invalid key type: " + this.keyType);
    return se.prototype.resolve.call(this);
  }, Si.d = function(Ei, $i, xi) {
    return typeof xi == "function" ? xi = Oe.decorateType(xi).name : xi && typeof xi == "object" && (xi = Oe.decorateEnum(xi).name), function(Ti, Oi) {
      Oe.decorateType(Ti.constructor).add(new Si(Oi, Ei, $i, xi));
    };
  }, mapfield;
}
var method, hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod)
    return method;
  hasRequiredMethod = 1, method = Oe;
  var se = requireObject();
  ((Oe.prototype = Object.create(se.prototype)).constructor = Oe).className = "Method";
  var e = requireUtil();
  function Oe(Si, wi, Ei, $i, xi, Ri, Ti, Oi, Mi) {
    if (e.isObject(xi) ? (Ti = xi, xi = Ri = void 0) : e.isObject(Ri) && (Ti = Ri, Ri = void 0), !(wi === void 0 || e.isString(wi)))
      throw TypeError("type must be a string");
    if (!e.isString(Ei))
      throw TypeError("requestType must be a string");
    if (!e.isString($i))
      throw TypeError("responseType must be a string");
    se.call(this, Si, Ti), this.type = wi || "rpc", this.requestType = Ei, this.requestStream = xi ? !0 : void 0, this.responseType = $i, this.responseStream = Ri ? !0 : void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = Oi, this.parsedOptions = Mi;
  }
  return Oe.fromJSON = function(wi, Ei) {
    return new Oe(wi, Ei.type, Ei.requestType, Ei.responseType, Ei.requestStream, Ei.responseStream, Ei.options, Ei.comment, Ei.parsedOptions);
  }, Oe.prototype.toJSON = function(wi) {
    var Ei = wi ? !!wi.keepComments : !1;
    return e.toObject([
      "type",
      this.type !== "rpc" && /* istanbul ignore next */
      this.type || void 0,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      Ei ? this.comment : void 0,
      "parsedOptions",
      this.parsedOptions
    ]);
  }, Oe.prototype.resolve = function() {
    return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), se.prototype.resolve.call(this));
  }, method;
}
var service, hasRequiredService;
function requireService() {
  if (hasRequiredService)
    return service;
  hasRequiredService = 1, service = wi;
  var se = requireNamespace();
  ((wi.prototype = Object.create(se.prototype)).constructor = wi).className = "Service";
  var e = requireMethod(), Oe = requireUtil(), Si = requireRpc();
  function wi($i, xi) {
    se.call(this, $i, xi), this.methods = {}, this._methodsArray = null;
  }
  wi.fromJSON = function(xi, Ri) {
    var Ti = new wi(xi, Ri.options);
    if (Ri.methods)
      for (var Oi = Object.keys(Ri.methods), Mi = 0; Mi < Oi.length; ++Mi)
        Ti.add(e.fromJSON(Oi[Mi], Ri.methods[Oi[Mi]]));
    return Ri.nested && Ti.addJSON(Ri.nested), Ti.comment = Ri.comment, Ti;
  }, wi.prototype.toJSON = function(xi) {
    var Ri = se.prototype.toJSON.call(this, xi), Ti = xi ? !!xi.keepComments : !1;
    return Oe.toObject([
      "options",
      Ri && Ri.options || void 0,
      "methods",
      se.arrayToJSON(this.methodsArray, xi) || /* istanbul ignore next */
      {},
      "nested",
      Ri && Ri.nested || void 0,
      "comment",
      Ti ? this.comment : void 0
    ]);
  }, Object.defineProperty(wi.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = Oe.toArray(this.methods));
    }
  });
  function Ei($i) {
    return $i._methodsArray = null, $i;
  }
  return wi.prototype.get = function(xi) {
    return this.methods[xi] || se.prototype.get.call(this, xi);
  }, wi.prototype.resolveAll = function() {
    for (var xi = this.methodsArray, Ri = 0; Ri < xi.length; ++Ri)
      xi[Ri].resolve();
    return se.prototype.resolve.call(this);
  }, wi.prototype.add = function(xi) {
    if (this.get(xi.name))
      throw Error("duplicate name '" + xi.name + "' in " + this);
    return xi instanceof e ? (this.methods[xi.name] = xi, xi.parent = this, Ei(this)) : se.prototype.add.call(this, xi);
  }, wi.prototype.remove = function(xi) {
    if (xi instanceof e) {
      if (this.methods[xi.name] !== xi)
        throw Error(xi + " is not a member of " + this);
      return delete this.methods[xi.name], xi.parent = null, Ei(this);
    }
    return se.prototype.remove.call(this, xi);
  }, wi.prototype.create = function(xi, Ri, Ti) {
    for (var Oi = new Si.Service(xi, Ri, Ti), Mi = 0, Ii; Mi < /* initializes */
    this.methodsArray.length; ++Mi) {
      var Ci = Oe.lcFirst((Ii = this._methodsArray[Mi]).resolve().name).replace(/[^$\w_]/g, "");
      Oi[Ci] = Oe.codegen(["r", "c"], Oe.isReserved(Ci) ? Ci + "_" : Ci)("return this.rpcCall(m,q,s,r,c)")({
        m: Ii,
        q: Ii.resolvedRequestType.ctor,
        s: Ii.resolvedResponseType.ctor
      });
    }
    return Oi;
  }, service;
}
var message = Message, util$2 = requireMinimal$1();
function Message(se) {
  if (se)
    for (var e = Object.keys(se), Oe = 0; Oe < e.length; ++Oe)
      this[e[Oe]] = se[e[Oe]];
}
Message.create = function se(e) {
  return this.$type.create(e);
};
Message.encode = function se(e, Oe) {
  return this.$type.encode(e, Oe);
};
Message.encodeDelimited = function se(e, Oe) {
  return this.$type.encodeDelimited(e, Oe);
};
Message.decode = function se(e) {
  return this.$type.decode(e);
};
Message.decodeDelimited = function se(e) {
  return this.$type.decodeDelimited(e);
};
Message.verify = function se(e) {
  return this.$type.verify(e);
};
Message.fromObject = function se(e) {
  return this.$type.fromObject(e);
};
Message.toObject = function se(e, Oe) {
  return this.$type.toObject(e, Oe);
};
Message.prototype.toJSON = function se() {
  return this.$type.toObject(this, util$2.toJSONOptions);
};
var decoder_1, hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder)
    return decoder_1;
  hasRequiredDecoder = 1, decoder_1 = wi;
  var se = require_enum(), e = requireTypes(), Oe = requireUtil();
  function Si(Ei) {
    return "missing required '" + Ei.name + "'";
  }
  function wi(Ei) {
    var $i = Oe.codegen(["r", "l"], Ei.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (Ei.fieldsArray.filter(function(Ii) {
      return Ii.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
    Ei.group && $i("if((t&7)===4)")("break"), $i("switch(t>>>3){");
    for (var xi = 0; xi < /* initializes */
    Ei.fieldsArray.length; ++xi) {
      var Ri = Ei._fieldsArray[xi].resolve(), Ti = Ri.resolvedType instanceof se ? "int32" : Ri.type, Oi = "m" + Oe.safeProp(Ri.name);
      $i("case %i: {", Ri.id), Ri.map ? ($i("if(%s===util.emptyObject)", Oi)("%s={}", Oi)("var c2 = r.uint32()+r.pos"), e.defaults[Ri.keyType] !== void 0 ? $i("k=%j", e.defaults[Ri.keyType]) : $i("k=null"), e.defaults[Ti] !== void 0 ? $i("value=%j", e.defaults[Ti]) : $i("value=null"), $i("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", Ri.keyType)("case 2:"), e.basic[Ti] === void 0 ? $i("value=types[%i].decode(r,r.uint32())", xi) : $i("value=r.%s()", Ti), $i("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), e.long[Ri.keyType] !== void 0 ? $i('%s[typeof k==="object"?util.longToHash(k):k]=value', Oi) : $i("%s[k]=value", Oi)) : Ri.repeated ? ($i("if(!(%s&&%s.length))", Oi, Oi)("%s=[]", Oi), e.packed[Ti] !== void 0 && $i("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", Oi, Ti)("}else"), e.basic[Ti] === void 0 ? $i(Ri.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", Oi, xi) : $i("%s.push(r.%s())", Oi, Ti)) : e.basic[Ti] === void 0 ? $i(Ri.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", Oi, xi) : $i("%s=r.%s()", Oi, Ti), $i("break")("}");
    }
    for ($i("default:")("r.skipType(t&7)")("break")("}")("}"), xi = 0; xi < Ei._fieldsArray.length; ++xi) {
      var Mi = Ei._fieldsArray[xi];
      Mi.required && $i("if(!m.hasOwnProperty(%j))", Mi.name)("throw util.ProtocolError(%j,{instance:m})", Si(Mi));
    }
    return $i("return m");
  }
  return decoder_1;
}
var verifier_1, hasRequiredVerifier;
function requireVerifier() {
  if (hasRequiredVerifier)
    return verifier_1;
  hasRequiredVerifier = 1, verifier_1 = Ei;
  var se = require_enum(), e = requireUtil();
  function Oe($i, xi) {
    return $i.name + ": " + xi + ($i.repeated && xi !== "array" ? "[]" : $i.map && xi !== "object" ? "{k:" + $i.keyType + "}" : "") + " expected";
  }
  function Si($i, xi, Ri, Ti) {
    if (xi.resolvedType)
      if (xi.resolvedType instanceof se) {
        $i("switch(%s){", Ti)("default:")("return%j", Oe(xi, "enum value"));
        for (var Oi = Object.keys(xi.resolvedType.values), Mi = 0; Mi < Oi.length; ++Mi)
          $i("case %i:", xi.resolvedType.values[Oi[Mi]]);
        $i("break")("}");
      } else
        $i("{")("var e=types[%i].verify(%s);", Ri, Ti)("if(e)")("return%j+e", xi.name + ".")("}");
    else
      switch (xi.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          $i("if(!util.isInteger(%s))", Ti)("return%j", Oe(xi, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          $i("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", Ti, Ti, Ti, Ti)("return%j", Oe(xi, "integer|Long"));
          break;
        case "float":
        case "double":
          $i('if(typeof %s!=="number")', Ti)("return%j", Oe(xi, "number"));
          break;
        case "bool":
          $i('if(typeof %s!=="boolean")', Ti)("return%j", Oe(xi, "boolean"));
          break;
        case "string":
          $i("if(!util.isString(%s))", Ti)("return%j", Oe(xi, "string"));
          break;
        case "bytes":
          $i('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', Ti, Ti, Ti)("return%j", Oe(xi, "buffer"));
          break;
      }
    return $i;
  }
  function wi($i, xi, Ri) {
    switch (xi.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        $i("if(!util.key32Re.test(%s))", Ri)("return%j", Oe(xi, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        $i("if(!util.key64Re.test(%s))", Ri)("return%j", Oe(xi, "integer|Long key"));
        break;
      case "bool":
        $i("if(!util.key2Re.test(%s))", Ri)("return%j", Oe(xi, "boolean key"));
        break;
    }
    return $i;
  }
  function Ei($i) {
    var xi = e.codegen(["m"], $i.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"), Ri = $i.oneofsArray, Ti = {};
    Ri.length && xi("var p={}");
    for (var Oi = 0; Oi < /* initializes */
    $i.fieldsArray.length; ++Oi) {
      var Mi = $i._fieldsArray[Oi].resolve(), Ii = "m" + e.safeProp(Mi.name);
      if (Mi.optional && xi("if(%s!=null&&m.hasOwnProperty(%j)){", Ii, Mi.name), Mi.map)
        xi("if(!util.isObject(%s))", Ii)("return%j", Oe(Mi, "object"))("var k=Object.keys(%s)", Ii)("for(var i=0;i<k.length;++i){"), wi(xi, Mi, "k[i]"), Si(xi, Mi, Oi, Ii + "[k[i]]")("}");
      else if (Mi.repeated)
        xi("if(!Array.isArray(%s))", Ii)("return%j", Oe(Mi, "array"))("for(var i=0;i<%s.length;++i){", Ii), Si(xi, Mi, Oi, Ii + "[i]")("}");
      else {
        if (Mi.partOf) {
          var Ci = e.safeProp(Mi.partOf.name);
          Ti[Mi.partOf.name] === 1 && xi("if(p%s===1)", Ci)("return%j", Mi.partOf.name + ": multiple values"), Ti[Mi.partOf.name] = 1, xi("p%s=1", Ci);
        }
        Si(xi, Mi, Oi, Ii);
      }
      Mi.optional && xi("}");
    }
    return xi("return null");
  }
  return verifier_1;
}
var converter = {}, hasRequiredConverter;
function requireConverter() {
  return hasRequiredConverter || (hasRequiredConverter = 1, function(se) {
    var e = se, Oe = require_enum(), Si = requireUtil();
    function wi($i, xi, Ri, Ti) {
      var Oi = !1;
      if (xi.resolvedType)
        if (xi.resolvedType instanceof Oe) {
          $i("switch(d%s){", Ti);
          for (var Mi = xi.resolvedType.values, Ii = Object.keys(Mi), Ci = 0; Ci < Ii.length; ++Ci)
            Mi[Ii[Ci]] === xi.typeDefault && !Oi && ($i("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', Ti, Ti, Ti), xi.repeated || $i("break"), Oi = !0), $i("case%j:", Ii[Ci])("case %i:", Mi[Ii[Ci]])("m%s=%j", Ti, Mi[Ii[Ci]])("break");
          $i("}");
        } else
          $i('if(typeof d%s!=="object")', Ti)("throw TypeError(%j)", xi.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", Ti, Ri, Ti);
      else {
        var Oo = !1;
        switch (xi.type) {
          case "double":
          case "float":
            $i("m%s=Number(d%s)", Ti, Ti);
            break;
          case "uint32":
          case "fixed32":
            $i("m%s=d%s>>>0", Ti, Ti);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            $i("m%s=d%s|0", Ti, Ti);
            break;
          case "uint64":
            Oo = !0;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            $i("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", Ti, Ti, Oo)('else if(typeof d%s==="string")', Ti)("m%s=parseInt(d%s,10)", Ti, Ti)('else if(typeof d%s==="number")', Ti)("m%s=d%s", Ti, Ti)('else if(typeof d%s==="object")', Ti)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", Ti, Ti, Ti, Oo ? "true" : "");
            break;
          case "bytes":
            $i('if(typeof d%s==="string")', Ti)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", Ti, Ti, Ti)("else if(d%s.length >= 0)", Ti)("m%s=d%s", Ti, Ti);
            break;
          case "string":
            $i("m%s=String(d%s)", Ti, Ti);
            break;
          case "bool":
            $i("m%s=Boolean(d%s)", Ti, Ti);
            break;
        }
      }
      return $i;
    }
    e.fromObject = function(xi) {
      var Ri = xi.fieldsArray, Ti = Si.codegen(["d"], xi.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!Ri.length)
        return Ti("return new this.ctor");
      Ti("var m=new this.ctor");
      for (var Oi = 0; Oi < Ri.length; ++Oi) {
        var Mi = Ri[Oi].resolve(), Ii = Si.safeProp(Mi.name);
        Mi.map ? (Ti("if(d%s){", Ii)('if(typeof d%s!=="object")', Ii)("throw TypeError(%j)", Mi.fullName + ": object expected")("m%s={}", Ii)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", Ii), wi(
          Ti,
          Mi,
          /* not sorted */
          Oi,
          Ii + "[ks[i]]"
        )("}")("}")) : Mi.repeated ? (Ti("if(d%s){", Ii)("if(!Array.isArray(d%s))", Ii)("throw TypeError(%j)", Mi.fullName + ": array expected")("m%s=[]", Ii)("for(var i=0;i<d%s.length;++i){", Ii), wi(
          Ti,
          Mi,
          /* not sorted */
          Oi,
          Ii + "[i]"
        )("}")("}")) : (Mi.resolvedType instanceof Oe || Ti("if(d%s!=null){", Ii), wi(
          Ti,
          Mi,
          /* not sorted */
          Oi,
          Ii
        ), Mi.resolvedType instanceof Oe || Ti("}"));
      }
      return Ti("return m");
    };
    function Ei($i, xi, Ri, Ti) {
      if (xi.resolvedType)
        xi.resolvedType instanceof Oe ? $i("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", Ti, Ri, Ti, Ti, Ri, Ti, Ti) : $i("d%s=types[%i].toObject(m%s,o)", Ti, Ri, Ti);
      else {
        var Oi = !1;
        switch (xi.type) {
          case "double":
          case "float":
            $i("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", Ti, Ti, Ti, Ti);
            break;
          case "uint64":
            Oi = !0;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            $i('if(typeof m%s==="number")', Ti)("d%s=o.longs===String?String(m%s):m%s", Ti, Ti, Ti)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", Ti, Ti, Ti, Ti, Oi ? "true" : "", Ti);
            break;
          case "bytes":
            $i("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", Ti, Ti, Ti, Ti, Ti);
            break;
          default:
            $i("d%s=m%s", Ti, Ti);
            break;
        }
      }
      return $i;
    }
    e.toObject = function(xi) {
      var Ri = xi.fieldsArray.slice().sort(Si.compareFieldsById);
      if (!Ri.length)
        return Si.codegen()("return {}");
      for (var Ti = Si.codegen(["m", "o"], xi.name + "$toObject")("if(!o)")("o={}")("var d={}"), Oi = [], Mi = [], Ii = [], Ci = 0; Ci < Ri.length; ++Ci)
        Ri[Ci].partOf || (Ri[Ci].resolve().repeated ? Oi : Ri[Ci].map ? Mi : Ii).push(Ri[Ci]);
      if (Oi.length) {
        for (Ti("if(o.arrays||o.defaults){"), Ci = 0; Ci < Oi.length; ++Ci)
          Ti("d%s=[]", Si.safeProp(Oi[Ci].name));
        Ti("}");
      }
      if (Mi.length) {
        for (Ti("if(o.objects||o.defaults){"), Ci = 0; Ci < Mi.length; ++Ci)
          Ti("d%s={}", Si.safeProp(Mi[Ci].name));
        Ti("}");
      }
      if (Ii.length) {
        for (Ti("if(o.defaults){"), Ci = 0; Ci < Ii.length; ++Ci) {
          var Oo = Ii[Ci], Ro = Si.safeProp(Oo.name);
          if (Oo.resolvedType instanceof Oe)
            Ti("d%s=o.enums===String?%j:%j", Ro, Oo.resolvedType.valuesById[Oo.typeDefault], Oo.typeDefault);
          else if (Oo.long)
            Ti("if(util.Long){")("var n=new util.Long(%i,%i,%j)", Oo.typeDefault.low, Oo.typeDefault.high, Oo.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", Ro)("}else")("d%s=o.longs===String?%j:%i", Ro, Oo.typeDefault.toString(), Oo.typeDefault.toNumber());
          else if (Oo.bytes) {
            var Bo = "[" + Array.prototype.slice.call(Oo.typeDefault).join(",") + "]";
            Ti("if(o.bytes===String)d%s=%j", Ro, String.fromCharCode.apply(String, Oo.typeDefault))("else{")("d%s=%s", Ro, Bo)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", Ro, Ro)("}");
          } else
            Ti("d%s=%j", Ro, Oo.typeDefault);
        }
        Ti("}");
      }
      var Fo = !1;
      for (Ci = 0; Ci < Ri.length; ++Ci) {
        var Oo = Ri[Ci], Io = xi._fieldsArray.indexOf(Oo), Ro = Si.safeProp(Oo.name);
        Oo.map ? (Fo || (Fo = !0, Ti("var ks2")), Ti("if(m%s&&(ks2=Object.keys(m%s)).length){", Ro, Ro)("d%s={}", Ro)("for(var j=0;j<ks2.length;++j){"), Ei(
          Ti,
          Oo,
          /* sorted */
          Io,
          Ro + "[ks2[j]]"
        )("}")) : Oo.repeated ? (Ti("if(m%s&&m%s.length){", Ro, Ro)("d%s=[]", Ro)("for(var j=0;j<m%s.length;++j){", Ro), Ei(
          Ti,
          Oo,
          /* sorted */
          Io,
          Ro + "[j]"
        )("}")) : (Ti("if(m%s!=null&&m.hasOwnProperty(%j)){", Ro, Oo.name), Ei(
          Ti,
          Oo,
          /* sorted */
          Io,
          Ro
        ), Oo.partOf && Ti("if(o.oneofs)")("d%s=%j", Si.safeProp(Oo.partOf.name), Oo.name)), Ti("}");
      }
      return Ti("return d");
    };
  }(converter)), converter;
}
var wrappers = {};
(function(se) {
  var e = se, Oe = message;
  e[".google.protobuf.Any"] = {
    fromObject: function(Si) {
      if (Si && Si["@type"]) {
        var wi = Si["@type"].substring(Si["@type"].lastIndexOf("/") + 1), Ei = this.lookup(wi);
        if (Ei) {
          var $i = Si["@type"].charAt(0) === "." ? Si["@type"].slice(1) : Si["@type"];
          return $i.indexOf("/") === -1 && ($i = "/" + $i), this.create({
            type_url: $i,
            value: Ei.encode(Ei.fromObject(Si)).finish()
          });
        }
      }
      return this.fromObject(Si);
    },
    toObject: function(Si, wi) {
      var Ei = "type.googleapis.com/", $i = "", xi = "";
      if (wi && wi.json && Si.type_url && Si.value) {
        xi = Si.type_url.substring(Si.type_url.lastIndexOf("/") + 1), $i = Si.type_url.substring(0, Si.type_url.lastIndexOf("/") + 1);
        var Ri = this.lookup(xi);
        Ri && (Si = Ri.decode(Si.value));
      }
      if (!(Si instanceof this.ctor) && Si instanceof Oe) {
        var Ti = Si.$type.toObject(Si, wi), Oi = Si.$type.fullName[0] === "." ? Si.$type.fullName.slice(1) : Si.$type.fullName;
        return $i === "" && ($i = Ei), xi = $i + Oi, Ti["@type"] = xi, Ti;
      }
      return this.toObject(Si, wi);
    }
  };
})(wrappers);
var type, hasRequiredType;
function requireType() {
  if (hasRequiredType)
    return type;
  hasRequiredType = 1, type = Ro;
  var se = requireNamespace();
  ((Ro.prototype = Object.create(se.prototype)).constructor = Ro).className = "Type";
  var e = require_enum(), Oe = requireOneof(), Si = requireField(), wi = requireMapfield(), Ei = requireService(), $i = message, xi = requireReader(), Ri = requireWriter(), Ti = requireUtil(), Oi = requireEncoder(), Mi = requireDecoder(), Ii = requireVerifier(), Ci = requireConverter(), Oo = wrappers;
  function Ro(Fo, Io) {
    se.call(this, Fo, Io), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;
  }
  Object.defineProperties(Ro.prototype, {
    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var Fo = Object.keys(this.fields), Io = 0; Io < Fo.length; ++Io) {
          var Uo = this.fields[Fo[Io]], Co = Uo.id;
          if (this._fieldsById[Co])
            throw Error("duplicate id " + Co + " in " + this);
          this._fieldsById[Co] = Uo;
        }
        return this._fieldsById;
      }
    },
    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = Ti.toArray(this.fields));
      }
    },
    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = Ti.toArray(this.oneofs));
      }
    },
    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Ro.generateConstructor(this)());
      },
      set: function(Fo) {
        var Io = Fo.prototype;
        Io instanceof $i || ((Fo.prototype = new $i()).constructor = Fo, Ti.merge(Fo.prototype, Io)), Fo.$type = Fo.prototype.$type = this, Ti.merge(Fo, $i, !0), this._ctor = Fo;
        for (var Uo = 0; Uo < /* initializes */
        this.fieldsArray.length; ++Uo)
          this._fieldsArray[Uo].resolve();
        var Co = {};
        for (Uo = 0; Uo < /* initializes */
        this.oneofsArray.length; ++Uo)
          Co[this._oneofsArray[Uo].resolve().name] = {
            get: Ti.oneOfGetter(this._oneofsArray[Uo].oneof),
            set: Ti.oneOfSetter(this._oneofsArray[Uo].oneof)
          };
        Uo && Object.defineProperties(Fo.prototype, Co);
      }
    }
  }), Ro.generateConstructor = function(Io) {
    for (var Uo = Ti.codegen(["p"], Io.name), Co = 0, ko; Co < Io.fieldsArray.length; ++Co)
      (ko = Io._fieldsArray[Co]).map ? Uo("this%s={}", Ti.safeProp(ko.name)) : ko.repeated && Uo("this%s=[]", Ti.safeProp(ko.name));
    return Uo("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function Bo(Fo) {
    return Fo._fieldsById = Fo._fieldsArray = Fo._oneofsArray = null, delete Fo.encode, delete Fo.decode, delete Fo.verify, Fo;
  }
  return Ro.fromJSON = function(Io, Uo) {
    var Co = new Ro(Io, Uo.options);
    Co.extensions = Uo.extensions, Co.reserved = Uo.reserved;
    for (var ko = Object.keys(Uo.fields), Po = 0; Po < ko.length; ++Po)
      Co.add(
        (typeof Uo.fields[ko[Po]].keyType < "u" ? wi.fromJSON : Si.fromJSON)(ko[Po], Uo.fields[ko[Po]])
      );
    if (Uo.oneofs)
      for (ko = Object.keys(Uo.oneofs), Po = 0; Po < ko.length; ++Po)
        Co.add(Oe.fromJSON(ko[Po], Uo.oneofs[ko[Po]]));
    if (Uo.nested)
      for (ko = Object.keys(Uo.nested), Po = 0; Po < ko.length; ++Po) {
        var Mo = Uo.nested[ko[Po]];
        Co.add(
          // most to least likely
          (Mo.id !== void 0 ? Si.fromJSON : Mo.fields !== void 0 ? Ro.fromJSON : Mo.values !== void 0 ? e.fromJSON : Mo.methods !== void 0 ? Ei.fromJSON : se.fromJSON)(ko[Po], Mo)
        );
      }
    return Uo.extensions && Uo.extensions.length && (Co.extensions = Uo.extensions), Uo.reserved && Uo.reserved.length && (Co.reserved = Uo.reserved), Uo.group && (Co.group = !0), Uo.comment && (Co.comment = Uo.comment), Co;
  }, Ro.prototype.toJSON = function(Io) {
    var Uo = se.prototype.toJSON.call(this, Io), Co = Io ? !!Io.keepComments : !1;
    return Ti.toObject([
      "options",
      Uo && Uo.options || void 0,
      "oneofs",
      se.arrayToJSON(this.oneofsArray, Io),
      "fields",
      se.arrayToJSON(this.fieldsArray.filter(function(ko) {
        return !ko.declaringField;
      }), Io) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : void 0,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "group",
      this.group || void 0,
      "nested",
      Uo && Uo.nested || void 0,
      "comment",
      Co ? this.comment : void 0
    ]);
  }, Ro.prototype.resolveAll = function() {
    for (var Io = this.fieldsArray, Uo = 0; Uo < Io.length; )
      Io[Uo++].resolve();
    var Co = this.oneofsArray;
    for (Uo = 0; Uo < Co.length; )
      Co[Uo++].resolve();
    return se.prototype.resolveAll.call(this);
  }, Ro.prototype.get = function(Io) {
    return this.fields[Io] || this.oneofs && this.oneofs[Io] || this.nested && this.nested[Io] || null;
  }, Ro.prototype.add = function(Io) {
    if (this.get(Io.name))
      throw Error("duplicate name '" + Io.name + "' in " + this);
    if (Io instanceof Si && Io.extend === void 0) {
      if (this._fieldsById ? (
        /* istanbul ignore next */
        this._fieldsById[Io.id]
      ) : this.fieldsById[Io.id])
        throw Error("duplicate id " + Io.id + " in " + this);
      if (this.isReservedId(Io.id))
        throw Error("id " + Io.id + " is reserved in " + this);
      if (this.isReservedName(Io.name))
        throw Error("name '" + Io.name + "' is reserved in " + this);
      return Io.parent && Io.parent.remove(Io), this.fields[Io.name] = Io, Io.message = this, Io.onAdd(this), Bo(this);
    }
    return Io instanceof Oe ? (this.oneofs || (this.oneofs = {}), this.oneofs[Io.name] = Io, Io.onAdd(this), Bo(this)) : se.prototype.add.call(this, Io);
  }, Ro.prototype.remove = function(Io) {
    if (Io instanceof Si && Io.extend === void 0) {
      if (!this.fields || this.fields[Io.name] !== Io)
        throw Error(Io + " is not a member of " + this);
      return delete this.fields[Io.name], Io.parent = null, Io.onRemove(this), Bo(this);
    }
    if (Io instanceof Oe) {
      if (!this.oneofs || this.oneofs[Io.name] !== Io)
        throw Error(Io + " is not a member of " + this);
      return delete this.oneofs[Io.name], Io.parent = null, Io.onRemove(this), Bo(this);
    }
    return se.prototype.remove.call(this, Io);
  }, Ro.prototype.isReservedId = function(Io) {
    return se.isReservedId(this.reserved, Io);
  }, Ro.prototype.isReservedName = function(Io) {
    return se.isReservedName(this.reserved, Io);
  }, Ro.prototype.create = function(Io) {
    return new this.ctor(Io);
  }, Ro.prototype.setup = function() {
    for (var Io = this.fullName, Uo = [], Co = 0; Co < /* initializes */
    this.fieldsArray.length; ++Co)
      Uo.push(this._fieldsArray[Co].resolve().resolvedType);
    this.encode = Oi(this)({
      Writer: Ri,
      types: Uo,
      util: Ti
    }), this.decode = Mi(this)({
      Reader: xi,
      types: Uo,
      util: Ti
    }), this.verify = Ii(this)({
      types: Uo,
      util: Ti
    }), this.fromObject = Ci.fromObject(this)({
      types: Uo,
      util: Ti
    }), this.toObject = Ci.toObject(this)({
      types: Uo,
      util: Ti
    });
    var ko = Oo[Io];
    if (ko) {
      var Po = Object.create(this);
      Po.fromObject = this.fromObject, this.fromObject = ko.fromObject.bind(Po), Po.toObject = this.toObject, this.toObject = ko.toObject.bind(Po);
    }
    return this;
  }, Ro.prototype.encode = function(Io, Uo) {
    return this.setup().encode(Io, Uo);
  }, Ro.prototype.encodeDelimited = function(Io, Uo) {
    return this.encode(Io, Uo && Uo.len ? Uo.fork() : Uo).ldelim();
  }, Ro.prototype.decode = function(Io, Uo) {
    return this.setup().decode(Io, Uo);
  }, Ro.prototype.decodeDelimited = function(Io) {
    return Io instanceof xi || (Io = xi.create(Io)), this.decode(Io, Io.uint32());
  }, Ro.prototype.verify = function(Io) {
    return this.setup().verify(Io);
  }, Ro.prototype.fromObject = function(Io) {
    return this.setup().fromObject(Io);
  }, Ro.prototype.toObject = function(Io, Uo) {
    return this.setup().toObject(Io, Uo);
  }, Ro.d = function(Io) {
    return function(Co) {
      Ti.decorateType(Co, Io);
    };
  }, type;
}
var root, hasRequiredRoot;
function requireRoot() {
  if (hasRequiredRoot)
    return root;
  hasRequiredRoot = 1, root = Ri;
  var se = requireNamespace();
  ((Ri.prototype = Object.create(se.prototype)).constructor = Ri).className = "Root";
  var e = requireField(), Oe = require_enum(), Si = requireOneof(), wi = requireUtil(), Ei, $i, xi;
  function Ri(Ii) {
    se.call(this, "", Ii), this.deferred = [], this.files = [];
  }
  Ri.fromJSON = function(Ci, Oo) {
    return Oo || (Oo = new Ri()), Ci.options && Oo.setOptions(Ci.options), Oo.addJSON(Ci.nested);
  }, Ri.prototype.resolvePath = wi.path.resolve, Ri.prototype.fetch = wi.fetch;
  function Ti() {
  }
  Ri.prototype.load = function Ii(Ci, Oo, Ro) {
    typeof Oo == "function" && (Ro = Oo, Oo = void 0);
    var Bo = this;
    if (!Ro)
      return wi.asPromise(Ii, Bo, Ci, Oo);
    var Fo = Ro === Ti;
    function Io(Jo, zo) {
      if (Ro) {
        var Do = Ro;
        if (Ro = null, Fo)
          throw Jo;
        Do(Jo, zo);
      }
    }
    function Uo(Jo) {
      var zo = Jo.lastIndexOf("google/protobuf/");
      if (zo > -1) {
        var Do = Jo.substring(zo);
        if (Do in xi)
          return Do;
      }
      return null;
    }
    function Co(Jo, zo) {
      try {
        if (wi.isString(zo) && zo.charAt(0) === "{" && (zo = JSON.parse(zo)), !wi.isString(zo))
          Bo.setOptions(zo.options).addJSON(zo.nested);
        else {
          $i.filename = Jo;
          var Do = $i(zo, Bo, Oo), wo, Li = 0;
          if (Do.imports)
            for (; Li < Do.imports.length; ++Li)
              (wo = Uo(Do.imports[Li]) || Bo.resolvePath(Jo, Do.imports[Li])) && ko(wo);
          if (Do.weakImports)
            for (Li = 0; Li < Do.weakImports.length; ++Li)
              (wo = Uo(Do.weakImports[Li]) || Bo.resolvePath(Jo, Do.weakImports[Li])) && ko(wo, !0);
        }
      } catch (Ai) {
        Io(Ai);
      }
      !Fo && !Po && Io(null, Bo);
    }
    function ko(Jo, zo) {
      if (Jo = Uo(Jo) || Jo, !(Bo.files.indexOf(Jo) > -1)) {
        if (Bo.files.push(Jo), Jo in xi) {
          Fo ? Co(Jo, xi[Jo]) : (++Po, setTimeout(function() {
            --Po, Co(Jo, xi[Jo]);
          }));
          return;
        }
        if (Fo) {
          var Do;
          try {
            Do = wi.fs.readFileSync(Jo).toString("utf8");
          } catch (wo) {
            zo || Io(wo);
            return;
          }
          Co(Jo, Do);
        } else
          ++Po, Bo.fetch(Jo, function(wo, Li) {
            if (--Po, !!Ro) {
              if (wo) {
                zo ? Po || Io(null, Bo) : Io(wo);
                return;
              }
              Co(Jo, Li);
            }
          });
      }
    }
    var Po = 0;
    wi.isString(Ci) && (Ci = [Ci]);
    for (var Mo = 0, No; Mo < Ci.length; ++Mo)
      (No = Bo.resolvePath("", Ci[Mo])) && ko(No);
    if (Fo)
      return Bo;
    Po || Io(null, Bo);
  }, Ri.prototype.loadSync = function(Ci, Oo) {
    if (!wi.isNode)
      throw Error("not supported");
    return this.load(Ci, Oo, Ti);
  }, Ri.prototype.resolveAll = function() {
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(Ci) {
        return "'extend " + Ci.extend + "' in " + Ci.parent.fullName;
      }).join(", "));
    return se.prototype.resolveAll.call(this);
  };
  var Oi = /^[A-Z]/;
  function Mi(Ii, Ci) {
    var Oo = Ci.parent.lookup(Ci.extend);
    if (Oo) {
      var Ro = new e(Ci.fullName, Ci.id, Ci.type, Ci.rule, void 0, Ci.options);
      return Oo.get(Ro.name) || (Ro.declaringField = Ci, Ci.extensionField = Ro, Oo.add(Ro)), !0;
    }
    return !1;
  }
  return Ri.prototype._handleAdd = function(Ci) {
    if (Ci instanceof e)
      /* an extension field (implies not part of a oneof) */
      Ci.extend !== void 0 && /* not already handled */
      !Ci.extensionField && (Mi(this, Ci) || this.deferred.push(Ci));
    else if (Ci instanceof Oe)
      Oi.test(Ci.name) && (Ci.parent[Ci.name] = Ci.values);
    else if (!(Ci instanceof Si)) {
      if (Ci instanceof Ei)
        for (var Oo = 0; Oo < this.deferred.length; )
          Mi(this, this.deferred[Oo]) ? this.deferred.splice(Oo, 1) : ++Oo;
      for (var Ro = 0; Ro < /* initializes */
      Ci.nestedArray.length; ++Ro)
        this._handleAdd(Ci._nestedArray[Ro]);
      Oi.test(Ci.name) && (Ci.parent[Ci.name] = Ci);
    }
  }, Ri.prototype._handleRemove = function(Ci) {
    if (Ci instanceof e) {
      if (
        /* an extension field */
        Ci.extend !== void 0
      )
        if (
          /* already handled */
          Ci.extensionField
        )
          Ci.extensionField.parent.remove(Ci.extensionField), Ci.extensionField = null;
        else {
          var Oo = this.deferred.indexOf(Ci);
          Oo > -1 && this.deferred.splice(Oo, 1);
        }
    } else if (Ci instanceof Oe)
      Oi.test(Ci.name) && delete Ci.parent[Ci.name];
    else if (Ci instanceof se) {
      for (var Ro = 0; Ro < /* initializes */
      Ci.nestedArray.length; ++Ro)
        this._handleRemove(Ci._nestedArray[Ro]);
      Oi.test(Ci.name) && delete Ci.parent[Ci.name];
    }
  }, Ri._configure = function(Ii, Ci, Oo) {
    Ei = Ii, $i = Ci, xi = Oo;
  }, root;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$3.exports;
  hasRequiredUtil = 1;
  var se = util$3.exports = requireMinimal$1(), e = requireRoots(), Oe, Si;
  se.codegen = codegen_1, se.fetch = fetch_1, se.path = path, se.fs = se.inquire("fs"), se.toArray = function(Ti) {
    if (Ti) {
      for (var Oi = Object.keys(Ti), Mi = new Array(Oi.length), Ii = 0; Ii < Oi.length; )
        Mi[Ii] = Ti[Oi[Ii++]];
      return Mi;
    }
    return [];
  }, se.toObject = function(Ti) {
    for (var Oi = {}, Mi = 0; Mi < Ti.length; ) {
      var Ii = Ti[Mi++], Ci = Ti[Mi++];
      Ci !== void 0 && (Oi[Ii] = Ci);
    }
    return Oi;
  };
  var wi = /\\/g, Ei = /"/g;
  se.isReserved = function(Ti) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(Ti);
  }, se.safeProp = function(Ti) {
    return !/^[$\w_]+$/.test(Ti) || se.isReserved(Ti) ? '["' + Ti.replace(wi, "\\\\").replace(Ei, '\\"') + '"]' : "." + Ti;
  }, se.ucFirst = function(Ti) {
    return Ti.charAt(0).toUpperCase() + Ti.substring(1);
  };
  var $i = /_([a-z])/g;
  se.camelCase = function(Ti) {
    return Ti.substring(0, 1) + Ti.substring(1).replace($i, function(Oi, Mi) {
      return Mi.toUpperCase();
    });
  }, se.compareFieldsById = function(Ti, Oi) {
    return Ti.id - Oi.id;
  }, se.decorateType = function(Ti, Oi) {
    if (Ti.$type)
      return Oi && Ti.$type.name !== Oi && (se.decorateRoot.remove(Ti.$type), Ti.$type.name = Oi, se.decorateRoot.add(Ti.$type)), Ti.$type;
    Oe || (Oe = requireType());
    var Mi = new Oe(Oi || Ti.name);
    return se.decorateRoot.add(Mi), Mi.ctor = Ti, Object.defineProperty(Ti, "$type", { value: Mi, enumerable: !1 }), Object.defineProperty(Ti.prototype, "$type", { value: Mi, enumerable: !1 }), Mi;
  };
  var xi = 0;
  return se.decorateEnum = function(Ti) {
    if (Ti.$type)
      return Ti.$type;
    Si || (Si = require_enum());
    var Oi = new Si("Enum" + xi++, Ti);
    return se.decorateRoot.add(Oi), Object.defineProperty(Ti, "$type", { value: Oi, enumerable: !1 }), Oi;
  }, se.setProperty = function(Ti, Oi, Mi) {
    function Ii(Ci, Oo, Ro) {
      var Bo = Oo.shift();
      if (Bo === "__proto__" || Bo === "prototype")
        return Ci;
      if (Oo.length > 0)
        Ci[Bo] = Ii(Ci[Bo] || {}, Oo, Ro);
      else {
        var Fo = Ci[Bo];
        Fo && (Ro = [].concat(Fo).concat(Ro)), Ci[Bo] = Ro;
      }
      return Ci;
    }
    if (typeof Ti != "object")
      throw TypeError("dst must be an object");
    if (!Oi)
      throw TypeError("path must be specified");
    return Oi = Oi.split("."), Ii(Ti, Oi, Mi);
  }, Object.defineProperty(se, "decorateRoot", {
    get: function() {
      return e.decorated || (e.decorated = new (requireRoot())());
    }
  }), util$3.exports;
}
var object, hasRequiredObject;
function requireObject() {
  if (hasRequiredObject)
    return object;
  hasRequiredObject = 1, object = Oe, Oe.className = "ReflectionObject";
  var se = requireUtil(), e;
  function Oe(Si, wi) {
    if (!se.isString(Si))
      throw TypeError("name must be a string");
    if (wi && !se.isObject(wi))
      throw TypeError("options must be an object");
    this.options = wi, this.parsedOptions = null, this.name = Si, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;
  }
  return Object.defineProperties(Oe.prototype, {
    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
      get: function() {
        for (var Si = this; Si.parent !== null; )
          Si = Si.parent;
        return Si;
      }
    },
    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
      get: function() {
        for (var Si = [this.name], wi = this.parent; wi; )
          Si.unshift(wi.name), wi = wi.parent;
        return Si.join(".");
      }
    }
  }), Oe.prototype.toJSON = /* istanbul ignore next */
  function() {
    throw Error();
  }, Oe.prototype.onAdd = function(wi) {
    this.parent && this.parent !== wi && this.parent.remove(this), this.parent = wi, this.resolved = !1;
    var Ei = wi.root;
    Ei instanceof e && Ei._handleAdd(this);
  }, Oe.prototype.onRemove = function(wi) {
    var Ei = wi.root;
    Ei instanceof e && Ei._handleRemove(this), this.parent = null, this.resolved = !1;
  }, Oe.prototype.resolve = function() {
    return this.resolved ? this : (this.root instanceof e && (this.resolved = !0), this);
  }, Oe.prototype.getOption = function(wi) {
    if (this.options)
      return this.options[wi];
  }, Oe.prototype.setOption = function(wi, Ei, $i) {
    return (!$i || !this.options || this.options[wi] === void 0) && ((this.options || (this.options = {}))[wi] = Ei), this;
  }, Oe.prototype.setParsedOption = function(wi, Ei, $i) {
    this.parsedOptions || (this.parsedOptions = []);
    var xi = this.parsedOptions;
    if ($i) {
      var Ri = xi.find(function(Mi) {
        return Object.prototype.hasOwnProperty.call(Mi, wi);
      });
      if (Ri) {
        var Ti = Ri[wi];
        se.setProperty(Ti, $i, Ei);
      } else
        Ri = {}, Ri[wi] = se.setProperty({}, $i, Ei), xi.push(Ri);
    } else {
      var Oi = {};
      Oi[wi] = Ei, xi.push(Oi);
    }
    return this;
  }, Oe.prototype.setOptions = function(wi, Ei) {
    if (wi)
      for (var $i = Object.keys(wi), xi = 0; xi < $i.length; ++xi)
        this.setOption($i[xi], wi[$i[xi]], Ei);
    return this;
  }, Oe.prototype.toString = function() {
    var wi = this.constructor.className, Ei = this.fullName;
    return Ei.length ? wi + " " + Ei : wi;
  }, Oe._configure = function(Si) {
    e = Si;
  }, object;
}
var _enum, hasRequired_enum;
function require_enum() {
  if (hasRequired_enum)
    return _enum;
  hasRequired_enum = 1, _enum = Si;
  var se = requireObject();
  ((Si.prototype = Object.create(se.prototype)).constructor = Si).className = "Enum";
  var e = requireNamespace(), Oe = requireUtil();
  function Si(wi, Ei, $i, xi, Ri, Ti) {
    if (se.call(this, wi, $i), Ei && typeof Ei != "object")
      throw TypeError("values must be an object");
    if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = xi, this.comments = Ri || {}, this.valuesOptions = Ti, this.reserved = void 0, Ei)
      for (var Oi = Object.keys(Ei), Mi = 0; Mi < Oi.length; ++Mi)
        typeof Ei[Oi[Mi]] == "number" && (this.valuesById[this.values[Oi[Mi]] = Ei[Oi[Mi]]] = Oi[Mi]);
  }
  return Si.fromJSON = function(Ei, $i) {
    var xi = new Si(Ei, $i.values, $i.options, $i.comment, $i.comments);
    return xi.reserved = $i.reserved, xi;
  }, Si.prototype.toJSON = function(Ei) {
    var $i = Ei ? !!Ei.keepComments : !1;
    return Oe.toObject([
      "options",
      this.options,
      "valuesOptions",
      this.valuesOptions,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "comment",
      $i ? this.comment : void 0,
      "comments",
      $i ? this.comments : void 0
    ]);
  }, Si.prototype.add = function(Ei, $i, xi, Ri) {
    if (!Oe.isString(Ei))
      throw TypeError("name must be a string");
    if (!Oe.isInteger($i))
      throw TypeError("id must be an integer");
    if (this.values[Ei] !== void 0)
      throw Error("duplicate name '" + Ei + "' in " + this);
    if (this.isReservedId($i))
      throw Error("id " + $i + " is reserved in " + this);
    if (this.isReservedName(Ei))
      throw Error("name '" + Ei + "' is reserved in " + this);
    if (this.valuesById[$i] !== void 0) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + $i + " in " + this);
      this.values[Ei] = $i;
    } else
      this.valuesById[this.values[Ei] = $i] = Ei;
    return Ri && (this.valuesOptions === void 0 && (this.valuesOptions = {}), this.valuesOptions[Ei] = Ri || null), this.comments[Ei] = xi || null, this;
  }, Si.prototype.remove = function(Ei) {
    if (!Oe.isString(Ei))
      throw TypeError("name must be a string");
    var $i = this.values[Ei];
    if ($i == null)
      throw Error("name '" + Ei + "' does not exist in " + this);
    return delete this.valuesById[$i], delete this.values[Ei], delete this.comments[Ei], this.valuesOptions && delete this.valuesOptions[Ei], this;
  }, Si.prototype.isReservedId = function(Ei) {
    return e.isReservedId(this.reserved, Ei);
  }, Si.prototype.isReservedName = function(Ei) {
    return e.isReservedName(this.reserved, Ei);
  }, _enum;
}
var encoder_1, hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder)
    return encoder_1;
  hasRequiredEncoder = 1, encoder_1 = wi;
  var se = require_enum(), e = requireTypes(), Oe = requireUtil();
  function Si(Ei, $i, xi, Ri) {
    return $i.resolvedType.group ? Ei("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", xi, Ri, ($i.id << 3 | 3) >>> 0, ($i.id << 3 | 4) >>> 0) : Ei("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", xi, Ri, ($i.id << 3 | 2) >>> 0);
  }
  function wi(Ei) {
    for (var $i = Oe.codegen(["m", "w"], Ei.name + "$encode")("if(!w)")("w=Writer.create()"), xi, Ri, Ti = (
      /* initializes */
      Ei.fieldsArray.slice().sort(Oe.compareFieldsById)
    ), xi = 0; xi < Ti.length; ++xi) {
      var Oi = Ti[xi].resolve(), Mi = Ei._fieldsArray.indexOf(Oi), Ii = Oi.resolvedType instanceof se ? "int32" : Oi.type, Ci = e.basic[Ii];
      Ri = "m" + Oe.safeProp(Oi.name), Oi.map ? ($i("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", Ri, Oi.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", Ri)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (Oi.id << 3 | 2) >>> 0, 8 | e.mapKey[Oi.keyType], Oi.keyType), Ci === void 0 ? $i("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", Mi, Ri) : $i(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | Ci, Ii, Ri), $i("}")("}")) : Oi.repeated ? ($i("if(%s!=null&&%s.length){", Ri, Ri), Oi.packed && e.packed[Ii] !== void 0 ? $i("w.uint32(%i).fork()", (Oi.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", Ri)("w.%s(%s[i])", Ii, Ri)("w.ldelim()") : ($i("for(var i=0;i<%s.length;++i)", Ri), Ci === void 0 ? Si($i, Oi, Mi, Ri + "[i]") : $i("w.uint32(%i).%s(%s[i])", (Oi.id << 3 | Ci) >>> 0, Ii, Ri)), $i("}")) : (Oi.optional && $i("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", Ri, Oi.name), Ci === void 0 ? Si($i, Oi, Mi, Ri) : $i("w.uint32(%i).%s(%s)", (Oi.id << 3 | Ci) >>> 0, Ii, Ri));
    }
    return $i("return w");
  }
  return encoder_1;
}
var protobuf$1 = indexLight.exports = requireIndexMinimal();
protobuf$1.build = "light";
function load(se, e, Oe) {
  return typeof e == "function" ? (Oe = e, e = new protobuf$1.Root()) : e || (e = new protobuf$1.Root()), e.load(se, Oe);
}
protobuf$1.load = load;
function loadSync(se, e) {
  return e || (e = new protobuf$1.Root()), e.loadSync(se);
}
protobuf$1.loadSync = loadSync;
protobuf$1.encoder = requireEncoder();
protobuf$1.decoder = requireDecoder();
protobuf$1.verifier = requireVerifier();
protobuf$1.converter = requireConverter();
protobuf$1.ReflectionObject = requireObject();
protobuf$1.Namespace = requireNamespace();
protobuf$1.Root = requireRoot();
protobuf$1.Enum = require_enum();
protobuf$1.Type = requireType();
protobuf$1.Field = requireField();
protobuf$1.OneOf = requireOneof();
protobuf$1.MapField = requireMapfield();
protobuf$1.Service = requireService();
protobuf$1.Method = requireMethod();
protobuf$1.Message = message;
protobuf$1.wrappers = wrappers;
protobuf$1.types = requireTypes();
protobuf$1.util = requireUtil();
protobuf$1.ReflectionObject._configure(protobuf$1.Root);
protobuf$1.Namespace._configure(protobuf$1.Type, protobuf$1.Service, protobuf$1.Enum);
protobuf$1.Root._configure(protobuf$1.Type);
protobuf$1.Field._configure(protobuf$1.Type);
var indexLightExports = indexLight.exports, tokenize_1 = tokenize$1, delimRe = /[\s{}=;:[\],'"()<>]/g, stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g, stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g, setCommentRe = /^ *[*/]+ */, setCommentAltRe = /^\s*\*?\/*/, setCommentSplitRe = /\n/g, whitespaceRe = /\s/, unescapeRe = /\\(.?)/g, unescapeMap = {
  0: "\0",
  r: "\r",
  n: `
`,
  t: "	"
};
function unescape(se) {
  return se.replace(unescapeRe, function(e, Oe) {
    switch (Oe) {
      case "\\":
      case "":
        return Oe;
      default:
        return unescapeMap[Oe] || "";
    }
  });
}
tokenize$1.unescape = unescape;
function tokenize$1(se, e) {
  se = se.toString();
  var Oe = 0, Si = se.length, wi = 1, Ei = 0, $i = {}, xi = [], Ri = null;
  function Ti(Co) {
    return Error("illegal " + Co + " (line " + wi + ")");
  }
  function Oi() {
    var Co = Ri === "'" ? stringSingleRe : stringDoubleRe;
    Co.lastIndex = Oe - 1;
    var ko = Co.exec(se);
    if (!ko)
      throw Ti("string");
    return Oe = Co.lastIndex, Bo(Ri), Ri = null, unescape(ko[1]);
  }
  function Mi(Co) {
    return se.charAt(Co);
  }
  function Ii(Co, ko, Po) {
    var Mo = {
      type: se.charAt(Co++),
      lineEmpty: !1,
      leading: Po
    }, No;
    e ? No = 2 : No = 3;
    var Jo = Co - No, zo;
    do
      if (--Jo < 0 || (zo = se.charAt(Jo)) === `
`) {
        Mo.lineEmpty = !0;
        break;
      }
    while (zo === " " || zo === "	");
    for (var Do = se.substring(Co, ko).split(setCommentSplitRe), wo = 0; wo < Do.length; ++wo)
      Do[wo] = Do[wo].replace(e ? setCommentAltRe : setCommentRe, "").trim();
    Mo.text = Do.join(`
`).trim(), $i[wi] = Mo, Ei = wi;
  }
  function Ci(Co) {
    var ko = Oo(Co), Po = se.substring(Co, ko), Mo = /^\s*\/\//.test(Po);
    return Mo;
  }
  function Oo(Co) {
    for (var ko = Co; ko < Si && Mi(ko) !== `
`; )
      ko++;
    return ko;
  }
  function Ro() {
    if (xi.length > 0)
      return xi.shift();
    if (Ri)
      return Oi();
    var Co, ko, Po, Mo, No, Jo = Oe === 0;
    do {
      if (Oe === Si)
        return null;
      for (Co = !1; whitespaceRe.test(Po = Mi(Oe)); )
        if (Po === `
` && (Jo = !0, ++wi), ++Oe === Si)
          return null;
      if (Mi(Oe) === "/") {
        if (++Oe === Si)
          throw Ti("comment");
        if (Mi(Oe) === "/")
          if (e) {
            if (Mo = Oe, No = !1, Ci(Oe - 1)) {
              No = !0;
              do
                if (Oe = Oo(Oe), Oe === Si || (Oe++, !Jo))
                  break;
              while (Ci(Oe));
            } else
              Oe = Math.min(Si, Oo(Oe) + 1);
            No && (Ii(Mo, Oe, Jo), Jo = !0), wi++, Co = !0;
          } else {
            for (No = Mi(Mo = Oe + 1) === "/"; Mi(++Oe) !== `
`; )
              if (Oe === Si)
                return null;
            ++Oe, No && (Ii(Mo, Oe - 1, Jo), Jo = !0), ++wi, Co = !0;
          }
        else if ((Po = Mi(Oe)) === "*") {
          Mo = Oe + 1, No = e || Mi(Mo) === "*";
          do {
            if (Po === `
` && ++wi, ++Oe === Si)
              throw Ti("comment");
            ko = Po, Po = Mi(Oe);
          } while (ko !== "*" || Po !== "/");
          ++Oe, No && (Ii(Mo, Oe - 2, Jo), Jo = !0), Co = !0;
        } else
          return "/";
      }
    } while (Co);
    var zo = Oe;
    delimRe.lastIndex = 0;
    var Do = delimRe.test(Mi(zo++));
    if (!Do)
      for (; zo < Si && !delimRe.test(Mi(zo)); )
        ++zo;
    var wo = se.substring(Oe, Oe = zo);
    return (wo === '"' || wo === "'") && (Ri = wo), wo;
  }
  function Bo(Co) {
    xi.push(Co);
  }
  function Fo() {
    if (!xi.length) {
      var Co = Ro();
      if (Co === null)
        return null;
      Bo(Co);
    }
    return xi[0];
  }
  function Io(Co, ko) {
    var Po = Fo(), Mo = Po === Co;
    if (Mo)
      return Ro(), !0;
    if (!ko)
      throw Ti("token '" + Po + "', '" + Co + "' expected");
    return !1;
  }
  function Uo(Co) {
    var ko = null, Po;
    return Co === void 0 ? (Po = $i[wi - 1], delete $i[wi - 1], Po && (e || Po.type === "*" || Po.lineEmpty) && (ko = Po.leading ? Po.text : null)) : (Ei < Co && Fo(), Po = $i[Co], delete $i[Co], Po && !Po.lineEmpty && (e || Po.type === "/") && (ko = Po.leading ? null : Po.text)), ko;
  }
  return Object.defineProperty({
    next: Ro,
    peek: Fo,
    push: Bo,
    skip: Io,
    cmnt: Uo
  }, "line", {
    get: function() {
      return wi;
    }
  });
}
var parse_1 = parse;
parse.filename = null;
parse.defaults = { keepCase: !1 };
var tokenize = tokenize_1, Root = requireRoot(), Type = requireType(), Field = requireField(), MapField = requireMapfield(), OneOf = requireOneof(), Enum = require_enum(), Service = requireService(), Method = requireMethod(), types = requireTypes(), util$1 = requireUtil(), base10Re = /^[1-9][0-9]*$/, base10NegRe = /^-?[1-9][0-9]*$/, base16Re = /^0[x][0-9a-fA-F]+$/, base16NegRe = /^-?0[x][0-9a-fA-F]+$/, base8Re = /^0[0-7]+$/, base8NegRe = /^-?0[0-7]+$/, numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/, typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/, fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
function parse(se, e, Oe) {
  e instanceof Root || (Oe = e, e = new Root()), Oe || (Oe = parse.defaults);
  var Si = Oe.preferTrailingComment || !1, wi = tokenize(se, Oe.alternateCommentMode || !1), Ei = wi.next, $i = wi.push, xi = wi.peek, Ri = wi.skip, Ti = wi.cmnt, Oi = !0, Mi, Ii, Ci, Oo, Ro = !1, Bo = e, Fo = Oe.keepCase ? function(jo) {
    return jo;
  } : util$1.camelCase;
  function Io(jo, Ao, Lo) {
    var Zo = parse.filename;
    return Lo || (parse.filename = null), Error("illegal " + (Ao || "token") + " '" + jo + "' (" + (Zo ? Zo + ", " : "") + "line " + wi.line + ")");
  }
  function Uo() {
    var jo = [], Ao;
    do {
      if ((Ao = Ei()) !== '"' && Ao !== "'")
        throw Io(Ao);
      jo.push(Ei()), Ri(Ao), Ao = xi();
    } while (Ao === '"' || Ao === "'");
    return jo.join("");
  }
  function Co(jo) {
    var Ao = Ei();
    switch (Ao) {
      case "'":
      case '"':
        return $i(Ao), Uo();
      case "true":
      case "TRUE":
        return !0;
      case "false":
      case "FALSE":
        return !1;
    }
    try {
      return Po(
        Ao,
        /* insideTryCatch */
        !0
      );
    } catch {
      if (jo && typeRefRe.test(Ao))
        return Ao;
      throw Io(Ao, "value");
    }
  }
  function ko(jo, Ao) {
    var Lo, Zo;
    do
      Ao && ((Lo = xi()) === '"' || Lo === "'") ? jo.push(Uo()) : jo.push([Zo = Mo(Ei()), Ri("to", !0) ? Mo(Ei()) : Zo]);
    while (Ri(",", !0));
    Ri(";");
  }
  function Po(jo, Ao) {
    var Lo = 1;
    switch (jo.charAt(0) === "-" && (Lo = -1, jo = jo.substring(1)), jo) {
      case "inf":
      case "INF":
      case "Inf":
        return Lo * (1 / 0);
      case "nan":
      case "NAN":
      case "Nan":
      case "NaN":
        return NaN;
      case "0":
        return 0;
    }
    if (base10Re.test(jo))
      return Lo * parseInt(jo, 10);
    if (base16Re.test(jo))
      return Lo * parseInt(jo, 16);
    if (base8Re.test(jo))
      return Lo * parseInt(jo, 8);
    if (numberRe.test(jo))
      return Lo * parseFloat(jo);
    throw Io(jo, "number", Ao);
  }
  function Mo(jo, Ao) {
    switch (jo) {
      case "max":
      case "MAX":
      case "Max":
        return 536870911;
      case "0":
        return 0;
    }
    if (!Ao && jo.charAt(0) === "-")
      throw Io(jo, "id");
    if (base10NegRe.test(jo))
      return parseInt(jo, 10);
    if (base16NegRe.test(jo))
      return parseInt(jo, 16);
    if (base8NegRe.test(jo))
      return parseInt(jo, 8);
    throw Io(jo, "id");
  }
  function No() {
    if (Mi !== void 0)
      throw Io("package");
    if (Mi = Ei(), !typeRefRe.test(Mi))
      throw Io(Mi, "name");
    Bo = Bo.define(Mi), Ri(";");
  }
  function Jo() {
    var jo = xi(), Ao;
    switch (jo) {
      case "weak":
        Ao = Ci || (Ci = []), Ei();
        break;
      case "public":
        Ei();
      default:
        Ao = Ii || (Ii = []);
        break;
    }
    jo = Uo(), Ri(";"), Ao.push(jo);
  }
  function zo() {
    if (Ri("="), Oo = Uo(), Ro = Oo === "proto3", !Ro && Oo !== "proto2")
      throw Io(Oo, "syntax");
    Ri(";");
  }
  function Do(jo, Ao) {
    switch (Ao) {
      case "option":
        return zi(jo, Ao), Ri(";"), !0;
      case "message":
        return Li(jo, Ao), !0;
      case "enum":
        return $o(jo, Ao), !0;
      case "service":
        return To(jo, Ao), !0;
      case "extend":
        return Vo(jo, Ao), !0;
    }
    return !1;
  }
  function wo(jo, Ao, Lo) {
    var Zo = wi.line;
    if (jo && (typeof jo.comment != "string" && (jo.comment = Ti()), jo.filename = parse.filename), Ri("{", !0)) {
      for (var An; (An = Ei()) !== "}"; )
        Ao(An);
      Ri(";", !0);
    } else
      Lo && Lo(), Ri(";"), jo && (typeof jo.comment != "string" || Si) && (jo.comment = Ti(Zo) || jo.comment);
  }
  function Li(jo, Ao) {
    if (!nameRe.test(Ao = Ei()))
      throw Io(Ao, "type name");
    var Lo = new Type(Ao);
    wo(Lo, function(An) {
      if (!Do(Lo, An))
        switch (An) {
          case "map":
            Ui(Lo);
            break;
          case "required":
          case "repeated":
            Ai(Lo, An);
            break;
          case "optional":
            Ro ? Ai(Lo, "proto3_optional") : Ai(Lo, "optional");
            break;
          case "oneof":
            So(Lo, An);
            break;
          case "extensions":
            ko(Lo.extensions || (Lo.extensions = []));
            break;
          case "reserved":
            ko(Lo.reserved || (Lo.reserved = []), !0);
            break;
          default:
            if (!Ro || !typeRefRe.test(An))
              throw Io(An);
            $i(An), Ai(Lo, "optional");
            break;
        }
    }), jo.add(Lo);
  }
  function Ai(jo, Ao, Lo) {
    var Zo = Ei();
    if (Zo === "group") {
      Ni(jo, Ao);
      return;
    }
    for (; Zo.endsWith(".") || xi().startsWith("."); )
      Zo += Ei();
    if (!typeRefRe.test(Zo))
      throw Io(Zo, "type");
    var An = Ei();
    if (!nameRe.test(An))
      throw Io(An, "name");
    An = Fo(An), Ri("=");
    var ra = new Field(An, Mo(Ei()), Zo, Ao, Lo);
    if (wo(ra, function(ba) {
      if (ba === "option")
        zi(ra, ba), Ri(";");
      else
        throw Io(ba);
    }, function() {
      Qo(ra);
    }), Ao === "proto3_optional") {
      var sa = new OneOf("_" + An);
      ra.setOption("proto3_optional", !0), sa.add(ra), jo.add(sa);
    } else
      jo.add(ra);
    !Ro && ra.repeated && (types.packed[Zo] !== void 0 || types.basic[Zo] === void 0) && ra.setOption(
      "packed",
      !1,
      /* ifNotSet */
      !0
    );
  }
  function Ni(jo, Ao) {
    var Lo = Ei();
    if (!nameRe.test(Lo))
      throw Io(Lo, "name");
    var Zo = util$1.lcFirst(Lo);
    Lo === Zo && (Lo = util$1.ucFirst(Lo)), Ri("=");
    var An = Mo(Ei()), ra = new Type(Lo);
    ra.group = !0;
    var sa = new Field(Zo, An, Lo, Ao);
    sa.filename = parse.filename, wo(ra, function(ba) {
      switch (ba) {
        case "option":
          zi(ra, ba), Ri(";");
          break;
        case "required":
        case "repeated":
          Ai(ra, ba);
          break;
        case "optional":
          Ro ? Ai(ra, "proto3_optional") : Ai(ra, "optional");
          break;
        case "message":
          Li(ra, ba);
          break;
        case "enum":
          $o(ra, ba);
          break;
        default:
          throw Io(ba);
      }
    }), jo.add(ra).add(sa);
  }
  function Ui(jo) {
    Ri("<");
    var Ao = Ei();
    if (types.mapKey[Ao] === void 0)
      throw Io(Ao, "type");
    Ri(",");
    var Lo = Ei();
    if (!typeRefRe.test(Lo))
      throw Io(Lo, "type");
    Ri(">");
    var Zo = Ei();
    if (!nameRe.test(Zo))
      throw Io(Zo, "name");
    Ri("=");
    var An = new MapField(Fo(Zo), Mo(Ei()), Ao, Lo);
    wo(An, function(sa) {
      if (sa === "option")
        zi(An, sa), Ri(";");
      else
        throw Io(sa);
    }, function() {
      Qo(An);
    }), jo.add(An);
  }
  function So(jo, Ao) {
    if (!nameRe.test(Ao = Ei()))
      throw Io(Ao, "name");
    var Lo = new OneOf(Fo(Ao));
    wo(Lo, function(An) {
      An === "option" ? (zi(Lo, An), Ri(";")) : ($i(An), Ai(Lo, "optional"));
    }), jo.add(Lo);
  }
  function $o(jo, Ao) {
    if (!nameRe.test(Ao = Ei()))
      throw Io(Ao, "name");
    var Lo = new Enum(Ao);
    wo(Lo, function(An) {
      switch (An) {
        case "option":
          zi(Lo, An), Ri(";");
          break;
        case "reserved":
          ko(Lo.reserved || (Lo.reserved = []), !0);
          break;
        default:
          Eo(Lo, An);
      }
    }), jo.add(Lo);
  }
  function Eo(jo, Ao) {
    if (!nameRe.test(Ao))
      throw Io(Ao, "name");
    Ri("=");
    var Lo = Mo(Ei(), !0), Zo = {
      options: void 0
    };
    Zo.setOption = function(An, ra) {
      this.options === void 0 && (this.options = {}), this.options[An] = ra;
    }, wo(Zo, function(ra) {
      if (ra === "option")
        zi(Zo, ra), Ri(";");
      else
        throw Io(ra);
    }, function() {
      Qo(Zo);
    }), jo.add(Ao, Lo, Zo.comment, Zo.options);
  }
  function zi(jo, Ao) {
    var Lo = Ri("(", !0);
    if (!typeRefRe.test(Ao = Ei()))
      throw Io(Ao, "name");
    var Zo = Ao, An = Zo, ra;
    Lo && (Ri(")"), Zo = "(" + Zo + ")", An = Zo, Ao = xi(), fqTypeRefRe.test(Ao) && (ra = Ao.slice(1), Zo += Ao, Ei())), Ri("=");
    var sa = _o(jo, Zo);
    xo(jo, An, sa, ra);
  }
  function _o(jo, Ao) {
    if (Ri("{", !0)) {
      for (var Lo = {}; !Ri("}", !0); ) {
        if (!nameRe.test(Wo = Ei()))
          throw Io(Wo, "name");
        if (Wo === null)
          throw Io(Wo, "end of input");
        var Zo, An = Wo;
        if (Ri(":", !0), xi() === "{")
          Zo = _o(jo, Ao + "." + Wo);
        else if (xi() === "[") {
          Zo = [];
          var ra;
          if (Ri("[", !0)) {
            do
              ra = Co(!0), Zo.push(ra);
            while (Ri(",", !0));
            Ri("]"), typeof ra < "u" && Fi(jo, Ao + "." + Wo, ra);
          }
        } else
          Zo = Co(!0), Fi(jo, Ao + "." + Wo, Zo);
        var sa = Lo[An];
        sa && (Zo = [].concat(sa).concat(Zo)), Lo[An] = Zo, Ri(",", !0), Ri(";", !0);
      }
      return Lo;
    }
    var Ma = Co(!0);
    return Fi(jo, Ao, Ma), Ma;
  }
  function Fi(jo, Ao, Lo) {
    jo.setOption && jo.setOption(Ao, Lo);
  }
  function xo(jo, Ao, Lo, Zo) {
    jo.setParsedOption && jo.setParsedOption(Ao, Lo, Zo);
  }
  function Qo(jo) {
    if (Ri("[", !0)) {
      do
        zi(jo, "option");
      while (Ri(",", !0));
      Ri("]");
    }
    return jo;
  }
  function To(jo, Ao) {
    if (!nameRe.test(Ao = Ei()))
      throw Io(Ao, "service name");
    var Lo = new Service(Ao);
    wo(Lo, function(An) {
      if (!Do(Lo, An))
        if (An === "rpc")
          Ko(Lo, An);
        else
          throw Io(An);
    }), jo.add(Lo);
  }
  function Ko(jo, Ao) {
    var Lo = Ti(), Zo = Ao;
    if (!nameRe.test(Ao = Ei()))
      throw Io(Ao, "name");
    var An = Ao, ra, sa, Ma, ba;
    if (Ri("("), Ri("stream", !0) && (sa = !0), !typeRefRe.test(Ao = Ei()) || (ra = Ao, Ri(")"), Ri("returns"), Ri("("), Ri("stream", !0) && (ba = !0), !typeRefRe.test(Ao = Ei())))
      throw Io(Ao);
    Ma = Ao, Ri(")");
    var ma = new Method(An, Zo, ra, Ma, sa, ba);
    ma.comment = Lo, wo(ma, function(wa) {
      if (wa === "option")
        zi(ma, wa), Ri(";");
      else
        throw Io(wa);
    }), jo.add(ma);
  }
  function Vo(jo, Ao) {
    if (!typeRefRe.test(Ao = Ei()))
      throw Io(Ao, "reference");
    var Lo = Ao;
    wo(null, function(An) {
      switch (An) {
        case "required":
        case "repeated":
          Ai(jo, An, Lo);
          break;
        case "optional":
          Ro ? Ai(jo, "proto3_optional", Lo) : Ai(jo, "optional", Lo);
          break;
        default:
          if (!Ro || !typeRefRe.test(An))
            throw Io(An);
          $i(An), Ai(jo, "optional", Lo);
          break;
      }
    });
  }
  for (var Wo; (Wo = Ei()) !== null; )
    switch (Wo) {
      case "package":
        if (!Oi)
          throw Io(Wo);
        No();
        break;
      case "import":
        if (!Oi)
          throw Io(Wo);
        Jo();
        break;
      case "syntax":
        if (!Oi)
          throw Io(Wo);
        zo();
        break;
      case "option":
        zi(Bo, Wo), Ri(";");
        break;
      default:
        if (Do(Bo, Wo)) {
          Oi = !1;
          continue;
        }
        throw Io(Wo);
    }
  return parse.filename = null, {
    package: Mi,
    imports: Ii,
    weakImports: Ci,
    syntax: Oo,
    root: e
  };
}
var common_1 = common, commonRe = /\/|\./;
function common(se, e) {
  commonRe.test(se) || (se = "google/protobuf/" + se + ".proto", e = { nested: { google: { nested: { protobuf: { nested: e } } } } }), common[se] = e;
}
common("any", {
  /**
   * Properties of a google.protobuf.Any message.
   * @interface IAny
   * @type {Object}
   * @property {string} [typeUrl]
   * @property {Uint8Array} [bytes]
   * @memberof common
   */
  Any: {
    fields: {
      type_url: {
        type: "string",
        id: 1
      },
      value: {
        type: "bytes",
        id: 2
      }
    }
  }
});
var timeType;
common("duration", {
  /**
   * Properties of a google.protobuf.Duration message.
   * @interface IDuration
   * @type {Object}
   * @property {number|Long} [seconds]
   * @property {number} [nanos]
   * @memberof common
   */
  Duration: timeType = {
    fields: {
      seconds: {
        type: "int64",
        id: 1
      },
      nanos: {
        type: "int32",
        id: 2
      }
    }
  }
});
common("timestamp", {
  /**
   * Properties of a google.protobuf.Timestamp message.
   * @interface ITimestamp
   * @type {Object}
   * @property {number|Long} [seconds]
   * @property {number} [nanos]
   * @memberof common
   */
  Timestamp: timeType
});
common("empty", {
  /**
   * Properties of a google.protobuf.Empty message.
   * @interface IEmpty
   * @memberof common
   */
  Empty: {
    fields: {}
  }
});
common("struct", {
  /**
   * Properties of a google.protobuf.Struct message.
   * @interface IStruct
   * @type {Object}
   * @property {Object.<string,IValue>} [fields]
   * @memberof common
   */
  Struct: {
    fields: {
      fields: {
        keyType: "string",
        type: "Value",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.Value message.
   * @interface IValue
   * @type {Object}
   * @property {string} [kind]
   * @property {0} [nullValue]
   * @property {number} [numberValue]
   * @property {string} [stringValue]
   * @property {boolean} [boolValue]
   * @property {IStruct} [structValue]
   * @property {IListValue} [listValue]
   * @memberof common
   */
  Value: {
    oneofs: {
      kind: {
        oneof: [
          "nullValue",
          "numberValue",
          "stringValue",
          "boolValue",
          "structValue",
          "listValue"
        ]
      }
    },
    fields: {
      nullValue: {
        type: "NullValue",
        id: 1
      },
      numberValue: {
        type: "double",
        id: 2
      },
      stringValue: {
        type: "string",
        id: 3
      },
      boolValue: {
        type: "bool",
        id: 4
      },
      structValue: {
        type: "Struct",
        id: 5
      },
      listValue: {
        type: "ListValue",
        id: 6
      }
    }
  },
  NullValue: {
    values: {
      NULL_VALUE: 0
    }
  },
  /**
   * Properties of a google.protobuf.ListValue message.
   * @interface IListValue
   * @type {Object}
   * @property {Array.<IValue>} [values]
   * @memberof common
   */
  ListValue: {
    fields: {
      values: {
        rule: "repeated",
        type: "Value",
        id: 1
      }
    }
  }
});
common("wrappers", {
  /**
   * Properties of a google.protobuf.DoubleValue message.
   * @interface IDoubleValue
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  DoubleValue: {
    fields: {
      value: {
        type: "double",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.FloatValue message.
   * @interface IFloatValue
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  FloatValue: {
    fields: {
      value: {
        type: "float",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.Int64Value message.
   * @interface IInt64Value
   * @type {Object}
   * @property {number|Long} [value]
   * @memberof common
   */
  Int64Value: {
    fields: {
      value: {
        type: "int64",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.UInt64Value message.
   * @interface IUInt64Value
   * @type {Object}
   * @property {number|Long} [value]
   * @memberof common
   */
  UInt64Value: {
    fields: {
      value: {
        type: "uint64",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.Int32Value message.
   * @interface IInt32Value
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  Int32Value: {
    fields: {
      value: {
        type: "int32",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.UInt32Value message.
   * @interface IUInt32Value
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  UInt32Value: {
    fields: {
      value: {
        type: "uint32",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.BoolValue message.
   * @interface IBoolValue
   * @type {Object}
   * @property {boolean} [value]
   * @memberof common
   */
  BoolValue: {
    fields: {
      value: {
        type: "bool",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.StringValue message.
   * @interface IStringValue
   * @type {Object}
   * @property {string} [value]
   * @memberof common
   */
  StringValue: {
    fields: {
      value: {
        type: "string",
        id: 1
      }
    }
  },
  /**
   * Properties of a google.protobuf.BytesValue message.
   * @interface IBytesValue
   * @type {Object}
   * @property {Uint8Array} [value]
   * @memberof common
   */
  BytesValue: {
    fields: {
      value: {
        type: "bytes",
        id: 1
      }
    }
  }
});
common("field_mask", {
  /**
   * Properties of a google.protobuf.FieldMask message.
   * @interface IDoubleValue
   * @type {Object}
   * @property {number} [value]
   * @memberof common
   */
  FieldMask: {
    fields: {
      paths: {
        rule: "repeated",
        type: "string",
        id: 1
      }
    }
  }
});
common.get = function se(e) {
  return common[e] || null;
};
var protobuf = src.exports = indexLightExports;
protobuf.build = "full";
protobuf.tokenize = tokenize_1;
protobuf.parse = parse_1;
protobuf.common = common_1;
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
var srcExports = src.exports, protobufjs = srcExports, lib$1 = {}, descriptor_pb = {}, googleProtobuf = {};
(function(exports) {
  var $jscomp = $jscomp || {};
  $jscomp.scope = {}, $jscomp.findInternal = function(se, e, Oe) {
    se instanceof String && (se = String(se));
    for (var Si = se.length, wi = 0; wi < Si; wi++) {
      var Ei = se[wi];
      if (e.call(Oe, Ei, wi, se))
        return { i: wi, v: Ei };
    }
    return { i: -1, v: void 0 };
  }, $jscomp.ASSUME_ES5 = !1, $jscomp.ASSUME_NO_NATIVE_MAP = !1, $jscomp.ASSUME_NO_NATIVE_SET = !1, $jscomp.SIMPLE_FROUND_POLYFILL = !1, $jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(se, e, Oe) {
    se != Array.prototype && se != Object.prototype && (se[e] = Oe.value);
  }, $jscomp.getGlobal = function(se) {
    return typeof window < "u" && window === se ? se : typeof commonjsGlobal < "u" && commonjsGlobal != null ? commonjsGlobal : se;
  }, $jscomp.global = $jscomp.getGlobal(commonjsGlobal), $jscomp.polyfill = function(se, e, Oe, Si) {
    if (e) {
      for (Oe = $jscomp.global, se = se.split("."), Si = 0; Si < se.length - 1; Si++) {
        var wi = se[Si];
        wi in Oe || (Oe[wi] = {}), Oe = Oe[wi];
      }
      se = se[se.length - 1], Si = Oe[se], e = e(Si), e != Si && e != null && $jscomp.defineProperty(Oe, se, { configurable: !0, writable: !0, value: e });
    }
  }, $jscomp.polyfill("Array.prototype.findIndex", function(se) {
    return se || function(e, Oe) {
      return $jscomp.findInternal(this, e, Oe).i;
    };
  }, "es6", "es3"), $jscomp.checkStringArgs = function(se, e, Oe) {
    if (se == null)
      throw new TypeError("The 'this' value for String.prototype." + Oe + " must not be null or undefined");
    if (e instanceof RegExp)
      throw new TypeError("First argument to String.prototype." + Oe + " must not be a regular expression");
    return se + "";
  }, $jscomp.polyfill("String.prototype.endsWith", function(se) {
    return se || function(e, Oe) {
      var Si = $jscomp.checkStringArgs(this, e, "endsWith");
      e += "", Oe === void 0 && (Oe = Si.length), Oe = Math.max(0, Math.min(Oe | 0, Si.length));
      for (var wi = e.length; 0 < wi && 0 < Oe; )
        if (Si[--Oe] != e[--wi])
          return !1;
      return 0 >= wi;
    };
  }, "es6", "es3"), $jscomp.polyfill("Array.prototype.find", function(se) {
    return se || function(e, Oe) {
      return $jscomp.findInternal(this, e, Oe).v;
    };
  }, "es6", "es3"), $jscomp.polyfill("String.prototype.startsWith", function(se) {
    return se || function(e, Oe) {
      var Si = $jscomp.checkStringArgs(this, e, "startsWith");
      e += "";
      var wi = Si.length, Ei = e.length;
      Oe = Math.max(0, Math.min(Oe | 0, Si.length));
      for (var $i = 0; $i < Ei && Oe < wi; )
        if (Si[Oe++] != e[$i++])
          return !1;
      return $i >= Ei;
    };
  }, "es6", "es3"), $jscomp.polyfill("String.prototype.repeat", function(se) {
    return se || function(e) {
      var Oe = $jscomp.checkStringArgs(this, null, "repeat");
      if (0 > e || 1342177279 < e)
        throw new RangeError("Invalid count value");
      e |= 0;
      for (var Si = ""; e; )
        e & 1 && (Si += Oe), (e >>>= 1) && (Oe += Oe);
      return Si;
    };
  }, "es6", "es3");
  var COMPILED = !0, goog = goog || {};
  goog.global = commonjsGlobal || self, goog.exportPath_ = function(se, e, Oe) {
    se = se.split("."), Oe = Oe || goog.global, se[0] in Oe || typeof Oe.execScript > "u" || Oe.execScript("var " + se[0]);
    for (var Si; se.length && (Si = se.shift()); )
      se.length || e === void 0 ? Oe = Oe[Si] && Oe[Si] !== Object.prototype[Si] ? Oe[Si] : Oe[Si] = {} : Oe[Si] = e;
  }, goog.define = function(se, e) {
    return e;
  }, goog.FEATURESET_YEAR = 2012, goog.DEBUG = !0, goog.LOCALE = "en", goog.TRUSTED_SITE = !0, goog.STRICT_MODE_COMPATIBLE = !1, goog.DISALLOW_TEST_ONLY_CODE = !goog.DEBUG, goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1, goog.provide = function(se) {
    if (goog.isInModuleLoader_())
      throw Error("goog.provide cannot be used within a module.");
    goog.constructNamespace_(se);
  }, goog.constructNamespace_ = function(se, e) {
    goog.exportPath_(se, e);
  }, goog.getScriptNonce = function(se) {
    return se && se != goog.global ? goog.getScriptNonce_(se.document) : (goog.cspNonce_ === null && (goog.cspNonce_ = goog.getScriptNonce_(goog.global.document)), goog.cspNonce_);
  }, goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/, goog.cspNonce_ = null, goog.getScriptNonce_ = function(se) {
    return (se = se.querySelector && se.querySelector("script[nonce]")) && (se = se.nonce || se.getAttribute("nonce")) && goog.NONCE_PATTERN_.test(se) ? se : "";
  }, goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/, goog.module = function(se) {
    if (typeof se != "string" || !se || se.search(goog.VALID_MODULE_RE_) == -1)
      throw Error("Invalid module identifier");
    if (!goog.isInGoogModuleLoader_())
      throw Error("Module " + se + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
    if (goog.moduleLoaderState_.moduleName)
      throw Error("goog.module may only be called once per module.");
    goog.moduleLoaderState_.moduleName = se;
  }, goog.module.get = function(se) {
    return goog.module.getInternal_(se);
  }, goog.module.getInternal_ = function(se) {
    return null;
  }, goog.ModuleType = { ES6: "es6", GOOG: "goog" }, goog.moduleLoaderState_ = null, goog.isInModuleLoader_ = function() {
    return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
  }, goog.isInGoogModuleLoader_ = function() {
    return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
  }, goog.isInEs6ModuleLoader_ = function() {
    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6)
      return !0;
    var se = goog.global.$jscomp;
    return se ? typeof se.getCurrentModulePath != "function" ? !1 : !!se.getCurrentModulePath() : !1;
  }, goog.module.declareLegacyNamespace = function() {
    goog.moduleLoaderState_.declareLegacyNamespace = !0;
  }, goog.declareModuleId = function(se) {
    if (goog.moduleLoaderState_)
      goog.moduleLoaderState_.moduleName = se;
    else {
      var e = goog.global.$jscomp;
      if (!e || typeof e.getCurrentModulePath != "function")
        throw Error('Module with namespace "' + se + '" has been loaded incorrectly.');
      e = e.require(e.getCurrentModulePath()), goog.loadedModules_[se] = { exports: e, type: goog.ModuleType.ES6, moduleId: se };
    }
  }, goog.setTestOnly = function(se) {
    if (goog.DISALLOW_TEST_ONLY_CODE)
      throw se = se || "", Error("Importing test-only code into non-debug environment" + (se ? ": " + se : "."));
  }, goog.forwardDeclare = function(se) {
  }, goog.getObjectByName = function(se, e) {
    se = se.split("."), e = e || goog.global;
    for (var Oe = 0; Oe < se.length; Oe++)
      if (e = e[se[Oe]], e == null)
        return null;
    return e;
  }, goog.globalize = function(se, e) {
    e = e || goog.global;
    for (var Oe in se)
      e[Oe] = se[Oe];
  }, goog.addDependency = function(se, e, Oe, Si) {
  }, goog.ENABLE_DEBUG_LOADER = !0, goog.logToConsole_ = function(se) {
    goog.global.console && goog.global.console.error(se);
  }, goog.require = function(se) {
  }, goog.requireType = function(se) {
    return {};
  }, goog.basePath = "", goog.nullFunction = function() {
  }, goog.abstractMethod = function() {
    throw Error("unimplemented abstract method");
  }, goog.addSingletonGetter = function(se) {
    se.instance_ = void 0, se.getInstance = function() {
      return se.instance_ ? se.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = se), se.instance_ = new se());
    };
  }, goog.instantiatedSingletons_ = [], goog.LOAD_MODULE_USING_EVAL = !0, goog.SEAL_MODULE_EXPORTS = goog.DEBUG, goog.loadedModules_ = {}, goog.DEPENDENCIES_ENABLED = !COMPILED, goog.TRANSPILE = "detect", goog.ASSUME_ES_MODULES_TRANSPILED = !1, goog.TRANSPILE_TO_LANGUAGE = "", goog.TRANSPILER = "transpile.js", goog.hasBadLetScoping = null, goog.useSafari10Workaround = function() {
    if (goog.hasBadLetScoping == null) {
      try {
        var a = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');
      } catch (se) {
        a = !1;
      }
      goog.hasBadLetScoping = a;
    }
    return goog.hasBadLetScoping;
  }, goog.workaroundSafari10EvalBug = function(se) {
    return "(function(){" + se + `
;})();
`;
  }, goog.loadModule = function(se) {
    var e = goog.moduleLoaderState_;
    try {
      if (goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: !1, type: goog.ModuleType.GOOG }, goog.isFunction(se))
        var Oe = se.call(void 0, {});
      else if (typeof se == "string")
        goog.useSafari10Workaround() && (se = goog.workaroundSafari10EvalBug(se)), Oe = goog.loadModuleFromSource_.call(void 0, se);
      else
        throw Error("Invalid module definition");
      var Si = goog.moduleLoaderState_.moduleName;
      if (typeof Si == "string" && Si)
        goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(
          Si,
          Oe
        ) : goog.SEAL_MODULE_EXPORTS && Object.seal && typeof Oe == "object" && Oe != null && Object.seal(Oe), goog.loadedModules_[Si] = { exports: Oe, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
      else
        throw Error('Invalid module name "' + Si + '"');
    } finally {
      goog.moduleLoaderState_ = e;
    }
  }, goog.loadModuleFromSource_ = function(a) {
    return eval(a), {};
  }, goog.normalizePath_ = function(se) {
    se = se.split("/");
    for (var e = 0; e < se.length; )
      se[e] == "." ? se.splice(e, 1) : e && se[e] == ".." && se[e - 1] && se[e - 1] != ".." ? se.splice(--e, 2) : e++;
    return se.join("/");
  }, goog.loadFileSync_ = function(se) {
    if (goog.global.CLOSURE_LOAD_FILE_SYNC)
      return goog.global.CLOSURE_LOAD_FILE_SYNC(se);
    try {
      var e = new goog.global.XMLHttpRequest();
      return e.open("get", se, !1), e.send(), e.status == 0 || e.status == 200 ? e.responseText : null;
    } catch {
      return null;
    }
  }, goog.transpile_ = function(se, e, Oe) {
    var Si = goog.global.$jscomp;
    Si || (goog.global.$jscomp = Si = {});
    var wi = Si.transpile;
    if (!wi) {
      var Ei = goog.basePath + goog.TRANSPILER, $i = goog.loadFileSync_(Ei);
      if ($i) {
        if (function() {
          (0, eval)($i + `
//# sourceURL=` + Ei);
        }.call(goog.global), goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile)
          throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));
        goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile, Si = goog.global.$jscomp, wi = Si.transpile;
      }
    }
    return wi || (wi = Si.transpile = function(xi, Ri) {
      return goog.logToConsole_(Ri + " requires transpilation but no transpiler was found."), xi;
    }), wi(se, e, Oe);
  }, goog.typeOf = function(se) {
    var e = typeof se;
    if (e == "object")
      if (se) {
        if (se instanceof Array)
          return "array";
        if (se instanceof Object)
          return e;
        var Oe = Object.prototype.toString.call(se);
        if (Oe == "[object Window]")
          return "object";
        if (Oe == "[object Array]" || typeof se.length == "number" && typeof se.splice < "u" && typeof se.propertyIsEnumerable < "u" && !se.propertyIsEnumerable("splice"))
          return "array";
        if (Oe == "[object Function]" || typeof se.call < "u" && typeof se.propertyIsEnumerable < "u" && !se.propertyIsEnumerable("call"))
          return "function";
      } else
        return "null";
    else if (e == "function" && typeof se.call > "u")
      return "object";
    return e;
  }, goog.isArray = function(se) {
    return goog.typeOf(se) == "array";
  }, goog.isArrayLike = function(se) {
    var e = goog.typeOf(se);
    return e == "array" || e == "object" && typeof se.length == "number";
  }, goog.isDateLike = function(se) {
    return goog.isObject(se) && typeof se.getFullYear == "function";
  }, goog.isFunction = function(se) {
    return goog.typeOf(se) == "function";
  }, goog.isObject = function(se) {
    var e = typeof se;
    return e == "object" && se != null || e == "function";
  }, goog.getUid = function(se) {
    return Object.prototype.hasOwnProperty.call(se, goog.UID_PROPERTY_) && se[goog.UID_PROPERTY_] || (se[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  }, goog.hasUid = function(se) {
    return !!se[goog.UID_PROPERTY_];
  }, goog.removeUid = function(se) {
    se !== null && "removeAttribute" in se && se.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete se[goog.UID_PROPERTY_];
    } catch {
    }
  }, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(se) {
    var e = goog.typeOf(se);
    if (e == "object" || e == "array") {
      if (typeof se.clone == "function")
        return se.clone();
      e = e == "array" ? [] : {};
      for (var Oe in se)
        e[Oe] = goog.cloneObject(se[Oe]);
      return e;
    }
    return se;
  }, goog.bindNative_ = function(se, e, Oe) {
    return se.call.apply(se.bind, arguments);
  }, goog.bindJs_ = function(se, e, Oe) {
    if (!se)
      throw Error();
    if (2 < arguments.length) {
      var Si = Array.prototype.slice.call(arguments, 2);
      return function() {
        var wi = Array.prototype.slice.call(arguments);
        return Array.prototype.unshift.apply(wi, Si), se.apply(e, wi);
      };
    }
    return function() {
      return se.apply(e, arguments);
    };
  }, goog.bind = function(se, e, Oe) {
    return Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_, goog.bind.apply(null, arguments);
  }, goog.partial = function(se, e) {
    var Oe = Array.prototype.slice.call(arguments, 1);
    return function() {
      var Si = Oe.slice();
      return Si.push.apply(Si, arguments), se.apply(this, Si);
    };
  }, goog.mixin = function(se, e) {
    for (var Oe in e)
      se[Oe] = e[Oe];
  }, goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return +/* @__PURE__ */ new Date();
  }, goog.globalEval = function(se) {
    if (goog.global.execScript)
      goog.global.execScript(se, "JavaScript");
    else if (goog.global.eval) {
      if (goog.evalWorksForGlobals_ == null) {
        try {
          goog.global.eval("var _evalTest_ = 1;");
        } catch {
        }
        if (typeof goog.global._evalTest_ < "u") {
          try {
            delete goog.global._evalTest_;
          } catch {
          }
          goog.evalWorksForGlobals_ = !0;
        } else
          goog.evalWorksForGlobals_ = !1;
      }
      if (goog.evalWorksForGlobals_)
        goog.global.eval(se);
      else {
        var e = goog.global.document, Oe = e.createElement("script");
        Oe.type = "text/javascript", Oe.defer = !1, Oe.appendChild(e.createTextNode(se)), e.head.appendChild(Oe), e.head.removeChild(Oe);
      }
    } else
      throw Error("goog.globalEval not available");
  }, goog.evalWorksForGlobals_ = null, goog.getCssName = function(se, e) {
    if (String(se).charAt(0) == ".")
      throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + se);
    var Oe = function(wi) {
      return goog.cssNameMapping_[wi] || wi;
    }, Si = function(wi) {
      wi = wi.split("-");
      for (var Ei = [], $i = 0; $i < wi.length; $i++)
        Ei.push(Oe(wi[$i]));
      return Ei.join("-");
    };
    return Si = goog.cssNameMapping_ ? goog.cssNameMappingStyle_ == "BY_WHOLE" ? Oe : Si : function(wi) {
      return wi;
    }, se = e ? se + "-" + Si(e) : Si(se), goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(se) : se;
  }, goog.setCssNameMapping = function(se, e) {
    goog.cssNameMapping_ = se, goog.cssNameMappingStyle_ = e;
  }, goog.getMsg = function(se, e, Oe) {
    return Oe && Oe.html && (se = se.replace(/</g, "&lt;")), e && (se = se.replace(/\{\$([^}]+)}/g, function(Si, wi) {
      return e != null && wi in e ? e[wi] : Si;
    })), se;
  }, goog.getMsgWithFallback = function(se, e) {
    return se;
  }, goog.exportSymbol = function(se, e, Oe) {
    goog.exportPath_(se, e, Oe);
  }, goog.exportProperty = function(se, e, Oe) {
    se[e] = Oe;
  }, goog.inherits = function(se, e) {
    function Oe() {
    }
    Oe.prototype = e.prototype, se.superClass_ = e.prototype, se.prototype = new Oe(), se.prototype.constructor = se, se.base = function(Si, wi, Ei) {
      for (var $i = Array(arguments.length - 2), xi = 2; xi < arguments.length; xi++)
        $i[xi - 2] = arguments[xi];
      return e.prototype[wi].apply(Si, $i);
    };
  }, goog.scope = function(se) {
    if (goog.isInModuleLoader_())
      throw Error("goog.scope is not supported within a module.");
    se.call(goog.global);
  }, goog.defineClass = function(se, e) {
    var Oe = e.constructor, Si = e.statics;
    return Oe && Oe != Object.prototype.constructor || (Oe = function() {
      throw Error("cannot instantiate an interface (no constructor defined).");
    }), Oe = goog.defineClass.createSealingConstructor_(Oe, se), se && goog.inherits(Oe, se), delete e.constructor, delete e.statics, goog.defineClass.applyProperties_(Oe.prototype, e), Si != null && (Si instanceof Function ? Si(Oe) : goog.defineClass.applyProperties_(Oe, Si)), Oe;
  }, goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG, goog.defineClass.createSealingConstructor_ = function(se, e) {
    if (!goog.defineClass.SEAL_CLASS_INSTANCES)
      return se;
    var Oe = !goog.defineClass.isUnsealable_(e), Si = function() {
      var wi = se.apply(this, arguments) || this;
      return wi[goog.UID_PROPERTY_] = wi[goog.UID_PROPERTY_], this.constructor === Si && Oe && Object.seal instanceof Function && Object.seal(wi), wi;
    };
    return Si;
  }, goog.defineClass.isUnsealable_ = function(se) {
    return se && se.prototype && se.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
  }, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.defineClass.applyProperties_ = function(se, e) {
    for (var Oe in e)
      Object.prototype.hasOwnProperty.call(e, Oe) && (se[Oe] = e[Oe]);
    for (var Si = 0; Si < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; Si++)
      Oe = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[Si], Object.prototype.hasOwnProperty.call(e, Oe) && (se[Oe] = e[Oe]);
  }, goog.tagUnsealableClass = function(se) {
  }, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.TRUSTED_TYPES_POLICY_NAME = "", goog.identity_ = function(se) {
    return se;
  }, goog.createTrustedTypesPolicy = function(se) {
    var e = null, Oe = goog.global.trustedTypes || goog.global.TrustedTypes;
    if (!Oe || !Oe.createPolicy)
      return e;
    try {
      e = Oe.createPolicy(se, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_, createURL: goog.identity_ });
    } catch (Si) {
      goog.logToConsole_(Si.message);
    }
    return e;
  }, goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#base") : null, goog.object = {}, goog.object.is = function(se, e) {
    return se === e ? se !== 0 || 1 / se === 1 / e : se !== se && e !== e;
  }, goog.object.forEach = function(se, e, Oe) {
    for (var Si in se)
      e.call(Oe, se[Si], Si, se);
  }, goog.object.filter = function(se, e, Oe) {
    var Si = {}, wi;
    for (wi in se)
      e.call(Oe, se[wi], wi, se) && (Si[wi] = se[wi]);
    return Si;
  }, goog.object.map = function(se, e, Oe) {
    var Si = {}, wi;
    for (wi in se)
      Si[wi] = e.call(Oe, se[wi], wi, se);
    return Si;
  }, goog.object.some = function(se, e, Oe) {
    for (var Si in se)
      if (e.call(Oe, se[Si], Si, se))
        return !0;
    return !1;
  }, goog.object.every = function(se, e, Oe) {
    for (var Si in se)
      if (!e.call(Oe, se[Si], Si, se))
        return !1;
    return !0;
  }, goog.object.getCount = function(se) {
    var e = 0, Oe;
    for (Oe in se)
      e++;
    return e;
  }, goog.object.getAnyKey = function(se) {
    for (var e in se)
      return e;
  }, goog.object.getAnyValue = function(se) {
    for (var e in se)
      return se[e];
  }, goog.object.contains = function(se, e) {
    return goog.object.containsValue(se, e);
  }, goog.object.getValues = function(se) {
    var e = [], Oe = 0, Si;
    for (Si in se)
      e[Oe++] = se[Si];
    return e;
  }, goog.object.getKeys = function(se) {
    var e = [], Oe = 0, Si;
    for (Si in se)
      e[Oe++] = Si;
    return e;
  }, goog.object.getValueByKeys = function(se, e) {
    var Oe = goog.isArrayLike(e), Si = Oe ? e : arguments;
    for (Oe = Oe ? 0 : 1; Oe < Si.length; Oe++) {
      if (se == null)
        return;
      se = se[Si[Oe]];
    }
    return se;
  }, goog.object.containsKey = function(se, e) {
    return se !== null && e in se;
  }, goog.object.containsValue = function(se, e) {
    for (var Oe in se)
      if (se[Oe] == e)
        return !0;
    return !1;
  }, goog.object.findKey = function(se, e, Oe) {
    for (var Si in se)
      if (e.call(Oe, se[Si], Si, se))
        return Si;
  }, goog.object.findValue = function(se, e, Oe) {
    return (e = goog.object.findKey(se, e, Oe)) && se[e];
  }, goog.object.isEmpty = function(se) {
    for (var e in se)
      return !1;
    return !0;
  }, goog.object.clear = function(se) {
    for (var e in se)
      delete se[e];
  }, goog.object.remove = function(se, e) {
    var Oe;
    return (Oe = e in se) && delete se[e], Oe;
  }, goog.object.add = function(se, e, Oe) {
    if (se !== null && e in se)
      throw Error('The object already contains the key "' + e + '"');
    goog.object.set(se, e, Oe);
  }, goog.object.get = function(se, e, Oe) {
    return se !== null && e in se ? se[e] : Oe;
  }, goog.object.set = function(se, e, Oe) {
    se[e] = Oe;
  }, goog.object.setIfUndefined = function(se, e, Oe) {
    return e in se ? se[e] : se[e] = Oe;
  }, goog.object.setWithReturnValueIfNotSet = function(se, e, Oe) {
    return e in se ? se[e] : (Oe = Oe(), se[e] = Oe);
  }, goog.object.equals = function(se, e) {
    for (var Oe in se)
      if (!(Oe in e) || se[Oe] !== e[Oe])
        return !1;
    for (var Si in e)
      if (!(Si in se))
        return !1;
    return !0;
  }, goog.object.clone = function(se) {
    var e = {}, Oe;
    for (Oe in se)
      e[Oe] = se[Oe];
    return e;
  }, goog.object.unsafeClone = function(se) {
    var e = goog.typeOf(se);
    if (e == "object" || e == "array") {
      if (goog.isFunction(se.clone))
        return se.clone();
      e = e == "array" ? [] : {};
      for (var Oe in se)
        e[Oe] = goog.object.unsafeClone(se[Oe]);
      return e;
    }
    return se;
  }, goog.object.transpose = function(se) {
    var e = {}, Oe;
    for (Oe in se)
      e[se[Oe]] = Oe;
    return e;
  }, goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.object.extend = function(se, e) {
    for (var Oe, Si, wi = 1; wi < arguments.length; wi++) {
      Si = arguments[wi];
      for (Oe in Si)
        se[Oe] = Si[Oe];
      for (var Ei = 0; Ei < goog.object.PROTOTYPE_FIELDS_.length; Ei++)
        Oe = goog.object.PROTOTYPE_FIELDS_[Ei], Object.prototype.hasOwnProperty.call(Si, Oe) && (se[Oe] = Si[Oe]);
    }
  }, goog.object.create = function(se) {
    var e = arguments.length;
    if (e == 1 && Array.isArray(arguments[0]))
      return goog.object.create.apply(null, arguments[0]);
    if (e % 2)
      throw Error("Uneven number of arguments");
    for (var Oe = {}, Si = 0; Si < e; Si += 2)
      Oe[arguments[Si]] = arguments[Si + 1];
    return Oe;
  }, goog.object.createSet = function(se) {
    var e = arguments.length;
    if (e == 1 && Array.isArray(arguments[0]))
      return goog.object.createSet.apply(null, arguments[0]);
    for (var Oe = {}, Si = 0; Si < e; Si++)
      Oe[arguments[Si]] = !0;
    return Oe;
  }, goog.object.createImmutableView = function(se) {
    var e = se;
    return Object.isFrozen && !Object.isFrozen(se) && (e = Object.create(se), Object.freeze(e)), e;
  }, goog.object.isImmutableView = function(se) {
    return !!Object.isFrozen && Object.isFrozen(se);
  }, goog.object.getAllPropertyNames = function(se, e, Oe) {
    if (!se)
      return [];
    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf)
      return goog.object.getKeys(se);
    for (var Si = {}; se && (se !== Object.prototype || e) && (se !== Function.prototype || Oe); ) {
      for (var wi = Object.getOwnPropertyNames(se), Ei = 0; Ei < wi.length; Ei++)
        Si[wi[Ei]] = !0;
      se = Object.getPrototypeOf(se);
    }
    return goog.object.getKeys(Si);
  }, goog.object.getSuperClass = function(se) {
    return (se = Object.getPrototypeOf(se.prototype)) && se.constructor;
  };
  var jspb = { asserts: {} };
  jspb.asserts.doAssertFailure = function(se, e, Oe, Si) {
    var wi = "Assertion failed";
    if (Oe) {
      wi += ": " + Oe;
      var Ei = Si;
    } else
      se && (wi += ": " + se, Ei = e);
    throw Error("" + wi, Ei || []);
  }, jspb.asserts.assert = function(se, e, Oe) {
    for (var Si = [], wi = 2; wi < arguments.length; ++wi)
      Si[wi - 2] = arguments[wi];
    return se || jspb.asserts.doAssertFailure("", null, e, Si), se;
  }, jspb.asserts.assertString = function(se, e, Oe) {
    for (var Si = [], wi = 2; wi < arguments.length; ++wi)
      Si[wi - 2] = arguments[wi];
    return typeof se != "string" && jspb.asserts.doAssertFailure("Expected string but got %s: %s.", [goog.typeOf(se), se], e, Si), se;
  }, jspb.asserts.assertArray = function(se, e, Oe) {
    for (var Si = [], wi = 2; wi < arguments.length; ++wi)
      Si[wi - 2] = arguments[wi];
    return Array.isArray(se) || jspb.asserts.doAssertFailure("Expected array but got %s: %s.", [goog.typeOf(se), se], e, Si), se;
  }, jspb.asserts.fail = function(se, e) {
    for (var Oe = [], Si = 1; Si < arguments.length; ++Si)
      Oe[Si - 1] = arguments[Si];
    throw Error("Failure" + (se ? ": " + se : ""), Oe);
  }, jspb.asserts.assertInstanceof = function(se, e, Oe, Si) {
    for (var wi = [], Ei = 3; Ei < arguments.length; ++Ei)
      wi[Ei - 3] = arguments[Ei];
    return se instanceof e || jspb.asserts.doAssertFailure("Expected instanceof %s but got %s.", [jspb.asserts.getType(e), jspb.asserts.getType(se)], Oe, wi), se;
  }, jspb.asserts.getType = function(se) {
    return se instanceof Function ? se.displayName || se.name || "unknown type name" : se instanceof Object ? se.constructor.displayName || se.constructor.name || Object.prototype.toString.call(se) : se === null ? "null" : typeof se;
  }, jspb.BinaryConstants = {}, jspb.ConstBinaryMessage = function() {
  }, jspb.BinaryMessage = function() {
  }, jspb.BinaryConstants.FieldType = { INVALID: -1, DOUBLE: 1, FLOAT: 2, INT64: 3, UINT64: 4, INT32: 5, FIXED64: 6, FIXED32: 7, BOOL: 8, STRING: 9, GROUP: 10, MESSAGE: 11, BYTES: 12, UINT32: 13, ENUM: 14, SFIXED32: 15, SFIXED64: 16, SINT32: 17, SINT64: 18, FHASH64: 30, VHASH64: 31 }, jspb.BinaryConstants.WireType = { INVALID: -1, VARINT: 0, FIXED64: 1, DELIMITED: 2, START_GROUP: 3, END_GROUP: 4, FIXED32: 5 }, jspb.BinaryConstants.FieldTypeToWireType = function(se) {
    var e = jspb.BinaryConstants.FieldType, Oe = jspb.BinaryConstants.WireType;
    switch (se) {
      case e.INT32:
      case e.INT64:
      case e.UINT32:
      case e.UINT64:
      case e.SINT32:
      case e.SINT64:
      case e.BOOL:
      case e.ENUM:
      case e.VHASH64:
        return Oe.VARINT;
      case e.DOUBLE:
      case e.FIXED64:
      case e.SFIXED64:
      case e.FHASH64:
        return Oe.FIXED64;
      case e.STRING:
      case e.MESSAGE:
      case e.BYTES:
        return Oe.DELIMITED;
      case e.FLOAT:
      case e.FIXED32:
      case e.SFIXED32:
        return Oe.FIXED32;
      default:
        return Oe.INVALID;
    }
  }, jspb.BinaryConstants.INVALID_FIELD_NUMBER = -1, jspb.BinaryConstants.FLOAT32_EPS = 1401298464324817e-60, jspb.BinaryConstants.FLOAT32_MIN = 11754943508222875e-54, jspb.BinaryConstants.FLOAT32_MAX = 34028234663852886e22, jspb.BinaryConstants.FLOAT64_EPS = 5e-324, jspb.BinaryConstants.FLOAT64_MIN = 22250738585072014e-324, jspb.BinaryConstants.FLOAT64_MAX = 17976931348623157e292, jspb.BinaryConstants.TWO_TO_20 = 1048576, jspb.BinaryConstants.TWO_TO_23 = 8388608, jspb.BinaryConstants.TWO_TO_31 = 2147483648, jspb.BinaryConstants.TWO_TO_32 = 4294967296, jspb.BinaryConstants.TWO_TO_52 = 4503599627370496, jspb.BinaryConstants.TWO_TO_63 = 9223372036854776e3, jspb.BinaryConstants.TWO_TO_64 = 18446744073709552e3, jspb.BinaryConstants.ZERO_HASH = "\0\0\0\0\0\0\0\0", goog.debug = {}, goog.debug.Error = function(se) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, goog.debug.Error);
    else {
      var e = Error().stack;
      e && (this.stack = e);
    }
    se && (this.message = String(se)), this.reportErrorToServer = !0;
  }, goog.inherits(goog.debug.Error, Error), goog.debug.Error.prototype.name = "CustomError", goog.dom = {}, goog.dom.NodeType = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, CDATA_SECTION: 4, ENTITY_REFERENCE: 5, ENTITY: 6, PROCESSING_INSTRUCTION: 7, COMMENT: 8, DOCUMENT: 9, DOCUMENT_TYPE: 10, DOCUMENT_FRAGMENT: 11, NOTATION: 12 }, goog.asserts = {}, goog.asserts.ENABLE_ASSERTS = goog.DEBUG, goog.asserts.AssertionError = function(se, e) {
    goog.debug.Error.call(this, goog.asserts.subs_(se, e)), this.messagePattern = se;
  }, goog.inherits(goog.asserts.AssertionError, goog.debug.Error), goog.asserts.AssertionError.prototype.name = "AssertionError", goog.asserts.DEFAULT_ERROR_HANDLER = function(se) {
    throw se;
  }, goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER, goog.asserts.subs_ = function(se, e) {
    se = se.split("%s");
    for (var Oe = "", Si = se.length - 1, wi = 0; wi < Si; wi++)
      Oe += se[wi] + (wi < e.length ? e[wi] : "%s");
    return Oe + se[Si];
  }, goog.asserts.doAssertFailure_ = function(se, e, Oe, Si) {
    var wi = "Assertion failed";
    if (Oe) {
      wi += ": " + Oe;
      var Ei = Si;
    } else
      se && (wi += ": " + se, Ei = e);
    se = new goog.asserts.AssertionError("" + wi, Ei || []), goog.asserts.errorHandler_(se);
  }, goog.asserts.setErrorHandler = function(se) {
    goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = se);
  }, goog.asserts.assert = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && !se && goog.asserts.doAssertFailure_("", null, e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertExists = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && se == null && goog.asserts.doAssertFailure_("Expected to exist: %s.", [se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.fail = function(se, e) {
    goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (se ? ": " + se : ""), Array.prototype.slice.call(arguments, 1)));
  }, goog.asserts.assertNumber = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && typeof se != "number" && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertString = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && typeof se != "string" && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertFunction = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && !goog.isFunction(se) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertObject = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && !goog.isObject(se) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertArray = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && !Array.isArray(se) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertBoolean = function(se, e, Oe) {
    return goog.asserts.ENABLE_ASSERTS && typeof se != "boolean" && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertElement = function(se, e, Oe) {
    return !goog.asserts.ENABLE_ASSERTS || goog.isObject(se) && se.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(se), se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertInstanceof = function(se, e, Oe, Si) {
    return !goog.asserts.ENABLE_ASSERTS || se instanceof e || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(e), goog.asserts.getType_(se)], Oe, Array.prototype.slice.call(arguments, 3)), se;
  }, goog.asserts.assertFinite = function(se, e, Oe) {
    return !goog.asserts.ENABLE_ASSERTS || typeof se == "number" && isFinite(se) || goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [se], e, Array.prototype.slice.call(arguments, 2)), se;
  }, goog.asserts.assertObjectPrototypeIsIntact = function() {
    for (var se in Object.prototype)
      goog.asserts.fail(se + " should not be enumerable in Object.prototype.");
  }, goog.asserts.getType_ = function(se) {
    return se instanceof Function ? se.displayName || se.name || "unknown type name" : se instanceof Object ? se.constructor.displayName || se.constructor.name || Object.prototype.toString.call(se) : se === null ? "null" : typeof se;
  }, goog.array = {}, goog.NATIVE_ARRAY_PROTOTYPES = goog.TRUSTED_SITE, goog.array.ASSUME_NATIVE_FUNCTIONS = 2012 < goog.FEATURESET_YEAR, goog.array.peek = function(se) {
    return se[se.length - 1];
  }, goog.array.last = goog.array.peek, goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), Array.prototype.indexOf.call(se, e, Oe);
  } : function(se, e, Oe) {
    if (Oe = Oe == null ? 0 : 0 > Oe ? Math.max(0, se.length + Oe) : Oe, typeof se == "string")
      return typeof e != "string" || e.length != 1 ? -1 : se.indexOf(e, Oe);
    for (; Oe < se.length; Oe++)
      if (Oe in se && se[Oe] === e)
        return Oe;
    return -1;
  }, goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), Array.prototype.lastIndexOf.call(se, e, Oe ?? se.length - 1);
  } : function(se, e, Oe) {
    if (Oe = Oe ?? se.length - 1, 0 > Oe && (Oe = Math.max(0, se.length + Oe)), typeof se == "string")
      return typeof e != "string" || e.length != 1 ? -1 : se.lastIndexOf(e, Oe);
    for (; 0 <= Oe; Oe--)
      if (Oe in se && se[Oe] === e)
        return Oe;
    return -1;
  }, goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function(se, e, Oe) {
    goog.asserts.assert(se.length != null), Array.prototype.forEach.call(se, e, Oe);
  } : function(se, e, Oe) {
    for (var Si = se.length, wi = typeof se == "string" ? se.split("") : se, Ei = 0; Ei < Si; Ei++)
      Ei in wi && e.call(Oe, wi[Ei], Ei, se);
  }, goog.array.forEachRight = function(se, e, Oe) {
    var Si = se.length, wi = typeof se == "string" ? se.split("") : se;
    for (--Si; 0 <= Si; --Si)
      Si in wi && e.call(Oe, wi[Si], Si, se);
  }, goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), Array.prototype.filter.call(se, e, Oe);
  } : function(se, e, Oe) {
    for (var Si = se.length, wi = [], Ei = 0, $i = typeof se == "string" ? se.split("") : se, xi = 0; xi < Si; xi++)
      if (xi in $i) {
        var Ri = $i[xi];
        e.call(Oe, Ri, xi, se) && (wi[Ei++] = Ri);
      }
    return wi;
  }, goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), Array.prototype.map.call(se, e, Oe);
  } : function(se, e, Oe) {
    for (var Si = se.length, wi = Array(Si), Ei = typeof se == "string" ? se.split("") : se, $i = 0; $i < Si; $i++)
      $i in Ei && (wi[$i] = e.call(Oe, Ei[$i], $i, se));
    return wi;
  }, goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function(se, e, Oe, Si) {
    return goog.asserts.assert(se.length != null), Si && (e = goog.bind(e, Si)), Array.prototype.reduce.call(se, e, Oe);
  } : function(se, e, Oe, Si) {
    var wi = Oe;
    return goog.array.forEach(se, function(Ei, $i) {
      wi = e.call(Si, wi, Ei, $i, se);
    }), wi;
  }, goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function(se, e, Oe, Si) {
    return goog.asserts.assert(se.length != null), goog.asserts.assert(e != null), Si && (e = goog.bind(e, Si)), Array.prototype.reduceRight.call(se, e, Oe);
  } : function(se, e, Oe, Si) {
    var wi = Oe;
    return goog.array.forEachRight(se, function(Ei, $i) {
      wi = e.call(Si, wi, Ei, $i, se);
    }), wi;
  }, goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), Array.prototype.some.call(se, e, Oe);
  } : function(se, e, Oe) {
    for (var Si = se.length, wi = typeof se == "string" ? se.split("") : se, Ei = 0; Ei < Si; Ei++)
      if (Ei in wi && e.call(Oe, wi[Ei], Ei, se))
        return !0;
    return !1;
  }, goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), Array.prototype.every.call(se, e, Oe);
  } : function(se, e, Oe) {
    for (var Si = se.length, wi = typeof se == "string" ? se.split("") : se, Ei = 0; Ei < Si; Ei++)
      if (Ei in wi && !e.call(Oe, wi[Ei], Ei, se))
        return !1;
    return !0;
  }, goog.array.count = function(se, e, Oe) {
    var Si = 0;
    return goog.array.forEach(se, function(wi, Ei, $i) {
      e.call(Oe, wi, Ei, $i) && ++Si;
    }, Oe), Si;
  }, goog.array.find = function(se, e, Oe) {
    return e = goog.array.findIndex(se, e, Oe), 0 > e ? null : typeof se == "string" ? se.charAt(e) : se[e];
  }, goog.array.findIndex = function(se, e, Oe) {
    for (var Si = se.length, wi = typeof se == "string" ? se.split("") : se, Ei = 0; Ei < Si; Ei++)
      if (Ei in wi && e.call(Oe, wi[Ei], Ei, se))
        return Ei;
    return -1;
  }, goog.array.findRight = function(se, e, Oe) {
    return e = goog.array.findIndexRight(se, e, Oe), 0 > e ? null : typeof se == "string" ? se.charAt(e) : se[e];
  }, goog.array.findIndexRight = function(se, e, Oe) {
    var Si = se.length, wi = typeof se == "string" ? se.split("") : se;
    for (--Si; 0 <= Si; Si--)
      if (Si in wi && e.call(Oe, wi[Si], Si, se))
        return Si;
    return -1;
  }, goog.array.contains = function(se, e) {
    return 0 <= goog.array.indexOf(se, e);
  }, goog.array.isEmpty = function(se) {
    return se.length == 0;
  }, goog.array.clear = function(se) {
    if (!Array.isArray(se))
      for (var e = se.length - 1; 0 <= e; e--)
        delete se[e];
    se.length = 0;
  }, goog.array.insert = function(se, e) {
    goog.array.contains(se, e) || se.push(e);
  }, goog.array.insertAt = function(se, e, Oe) {
    goog.array.splice(se, Oe, 0, e);
  }, goog.array.insertArrayAt = function(se, e, Oe) {
    goog.partial(goog.array.splice, se, Oe, 0).apply(null, e);
  }, goog.array.insertBefore = function(se, e, Oe) {
    var Si;
    arguments.length == 2 || 0 > (Si = goog.array.indexOf(se, Oe)) ? se.push(e) : goog.array.insertAt(se, e, Si);
  }, goog.array.remove = function(se, e) {
    e = goog.array.indexOf(se, e);
    var Oe;
    return (Oe = 0 <= e) && goog.array.removeAt(se, e), Oe;
  }, goog.array.removeLast = function(se, e) {
    return e = goog.array.lastIndexOf(se, e), 0 <= e ? (goog.array.removeAt(se, e), !0) : !1;
  }, goog.array.removeAt = function(se, e) {
    return goog.asserts.assert(se.length != null), Array.prototype.splice.call(se, e, 1).length == 1;
  }, goog.array.removeIf = function(se, e, Oe) {
    return e = goog.array.findIndex(se, e, Oe), 0 <= e ? (goog.array.removeAt(se, e), !0) : !1;
  }, goog.array.removeAllIf = function(se, e, Oe) {
    var Si = 0;
    return goog.array.forEachRight(se, function(wi, Ei) {
      e.call(Oe, wi, Ei, se) && goog.array.removeAt(se, Ei) && Si++;
    }), Si;
  }, goog.array.concat = function(se) {
    return Array.prototype.concat.apply([], arguments);
  }, goog.array.join = function(se) {
    return Array.prototype.concat.apply([], arguments);
  }, goog.array.toArray = function(se) {
    var e = se.length;
    if (0 < e) {
      for (var Oe = Array(e), Si = 0; Si < e; Si++)
        Oe[Si] = se[Si];
      return Oe;
    }
    return [];
  }, goog.array.clone = goog.array.toArray, goog.array.extend = function(se, e) {
    for (var Oe = 1; Oe < arguments.length; Oe++) {
      var Si = arguments[Oe];
      if (goog.isArrayLike(Si)) {
        var wi = se.length || 0, Ei = Si.length || 0;
        se.length = wi + Ei;
        for (var $i = 0; $i < Ei; $i++)
          se[wi + $i] = Si[$i];
      } else
        se.push(Si);
    }
  }, goog.array.splice = function(se, e, Oe, Si) {
    return goog.asserts.assert(se.length != null), Array.prototype.splice.apply(se, goog.array.slice(arguments, 1));
  }, goog.array.slice = function(se, e, Oe) {
    return goog.asserts.assert(se.length != null), 2 >= arguments.length ? Array.prototype.slice.call(se, e) : Array.prototype.slice.call(se, e, Oe);
  }, goog.array.removeDuplicates = function(se, e, Oe) {
    e = e || se;
    var Si = function(Ri) {
      return goog.isObject(Ri) ? "o" + goog.getUid(Ri) : (typeof Ri).charAt(0) + Ri;
    };
    Oe = Oe || Si, Si = {};
    for (var wi = 0, Ei = 0; Ei < se.length; ) {
      var $i = se[Ei++], xi = Oe($i);
      Object.prototype.hasOwnProperty.call(Si, xi) || (Si[xi] = !0, e[wi++] = $i);
    }
    e.length = wi;
  }, goog.array.binarySearch = function(se, e, Oe) {
    return goog.array.binarySearch_(se, Oe || goog.array.defaultCompare, !1, e);
  }, goog.array.binarySelect = function(se, e, Oe) {
    return goog.array.binarySearch_(se, e, !0, void 0, Oe);
  }, goog.array.binarySearch_ = function(se, e, Oe, Si, wi) {
    for (var Ei = 0, $i = se.length, xi; Ei < $i; ) {
      var Ri = Ei + ($i - Ei >>> 1), Ti = Oe ? e.call(wi, se[Ri], Ri, se) : e(Si, se[Ri]);
      0 < Ti ? Ei = Ri + 1 : ($i = Ri, xi = !Ti);
    }
    return xi ? Ei : -Ei - 1;
  }, goog.array.sort = function(se, e) {
    se.sort(e || goog.array.defaultCompare);
  }, goog.array.stableSort = function(se, e) {
    for (var Oe = Array(se.length), Si = 0; Si < se.length; Si++)
      Oe[Si] = { index: Si, value: se[Si] };
    var wi = e || goog.array.defaultCompare;
    for (goog.array.sort(Oe, function(Ei, $i) {
      return wi(Ei.value, $i.value) || Ei.index - $i.index;
    }), Si = 0; Si < se.length; Si++)
      se[Si] = Oe[Si].value;
  }, goog.array.sortByKey = function(se, e, Oe) {
    var Si = Oe || goog.array.defaultCompare;
    goog.array.sort(se, function(wi, Ei) {
      return Si(e(wi), e(Ei));
    });
  }, goog.array.sortObjectsByKey = function(se, e, Oe) {
    goog.array.sortByKey(se, function(Si) {
      return Si[e];
    }, Oe);
  }, goog.array.isSorted = function(se, e, Oe) {
    e = e || goog.array.defaultCompare;
    for (var Si = 1; Si < se.length; Si++) {
      var wi = e(se[Si - 1], se[Si]);
      if (0 < wi || wi == 0 && Oe)
        return !1;
    }
    return !0;
  }, goog.array.equals = function(se, e, Oe) {
    if (!goog.isArrayLike(se) || !goog.isArrayLike(e) || se.length != e.length)
      return !1;
    var Si = se.length;
    Oe = Oe || goog.array.defaultCompareEquality;
    for (var wi = 0; wi < Si; wi++)
      if (!Oe(se[wi], e[wi]))
        return !1;
    return !0;
  }, goog.array.compare3 = function(se, e, Oe) {
    Oe = Oe || goog.array.defaultCompare;
    for (var Si = Math.min(se.length, e.length), wi = 0; wi < Si; wi++) {
      var Ei = Oe(se[wi], e[wi]);
      if (Ei != 0)
        return Ei;
    }
    return goog.array.defaultCompare(se.length, e.length);
  }, goog.array.defaultCompare = function(se, e) {
    return se > e ? 1 : se < e ? -1 : 0;
  }, goog.array.inverseDefaultCompare = function(se, e) {
    return -goog.array.defaultCompare(se, e);
  }, goog.array.defaultCompareEquality = function(se, e) {
    return se === e;
  }, goog.array.binaryInsert = function(se, e, Oe) {
    return Oe = goog.array.binarySearch(se, e, Oe), 0 > Oe ? (goog.array.insertAt(se, e, -(Oe + 1)), !0) : !1;
  }, goog.array.binaryRemove = function(se, e, Oe) {
    return e = goog.array.binarySearch(se, e, Oe), 0 <= e ? goog.array.removeAt(se, e) : !1;
  }, goog.array.bucket = function(se, e, Oe) {
    for (var Si = {}, wi = 0; wi < se.length; wi++) {
      var Ei = se[wi], $i = e.call(Oe, Ei, wi, se);
      $i !== void 0 && (Si[$i] || (Si[$i] = [])).push(Ei);
    }
    return Si;
  }, goog.array.toObject = function(se, e, Oe) {
    var Si = {};
    return goog.array.forEach(se, function(wi, Ei) {
      Si[e.call(Oe, wi, Ei, se)] = wi;
    }), Si;
  }, goog.array.range = function(se, e, Oe) {
    var Si = [], wi = 0, Ei = se;
    if (Oe = Oe || 1, e !== void 0 && (wi = se, Ei = e), 0 > Oe * (Ei - wi))
      return [];
    if (0 < Oe)
      for (se = wi; se < Ei; se += Oe)
        Si.push(se);
    else
      for (se = wi; se > Ei; se += Oe)
        Si.push(se);
    return Si;
  }, goog.array.repeat = function(se, e) {
    for (var Oe = [], Si = 0; Si < e; Si++)
      Oe[Si] = se;
    return Oe;
  }, goog.array.flatten = function(se) {
    for (var e = [], Oe = 0; Oe < arguments.length; Oe++) {
      var Si = arguments[Oe];
      if (Array.isArray(Si))
        for (var wi = 0; wi < Si.length; wi += 8192) {
          var Ei = goog.array.slice(Si, wi, wi + 8192);
          Ei = goog.array.flatten.apply(null, Ei);
          for (var $i = 0; $i < Ei.length; $i++)
            e.push(Ei[$i]);
        }
      else
        e.push(Si);
    }
    return e;
  }, goog.array.rotate = function(se, e) {
    return goog.asserts.assert(se.length != null), se.length && (e %= se.length, 0 < e ? Array.prototype.unshift.apply(se, se.splice(-e, e)) : 0 > e && Array.prototype.push.apply(se, se.splice(0, -e))), se;
  }, goog.array.moveItem = function(se, e, Oe) {
    goog.asserts.assert(0 <= e && e < se.length), goog.asserts.assert(0 <= Oe && Oe < se.length), e = Array.prototype.splice.call(se, e, 1), Array.prototype.splice.call(se, Oe, 0, e[0]);
  }, goog.array.zip = function(se) {
    if (!arguments.length)
      return [];
    for (var e = [], Oe = arguments[0].length, Si = 1; Si < arguments.length; Si++)
      arguments[Si].length < Oe && (Oe = arguments[Si].length);
    for (Si = 0; Si < Oe; Si++) {
      for (var wi = [], Ei = 0; Ei < arguments.length; Ei++)
        wi.push(arguments[Ei][Si]);
      e.push(wi);
    }
    return e;
  }, goog.array.shuffle = function(se, e) {
    e = e || Math.random;
    for (var Oe = se.length - 1; 0 < Oe; Oe--) {
      var Si = Math.floor(e() * (Oe + 1)), wi = se[Oe];
      se[Oe] = se[Si], se[Si] = wi;
    }
  }, goog.array.copyByIndex = function(se, e) {
    var Oe = [];
    return goog.array.forEach(e, function(Si) {
      Oe.push(se[Si]);
    }), Oe;
  }, goog.array.concatMap = function(se, e, Oe) {
    return goog.array.concat.apply([], goog.array.map(se, e, Oe));
  }, goog.crypt = {}, goog.crypt.stringToByteArray = function(se) {
    for (var e = [], Oe = 0, Si = 0; Si < se.length; Si++) {
      var wi = se.charCodeAt(Si);
      255 < wi && (e[Oe++] = wi & 255, wi >>= 8), e[Oe++] = wi;
    }
    return e;
  }, goog.crypt.byteArrayToString = function(se) {
    if (8192 >= se.length)
      return String.fromCharCode.apply(null, se);
    for (var e = "", Oe = 0; Oe < se.length; Oe += 8192) {
      var Si = goog.array.slice(se, Oe, Oe + 8192);
      e += String.fromCharCode.apply(null, Si);
    }
    return e;
  }, goog.crypt.byteArrayToHex = function(se, e) {
    return goog.array.map(se, function(Oe) {
      return Oe = Oe.toString(16), 1 < Oe.length ? Oe : "0" + Oe;
    }).join(e || "");
  }, goog.crypt.hexToByteArray = function(se) {
    goog.asserts.assert(se.length % 2 == 0, "Key string length must be multiple of 2");
    for (var e = [], Oe = 0; Oe < se.length; Oe += 2)
      e.push(parseInt(se.substring(Oe, Oe + 2), 16));
    return e;
  }, goog.crypt.stringToUtf8ByteArray = function(se) {
    for (var e = [], Oe = 0, Si = 0; Si < se.length; Si++) {
      var wi = se.charCodeAt(Si);
      128 > wi ? e[Oe++] = wi : (2048 > wi ? e[Oe++] = wi >> 6 | 192 : ((wi & 64512) == 55296 && Si + 1 < se.length && (se.charCodeAt(Si + 1) & 64512) == 56320 ? (wi = 65536 + ((wi & 1023) << 10) + (se.charCodeAt(++Si) & 1023), e[Oe++] = wi >> 18 | 240, e[Oe++] = wi >> 12 & 63 | 128) : e[Oe++] = wi >> 12 | 224, e[Oe++] = wi >> 6 & 63 | 128), e[Oe++] = wi & 63 | 128);
    }
    return e;
  }, goog.crypt.utf8ByteArrayToString = function(se) {
    for (var e = [], Oe = 0, Si = 0; Oe < se.length; ) {
      var wi = se[Oe++];
      if (128 > wi)
        e[Si++] = String.fromCharCode(wi);
      else if (191 < wi && 224 > wi) {
        var Ei = se[Oe++];
        e[Si++] = String.fromCharCode((wi & 31) << 6 | Ei & 63);
      } else if (239 < wi && 365 > wi) {
        Ei = se[Oe++];
        var $i = se[Oe++], xi = se[Oe++];
        wi = ((wi & 7) << 18 | (Ei & 63) << 12 | ($i & 63) << 6 | xi & 63) - 65536, e[Si++] = String.fromCharCode(55296 + (wi >> 10)), e[Si++] = String.fromCharCode(56320 + (wi & 1023));
      } else
        Ei = se[Oe++], $i = se[Oe++], e[Si++] = String.fromCharCode((wi & 15) << 12 | (Ei & 63) << 6 | $i & 63);
    }
    return e.join("");
  }, goog.crypt.xorByteArray = function(se, e) {
    goog.asserts.assert(se.length == e.length, "XOR array lengths must match");
    for (var Oe = [], Si = 0; Si < se.length; Si++)
      Oe.push(se[Si] ^ e[Si]);
    return Oe;
  }, goog.dom.asserts = {}, goog.dom.asserts.assertIsLocation = function(se) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var e = goog.dom.asserts.getWindow_(se);
      e && (!se || !(se instanceof e.Location) && se instanceof e.Element) && goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s", goog.dom.asserts.debugStringForType_(se));
    }
    return se;
  }, goog.dom.asserts.assertIsElementType_ = function(se, e) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var Oe = goog.dom.asserts.getWindow_(se);
      Oe && typeof Oe[e] < "u" && (se && (se instanceof Oe[e] || !(se instanceof Oe.Location || se instanceof Oe.Element)) || goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s", e, goog.dom.asserts.debugStringForType_(se)));
    }
    return se;
  }, goog.dom.asserts.assertIsHTMLAnchorElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLAnchorElement");
  }, goog.dom.asserts.assertIsHTMLButtonElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLButtonElement");
  }, goog.dom.asserts.assertIsHTMLLinkElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLLinkElement");
  }, goog.dom.asserts.assertIsHTMLImageElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLImageElement");
  }, goog.dom.asserts.assertIsHTMLAudioElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLAudioElement");
  }, goog.dom.asserts.assertIsHTMLVideoElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLVideoElement");
  }, goog.dom.asserts.assertIsHTMLInputElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLInputElement");
  }, goog.dom.asserts.assertIsHTMLTextAreaElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLTextAreaElement");
  }, goog.dom.asserts.assertIsHTMLCanvasElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLCanvasElement");
  }, goog.dom.asserts.assertIsHTMLEmbedElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLEmbedElement");
  }, goog.dom.asserts.assertIsHTMLFormElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLFormElement");
  }, goog.dom.asserts.assertIsHTMLFrameElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLFrameElement");
  }, goog.dom.asserts.assertIsHTMLIFrameElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLIFrameElement");
  }, goog.dom.asserts.assertIsHTMLObjectElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLObjectElement");
  }, goog.dom.asserts.assertIsHTMLScriptElement = function(se) {
    return goog.dom.asserts.assertIsElementType_(se, "HTMLScriptElement");
  }, goog.dom.asserts.debugStringForType_ = function(se) {
    if (goog.isObject(se))
      try {
        return se.constructor.displayName || se.constructor.name || Object.prototype.toString.call(se);
      } catch {
        return "<object could not be stringified>";
      }
    else
      return se === void 0 ? "undefined" : se === null ? "null" : typeof se;
  }, goog.dom.asserts.getWindow_ = function(se) {
    try {
      var e = se && se.ownerDocument, Oe = e && (e.defaultView || e.parentWindow);
      if (Oe = Oe || goog.global, Oe.Element && Oe.Location)
        return Oe;
    } catch {
    }
    return null;
  }, goog.functions = {}, goog.functions.constant = function(se) {
    return function() {
      return se;
    };
  }, goog.functions.FALSE = function() {
    return !1;
  }, goog.functions.TRUE = function() {
    return !0;
  }, goog.functions.NULL = function() {
    return null;
  }, goog.functions.identity = function(se, e) {
    return se;
  }, goog.functions.error = function(se) {
    return function() {
      throw Error(se);
    };
  }, goog.functions.fail = function(se) {
    return function() {
      throw se;
    };
  }, goog.functions.lock = function(se, e) {
    return e = e || 0, function() {
      return se.apply(this, Array.prototype.slice.call(arguments, 0, e));
    };
  }, goog.functions.nth = function(se) {
    return function() {
      return arguments[se];
    };
  }, goog.functions.partialRight = function(se, e) {
    var Oe = Array.prototype.slice.call(arguments, 1);
    return function() {
      var Si = Array.prototype.slice.call(arguments);
      return Si.push.apply(Si, Oe), se.apply(this, Si);
    };
  }, goog.functions.withReturnValue = function(se, e) {
    return goog.functions.sequence(se, goog.functions.constant(e));
  }, goog.functions.equalTo = function(se, e) {
    return function(Oe) {
      return e ? se == Oe : se === Oe;
    };
  }, goog.functions.compose = function(se, e) {
    var Oe = arguments, Si = Oe.length;
    return function() {
      var wi;
      Si && (wi = Oe[Si - 1].apply(this, arguments));
      for (var Ei = Si - 2; 0 <= Ei; Ei--)
        wi = Oe[Ei].call(this, wi);
      return wi;
    };
  }, goog.functions.sequence = function(se) {
    var e = arguments, Oe = e.length;
    return function() {
      for (var Si, wi = 0; wi < Oe; wi++)
        Si = e[wi].apply(this, arguments);
      return Si;
    };
  }, goog.functions.and = function(se) {
    var e = arguments, Oe = e.length;
    return function() {
      for (var Si = 0; Si < Oe; Si++)
        if (!e[Si].apply(this, arguments))
          return !1;
      return !0;
    };
  }, goog.functions.or = function(se) {
    var e = arguments, Oe = e.length;
    return function() {
      for (var Si = 0; Si < Oe; Si++)
        if (e[Si].apply(this, arguments))
          return !0;
      return !1;
    };
  }, goog.functions.not = function(se) {
    return function() {
      return !se.apply(this, arguments);
    };
  }, goog.functions.create = function(se, e) {
    var Oe = function() {
    };
    return Oe.prototype = se.prototype, Oe = new Oe(), se.apply(Oe, Array.prototype.slice.call(arguments, 1)), Oe;
  }, goog.functions.CACHE_RETURN_VALUE = !0, goog.functions.cacheReturnValue = function(se) {
    var e = !1, Oe;
    return function() {
      return goog.functions.CACHE_RETURN_VALUE ? (e || (Oe = se(), e = !0), Oe) : se();
    };
  }, goog.functions.once = function(se) {
    var e = se;
    return function() {
      if (e) {
        var Oe = e;
        e = null, Oe();
      }
    };
  }, goog.functions.debounce = function(se, e, Oe) {
    var Si = 0;
    return function(wi) {
      goog.global.clearTimeout(Si);
      var Ei = arguments;
      Si = goog.global.setTimeout(function() {
        se.apply(Oe, Ei);
      }, e);
    };
  }, goog.functions.throttle = function(se, e, Oe) {
    var Si = 0, wi = !1, Ei = [], $i = function() {
      Si = 0, wi && (wi = !1, xi());
    }, xi = function() {
      Si = goog.global.setTimeout($i, e), se.apply(Oe, Ei);
    };
    return function(Ri) {
      Ei = arguments, Si ? wi = !0 : xi();
    };
  }, goog.functions.rateLimit = function(se, e, Oe) {
    var Si = 0, wi = function() {
      Si = 0;
    };
    return function(Ei) {
      Si || (Si = goog.global.setTimeout(wi, e), se.apply(Oe, arguments));
    };
  }, goog.dom.HtmlElement = function() {
  }, goog.dom.TagName = function(se) {
    this.tagName_ = se;
  }, goog.dom.TagName.prototype.toString = function() {
    return this.tagName_;
  }, goog.dom.TagName.A = new goog.dom.TagName("A"), goog.dom.TagName.ABBR = new goog.dom.TagName("ABBR"), goog.dom.TagName.ACRONYM = new goog.dom.TagName("ACRONYM"), goog.dom.TagName.ADDRESS = new goog.dom.TagName("ADDRESS"), goog.dom.TagName.APPLET = new goog.dom.TagName("APPLET"), goog.dom.TagName.AREA = new goog.dom.TagName("AREA"), goog.dom.TagName.ARTICLE = new goog.dom.TagName("ARTICLE"), goog.dom.TagName.ASIDE = new goog.dom.TagName("ASIDE"), goog.dom.TagName.AUDIO = new goog.dom.TagName("AUDIO"), goog.dom.TagName.B = new goog.dom.TagName("B"), goog.dom.TagName.BASE = new goog.dom.TagName("BASE"), goog.dom.TagName.BASEFONT = new goog.dom.TagName("BASEFONT"), goog.dom.TagName.BDI = new goog.dom.TagName("BDI"), goog.dom.TagName.BDO = new goog.dom.TagName("BDO"), goog.dom.TagName.BIG = new goog.dom.TagName("BIG"), goog.dom.TagName.BLOCKQUOTE = new goog.dom.TagName("BLOCKQUOTE"), goog.dom.TagName.BODY = new goog.dom.TagName("BODY"), goog.dom.TagName.BR = new goog.dom.TagName("BR"), goog.dom.TagName.BUTTON = new goog.dom.TagName("BUTTON"), goog.dom.TagName.CANVAS = new goog.dom.TagName("CANVAS"), goog.dom.TagName.CAPTION = new goog.dom.TagName("CAPTION"), goog.dom.TagName.CENTER = new goog.dom.TagName("CENTER"), goog.dom.TagName.CITE = new goog.dom.TagName("CITE"), goog.dom.TagName.CODE = new goog.dom.TagName("CODE"), goog.dom.TagName.COL = new goog.dom.TagName("COL"), goog.dom.TagName.COLGROUP = new goog.dom.TagName("COLGROUP"), goog.dom.TagName.COMMAND = new goog.dom.TagName("COMMAND"), goog.dom.TagName.DATA = new goog.dom.TagName("DATA"), goog.dom.TagName.DATALIST = new goog.dom.TagName("DATALIST"), goog.dom.TagName.DD = new goog.dom.TagName("DD"), goog.dom.TagName.DEL = new goog.dom.TagName("DEL"), goog.dom.TagName.DETAILS = new goog.dom.TagName("DETAILS"), goog.dom.TagName.DFN = new goog.dom.TagName("DFN"), goog.dom.TagName.DIALOG = new goog.dom.TagName("DIALOG"), goog.dom.TagName.DIR = new goog.dom.TagName("DIR"), goog.dom.TagName.DIV = new goog.dom.TagName("DIV"), goog.dom.TagName.DL = new goog.dom.TagName("DL"), goog.dom.TagName.DT = new goog.dom.TagName("DT"), goog.dom.TagName.EM = new goog.dom.TagName("EM"), goog.dom.TagName.EMBED = new goog.dom.TagName("EMBED"), goog.dom.TagName.FIELDSET = new goog.dom.TagName("FIELDSET"), goog.dom.TagName.FIGCAPTION = new goog.dom.TagName("FIGCAPTION"), goog.dom.TagName.FIGURE = new goog.dom.TagName("FIGURE"), goog.dom.TagName.FONT = new goog.dom.TagName("FONT"), goog.dom.TagName.FOOTER = new goog.dom.TagName("FOOTER"), goog.dom.TagName.FORM = new goog.dom.TagName("FORM"), goog.dom.TagName.FRAME = new goog.dom.TagName("FRAME"), goog.dom.TagName.FRAMESET = new goog.dom.TagName("FRAMESET"), goog.dom.TagName.H1 = new goog.dom.TagName("H1"), goog.dom.TagName.H2 = new goog.dom.TagName("H2"), goog.dom.TagName.H3 = new goog.dom.TagName("H3"), goog.dom.TagName.H4 = new goog.dom.TagName("H4"), goog.dom.TagName.H5 = new goog.dom.TagName("H5"), goog.dom.TagName.H6 = new goog.dom.TagName("H6"), goog.dom.TagName.HEAD = new goog.dom.TagName("HEAD"), goog.dom.TagName.HEADER = new goog.dom.TagName("HEADER"), goog.dom.TagName.HGROUP = new goog.dom.TagName("HGROUP"), goog.dom.TagName.HR = new goog.dom.TagName("HR"), goog.dom.TagName.HTML = new goog.dom.TagName("HTML"), goog.dom.TagName.I = new goog.dom.TagName("I"), goog.dom.TagName.IFRAME = new goog.dom.TagName("IFRAME"), goog.dom.TagName.IMG = new goog.dom.TagName("IMG"), goog.dom.TagName.INPUT = new goog.dom.TagName("INPUT"), goog.dom.TagName.INS = new goog.dom.TagName("INS"), goog.dom.TagName.ISINDEX = new goog.dom.TagName("ISINDEX"), goog.dom.TagName.KBD = new goog.dom.TagName("KBD"), goog.dom.TagName.KEYGEN = new goog.dom.TagName("KEYGEN"), goog.dom.TagName.LABEL = new goog.dom.TagName("LABEL"), goog.dom.TagName.LEGEND = new goog.dom.TagName("LEGEND"), goog.dom.TagName.LI = new goog.dom.TagName("LI"), goog.dom.TagName.LINK = new goog.dom.TagName("LINK"), goog.dom.TagName.MAIN = new goog.dom.TagName("MAIN"), goog.dom.TagName.MAP = new goog.dom.TagName("MAP"), goog.dom.TagName.MARK = new goog.dom.TagName("MARK"), goog.dom.TagName.MATH = new goog.dom.TagName("MATH"), goog.dom.TagName.MENU = new goog.dom.TagName("MENU"), goog.dom.TagName.MENUITEM = new goog.dom.TagName("MENUITEM"), goog.dom.TagName.META = new goog.dom.TagName("META"), goog.dom.TagName.METER = new goog.dom.TagName("METER"), goog.dom.TagName.NAV = new goog.dom.TagName("NAV"), goog.dom.TagName.NOFRAMES = new goog.dom.TagName("NOFRAMES"), goog.dom.TagName.NOSCRIPT = new goog.dom.TagName("NOSCRIPT"), goog.dom.TagName.OBJECT = new goog.dom.TagName("OBJECT"), goog.dom.TagName.OL = new goog.dom.TagName("OL"), goog.dom.TagName.OPTGROUP = new goog.dom.TagName("OPTGROUP"), goog.dom.TagName.OPTION = new goog.dom.TagName("OPTION"), goog.dom.TagName.OUTPUT = new goog.dom.TagName("OUTPUT"), goog.dom.TagName.P = new goog.dom.TagName("P"), goog.dom.TagName.PARAM = new goog.dom.TagName("PARAM"), goog.dom.TagName.PICTURE = new goog.dom.TagName("PICTURE"), goog.dom.TagName.PRE = new goog.dom.TagName("PRE"), goog.dom.TagName.PROGRESS = new goog.dom.TagName("PROGRESS"), goog.dom.TagName.Q = new goog.dom.TagName("Q"), goog.dom.TagName.RP = new goog.dom.TagName("RP"), goog.dom.TagName.RT = new goog.dom.TagName("RT"), goog.dom.TagName.RTC = new goog.dom.TagName("RTC"), goog.dom.TagName.RUBY = new goog.dom.TagName("RUBY"), goog.dom.TagName.S = new goog.dom.TagName("S"), goog.dom.TagName.SAMP = new goog.dom.TagName("SAMP"), goog.dom.TagName.SCRIPT = new goog.dom.TagName("SCRIPT"), goog.dom.TagName.SECTION = new goog.dom.TagName("SECTION"), goog.dom.TagName.SELECT = new goog.dom.TagName("SELECT"), goog.dom.TagName.SMALL = new goog.dom.TagName("SMALL"), goog.dom.TagName.SOURCE = new goog.dom.TagName("SOURCE"), goog.dom.TagName.SPAN = new goog.dom.TagName("SPAN"), goog.dom.TagName.STRIKE = new goog.dom.TagName("STRIKE"), goog.dom.TagName.STRONG = new goog.dom.TagName("STRONG"), goog.dom.TagName.STYLE = new goog.dom.TagName("STYLE"), goog.dom.TagName.SUB = new goog.dom.TagName("SUB"), goog.dom.TagName.SUMMARY = new goog.dom.TagName("SUMMARY"), goog.dom.TagName.SUP = new goog.dom.TagName("SUP"), goog.dom.TagName.SVG = new goog.dom.TagName("SVG"), goog.dom.TagName.TABLE = new goog.dom.TagName("TABLE"), goog.dom.TagName.TBODY = new goog.dom.TagName("TBODY"), goog.dom.TagName.TD = new goog.dom.TagName("TD"), goog.dom.TagName.TEMPLATE = new goog.dom.TagName("TEMPLATE"), goog.dom.TagName.TEXTAREA = new goog.dom.TagName("TEXTAREA"), goog.dom.TagName.TFOOT = new goog.dom.TagName("TFOOT"), goog.dom.TagName.TH = new goog.dom.TagName("TH"), goog.dom.TagName.THEAD = new goog.dom.TagName("THEAD"), goog.dom.TagName.TIME = new goog.dom.TagName("TIME"), goog.dom.TagName.TITLE = new goog.dom.TagName("TITLE"), goog.dom.TagName.TR = new goog.dom.TagName("TR"), goog.dom.TagName.TRACK = new goog.dom.TagName("TRACK"), goog.dom.TagName.TT = new goog.dom.TagName("TT"), goog.dom.TagName.U = new goog.dom.TagName("U"), goog.dom.TagName.UL = new goog.dom.TagName("UL"), goog.dom.TagName.VAR = new goog.dom.TagName("VAR"), goog.dom.TagName.VIDEO = new goog.dom.TagName("VIDEO"), goog.dom.TagName.WBR = new goog.dom.TagName("WBR"), goog.dom.tags = {}, goog.dom.tags.VOID_TAGS_ = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, goog.dom.tags.isVoidTag = function(se) {
    return goog.dom.tags.VOID_TAGS_[se] === !0;
  }, goog.html = {}, goog.html.trustedtypes = {}, goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#html") : null, goog.string = {}, goog.string.TypedString = function() {
  }, goog.string.Const = function(se, e) {
    this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = se === goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ && e || "", this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_;
  }, goog.string.Const.prototype.implementsGoogStringTypedString = !0, goog.string.Const.prototype.getTypedStringValue = function() {
    return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
  }, goog.DEBUG && (goog.string.Const.prototype.toString = function() {
    return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}";
  }), goog.string.Const.unwrap = function(se) {
    return se instanceof goog.string.Const && se.constructor === goog.string.Const && se.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_ ? se.stringConstValueWithSecurityContract__googStringSecurityPrivate_ : (goog.asserts.fail("expected object of type Const, got '" + se + "'"), "type_error:Const");
  }, goog.string.Const.from = function(se) {
    return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, se);
  }, goog.string.Const.TYPE_MARKER_ = {}, goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.Const.EMPTY = goog.string.Const.from(""), goog.html.SafeScript = function() {
    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "", this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeScript.prototype.implementsGoogStringTypedString = !0, goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeScript.fromConstant = function(se) {
    return se = goog.string.Const.unwrap(se), se.length === 0 ? goog.html.SafeScript.EMPTY : goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeScript.fromConstantAndArgs = function(se, e) {
    for (var Oe = [], Si = 1; Si < arguments.length; Si++)
      Oe.push(goog.html.SafeScript.stringify_(arguments[Si]));
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("(" + goog.string.Const.unwrap(se) + ")(" + Oe.join(", ") + ");");
  }, goog.html.SafeScript.fromJson = function(se) {
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(se));
  }, goog.html.SafeScript.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
  }, goog.DEBUG && (goog.html.SafeScript.prototype.toString = function() {
    return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}";
  }), goog.html.SafeScript.unwrap = function(se) {
    return goog.html.SafeScript.unwrapTrustedScript(se).toString();
  }, goog.html.SafeScript.unwrapTrustedScript = function(se) {
    return se instanceof goog.html.SafeScript && se.constructor === goog.html.SafeScript && se.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? se.privateDoNotAccessOrElseSafeScriptWrappedValue_ : (goog.asserts.fail("expected object of type SafeScript, got '" + se + "' of type " + goog.typeOf(se)), "type_error:SafeScript");
  }, goog.html.SafeScript.stringify_ = function(se) {
    return JSON.stringify(se).replace(/</g, "\\x3c");
  }, goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(se) {
    return new goog.html.SafeScript().initSecurityPrivateDoNotAccessOrElse_(se);
  }, goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(se) {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(se) : se, this;
  }, goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(""), goog.fs = {}, goog.fs.url = {}, goog.fs.url.createObjectUrl = function(se) {
    return goog.fs.url.getUrlObject_().createObjectURL(se);
  }, goog.fs.url.revokeObjectUrl = function(se) {
    goog.fs.url.getUrlObject_().revokeObjectURL(se);
  }, goog.fs.url.UrlObject_ = function() {
  }, goog.fs.url.UrlObject_.prototype.createObjectURL = function(se) {
  }, goog.fs.url.UrlObject_.prototype.revokeObjectURL = function(se) {
  }, goog.fs.url.getUrlObject_ = function() {
    var se = goog.fs.url.findUrlObject_();
    if (se != null)
      return se;
    throw Error("This browser doesn't seem to support blob URLs");
  }, goog.fs.url.findUrlObject_ = function() {
    return goog.global.URL !== void 0 && goog.global.URL.createObjectURL !== void 0 ? goog.global.URL : goog.global.webkitURL !== void 0 && goog.global.webkitURL.createObjectURL !== void 0 ? goog.global.webkitURL : goog.global.createObjectURL !== void 0 ? goog.global : null;
  }, goog.fs.url.browserSupportsObjectUrls = function() {
    return goog.fs.url.findUrlObject_() != null;
  }, goog.fs.blob = {}, goog.fs.blob.getBlob = function(se) {
    var e = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
    if (e !== void 0) {
      e = new e();
      for (var Oe = 0; Oe < arguments.length; Oe++)
        e.append(arguments[Oe]);
      return e.getBlob();
    }
    return goog.fs.blob.getBlobWithProperties(goog.array.toArray(arguments));
  }, goog.fs.blob.getBlobWithProperties = function(se, e, Oe) {
    var Si = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
    if (Si !== void 0) {
      Si = new Si();
      for (var wi = 0; wi < se.length; wi++)
        Si.append(se[wi], Oe);
      return Si.getBlob(e);
    }
    if (goog.global.Blob !== void 0)
      return Si = {}, e && (Si.type = e), Oe && (Si.endings = Oe), new Blob(se, Si);
    throw Error("This browser doesn't seem to support creating Blobs");
  }, goog.i18n = {}, goog.i18n.bidi = {}, goog.i18n.bidi.FORCE_RTL = !1, goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == "ar" || goog.LOCALE.substring(0, 2).toLowerCase() == "fa" || goog.LOCALE.substring(0, 2).toLowerCase() == "he" || goog.LOCALE.substring(0, 2).toLowerCase() == "iw" || goog.LOCALE.substring(0, 2).toLowerCase() == "ps" || goog.LOCALE.substring(0, 2).toLowerCase() == "sd" || goog.LOCALE.substring(0, 2).toLowerCase() == "ug" || goog.LOCALE.substring(0, 2).toLowerCase() == "ur" || goog.LOCALE.substring(0, 2).toLowerCase() == "yi") && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") || 3 <= goog.LOCALE.length && goog.LOCALE.substring(0, 3).toLowerCase() == "ckb" && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") || 7 <= goog.LOCALE.length && (goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") && (goog.LOCALE.substring(3, 7).toLowerCase() == "adlm" || goog.LOCALE.substring(3, 7).toLowerCase() == "arab" || goog.LOCALE.substring(3, 7).toLowerCase() == "hebr" || goog.LOCALE.substring(
    3,
    7
  ).toLowerCase() == "nkoo" || goog.LOCALE.substring(3, 7).toLowerCase() == "rohg" || goog.LOCALE.substring(3, 7).toLowerCase() == "thaa") || 8 <= goog.LOCALE.length && (goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") && (goog.LOCALE.substring(4, 8).toLowerCase() == "adlm" || goog.LOCALE.substring(4, 8).toLowerCase() == "arab" || goog.LOCALE.substring(4, 8).toLowerCase() == "hebr" || goog.LOCALE.substring(4, 8).toLowerCase() == "nkoo" || goog.LOCALE.substring(4, 8).toLowerCase() == "rohg" || goog.LOCALE.substring(4, 8).toLowerCase() == "thaa"), goog.i18n.bidi.Format = { LRE: "‪", RLE: "‫", PDF: "‬", LRM: "‎", RLM: "‏" }, goog.i18n.bidi.Dir = { LTR: 1, RTL: -1, NEUTRAL: 0 }, goog.i18n.bidi.RIGHT = "right", goog.i18n.bidi.LEFT = "left", goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT, goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, goog.i18n.bidi.toDir = function(se, e) {
    return typeof se == "number" ? 0 < se ? goog.i18n.bidi.Dir.LTR : 0 > se ? goog.i18n.bidi.Dir.RTL : e ? null : goog.i18n.bidi.Dir.NEUTRAL : se == null ? null : se ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }, goog.i18n.bidi.ltrChars_ = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ऀ-῿‎Ⰰ-\uD801\uD804-\uD839\uD83C-\uDBFF豈-﬜︀-﹯﻽-￿", goog.i18n.bidi.rtlChars_ = "֑-ۯۺ-ࣿ‏\uD802-\uD803\uD83A-\uD83Bיִ-﷿ﹰ-ﻼ", goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g, goog.i18n.bidi.stripHtmlIfNeeded_ = function(se, e) {
    return e ? se.replace(goog.i18n.bidi.htmlSkipReg_, "") : se;
  }, goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.hasAnyRtl = function(se, e) {
    return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(se, e));
  }, goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl, goog.i18n.bidi.hasAnyLtr = function(se, e) {
    return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(se, e));
  }, goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.isRtlChar = function(se) {
    return goog.i18n.bidi.rtlRe_.test(se);
  }, goog.i18n.bidi.isLtrChar = function(se) {
    return goog.i18n.bidi.ltrRe_.test(se);
  }, goog.i18n.bidi.isNeutralChar = function(se) {
    return !goog.i18n.bidi.isLtrChar(se) && !goog.i18n.bidi.isRtlChar(se);
  }, goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.startsWithRtl = function(se, e) {
    return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(se, e));
  }, goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl, goog.i18n.bidi.startsWithLtr = function(se, e) {
    return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(se, e));
  }, goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr, goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/, goog.i18n.bidi.isNeutralText = function(se, e) {
    return se = goog.i18n.bidi.stripHtmlIfNeeded_(se, e), goog.i18n.bidi.isRequiredLtrRe_.test(se) || !goog.i18n.bidi.hasAnyLtr(se) && !goog.i18n.bidi.hasAnyRtl(se);
  }, goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "][^" + goog.i18n.bidi.rtlChars_ + "]*$"), goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "][^" + goog.i18n.bidi.ltrChars_ + "]*$"), goog.i18n.bidi.endsWithLtr = function(se, e) {
    return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(se, e));
  }, goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr, goog.i18n.bidi.endsWithRtl = function(se, e) {
    return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(se, e));
  }, goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl, goog.i18n.bidi.rtlLocalesRe_ = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i, goog.i18n.bidi.isRtlLanguage = function(se) {
    return goog.i18n.bidi.rtlLocalesRe_.test(se);
  }, goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g, goog.i18n.bidi.guardBracketInText = function(se, e) {
    return e = (e === void 0 ? goog.i18n.bidi.hasAnyRtl(se) : e) ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM, se.replace(goog.i18n.bidi.bracketGuardTextRe_, e + "$&" + e);
  }, goog.i18n.bidi.enforceRtlInHtml = function(se) {
    return se.charAt(0) == "<" ? se.replace(/<\w+/, "$& dir=rtl") : `
<span dir=rtl>` + se + "</span>";
  }, goog.i18n.bidi.enforceRtlInText = function(se) {
    return goog.i18n.bidi.Format.RLE + se + goog.i18n.bidi.Format.PDF;
  }, goog.i18n.bidi.enforceLtrInHtml = function(se) {
    return se.charAt(0) == "<" ? se.replace(/<\w+/, "$& dir=ltr") : `
<span dir=ltr>` + se + "</span>";
  }, goog.i18n.bidi.enforceLtrInText = function(se) {
    return goog.i18n.bidi.Format.LRE + se + goog.i18n.bidi.Format.PDF;
  }, goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g, goog.i18n.bidi.leftRe_ = /left/gi, goog.i18n.bidi.rightRe_ = /right/gi, goog.i18n.bidi.tempRe_ = /%%%%/g, goog.i18n.bidi.mirrorCSS = function(se) {
    return se.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
  }, goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g, goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g, goog.i18n.bidi.normalizeHebrewQuote = function(se) {
    return se.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1״").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1׳");
  }, goog.i18n.bidi.wordSeparatorRe_ = /\s+/, goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/, goog.i18n.bidi.rtlDetectionThreshold_ = 0.4, goog.i18n.bidi.estimateDirection = function(se, e) {
    var Oe = 0, Si = 0, wi = !1;
    for (se = goog.i18n.bidi.stripHtmlIfNeeded_(se, e).split(goog.i18n.bidi.wordSeparatorRe_), e = 0; e < se.length; e++) {
      var Ei = se[e];
      goog.i18n.bidi.startsWithRtl(Ei) ? (Oe++, Si++) : goog.i18n.bidi.isRequiredLtrRe_.test(Ei) ? wi = !0 : goog.i18n.bidi.hasAnyLtr(Ei) ? Si++ : goog.i18n.bidi.hasNumeralsRe_.test(Ei) && (wi = !0);
    }
    return Si == 0 ? wi ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : Oe / Si > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }, goog.i18n.bidi.detectRtlDirectionality = function(se, e) {
    return goog.i18n.bidi.estimateDirection(se, e) == goog.i18n.bidi.Dir.RTL;
  }, goog.i18n.bidi.setElementDirAndAlign = function(se, e) {
    se && (e = goog.i18n.bidi.toDir(e)) && (se.style.textAlign = e == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, se.dir = e == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
  }, goog.i18n.bidi.setElementDirByTextDirectionality = function(se, e) {
    switch (goog.i18n.bidi.estimateDirection(e)) {
      case goog.i18n.bidi.Dir.LTR:
        se.dir = "ltr";
        break;
      case goog.i18n.bidi.Dir.RTL:
        se.dir = "rtl";
        break;
      default:
        se.removeAttribute("dir");
    }
  }, goog.i18n.bidi.DirectionalString = function() {
  }, goog.html.TrustedResourceUrl = function(se, e) {
    this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = se === goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && e || "", this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = !0, goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString();
  }, goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.TrustedResourceUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR;
  }, goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(se, e) {
    var Oe = goog.html.TrustedResourceUrl.unwrap(this);
    Oe = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(Oe);
    var Si = Oe[3] || "";
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(Oe[1] + goog.html.TrustedResourceUrl.stringifyParams_("?", Oe[2] || "", se) + goog.html.TrustedResourceUrl.stringifyParams_("#", Si, e));
  }, goog.DEBUG && (goog.html.TrustedResourceUrl.prototype.toString = function() {
    return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}";
  }), goog.html.TrustedResourceUrl.unwrap = function(se) {
    return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(se).toString();
  }, goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(se) {
    return se instanceof goog.html.TrustedResourceUrl && se.constructor === goog.html.TrustedResourceUrl && se.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? se.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ : (goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + se + "' of type " + goog.typeOf(se)), "type_error:TrustedResourceUrl");
  }, goog.html.TrustedResourceUrl.format = function(se, e) {
    var Oe = goog.string.Const.unwrap(se);
    if (!goog.html.TrustedResourceUrl.BASE_URL_.test(Oe))
      throw Error("Invalid TrustedResourceUrl format: " + Oe);
    return se = Oe.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(Si, wi) {
      if (!Object.prototype.hasOwnProperty.call(e, wi))
        throw Error('Found marker, "' + wi + '", in format string, "' + Oe + '", but no valid label mapping found in args: ' + JSON.stringify(e));
      return Si = e[wi], Si instanceof goog.string.Const ? goog.string.Const.unwrap(Si) : encodeURIComponent(String(Si));
    }), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g, goog.html.TrustedResourceUrl.BASE_URL_ = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ = /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/, goog.html.TrustedResourceUrl.formatWithParams = function(se, e, Oe, Si) {
    return goog.html.TrustedResourceUrl.format(se, e).cloneWithParams(Oe, Si);
  }, goog.html.TrustedResourceUrl.fromConstant = function(se) {
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(se));
  }, goog.html.TrustedResourceUrl.fromConstants = function(se) {
    for (var e = "", Oe = 0; Oe < se.length; Oe++)
      e += goog.string.Const.unwrap(se[Oe]);
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.TrustedResourceUrl.fromSafeScript = function(se) {
    return se = goog.fs.blob.getBlobWithProperties([goog.html.SafeScript.unwrap(se)], "text/javascript"), se = goog.fs.url.createObjectUrl(se), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(se) {
    return se = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(se) : se, new goog.html.TrustedResourceUrl(goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_, se);
  }, goog.html.TrustedResourceUrl.stringifyParams_ = function(se, e, Oe) {
    if (Oe == null)
      return e;
    if (typeof Oe == "string")
      return Oe ? se + encodeURIComponent(Oe) : "";
    for (var Si in Oe) {
      var wi = Oe[Si];
      wi = Array.isArray(wi) ? wi : [wi];
      for (var Ei = 0; Ei < wi.length; Ei++) {
        var $i = wi[Ei];
        $i != null && (e || (e = se), e += (e.length > se.length ? "&" : "") + encodeURIComponent(Si) + "=" + encodeURIComponent(String($i)));
      }
    }
    return e;
  }, goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.internal = {}, goog.string.internal.startsWith = function(se, e) {
    return se.lastIndexOf(e, 0) == 0;
  }, goog.string.internal.endsWith = function(se, e) {
    var Oe = se.length - e.length;
    return 0 <= Oe && se.indexOf(e, Oe) == Oe;
  }, goog.string.internal.caseInsensitiveStartsWith = function(se, e) {
    return goog.string.internal.caseInsensitiveCompare(e, se.substr(0, e.length)) == 0;
  }, goog.string.internal.caseInsensitiveEndsWith = function(se, e) {
    return goog.string.internal.caseInsensitiveCompare(e, se.substr(se.length - e.length, e.length)) == 0;
  }, goog.string.internal.caseInsensitiveEquals = function(se, e) {
    return se.toLowerCase() == e.toLowerCase();
  }, goog.string.internal.isEmptyOrWhitespace = function(se) {
    return /^[\s\xa0]*$/.test(se);
  }, goog.string.internal.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(se) {
    return se.trim();
  } : function(se) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(se)[1];
  }, goog.string.internal.caseInsensitiveCompare = function(se, e) {
    return se = String(se).toLowerCase(), e = String(e).toLowerCase(), se < e ? -1 : se == e ? 0 : 1;
  }, goog.string.internal.newLineToBr = function(se, e) {
    return se.replace(/(\r\n|\r|\n)/g, e ? "<br />" : "<br>");
  }, goog.string.internal.htmlEscape = function(se, e) {
    if (e)
      se = se.replace(goog.string.internal.AMP_RE_, "&amp;").replace(goog.string.internal.LT_RE_, "&lt;").replace(goog.string.internal.GT_RE_, "&gt;").replace(goog.string.internal.QUOT_RE_, "&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.internal.NULL_RE_, "&#0;");
    else {
      if (!goog.string.internal.ALL_RE_.test(se))
        return se;
      se.indexOf("&") != -1 && (se = se.replace(goog.string.internal.AMP_RE_, "&amp;")), se.indexOf("<") != -1 && (se = se.replace(
        goog.string.internal.LT_RE_,
        "&lt;"
      )), se.indexOf(">") != -1 && (se = se.replace(goog.string.internal.GT_RE_, "&gt;")), se.indexOf('"') != -1 && (se = se.replace(goog.string.internal.QUOT_RE_, "&quot;")), se.indexOf("'") != -1 && (se = se.replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;")), se.indexOf("\0") != -1 && (se = se.replace(goog.string.internal.NULL_RE_, "&#0;"));
    }
    return se;
  }, goog.string.internal.AMP_RE_ = /&/g, goog.string.internal.LT_RE_ = /</g, goog.string.internal.GT_RE_ = />/g, goog.string.internal.QUOT_RE_ = /"/g, goog.string.internal.SINGLE_QUOTE_RE_ = /'/g, goog.string.internal.NULL_RE_ = /\x00/g, goog.string.internal.ALL_RE_ = /[\x00&<>"']/, goog.string.internal.whitespaceEscape = function(se, e) {
    return goog.string.internal.newLineToBr(se.replace(/  /g, " &#160;"), e);
  }, goog.string.internal.contains = function(se, e) {
    return se.indexOf(e) != -1;
  }, goog.string.internal.caseInsensitiveContains = function(se, e) {
    return goog.string.internal.contains(se.toLowerCase(), e.toLowerCase());
  }, goog.string.internal.compareVersions = function(se, e) {
    var Oe = 0;
    se = goog.string.internal.trim(String(se)).split("."), e = goog.string.internal.trim(String(e)).split(".");
    for (var Si = Math.max(se.length, e.length), wi = 0; Oe == 0 && wi < Si; wi++) {
      var Ei = se[wi] || "", $i = e[wi] || "";
      do {
        if (Ei = /(\d*)(\D*)(.*)/.exec(Ei) || ["", "", "", ""], $i = /(\d*)(\D*)(.*)/.exec($i) || ["", "", "", ""], Ei[0].length == 0 && $i[0].length == 0)
          break;
        Oe = Ei[1].length == 0 ? 0 : parseInt(Ei[1], 10);
        var xi = $i[1].length == 0 ? 0 : parseInt($i[1], 10);
        Oe = goog.string.internal.compareElements_(Oe, xi) || goog.string.internal.compareElements_(Ei[2].length == 0, $i[2].length == 0) || goog.string.internal.compareElements_(Ei[2], $i[2]), Ei = Ei[3], $i = $i[3];
      } while (Oe == 0);
    }
    return Oe;
  }, goog.string.internal.compareElements_ = function(se, e) {
    return se < e ? -1 : se > e ? 1 : 0;
  }, goog.html.SafeUrl = function(se, e) {
    this.privateDoNotAccessOrElseSafeUrlWrappedValue_ = se === goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && e || "", this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez", goog.html.SafeUrl.prototype.implementsGoogStringTypedString = !0, goog.html.SafeUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
  }, goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.SafeUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR;
  }, goog.DEBUG && (goog.html.SafeUrl.prototype.toString = function() {
    return "SafeUrl{" + this.privateDoNotAccessOrElseSafeUrlWrappedValue_ + "}";
  }), goog.html.SafeUrl.unwrap = function(se) {
    return se instanceof goog.html.SafeUrl && se.constructor === goog.html.SafeUrl && se.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? se.privateDoNotAccessOrElseSafeUrlWrappedValue_ : (goog.asserts.fail("expected object of type SafeUrl, got '" + se + "' of type " + goog.typeOf(se)), "type_error:SafeUrl");
  }, goog.html.SafeUrl.fromConstant = function(se) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(se));
  }, goog.html.SAFE_MIME_TYPE_PATTERN_ = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i, goog.html.SafeUrl.isSafeMimeType = function(se) {
    return goog.html.SAFE_MIME_TYPE_PATTERN_.test(se);
  }, goog.html.SafeUrl.fromBlob = function(se) {
    return se = goog.html.SafeUrl.isSafeMimeType(se.type) ? goog.fs.url.createObjectUrl(se) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeUrl.fromMediaSource = function(se) {
    return goog.asserts.assert("MediaSource" in goog.global, "No support for MediaSource"), se = se instanceof MediaSource ? goog.fs.url.createObjectUrl(se) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.DATA_URL_PATTERN_ = /^data:(.*);base64,[a-z0-9+\/]+=*$/i, goog.html.SafeUrl.fromDataUrl = function(se) {
    se = se.replace(/(%0A|%0D)/g, "");
    var e = se.match(goog.html.DATA_URL_PATTERN_);
    return e = e && goog.html.SafeUrl.isSafeMimeType(e[1]), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e ? se : goog.html.SafeUrl.INNOCUOUS_STRING);
  }, goog.html.SafeUrl.fromTelUrl = function(se) {
    return goog.string.internal.caseInsensitiveStartsWith(se, "tel:") || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SIP_URL_PATTERN_ = /^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i, goog.html.SafeUrl.fromSipUrl = function(se) {
    return goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(se)) || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeUrl.fromFacebookMessengerUrl = function(se) {
    return goog.string.internal.caseInsensitiveStartsWith(se, "fb-messenger://share") || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeUrl.fromWhatsAppUrl = function(se) {
    return goog.string.internal.caseInsensitiveStartsWith(se, "whatsapp://send") || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeUrl.fromSmsUrl = function(se) {
    return goog.string.internal.caseInsensitiveStartsWith(se, "sms:") && goog.html.SafeUrl.isSmsUrlBodyValid_(se) || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeUrl.isSmsUrlBodyValid_ = function(se) {
    var e = se.indexOf("#");
    if (0 < e && (se = se.substring(0, e)), e = se.match(/[?&]body=/gi), !e)
      return !0;
    if (1 < e.length)
      return !1;
    if (se = se.match(/[?&]body=([^&]*)/)[1], !se)
      return !0;
    try {
      decodeURIComponent(se);
    } catch {
      return !1;
    }
    return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(se);
  }, goog.html.SafeUrl.fromSshUrl = function(se) {
    return goog.string.internal.caseInsensitiveStartsWith(se, "ssh://") || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(se, e) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//, se, e);
  }, goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(se, e) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//, se, e);
  }, goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(se, e) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//, se, e);
  }, goog.html.SafeUrl.sanitizeExtensionUrl_ = function(se, e, Oe) {
    return (se = se.exec(e)) ? (se = se[1], (Oe instanceof goog.string.Const ? [goog.string.Const.unwrap(Oe)] : Oe.map(function(Si) {
      return goog.string.Const.unwrap(Si);
    })).indexOf(se) == -1 && (e = goog.html.SafeUrl.INNOCUOUS_STRING)) : e = goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.SafeUrl.fromTrustedResourceUrl = function(se) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(se));
  }, goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i, goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_, goog.html.SafeUrl.sanitize = function(se) {
    return se instanceof goog.html.SafeUrl ? se : (se = typeof se == "object" && se.implementsGoogStringTypedString ? se.getTypedStringValue() : String(se), goog.html.SAFE_URL_PATTERN_.test(se) || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se));
  }, goog.html.SafeUrl.sanitizeAssertUnchanged = function(se, e) {
    return se instanceof goog.html.SafeUrl ? se : (se = typeof se == "object" && se.implementsGoogStringTypedString ? se.getTypedStringValue() : String(se), e && /^data:/i.test(se) && (e = goog.html.SafeUrl.fromDataUrl(se), e.getTypedStringValue() == se) ? e : (goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(se), "%s does not match the safe URL pattern", se) || (se = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(se)));
  }, goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(se) {
    return new goog.html.SafeUrl(goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_, se);
  }, goog.html.SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank"), goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.html.SafeStyle = function() {
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "", this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeStyle.prototype.implementsGoogStringTypedString = !0, goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyle.fromConstant = function(se) {
    return se = goog.string.Const.unwrap(se), se.length === 0 ? goog.html.SafeStyle.EMPTY : (goog.asserts.assert(goog.string.internal.endsWith(se, ";"), "Last character of style string is not ';': " + se), goog.asserts.assert(goog.string.internal.contains(se, ":"), `Style string must contain at least one ':', to specify a "name: value" pair: ` + se), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(se));
  }, goog.html.SafeStyle.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
  }, goog.DEBUG && (goog.html.SafeStyle.prototype.toString = function() {
    return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}";
  }), goog.html.SafeStyle.unwrap = function(se) {
    return se instanceof goog.html.SafeStyle && se.constructor === goog.html.SafeStyle && se.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? se.privateDoNotAccessOrElseSafeStyleWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyle, got '" + se + "' of type " + goog.typeOf(se)), "type_error:SafeStyle");
  }, goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(se) {
    return new goog.html.SafeStyle().initSecurityPrivateDoNotAccessOrElse_(se);
  }, goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(se) {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = se, this;
  }, goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(""), goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez", goog.html.SafeStyle.create = function(se) {
    var e = "", Oe;
    for (Oe in se) {
      if (!/^[-_a-zA-Z0-9]+$/.test(Oe))
        throw Error("Name allows only [-_a-zA-Z0-9], got: " + Oe);
      var Si = se[Oe];
      Si != null && (Si = Array.isArray(Si) ? goog.array.map(Si, goog.html.SafeStyle.sanitizePropertyValue_).join(" ") : goog.html.SafeStyle.sanitizePropertyValue_(Si), e += Oe + ":" + Si + ";");
    }
    return e ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e) : goog.html.SafeStyle.EMPTY;
  }, goog.html.SafeStyle.sanitizePropertyValue_ = function(se) {
    if (se instanceof goog.html.SafeUrl)
      return 'url("' + goog.html.SafeUrl.unwrap(se).replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")';
    if (se = se instanceof goog.string.Const ? goog.string.Const.unwrap(se) : goog.html.SafeStyle.sanitizePropertyValueString_(String(se)), /[{;}]/.test(se))
      throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.", [se]);
    return se;
  }, goog.html.SafeStyle.sanitizePropertyValueString_ = function(se) {
    var e = se.replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.URL_RE_, "url");
    if (goog.html.SafeStyle.VALUE_RE_.test(e)) {
      if (goog.html.SafeStyle.COMMENT_RE_.test(se))
        return goog.asserts.fail("String value disallows comments, got: " + se), goog.html.SafeStyle.INNOCUOUS_STRING;
      if (!goog.html.SafeStyle.hasBalancedQuotes_(se))
        return goog.asserts.fail("String value requires balanced quotes, got: " + se), goog.html.SafeStyle.INNOCUOUS_STRING;
      if (!goog.html.SafeStyle.hasBalancedSquareBrackets_(se))
        return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: " + se), goog.html.SafeStyle.INNOCUOUS_STRING;
    } else
      return goog.asserts.fail("String value allows only " + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + " and simple functions, got: " + se), goog.html.SafeStyle.INNOCUOUS_STRING;
    return goog.html.SafeStyle.sanitizeUrl_(se);
  }, goog.html.SafeStyle.hasBalancedQuotes_ = function(se) {
    for (var e = !0, Oe = !0, Si = 0; Si < se.length; Si++) {
      var wi = se.charAt(Si);
      wi == "'" && Oe ? e = !e : wi == '"' && e && (Oe = !Oe);
    }
    return e && Oe;
  }, goog.html.SafeStyle.hasBalancedSquareBrackets_ = function(se) {
    for (var e = !0, Oe = /^[-_a-zA-Z0-9]$/, Si = 0; Si < se.length; Si++) {
      var wi = se.charAt(Si);
      if (wi == "]") {
        if (e)
          return !1;
        e = !0;
      } else if (wi == "[") {
        if (!e)
          return !1;
        e = !1;
      } else if (!e && !Oe.test(wi))
        return !1;
    }
    return e;
  }, goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ = `[-,."'%_!# a-zA-Z0-9\\[\\]]`, goog.html.SafeStyle.VALUE_RE_ = new RegExp("^" + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + "+$"), goog.html.SafeStyle.URL_RE_ = /\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g, goog.html.SafeStyle.ALLOWED_FUNCTIONS_ = "calc cubic-bezier fit-content hsl hsla linear-gradient matrix minmax repeat rgb rgba (rotate|scale|translate)(X|Y|Z|3d)?".split(" "), goog.html.SafeStyle.FUNCTIONS_RE_ = new RegExp("\\b(" + goog.html.SafeStyle.ALLOWED_FUNCTIONS_.join("|") + ")\\([-+*/0-9a-z.%\\[\\], ]+\\)", "g"), goog.html.SafeStyle.COMMENT_RE_ = /\/\*/, goog.html.SafeStyle.sanitizeUrl_ = function(se) {
    return se.replace(goog.html.SafeStyle.URL_RE_, function(e, Oe, Si, wi) {
      var Ei = "";
      return Si = Si.replace(/^(['"])(.*)\1$/, function($i, xi, Ri) {
        return Ei = xi, Ri;
      }), e = goog.html.SafeUrl.sanitize(Si).getTypedStringValue(), Oe + Ei + e + Ei + wi;
    });
  }, goog.html.SafeStyle.concat = function(se) {
    var e = "", Oe = function(Si) {
      Array.isArray(Si) ? goog.array.forEach(Si, Oe) : e += goog.html.SafeStyle.unwrap(Si);
    };
    return goog.array.forEach(arguments, Oe), e ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e) : goog.html.SafeStyle.EMPTY;
  }, goog.html.SafeStyleSheet = function() {
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "", this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = !0, goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyleSheet.createRule = function(se, e) {
    if (goog.string.internal.contains(se, "<"))
      throw Error("Selector does not allow '<', got: " + se);
    var Oe = se.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");
    if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(Oe))
      throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: " + se);
    if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(Oe))
      throw Error("() and [] in selector must be balanced, got: " + se);
    return e instanceof goog.html.SafeStyle || (e = goog.html.SafeStyle.create(e)), se = se + "{" + goog.html.SafeStyle.unwrap(e).replace(/</g, "\\3C ") + "}", goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(se);
  }, goog.html.SafeStyleSheet.hasBalancedBrackets_ = function(se) {
    for (var e = { "(": ")", "[": "]" }, Oe = [], Si = 0; Si < se.length; Si++) {
      var wi = se[Si];
      if (e[wi])
        Oe.push(e[wi]);
      else if (goog.object.contains(e, wi) && Oe.pop() != wi)
        return !1;
    }
    return Oe.length == 0;
  }, goog.html.SafeStyleSheet.concat = function(se) {
    var e = "", Oe = function(Si) {
      Array.isArray(Si) ? goog.array.forEach(Si, Oe) : e += goog.html.SafeStyleSheet.unwrap(Si);
    };
    return goog.array.forEach(arguments, Oe), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.SafeStyleSheet.fromConstant = function(se) {
    return se = goog.string.Const.unwrap(se), se.length === 0 ? goog.html.SafeStyleSheet.EMPTY : (goog.asserts.assert(!goog.string.internal.contains(se, "<"), "Forbidden '<' character in style sheet string: " + se), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(se));
  }, goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
  }, goog.DEBUG && (goog.html.SafeStyleSheet.prototype.toString = function() {
    return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}";
  }), goog.html.SafeStyleSheet.unwrap = function(se) {
    return se instanceof goog.html.SafeStyleSheet && se.constructor === goog.html.SafeStyleSheet && se.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? se.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyleSheet, got '" + se + "' of type " + goog.typeOf(se)), "type_error:SafeStyleSheet");
  }, goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(se) {
    return new goog.html.SafeStyleSheet().initSecurityPrivateDoNotAccessOrElse_(se);
  }, goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(se) {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = se, this;
  }, goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(""), goog.labs = {}, goog.labs.userAgent = {}, goog.labs.userAgent.util = {}, goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
    var se = goog.labs.userAgent.util.getNavigator_();
    return se && (se = se.userAgent) ? se : "";
  }, goog.labs.userAgent.util.getNavigator_ = function() {
    return goog.global.navigator;
  }, goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_(), goog.labs.userAgent.util.setUserAgent = function(se) {
    goog.labs.userAgent.util.userAgent_ = se || goog.labs.userAgent.util.getNativeUserAgentString_();
  }, goog.labs.userAgent.util.getUserAgent = function() {
    return goog.labs.userAgent.util.userAgent_;
  }, goog.labs.userAgent.util.matchUserAgent = function(se) {
    var e = goog.labs.userAgent.util.getUserAgent();
    return goog.string.internal.contains(e, se);
  }, goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(se) {
    var e = goog.labs.userAgent.util.getUserAgent();
    return goog.string.internal.caseInsensitiveContains(e, se);
  }, goog.labs.userAgent.util.extractVersionTuples = function(se) {
    for (var e = /(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g, Oe = [], Si; Si = e.exec(se); )
      Oe.push([Si[1], Si[2], Si[3] || void 0]);
    return Oe;
  }, goog.labs.userAgent.browser = {}, goog.labs.userAgent.browser.matchOpera_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Opera");
  }, goog.labs.userAgent.browser.matchIE_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
  }, goog.labs.userAgent.browser.matchEdgeHtml_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge");
  }, goog.labs.userAgent.browser.matchEdgeChromium_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edg/");
  }, goog.labs.userAgent.browser.matchOperaChromium_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("OPR");
  }, goog.labs.userAgent.browser.matchFirefox_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Firefox") || goog.labs.userAgent.util.matchUserAgent("FxiOS");
  }, goog.labs.userAgent.browser.matchSafari_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdgeHtml_() || goog.labs.userAgent.browser.matchEdgeChromium_() || goog.labs.userAgent.browser.matchOperaChromium_() || goog.labs.userAgent.browser.matchFirefox_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"));
  }, goog.labs.userAgent.browser.matchCoast_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Coast");
  }, goog.labs.userAgent.browser.matchIosWebview_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && !goog.labs.userAgent.browser.matchFirefox_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit");
  }, goog.labs.userAgent.browser.matchChrome_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchEdgeHtml_();
  }, goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk());
  }, goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_, goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_, goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_, goog.labs.userAgent.browser.isEdgeChromium = goog.labs.userAgent.browser.matchEdgeChromium_, goog.labs.userAgent.browser.isOperaChromium = goog.labs.userAgent.browser.matchOperaChromium_, goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_, goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_, goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_, goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_, goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_, goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_, goog.labs.userAgent.browser.isSilk = function() {
    return goog.labs.userAgent.util.matchUserAgent("Silk");
  }, goog.labs.userAgent.browser.getVersion = function() {
    function se(wi) {
      return wi = goog.array.find(wi, Si), Oe[wi] || "";
    }
    var e = goog.labs.userAgent.util.getUserAgent();
    if (goog.labs.userAgent.browser.isIE())
      return goog.labs.userAgent.browser.getIEVersion_(e);
    e = goog.labs.userAgent.util.extractVersionTuples(e);
    var Oe = {};
    goog.array.forEach(e, function(wi) {
      Oe[wi[0]] = wi[1];
    });
    var Si = goog.partial(goog.object.containsKey, Oe);
    return goog.labs.userAgent.browser.isOpera() ? se(["Version", "Opera"]) : goog.labs.userAgent.browser.isEdge() ? se(["Edge"]) : goog.labs.userAgent.browser.isEdgeChromium() ? se(["Edg"]) : goog.labs.userAgent.browser.isChrome() ? se(["Chrome", "CriOS", "HeadlessChrome"]) : (e = e[2]) && e[1] || "";
  }, goog.labs.userAgent.browser.isVersionOrHigher = function(se) {
    return 0 <= goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(), se);
  }, goog.labs.userAgent.browser.getIEVersion_ = function(se) {
    var e = /rv: *([\d\.]*)/.exec(se);
    if (e && e[1])
      return e[1];
    e = "";
    var Oe = /MSIE +([\d\.]+)/.exec(se);
    if (Oe && Oe[1])
      if (se = /Trident\/(\d.\d)/.exec(se), Oe[1] == "7.0")
        if (se && se[1])
          switch (se[1]) {
            case "4.0":
              e = "8.0";
              break;
            case "5.0":
              e = "9.0";
              break;
            case "6.0":
              e = "10.0";
              break;
            case "7.0":
              e = "11.0";
          }
        else
          e = "7.0";
      else
        e = Oe[1];
    return e;
  }, goog.html.SafeHtml = function() {
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "", this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_, this.dir_ = null;
  }, goog.html.SafeHtml.ENABLE_ERROR_MESSAGES = goog.DEBUG, goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE = !0, goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.SafeHtml.prototype.getDirection = function() {
    return this.dir_;
  }, goog.html.SafeHtml.prototype.implementsGoogStringTypedString = !0, goog.html.SafeHtml.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
  }, goog.DEBUG && (goog.html.SafeHtml.prototype.toString = function() {
    return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
  }), goog.html.SafeHtml.unwrap = function(se) {
    return goog.html.SafeHtml.unwrapTrustedHTML(se).toString();
  }, goog.html.SafeHtml.unwrapTrustedHTML = function(se) {
    return se instanceof goog.html.SafeHtml && se.constructor === goog.html.SafeHtml && se.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? se.privateDoNotAccessOrElseSafeHtmlWrappedValue_ : (goog.asserts.fail("expected object of type SafeHtml, got '" + se + "' of type " + goog.typeOf(se)), "type_error:SafeHtml");
  }, goog.html.SafeHtml.htmlEscape = function(se) {
    if (se instanceof goog.html.SafeHtml)
      return se;
    var e = typeof se == "object", Oe = null;
    return e && se.implementsGoogI18nBidiDirectionalString && (Oe = se.getDirection()), se = e && se.implementsGoogStringTypedString ? se.getTypedStringValue() : String(se), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(se), Oe);
  }, goog.html.SafeHtml.htmlEscapePreservingNewlines = function(se) {
    return se instanceof goog.html.SafeHtml ? se : (se = goog.html.SafeHtml.htmlEscape(se), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(se)), se.getDirection()));
  }, goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(se) {
    return se instanceof goog.html.SafeHtml ? se : (se = goog.html.SafeHtml.htmlEscape(se), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(se)), se.getDirection()));
  }, goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape, goog.html.SafeHtml.comment = function(se) {
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!--" + goog.string.internal.htmlEscape(se) + "-->", null);
  }, goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/, goog.html.SafeHtml.URL_ATTRIBUTES_ = { action: !0, cite: !0, data: !0, formaction: !0, href: !0, manifest: !0, poster: !0, src: !0 }, goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = { APPLET: !0, BASE: !0, EMBED: !0, IFRAME: !0, LINK: !0, MATH: !0, META: !0, OBJECT: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 }, goog.html.SafeHtml.create = function(se, e, Oe) {
    return goog.html.SafeHtml.verifyTagName(String(se)), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(se), e, Oe);
  }, goog.html.SafeHtml.verifyTagName = function(se) {
    if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(se))
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Invalid tag name <" + se + ">." : "");
    if (se.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Tag name <" + se + "> is not allowed for SafeHtml." : "");
  }, goog.html.SafeHtml.createIframe = function(se, e, Oe, Si) {
    se && goog.html.TrustedResourceUrl.unwrap(se);
    var wi = {};
    return wi.src = se || null, wi.srcdoc = e && goog.html.SafeHtml.unwrap(e), se = goog.html.SafeHtml.combineAttributes(wi, { sandbox: "" }, Oe), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", se, Si);
  }, goog.html.SafeHtml.createSandboxIframe = function(se, e, Oe, Si) {
    if (!goog.html.SafeHtml.canUseSandboxIframe())
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "The browser does not support sandboxed iframes." : "");
    var wi = {};
    return wi.src = se ? goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(se)) : null, wi.srcdoc = e || null, wi.sandbox = "", se = goog.html.SafeHtml.combineAttributes(wi, {}, Oe), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", se, Si);
  }, goog.html.SafeHtml.canUseSandboxIframe = function() {
    return goog.global.HTMLIFrameElement && "sandbox" in goog.global.HTMLIFrameElement.prototype;
  }, goog.html.SafeHtml.createScriptSrc = function(se, e) {
    return goog.html.TrustedResourceUrl.unwrap(se), se = goog.html.SafeHtml.combineAttributes({ src: se }, {}, e), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", se);
  }, goog.html.SafeHtml.createScript = function(se, e) {
    for (var Oe in e) {
      var Si = Oe.toLowerCase();
      if (Si == "language" || Si == "src" || Si == "text" || Si == "type")
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot set "' + Si + '" attribute' : "");
    }
    for (Oe = "", se = goog.array.concat(se), Si = 0; Si < se.length; Si++)
      Oe += goog.html.SafeScript.unwrap(se[Si]);
    return se = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(Oe, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", e, se);
  }, goog.html.SafeHtml.createStyle = function(se, e) {
    e = goog.html.SafeHtml.combineAttributes({ type: "text/css" }, {}, e);
    var Oe = "";
    se = goog.array.concat(se);
    for (var Si = 0; Si < se.length; Si++)
      Oe += goog.html.SafeStyleSheet.unwrap(se[Si]);
    return se = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(Oe, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style", e, se);
  }, goog.html.SafeHtml.createMetaRefresh = function(se, e) {
    return se = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(se)), (goog.labs.userAgent.browser.isIE() || goog.labs.userAgent.browser.isEdge()) && goog.string.internal.contains(se, ";") && (se = "'" + se.replace(/'/g, "%27") + "'"), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta", { "http-equiv": "refresh", content: (e || 0) + "; url=" + se });
  }, goog.html.SafeHtml.getAttrNameAndValue_ = function(se, e, Oe) {
    if (Oe instanceof goog.string.Const)
      Oe = goog.string.Const.unwrap(Oe);
    else if (e.toLowerCase() == "style")
      if (goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE)
        Oe = goog.html.SafeHtml.getStyleValue_(Oe);
      else
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "style" not supported.' : "");
    else {
      if (/^on/i.test(e))
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + e + '" requires goog.string.Const value, "' + Oe + '" given.' : "");
      if (e.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_)
        if (Oe instanceof goog.html.TrustedResourceUrl)
          Oe = goog.html.TrustedResourceUrl.unwrap(Oe);
        else if (Oe instanceof goog.html.SafeUrl)
          Oe = goog.html.SafeUrl.unwrap(Oe);
        else if (typeof Oe == "string")
          Oe = goog.html.SafeUrl.sanitize(Oe).getTypedStringValue();
        else
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + e + '" on tag "' + se + '" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + Oe + '" given.' : "");
    }
    return Oe.implementsGoogStringTypedString && (Oe = Oe.getTypedStringValue()), goog.asserts.assert(typeof Oe == "string" || typeof Oe == "number", "String or number value expected, got " + typeof Oe + " with value: " + Oe), e + '="' + goog.string.internal.htmlEscape(String(Oe)) + '"';
  }, goog.html.SafeHtml.getStyleValue_ = function(se) {
    if (!goog.isObject(se))
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof se + " given: " + se : "");
    return se instanceof goog.html.SafeStyle || (se = goog.html.SafeStyle.create(se)), goog.html.SafeStyle.unwrap(se);
  }, goog.html.SafeHtml.createWithDir = function(se, e, Oe, Si) {
    return e = goog.html.SafeHtml.create(e, Oe, Si), e.dir_ = se, e;
  }, goog.html.SafeHtml.join = function(se, e) {
    se = goog.html.SafeHtml.htmlEscape(se);
    var Oe = se.getDirection(), Si = [], wi = function(Ei) {
      Array.isArray(Ei) ? goog.array.forEach(Ei, wi) : (Ei = goog.html.SafeHtml.htmlEscape(Ei), Si.push(goog.html.SafeHtml.unwrap(Ei)), Ei = Ei.getDirection(), Oe == goog.i18n.bidi.Dir.NEUTRAL ? Oe = Ei : Ei != goog.i18n.bidi.Dir.NEUTRAL && Oe != Ei && (Oe = null));
    };
    return goog.array.forEach(e, wi), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(Si.join(goog.html.SafeHtml.unwrap(se)), Oe);
  }, goog.html.SafeHtml.concat = function(se) {
    return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
  }, goog.html.SafeHtml.concatWithDir = function(se, e) {
    var Oe = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
    return Oe.dir_ = se, Oe;
  }, goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(se, e) {
    return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(se, e);
  }, goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(se, e) {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(se) : se, this.dir_ = e, this;
  }, goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(se, e, Oe) {
    var Si = null, wi = "<" + se + goog.html.SafeHtml.stringifyAttributes(se, e);
    return Oe == null ? Oe = [] : Array.isArray(Oe) || (Oe = [Oe]), goog.dom.tags.isVoidTag(se.toLowerCase()) ? (goog.asserts.assert(!Oe.length, "Void tag <" + se + "> does not allow content."), wi += ">") : (Si = goog.html.SafeHtml.concat(Oe), wi += ">" + goog.html.SafeHtml.unwrap(Si) + "</" + se + ">", Si = Si.getDirection()), (se = e && e.dir) && (Si = /^(ltr|rtl|auto)$/i.test(se) ? goog.i18n.bidi.Dir.NEUTRAL : null), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
      wi,
      Si
    );
  }, goog.html.SafeHtml.stringifyAttributes = function(se, e) {
    var Oe = "";
    if (e)
      for (var Si in e) {
        if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(Si))
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Invalid attribute name "' + Si + '".' : "");
        var wi = e[Si];
        wi != null && (Oe += " " + goog.html.SafeHtml.getAttrNameAndValue_(se, Si, wi));
      }
    return Oe;
  }, goog.html.SafeHtml.combineAttributes = function(se, e, Oe) {
    var Si = {}, wi;
    for (wi in se)
      goog.asserts.assert(wi.toLowerCase() == wi, "Must be lower case"), Si[wi] = se[wi];
    for (wi in e)
      goog.asserts.assert(wi.toLowerCase() == wi, "Must be lower case"), Si[wi] = e[wi];
    if (Oe)
      for (wi in Oe) {
        var Ei = wi.toLowerCase();
        if (Ei in se)
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot override "' + Ei + '" attribute, got "' + wi + '" with value "' + Oe[wi] + '"' : "");
        Ei in e && delete Si[Ei], Si[wi] = Oe[wi];
      }
    return Si;
  }, goog.html.SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.uncheckedconversions = {}, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(se, e, Oe) {
    return goog.asserts.assertString(goog.string.Const.unwrap(se), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(se)), "must provide non-empty justification"), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e, Oe || null);
  }, goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(se, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(se), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(se)), "must provide non-empty justification"), goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(se, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(se), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(se)), "must provide non-empty justification"), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(se, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(se), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(se)), "must provide non-empty justification"), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(se, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(se), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(se)), "must provide non-empty justification"), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(se, e) {
    return goog.asserts.assertString(goog.string.Const.unwrap(se), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(se)), "must provide non-empty justification"), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e);
  }, goog.dom.safe = {}, goog.dom.safe.InsertAdjacentHtmlPosition = { AFTERBEGIN: "afterbegin", AFTEREND: "afterend", BEFOREBEGIN: "beforebegin", BEFOREEND: "beforeend" }, goog.dom.safe.insertAdjacentHtml = function(se, e, Oe) {
    se.insertAdjacentHTML(e, goog.html.SafeHtml.unwrapTrustedHTML(Oe));
  }, goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = { MATH: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 }, goog.dom.safe.isInnerHtmlCleanupRecursive_ = goog.functions.cacheReturnValue(function() {
    if (goog.DEBUG && typeof document > "u")
      return !1;
    var se = document.createElement("div"), e = document.createElement("div");
    return e.appendChild(document.createElement("div")), se.appendChild(e), goog.DEBUG && !se.firstChild ? !1 : (e = se.firstChild.firstChild, se.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY), !e.parentElement);
  }), goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(se, e) {
    if (goog.dom.safe.isInnerHtmlCleanupRecursive_())
      for (; se.lastChild; )
        se.removeChild(se.lastChild);
    se.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(e);
  }, goog.dom.safe.setInnerHtml = function(se, e) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var Oe = se.tagName.toUpperCase();
      if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[Oe])
        throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + se.tagName + ".");
    }
    goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(se, e);
  }, goog.dom.safe.setOuterHtml = function(se, e) {
    se.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(e);
  }, goog.dom.safe.setFormElementAction = function(se, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), goog.dom.asserts.assertIsHTMLFormElement(se).action = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setButtonFormAction = function(se, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), goog.dom.asserts.assertIsHTMLButtonElement(se).formAction = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setInputFormAction = function(se, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), goog.dom.asserts.assertIsHTMLInputElement(se).formAction = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setStyle = function(se, e) {
    se.style.cssText = goog.html.SafeStyle.unwrap(e);
  }, goog.dom.safe.documentWrite = function(se, e) {
    se.write(goog.html.SafeHtml.unwrapTrustedHTML(e));
  }, goog.dom.safe.setAnchorHref = function(se, e) {
    goog.dom.asserts.assertIsHTMLAnchorElement(se), e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), se.href = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setImageSrc = function(se, e) {
    if (goog.dom.asserts.assertIsHTMLImageElement(se), !(e instanceof goog.html.SafeUrl)) {
      var Oe = /^data:image\//i.test(e);
      e = goog.html.SafeUrl.sanitizeAssertUnchanged(e, Oe);
    }
    se.src = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setAudioSrc = function(se, e) {
    if (goog.dom.asserts.assertIsHTMLAudioElement(se), !(e instanceof goog.html.SafeUrl)) {
      var Oe = /^data:audio\//i.test(e);
      e = goog.html.SafeUrl.sanitizeAssertUnchanged(e, Oe);
    }
    se.src = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setVideoSrc = function(se, e) {
    if (goog.dom.asserts.assertIsHTMLVideoElement(se), !(e instanceof goog.html.SafeUrl)) {
      var Oe = /^data:video\//i.test(e);
      e = goog.html.SafeUrl.sanitizeAssertUnchanged(e, Oe);
    }
    se.src = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.setEmbedSrc = function(se, e) {
    goog.dom.asserts.assertIsHTMLEmbedElement(se), se.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e);
  }, goog.dom.safe.setFrameSrc = function(se, e) {
    goog.dom.asserts.assertIsHTMLFrameElement(se), se.src = goog.html.TrustedResourceUrl.unwrap(e);
  }, goog.dom.safe.setIframeSrc = function(se, e) {
    goog.dom.asserts.assertIsHTMLIFrameElement(se), se.src = goog.html.TrustedResourceUrl.unwrap(e);
  }, goog.dom.safe.setIframeSrcdoc = function(se, e) {
    goog.dom.asserts.assertIsHTMLIFrameElement(se), se.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(e);
  }, goog.dom.safe.setLinkHrefAndRel = function(se, e, Oe) {
    goog.dom.asserts.assertIsHTMLLinkElement(se), se.rel = Oe, goog.string.internal.caseInsensitiveContains(Oe, "stylesheet") ? (goog.asserts.assert(e instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'), se.href = goog.html.TrustedResourceUrl.unwrap(e)) : se.href = e instanceof goog.html.TrustedResourceUrl ? goog.html.TrustedResourceUrl.unwrap(e) : e instanceof goog.html.SafeUrl ? goog.html.SafeUrl.unwrap(e) : goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitizeAssertUnchanged(e));
  }, goog.dom.safe.setObjectData = function(se, e) {
    goog.dom.asserts.assertIsHTMLObjectElement(se), se.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e);
  }, goog.dom.safe.setScriptSrc = function(se, e) {
    goog.dom.asserts.assertIsHTMLScriptElement(se), se.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e), (e = goog.getScriptNonce()) && se.setAttribute("nonce", e);
  }, goog.dom.safe.setScriptContent = function(se, e) {
    goog.dom.asserts.assertIsHTMLScriptElement(se), se.text = goog.html.SafeScript.unwrapTrustedScript(e), (e = goog.getScriptNonce()) && se.setAttribute("nonce", e);
  }, goog.dom.safe.setLocationHref = function(se, e) {
    goog.dom.asserts.assertIsLocation(se), e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), se.href = goog.html.SafeUrl.unwrap(e);
  }, goog.dom.safe.assignLocation = function(se, e) {
    goog.dom.asserts.assertIsLocation(se), e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), se.assign(goog.html.SafeUrl.unwrap(e));
  }, goog.dom.safe.replaceLocation = function(se, e) {
    e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), se.replace(goog.html.SafeUrl.unwrap(e));
  }, goog.dom.safe.openInWindow = function(se, e, Oe, Si, wi) {
    return se = se instanceof goog.html.SafeUrl ? se : goog.html.SafeUrl.sanitizeAssertUnchanged(se), e = e || goog.global, Oe = Oe instanceof goog.string.Const ? goog.string.Const.unwrap(Oe) : Oe || "", e.open(goog.html.SafeUrl.unwrap(se), Oe, Si, wi);
  }, goog.dom.safe.parseFromStringHtml = function(se, e) {
    return goog.dom.safe.parseFromString(se, e, "text/html");
  }, goog.dom.safe.parseFromString = function(se, e, Oe) {
    return se.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(e), Oe);
  }, goog.dom.safe.createImageFromBlob = function(se) {
    if (!/^image\/.*/g.test(se.type))
      throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");
    var e = goog.global.URL.createObjectURL(se);
    return se = new goog.global.Image(), se.onload = function() {
      goog.global.URL.revokeObjectURL(e);
    }, goog.dom.safe.setImageSrc(se, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."), e)), se;
  }, goog.string.DETECT_DOUBLE_ESCAPING = !1, goog.string.FORCE_NON_DOM_HTML_UNESCAPING = !1, goog.string.Unicode = { NBSP: " " }, goog.string.startsWith = goog.string.internal.startsWith, goog.string.endsWith = goog.string.internal.endsWith, goog.string.caseInsensitiveStartsWith = goog.string.internal.caseInsensitiveStartsWith, goog.string.caseInsensitiveEndsWith = goog.string.internal.caseInsensitiveEndsWith, goog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals, goog.string.subs = function(se, e) {
    for (var Oe = se.split("%s"), Si = "", wi = Array.prototype.slice.call(arguments, 1); wi.length && 1 < Oe.length; )
      Si += Oe.shift() + wi.shift();
    return Si + Oe.join("%s");
  }, goog.string.collapseWhitespace = function(se) {
    return se.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
  }, goog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace, goog.string.isEmptyString = function(se) {
    return se.length == 0;
  }, goog.string.isEmpty = goog.string.isEmptyOrWhitespace, goog.string.isEmptyOrWhitespaceSafe = function(se) {
    return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(se));
  }, goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe, goog.string.isBreakingWhitespace = function(se) {
    return !/[^\t\n\r ]/.test(se);
  }, goog.string.isAlpha = function(se) {
    return !/[^a-zA-Z]/.test(se);
  }, goog.string.isNumeric = function(se) {
    return !/[^0-9]/.test(se);
  }, goog.string.isAlphaNumeric = function(se) {
    return !/[^a-zA-Z0-9]/.test(se);
  }, goog.string.isSpace = function(se) {
    return se == " ";
  }, goog.string.isUnicodeChar = function(se) {
    return se.length == 1 && " " <= se && "~" >= se || "" <= se && "�" >= se;
  }, goog.string.stripNewlines = function(se) {
    return se.replace(/(\r\n|\r|\n)+/g, " ");
  }, goog.string.canonicalizeNewlines = function(se) {
    return se.replace(/(\r\n|\r|\n)/g, `
`);
  }, goog.string.normalizeWhitespace = function(se) {
    return se.replace(/\xa0|\s/g, " ");
  }, goog.string.normalizeSpaces = function(se) {
    return se.replace(/\xa0|[ \t]+/g, " ");
  }, goog.string.collapseBreakingSpaces = function(se) {
    return se.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
  }, goog.string.trim = goog.string.internal.trim, goog.string.trimLeft = function(se) {
    return se.replace(/^[\s\xa0]+/, "");
  }, goog.string.trimRight = function(se) {
    return se.replace(/[\s\xa0]+$/, "");
  }, goog.string.caseInsensitiveCompare = goog.string.internal.caseInsensitiveCompare, goog.string.numberAwareCompare_ = function(se, e, Oe) {
    if (se == e)
      return 0;
    if (!se)
      return -1;
    if (!e)
      return 1;
    for (var Si = se.toLowerCase().match(Oe), wi = e.toLowerCase().match(Oe), Ei = Math.min(Si.length, wi.length), $i = 0; $i < Ei; $i++) {
      Oe = Si[$i];
      var xi = wi[$i];
      if (Oe != xi)
        return se = parseInt(Oe, 10), !isNaN(se) && (e = parseInt(xi, 10), !isNaN(e) && se - e) ? se - e : Oe < xi ? -1 : 1;
    }
    return Si.length != wi.length ? Si.length - wi.length : se < e ? -1 : 1;
  }, goog.string.intAwareCompare = function(se, e) {
    return goog.string.numberAwareCompare_(se, e, /\d+|\D+/g);
  }, goog.string.floatAwareCompare = function(se, e) {
    return goog.string.numberAwareCompare_(se, e, /\d+|\.\d+|\D+/g);
  }, goog.string.numerateCompare = goog.string.floatAwareCompare, goog.string.urlEncode = function(se) {
    return encodeURIComponent(String(se));
  }, goog.string.urlDecode = function(se) {
    return decodeURIComponent(se.replace(/\+/g, " "));
  }, goog.string.newLineToBr = goog.string.internal.newLineToBr, goog.string.htmlEscape = function(se, e) {
    return se = goog.string.internal.htmlEscape(se, e), goog.string.DETECT_DOUBLE_ESCAPING && (se = se.replace(goog.string.E_RE_, "&#101;")), se;
  }, goog.string.E_RE_ = /e/g, goog.string.unescapeEntities = function(se) {
    return goog.string.contains(se, "&") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global ? goog.string.unescapeEntitiesUsingDom_(se) : goog.string.unescapePureXmlEntities_(se) : se;
  }, goog.string.unescapeEntitiesWithDocument = function(se, e) {
    return goog.string.contains(se, "&") ? goog.string.unescapeEntitiesUsingDom_(se, e) : se;
  }, goog.string.unescapeEntitiesUsingDom_ = function(se, e) {
    var Oe = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' }, Si = e ? e.createElement("div") : goog.global.document.createElement("div");
    return se.replace(goog.string.HTML_ENTITY_PATTERN_, function(wi, Ei) {
      var $i = Oe[wi];
      return $i || (Ei.charAt(0) == "#" && (Ei = +("0" + Ei.substr(1)), isNaN(Ei) || ($i = String.fromCharCode(Ei))), $i || (goog.dom.safe.setInnerHtml(Si, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(
        goog.string.Const.from("Single HTML entity."),
        wi + " "
      )), $i = Si.firstChild.nodeValue.slice(0, -1)), Oe[wi] = $i);
    });
  }, goog.string.unescapePureXmlEntities_ = function(se) {
    return se.replace(/&([^;]+);/g, function(e, Oe) {
      switch (Oe) {
        case "amp":
          return "&";
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "quot":
          return '"';
        default:
          return Oe.charAt(0) != "#" || (Oe = +("0" + Oe.substr(1)), isNaN(Oe)) ? e : String.fromCharCode(Oe);
      }
    });
  }, goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g, goog.string.whitespaceEscape = function(se, e) {
    return goog.string.newLineToBr(se.replace(/  /g, " &#160;"), e);
  }, goog.string.preserveSpaces = function(se) {
    return se.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
  }, goog.string.stripQuotes = function(se, e) {
    for (var Oe = e.length, Si = 0; Si < Oe; Si++) {
      var wi = Oe == 1 ? e : e.charAt(Si);
      if (se.charAt(0) == wi && se.charAt(se.length - 1) == wi)
        return se.substring(1, se.length - 1);
    }
    return se;
  }, goog.string.truncate = function(se, e, Oe) {
    return Oe && (se = goog.string.unescapeEntities(se)), se.length > e && (se = se.substring(0, e - 3) + "..."), Oe && (se = goog.string.htmlEscape(se)), se;
  }, goog.string.truncateMiddle = function(se, e, Oe, Si) {
    if (Oe && (se = goog.string.unescapeEntities(se)), Si && se.length > e) {
      Si > e && (Si = e);
      var wi = se.length - Si;
      se = se.substring(0, e - Si) + "..." + se.substring(wi);
    } else
      se.length > e && (Si = Math.floor(e / 2), wi = se.length - Si, se = se.substring(0, Si + e % 2) + "..." + se.substring(wi));
    return Oe && (se = goog.string.htmlEscape(se)), se;
  }, goog.string.specialEscapeChars_ = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" }, goog.string.jsEscapeCache_ = { "'": "\\'" }, goog.string.quote = function(se) {
    se = String(se);
    for (var e = ['"'], Oe = 0; Oe < se.length; Oe++) {
      var Si = se.charAt(Oe), wi = Si.charCodeAt(0);
      e[Oe + 1] = goog.string.specialEscapeChars_[Si] || (31 < wi && 127 > wi ? Si : goog.string.escapeChar(Si));
    }
    return e.push('"'), e.join("");
  }, goog.string.escapeString = function(se) {
    for (var e = [], Oe = 0; Oe < se.length; Oe++)
      e[Oe] = goog.string.escapeChar(se.charAt(Oe));
    return e.join("");
  }, goog.string.escapeChar = function(se) {
    if (se in goog.string.jsEscapeCache_)
      return goog.string.jsEscapeCache_[se];
    if (se in goog.string.specialEscapeChars_)
      return goog.string.jsEscapeCache_[se] = goog.string.specialEscapeChars_[se];
    var e = se.charCodeAt(0);
    if (31 < e && 127 > e)
      var Oe = se;
    else
      256 > e ? (Oe = "\\x", (16 > e || 256 < e) && (Oe += "0")) : (Oe = "\\u", 4096 > e && (Oe += "0")), Oe += e.toString(16).toUpperCase();
    return goog.string.jsEscapeCache_[se] = Oe;
  }, goog.string.contains = goog.string.internal.contains, goog.string.caseInsensitiveContains = goog.string.internal.caseInsensitiveContains, goog.string.countOf = function(se, e) {
    return se && e ? se.split(e).length - 1 : 0;
  }, goog.string.removeAt = function(se, e, Oe) {
    var Si = se;
    return 0 <= e && e < se.length && 0 < Oe && (Si = se.substr(0, e) + se.substr(e + Oe, se.length - e - Oe)), Si;
  }, goog.string.remove = function(se, e) {
    return se.replace(e, "");
  }, goog.string.removeAll = function(se, e) {
    return e = new RegExp(goog.string.regExpEscape(e), "g"), se.replace(e, "");
  }, goog.string.replaceAll = function(se, e, Oe) {
    return e = new RegExp(goog.string.regExpEscape(e), "g"), se.replace(e, Oe.replace(/\$/g, "$$$$"));
  }, goog.string.regExpEscape = function(se) {
    return String(se).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
  }, goog.string.repeat = String.prototype.repeat ? function(se, e) {
    return se.repeat(e);
  } : function(se, e) {
    return Array(e + 1).join(se);
  }, goog.string.padNumber = function(se, e, Oe) {
    return se = Oe !== void 0 ? se.toFixed(Oe) : String(se), Oe = se.indexOf("."), Oe == -1 && (Oe = se.length), goog.string.repeat("0", Math.max(0, e - Oe)) + se;
  }, goog.string.makeSafe = function(se) {
    return se == null ? "" : String(se);
  }, goog.string.buildString = function(se) {
    return Array.prototype.join.call(arguments, "");
  }, goog.string.getRandomString = function() {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
  }, goog.string.compareVersions = goog.string.internal.compareVersions, goog.string.hashCode = function(se) {
    for (var e = 0, Oe = 0; Oe < se.length; ++Oe)
      e = 31 * e + se.charCodeAt(Oe) >>> 0;
    return e;
  }, goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0, goog.string.createUniqueString = function() {
    return "goog_" + goog.string.uniqueStringCounter_++;
  }, goog.string.toNumber = function(se) {
    var e = Number(se);
    return e == 0 && goog.string.isEmptyOrWhitespace(se) ? NaN : e;
  }, goog.string.isLowerCamelCase = function(se) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(se);
  }, goog.string.isUpperCamelCase = function(se) {
    return /^([A-Z][a-z]*)+$/.test(se);
  }, goog.string.toCamelCase = function(se) {
    return String(se).replace(/\-([a-z])/g, function(e, Oe) {
      return Oe.toUpperCase();
    });
  }, goog.string.toSelectorCase = function(se) {
    return String(se).replace(/([A-Z])/g, "-$1").toLowerCase();
  }, goog.string.toTitleCase = function(se, e) {
    return e = typeof e == "string" ? goog.string.regExpEscape(e) : "\\s", se.replace(new RegExp("(^" + (e ? "|[" + e + "]+" : "") + ")([a-z])", "g"), function(Oe, Si, wi) {
      return Si + wi.toUpperCase();
    });
  }, goog.string.capitalize = function(se) {
    return String(se.charAt(0)).toUpperCase() + String(se.substr(1)).toLowerCase();
  }, goog.string.parseInt = function(se) {
    return isFinite(se) && (se = String(se)), typeof se == "string" ? /^\s*-?0x/i.test(se) ? parseInt(se, 16) : parseInt(se, 10) : NaN;
  }, goog.string.splitLimit = function(se, e, Oe) {
    se = se.split(e);
    for (var Si = []; 0 < Oe && se.length; )
      Si.push(se.shift()), Oe--;
    return se.length && Si.push(se.join(e)), Si;
  }, goog.string.lastComponent = function(se, e) {
    if (e)
      typeof e == "string" && (e = [e]);
    else
      return se;
    for (var Oe = -1, Si = 0; Si < e.length; Si++)
      if (e[Si] != "") {
        var wi = se.lastIndexOf(e[Si]);
        wi > Oe && (Oe = wi);
      }
    return Oe == -1 ? se : se.slice(Oe + 1);
  }, goog.string.editDistance = function(se, e) {
    var Oe = [], Si = [];
    if (se == e)
      return 0;
    if (!se.length || !e.length)
      return Math.max(se.length, e.length);
    for (var wi = 0; wi < e.length + 1; wi++)
      Oe[wi] = wi;
    for (wi = 0; wi < se.length; wi++) {
      Si[0] = wi + 1;
      for (var Ei = 0; Ei < e.length; Ei++)
        Si[Ei + 1] = Math.min(Si[Ei] + 1, Oe[Ei + 1] + 1, Oe[Ei] + +(se[wi] != e[Ei]));
      for (Ei = 0; Ei < Oe.length; Ei++)
        Oe[Ei] = Si[Ei];
    }
    return Si[e.length];
  }, goog.labs.userAgent.engine = {}, goog.labs.userAgent.engine.isPresto = function() {
    return goog.labs.userAgent.util.matchUserAgent("Presto");
  }, goog.labs.userAgent.engine.isTrident = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
  }, goog.labs.userAgent.engine.isEdge = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge");
  }, goog.labs.userAgent.engine.isWebKit = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge();
  }, goog.labs.userAgent.engine.isGecko = function() {
    return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge();
  }, goog.labs.userAgent.engine.getVersion = function() {
    var se = goog.labs.userAgent.util.getUserAgent();
    if (se) {
      se = goog.labs.userAgent.util.extractVersionTuples(se);
      var e = goog.labs.userAgent.engine.getEngineTuple_(se);
      if (e)
        return e[0] == "Gecko" ? goog.labs.userAgent.engine.getVersionForKey_(se, "Firefox") : e[1];
      se = se[0];
      var Oe;
      if (se && (Oe = se[2]) && (Oe = /Trident\/([^\s;]+)/.exec(Oe)))
        return Oe[1];
    }
    return "";
  }, goog.labs.userAgent.engine.getEngineTuple_ = function(se) {
    if (!goog.labs.userAgent.engine.isEdge())
      return se[1];
    for (var e = 0; e < se.length; e++) {
      var Oe = se[e];
      if (Oe[0] == "Edge")
        return Oe;
    }
  }, goog.labs.userAgent.engine.isVersionOrHigher = function(se) {
    return 0 <= goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), se);
  }, goog.labs.userAgent.engine.getVersionForKey_ = function(se, e) {
    return (se = goog.array.find(se, function(Oe) {
      return e == Oe[0];
    })) && se[1] || "";
  }, goog.labs.userAgent.platform = {}, goog.labs.userAgent.platform.isAndroid = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android");
  }, goog.labs.userAgent.platform.isIpod = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPod");
  }, goog.labs.userAgent.platform.isIphone = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad");
  }, goog.labs.userAgent.platform.isIpad = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPad");
  }, goog.labs.userAgent.platform.isIos = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod();
  }, goog.labs.userAgent.platform.isMacintosh = function() {
    return goog.labs.userAgent.util.matchUserAgent("Macintosh");
  }, goog.labs.userAgent.platform.isLinux = function() {
    return goog.labs.userAgent.util.matchUserAgent("Linux");
  }, goog.labs.userAgent.platform.isWindows = function() {
    return goog.labs.userAgent.util.matchUserAgent("Windows");
  }, goog.labs.userAgent.platform.isChromeOS = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrOS");
  }, goog.labs.userAgent.platform.isChromecast = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrKey");
  }, goog.labs.userAgent.platform.isKaiOS = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS");
  }, goog.labs.userAgent.platform.getVersion = function() {
    var se = goog.labs.userAgent.util.getUserAgent(), e = "";
    return goog.labs.userAgent.platform.isWindows() ? (e = /Windows (?:NT|Phone) ([0-9.]+)/, e = (se = e.exec(se)) ? se[1] : "0.0") : goog.labs.userAgent.platform.isIos() ? (e = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/, e = (se = e.exec(se)) && se[1].replace(/_/g, ".")) : goog.labs.userAgent.platform.isMacintosh() ? (e = /Mac OS X ([0-9_.]+)/, e = (se = e.exec(se)) ? se[1].replace(/_/g, ".") : "10") : goog.labs.userAgent.platform.isKaiOS() ? (e = /(?:KaiOS)\/(\S+)/i, e = (se = e.exec(se)) && se[1]) : goog.labs.userAgent.platform.isAndroid() ? (e = /Android\s+([^\);]+)(\)|;)/, e = (se = e.exec(se)) && se[1]) : goog.labs.userAgent.platform.isChromeOS() && (e = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/, e = (se = e.exec(se)) && se[1]), e || "";
  }, goog.labs.userAgent.platform.isVersionOrHigher = function(se) {
    return 0 <= goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), se);
  }, goog.reflect = {}, goog.reflect.object = function(se, e) {
    return e;
  }, goog.reflect.objectProperty = function(se, e) {
    return se;
  }, goog.reflect.sinkValue = function(se) {
    return goog.reflect.sinkValue[" "](se), se;
  }, goog.reflect.sinkValue[" "] = goog.nullFunction, goog.reflect.canAccessProperty = function(se, e) {
    try {
      return goog.reflect.sinkValue(se[e]), !0;
    } catch {
    }
    return !1;
  }, goog.reflect.cache = function(se, e, Oe, Si) {
    return Si = Si ? Si(e) : e, Object.prototype.hasOwnProperty.call(se, Si) ? se[Si] : se[Si] = Oe(e);
  }, goog.userAgent = {}, goog.userAgent.ASSUME_IE = !1, goog.userAgent.ASSUME_EDGE = !1, goog.userAgent.ASSUME_GECKO = !1, goog.userAgent.ASSUME_WEBKIT = !1, goog.userAgent.ASSUME_MOBILE_WEBKIT = !1, goog.userAgent.ASSUME_OPERA = !1, goog.userAgent.ASSUME_ANY_VERSION = !1, goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA, goog.userAgent.getUserAgentString = function() {
    return goog.labs.userAgent.util.getUserAgent();
  }, goog.userAgent.getNavigatorTyped = function() {
    return goog.global.navigator || null;
  }, goog.userAgent.getNavigator = function() {
    return goog.userAgent.getNavigatorTyped();
  }, goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera(), goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE(), goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge(), goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE, goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko(), goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit(), goog.userAgent.isMobile_ = function() {
    return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile");
  }, goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_(), goog.userAgent.SAFARI = goog.userAgent.WEBKIT, goog.userAgent.determinePlatform_ = function() {
    var se = goog.userAgent.getNavigatorTyped();
    return se && se.platform || "";
  }, goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_(), goog.userAgent.ASSUME_MAC = !1, goog.userAgent.ASSUME_WINDOWS = !1, goog.userAgent.ASSUME_LINUX = !1, goog.userAgent.ASSUME_X11 = !1, goog.userAgent.ASSUME_ANDROID = !1, goog.userAgent.ASSUME_IPHONE = !1, goog.userAgent.ASSUME_IPAD = !1, goog.userAgent.ASSUME_IPOD = !1, goog.userAgent.ASSUME_KAIOS = !1, goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD, goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh(), goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows(), goog.userAgent.isLegacyLinux_ = function() {
    return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS();
  }, goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_(), goog.userAgent.isX11_ = function() {
    var se = goog.userAgent.getNavigatorTyped();
    return !!se && goog.string.contains(se.appVersion || "", "X11");
  }, goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_(), goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid(), goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone(), goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIpod(), goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIos(), goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_KAIOS : goog.labs.userAgent.platform.isKaiOS(), goog.userAgent.determineVersion_ = function() {
    var se = "", e = goog.userAgent.getVersionRegexResult_();
    return e && (se = e ? e[1] : ""), goog.userAgent.IE && (e = goog.userAgent.getDocumentMode_(), e != null && e > parseFloat(se)) ? String(e) : se;
  }, goog.userAgent.getVersionRegexResult_ = function() {
    var se = goog.userAgent.getUserAgentString();
    if (goog.userAgent.GECKO)
      return /rv:([^\);]+)(\)|;)/.exec(se);
    if (goog.userAgent.EDGE)
      return /Edge\/([\d\.]+)/.exec(se);
    if (goog.userAgent.IE)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(se);
    if (goog.userAgent.WEBKIT)
      return /WebKit\/(\S+)/.exec(se);
    if (goog.userAgent.OPERA)
      return /(?:Version)[ \/]?(\S+)/.exec(se);
  }, goog.userAgent.getDocumentMode_ = function() {
    var se = goog.global.document;
    return se ? se.documentMode : void 0;
  }, goog.userAgent.VERSION = goog.userAgent.determineVersion_(), goog.userAgent.compare = function(se, e) {
    return goog.string.compareVersions(se, e);
  }, goog.userAgent.isVersionOrHigherCache_ = {}, goog.userAgent.isVersionOrHigher = function(se) {
    return goog.userAgent.ASSUME_ANY_VERSION || goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, se, function() {
      return 0 <= goog.string.compareVersions(goog.userAgent.VERSION, se);
    });
  }, goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher, goog.userAgent.isDocumentModeOrHigher = function(se) {
    return Number(goog.userAgent.DOCUMENT_MODE) >= se;
  }, goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher, goog.userAgent.DOCUMENT_MODE = function() {
    if (goog.global.document && goog.userAgent.IE) {
      var se = goog.userAgent.getDocumentMode_();
      return se || parseInt(goog.userAgent.VERSION, 10) || void 0;
    }
  }(), goog.userAgent.product = {}, goog.userAgent.product.ASSUME_FIREFOX = !1, goog.userAgent.product.ASSUME_IPHONE = !1, goog.userAgent.product.ASSUME_IPAD = !1, goog.userAgent.product.ASSUME_ANDROID = !1, goog.userAgent.product.ASSUME_CHROME = !1, goog.userAgent.product.ASSUME_SAFARI = !1, goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI, goog.userAgent.product.OPERA = goog.userAgent.OPERA, goog.userAgent.product.IE = goog.userAgent.IE, goog.userAgent.product.EDGE = goog.userAgent.EDGE, goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.labs.userAgent.browser.isFirefox(), goog.userAgent.product.isIphoneOrIpod_ = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpod();
  }, goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.isIphoneOrIpod_(), goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.labs.userAgent.browser.isAndroidBrowser(), goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.labs.userAgent.browser.isChrome(), goog.userAgent.product.isSafariDesktop_ = function() {
    return goog.labs.userAgent.browser.isSafari() && !goog.labs.userAgent.platform.isIos();
  }, goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.isSafariDesktop_(), goog.crypt.base64 = {}, goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "+/=", goog.crypt.base64.ENCODED_VALS_WEBSAFE = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "-_.", goog.crypt.base64.Alphabet = { DEFAULT: 0, NO_PADDING: 1, WEBSAFE: 2, WEBSAFE_DOT_PADDING: 3, WEBSAFE_NO_PADDING: 4 }, goog.crypt.base64.paddingChars_ = "=.", goog.crypt.base64.isPadding_ = function(se) {
    return goog.string.contains(goog.crypt.base64.paddingChars_, se);
  }, goog.crypt.base64.byteToCharMaps_ = {}, goog.crypt.base64.charToByteMap_ = null, goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO || goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI || goog.userAgent.OPERA, goog.crypt.base64.HAS_NATIVE_ENCODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || typeof goog.global.btoa == "function", goog.crypt.base64.HAS_NATIVE_DECODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || !goog.userAgent.product.SAFARI && !goog.userAgent.IE && typeof goog.global.atob == "function", goog.crypt.base64.encodeByteArray = function(se, e) {
    goog.asserts.assert(goog.isArrayLike(se), "encodeByteArray takes an array as a parameter"), e === void 0 && (e = goog.crypt.base64.Alphabet.DEFAULT), goog.crypt.base64.init_(), e = goog.crypt.base64.byteToCharMaps_[e];
    for (var Oe = [], Si = 0; Si < se.length; Si += 3) {
      var wi = se[Si], Ei = Si + 1 < se.length, $i = Ei ? se[Si + 1] : 0, xi = Si + 2 < se.length, Ri = xi ? se[Si + 2] : 0, Ti = wi >> 2;
      wi = (wi & 3) << 4 | $i >> 4, $i = ($i & 15) << 2 | Ri >> 6, Ri &= 63, xi || (Ri = 64, Ei || ($i = 64)), Oe.push(e[Ti], e[wi], e[$i] || "", e[Ri] || "");
    }
    return Oe.join("");
  }, goog.crypt.base64.encodeString = function(se, e) {
    return goog.crypt.base64.HAS_NATIVE_ENCODE_ && !e ? goog.global.btoa(se) : goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(se), e);
  }, goog.crypt.base64.decodeString = function(se, e) {
    if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !e)
      return goog.global.atob(se);
    var Oe = "";
    return goog.crypt.base64.decodeStringInternal_(se, function(Si) {
      Oe += String.fromCharCode(Si);
    }), Oe;
  }, goog.crypt.base64.decodeStringToByteArray = function(se, e) {
    var Oe = [];
    return goog.crypt.base64.decodeStringInternal_(se, function(Si) {
      Oe.push(Si);
    }), Oe;
  }, goog.crypt.base64.decodeStringToUint8Array = function(se) {
    goog.asserts.assert(!goog.userAgent.IE || goog.userAgent.isVersionOrHigher("10"), "Browser does not support typed arrays");
    var e = se.length, Oe = 3 * e / 4;
    Oe % 3 ? Oe = Math.floor(Oe) : goog.crypt.base64.isPadding_(se[e - 1]) && (Oe = goog.crypt.base64.isPadding_(se[e - 2]) ? Oe - 2 : Oe - 1);
    var Si = new Uint8Array(Oe), wi = 0;
    return goog.crypt.base64.decodeStringInternal_(se, function(Ei) {
      Si[wi++] = Ei;
    }), Si.subarray(0, wi);
  }, goog.crypt.base64.decodeStringInternal_ = function(se, e) {
    function Oe(Ri) {
      for (; Si < se.length; ) {
        var Ti = se.charAt(Si++), Oi = goog.crypt.base64.charToByteMap_[Ti];
        if (Oi != null)
          return Oi;
        if (!goog.string.isEmptyOrWhitespace(Ti))
          throw Error("Unknown base64 encoding at char: " + Ti);
      }
      return Ri;
    }
    goog.crypt.base64.init_();
    for (var Si = 0; ; ) {
      var wi = Oe(-1), Ei = Oe(0), $i = Oe(64), xi = Oe(64);
      if (xi === 64 && wi === -1)
        break;
      e(wi << 2 | Ei >> 4), $i != 64 && (e(Ei << 4 & 240 | $i >> 2), xi != 64 && e($i << 6 & 192 | xi));
    }
  }, goog.crypt.base64.init_ = function() {
    if (!goog.crypt.base64.charToByteMap_) {
      goog.crypt.base64.charToByteMap_ = {};
      for (var se = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""), e = ["+/=", "+/", "-_=", "-_.", "-_"], Oe = 0; 5 > Oe; Oe++) {
        var Si = se.concat(e[Oe].split(""));
        goog.crypt.base64.byteToCharMaps_[Oe] = Si;
        for (var wi = 0; wi < Si.length; wi++) {
          var Ei = Si[wi], $i = goog.crypt.base64.charToByteMap_[Ei];
          $i === void 0 ? goog.crypt.base64.charToByteMap_[Ei] = wi : goog.asserts.assert($i === wi);
        }
      }
    }
  }, jspb.utils = {}, jspb.utils.split64Low = 0, jspb.utils.split64High = 0, jspb.utils.splitUint64 = function(se) {
    var e = se >>> 0;
    se = Math.floor((se - e) / jspb.BinaryConstants.TWO_TO_32) >>> 0, jspb.utils.split64Low = e, jspb.utils.split64High = se;
  }, jspb.utils.splitInt64 = function(se) {
    var e = 0 > se;
    se = Math.abs(se);
    var Oe = se >>> 0;
    se = Math.floor((se - Oe) / jspb.BinaryConstants.TWO_TO_32), se >>>= 0, e && (se = ~se >>> 0, Oe = (~Oe >>> 0) + 1, 4294967295 < Oe && (Oe = 0, se++, 4294967295 < se && (se = 0))), jspb.utils.split64Low = Oe, jspb.utils.split64High = se;
  }, jspb.utils.splitZigzag64 = function(se) {
    var e = 0 > se;
    se = 2 * Math.abs(se), jspb.utils.splitUint64(se), se = jspb.utils.split64Low;
    var Oe = jspb.utils.split64High;
    e && (se == 0 ? Oe == 0 ? Oe = se = 4294967295 : (Oe--, se = 4294967295) : se--), jspb.utils.split64Low = se, jspb.utils.split64High = Oe;
  }, jspb.utils.splitFloat32 = function(se) {
    var e = 0 > se ? 1 : 0;
    if (se = e ? -se : se, se === 0)
      0 < 1 / se ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 0) : (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483648);
    else if (isNaN(se))
      jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483647;
    else if (se > jspb.BinaryConstants.FLOAT32_MAX)
      jspb.utils.split64High = 0, jspb.utils.split64Low = (e << 31 | 2139095040) >>> 0;
    else if (se < jspb.BinaryConstants.FLOAT32_MIN)
      se = Math.round(se / Math.pow(2, -149)), jspb.utils.split64High = 0, jspb.utils.split64Low = (e << 31 | se) >>> 0;
    else {
      var Oe = Math.floor(Math.log(se) / Math.LN2);
      se *= Math.pow(2, -Oe), se = Math.round(se * jspb.BinaryConstants.TWO_TO_23), 16777216 <= se && ++Oe, jspb.utils.split64High = 0, jspb.utils.split64Low = (e << 31 | Oe + 127 << 23 | se & 8388607) >>> 0;
    }
  }, jspb.utils.splitFloat64 = function(se) {
    var e = 0 > se ? 1 : 0;
    if (se = e ? -se : se, se === 0)
      jspb.utils.split64High = 0 < 1 / se ? 0 : 2147483648, jspb.utils.split64Low = 0;
    else if (isNaN(se))
      jspb.utils.split64High = 2147483647, jspb.utils.split64Low = 4294967295;
    else if (se > jspb.BinaryConstants.FLOAT64_MAX)
      jspb.utils.split64High = (e << 31 | 2146435072) >>> 0, jspb.utils.split64Low = 0;
    else if (se < jspb.BinaryConstants.FLOAT64_MIN) {
      var Oe = se / Math.pow(2, -1074);
      se = Oe / jspb.BinaryConstants.TWO_TO_32, jspb.utils.split64High = (e << 31 | se) >>> 0, jspb.utils.split64Low = Oe >>> 0;
    } else {
      Oe = se;
      var Si = 0;
      if (2 <= Oe)
        for (; 2 <= Oe && 1023 > Si; )
          Si++, Oe /= 2;
      else
        for (; 1 > Oe && -1022 < Si; )
          Oe *= 2, Si--;
      Oe = se * Math.pow(2, -Si), se = Oe * jspb.BinaryConstants.TWO_TO_20 & 1048575, Oe = Oe * jspb.BinaryConstants.TWO_TO_52 >>> 0, jspb.utils.split64High = (e << 31 | Si + 1023 << 20 | se) >>> 0, jspb.utils.split64Low = Oe;
    }
  }, jspb.utils.splitHash64 = function(se) {
    var e = se.charCodeAt(0), Oe = se.charCodeAt(1), Si = se.charCodeAt(2), wi = se.charCodeAt(3), Ei = se.charCodeAt(4), $i = se.charCodeAt(5), xi = se.charCodeAt(6);
    se = se.charCodeAt(7), jspb.utils.split64Low = e + (Oe << 8) + (Si << 16) + (wi << 24) >>> 0, jspb.utils.split64High = Ei + ($i << 8) + (xi << 16) + (se << 24) >>> 0;
  }, jspb.utils.joinUint64 = function(se, e) {
    return e * jspb.BinaryConstants.TWO_TO_32 + (se >>> 0);
  }, jspb.utils.joinInt64 = function(se, e) {
    var Oe = e & 2147483648;
    return Oe && (se = ~se + 1 >>> 0, e = ~e >>> 0, se == 0 && (e = e + 1 >>> 0)), se = jspb.utils.joinUint64(se, e), Oe ? -se : se;
  }, jspb.utils.toZigzag64 = function(se, e, Oe) {
    var Si = e >> 31;
    return Oe(se << 1 ^ Si, (e << 1 | se >>> 31) ^ Si);
  }, jspb.utils.joinZigzag64 = function(se, e) {
    return jspb.utils.fromZigzag64(se, e, jspb.utils.joinInt64);
  }, jspb.utils.fromZigzag64 = function(se, e, Oe) {
    var Si = -(se & 1);
    return Oe((se >>> 1 | e << 31) ^ Si, e >>> 1 ^ Si);
  }, jspb.utils.joinFloat32 = function(se, e) {
    e = 2 * (se >> 31) + 1;
    var Oe = se >>> 23 & 255;
    return se &= 8388607, Oe == 255 ? se ? NaN : 1 / 0 * e : Oe == 0 ? e * Math.pow(2, -149) * se : e * Math.pow(2, Oe - 150) * (se + Math.pow(2, 23));
  }, jspb.utils.joinFloat64 = function(se, e) {
    var Oe = 2 * (e >> 31) + 1, Si = e >>> 20 & 2047;
    return se = jspb.BinaryConstants.TWO_TO_32 * (e & 1048575) + se, Si == 2047 ? se ? NaN : 1 / 0 * Oe : Si == 0 ? Oe * Math.pow(2, -1074) * se : Oe * Math.pow(2, Si - 1075) * (se + jspb.BinaryConstants.TWO_TO_52);
  }, jspb.utils.joinHash64 = function(se, e) {
    return String.fromCharCode(se >>> 0 & 255, se >>> 8 & 255, se >>> 16 & 255, se >>> 24 & 255, e >>> 0 & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255);
  }, jspb.utils.DIGITS = "0123456789abcdef".split(""), jspb.utils.ZERO_CHAR_CODE_ = 48, jspb.utils.A_CHAR_CODE_ = 97, jspb.utils.joinUnsignedDecimalString = function(se, e) {
    function Oe(wi, Ei) {
      return wi = wi ? String(wi) : "", Ei ? "0000000".slice(wi.length) + wi : wi;
    }
    if (2097151 >= e)
      return "" + jspb.utils.joinUint64(se, e);
    var Si = (se >>> 24 | e << 8) >>> 0 & 16777215;
    return e = e >> 16 & 65535, se = (se & 16777215) + 6777216 * Si + 6710656 * e, Si += 8147497 * e, e *= 2, 1e7 <= se && (Si += Math.floor(se / 1e7), se %= 1e7), 1e7 <= Si && (e += Math.floor(Si / 1e7), Si %= 1e7), Oe(e, 0) + Oe(Si, e) + Oe(se, 1);
  }, jspb.utils.joinSignedDecimalString = function(se, e) {
    var Oe = e & 2147483648;
    return Oe && (se = ~se + 1 >>> 0, e = ~e + (se == 0 ? 1 : 0) >>> 0), se = jspb.utils.joinUnsignedDecimalString(se, e), Oe ? "-" + se : se;
  }, jspb.utils.hash64ToDecimalString = function(se, e) {
    jspb.utils.splitHash64(se), se = jspb.utils.split64Low;
    var Oe = jspb.utils.split64High;
    return e ? jspb.utils.joinSignedDecimalString(se, Oe) : jspb.utils.joinUnsignedDecimalString(se, Oe);
  }, jspb.utils.hash64ArrayToDecimalStrings = function(se, e) {
    for (var Oe = Array(se.length), Si = 0; Si < se.length; Si++)
      Oe[Si] = jspb.utils.hash64ToDecimalString(se[Si], e);
    return Oe;
  }, jspb.utils.decimalStringToHash64 = function(se) {
    function e($i, xi) {
      for (var Ri = 0; 8 > Ri && ($i !== 1 || 0 < xi); Ri++)
        xi = $i * wi[Ri] + xi, wi[Ri] = xi & 255, xi >>>= 8;
    }
    function Oe() {
      for (var $i = 0; 8 > $i; $i++)
        wi[$i] = ~wi[$i] & 255;
    }
    jspb.asserts.assert(0 < se.length);
    var Si = !1;
    se[0] === "-" && (Si = !0, se = se.slice(1));
    for (var wi = [0, 0, 0, 0, 0, 0, 0, 0], Ei = 0; Ei < se.length; Ei++)
      e(10, se.charCodeAt(Ei) - jspb.utils.ZERO_CHAR_CODE_);
    return Si && (Oe(), e(1, 1)), goog.crypt.byteArrayToString(wi);
  }, jspb.utils.splitDecimalString = function(se) {
    jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(se));
  }, jspb.utils.toHexDigit_ = function(se) {
    return String.fromCharCode(10 > se ? jspb.utils.ZERO_CHAR_CODE_ + se : jspb.utils.A_CHAR_CODE_ - 10 + se);
  }, jspb.utils.fromHexCharCode_ = function(se) {
    return se >= jspb.utils.A_CHAR_CODE_ ? se - jspb.utils.A_CHAR_CODE_ + 10 : se - jspb.utils.ZERO_CHAR_CODE_;
  }, jspb.utils.hash64ToHexString = function(se) {
    var e = Array(18);
    e[0] = "0", e[1] = "x";
    for (var Oe = 0; 8 > Oe; Oe++) {
      var Si = se.charCodeAt(7 - Oe);
      e[2 * Oe + 2] = jspb.utils.toHexDigit_(Si >> 4), e[2 * Oe + 3] = jspb.utils.toHexDigit_(Si & 15);
    }
    return e.join("");
  }, jspb.utils.hexStringToHash64 = function(se) {
    se = se.toLowerCase(), jspb.asserts.assert(se.length == 18), jspb.asserts.assert(se[0] == "0"), jspb.asserts.assert(se[1] == "x");
    for (var e = "", Oe = 0; 8 > Oe; Oe++) {
      var Si = jspb.utils.fromHexCharCode_(se.charCodeAt(2 * Oe + 2)), wi = jspb.utils.fromHexCharCode_(se.charCodeAt(2 * Oe + 3));
      e = String.fromCharCode(16 * Si + wi) + e;
    }
    return e;
  }, jspb.utils.hash64ToNumber = function(se, e) {
    jspb.utils.splitHash64(se), se = jspb.utils.split64Low;
    var Oe = jspb.utils.split64High;
    return e ? jspb.utils.joinInt64(se, Oe) : jspb.utils.joinUint64(se, Oe);
  }, jspb.utils.numberToHash64 = function(se) {
    return jspb.utils.splitInt64(se), jspb.utils.joinHash64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.utils.countVarints = function(se, e, Oe) {
    for (var Si = 0, wi = e; wi < Oe; wi++)
      Si += se[wi] >> 7;
    return Oe - e - Si;
  }, jspb.utils.countVarintFields = function(se, e, Oe, Si) {
    var wi = 0;
    if (Si = 8 * Si + jspb.BinaryConstants.WireType.VARINT, 128 > Si)
      for (; e < Oe && se[e++] == Si; )
        for (wi++; ; ) {
          var Ei = se[e++];
          if (!(Ei & 128))
            break;
        }
    else
      for (; e < Oe; ) {
        for (Ei = Si; 128 < Ei; ) {
          if (se[e] != (Ei & 127 | 128))
            return wi;
          e++, Ei >>= 7;
        }
        if (se[e++] != Ei)
          break;
        for (wi++; Ei = se[e++], (Ei & 128) != 0; )
          ;
      }
    return wi;
  }, jspb.utils.countFixedFields_ = function(se, e, Oe, Si, wi) {
    var Ei = 0;
    if (128 > Si)
      for (; e < Oe && se[e++] == Si; )
        Ei++, e += wi;
    else
      for (; e < Oe; ) {
        for (var $i = Si; 128 < $i; ) {
          if (se[e++] != ($i & 127 | 128))
            return Ei;
          $i >>= 7;
        }
        if (se[e++] != $i)
          break;
        Ei++, e += wi;
      }
    return Ei;
  }, jspb.utils.countFixed32Fields = function(se, e, Oe, Si) {
    return jspb.utils.countFixedFields_(se, e, Oe, 8 * Si + jspb.BinaryConstants.WireType.FIXED32, 4);
  }, jspb.utils.countFixed64Fields = function(se, e, Oe, Si) {
    return jspb.utils.countFixedFields_(se, e, Oe, 8 * Si + jspb.BinaryConstants.WireType.FIXED64, 8);
  }, jspb.utils.countDelimitedFields = function(se, e, Oe, Si) {
    var wi = 0;
    for (Si = 8 * Si + jspb.BinaryConstants.WireType.DELIMITED; e < Oe; ) {
      for (var Ei = Si; 128 < Ei; ) {
        if (se[e++] != (Ei & 127 | 128))
          return wi;
        Ei >>= 7;
      }
      if (se[e++] != Ei)
        break;
      wi++;
      for (var $i = 0, xi = 1; Ei = se[e++], $i += (Ei & 127) * xi, xi *= 128, (Ei & 128) != 0; )
        ;
      e += $i;
    }
    return wi;
  }, jspb.utils.debugBytesToTextFormat = function(se) {
    var e = '"';
    if (se) {
      se = jspb.utils.byteSourceToUint8Array(se);
      for (var Oe = 0; Oe < se.length; Oe++)
        e += "\\x", 16 > se[Oe] && (e += "0"), e += se[Oe].toString(16);
    }
    return e + '"';
  }, jspb.utils.debugScalarToTextFormat = function(se) {
    return typeof se == "string" ? goog.string.quote(se) : se.toString();
  }, jspb.utils.stringToByteArray = function(se) {
    for (var e = new Uint8Array(se.length), Oe = 0; Oe < se.length; Oe++) {
      var Si = se.charCodeAt(Oe);
      if (255 < Si)
        throw Error("Conversion error: string contains codepoint outside of byte range");
      e[Oe] = Si;
    }
    return e;
  }, jspb.utils.byteSourceToUint8Array = function(se) {
    return se.constructor === Uint8Array ? se : se.constructor === ArrayBuffer || se.constructor === Array ? new Uint8Array(se) : se.constructor === String ? goog.crypt.base64.decodeStringToUint8Array(se) : se instanceof Uint8Array ? new Uint8Array(se.buffer, se.byteOffset, se.byteLength) : (jspb.asserts.fail("Type not convertible to Uint8Array."), new Uint8Array(0));
  }, jspb.BinaryDecoder = function(se, e, Oe) {
    this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = !1, se && this.setBlock(se, e, Oe);
  }, jspb.BinaryDecoder.instanceCache_ = [], jspb.BinaryDecoder.alloc = function(se, e, Oe) {
    if (jspb.BinaryDecoder.instanceCache_.length) {
      var Si = jspb.BinaryDecoder.instanceCache_.pop();
      return se && Si.setBlock(se, e, Oe), Si;
    }
    return new jspb.BinaryDecoder(se, e, Oe);
  }, jspb.BinaryDecoder.prototype.free = function() {
    this.clear(), 100 > jspb.BinaryDecoder.instanceCache_.length && jspb.BinaryDecoder.instanceCache_.push(this);
  }, jspb.BinaryDecoder.prototype.clone = function() {
    return jspb.BinaryDecoder.alloc(this.bytes_, this.start_, this.end_ - this.start_);
  }, jspb.BinaryDecoder.prototype.clear = function() {
    this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = !1;
  }, jspb.BinaryDecoder.prototype.getBuffer = function() {
    return this.bytes_;
  }, jspb.BinaryDecoder.prototype.setBlock = function(se, e, Oe) {
    this.bytes_ = jspb.utils.byteSourceToUint8Array(se), this.start_ = e !== void 0 ? e : 0, this.end_ = Oe !== void 0 ? this.start_ + Oe : this.bytes_.length, this.cursor_ = this.start_;
  }, jspb.BinaryDecoder.prototype.getEnd = function() {
    return this.end_;
  }, jspb.BinaryDecoder.prototype.setEnd = function(se) {
    this.end_ = se;
  }, jspb.BinaryDecoder.prototype.reset = function() {
    this.cursor_ = this.start_;
  }, jspb.BinaryDecoder.prototype.getCursor = function() {
    return this.cursor_;
  }, jspb.BinaryDecoder.prototype.setCursor = function(se) {
    this.cursor_ = se;
  }, jspb.BinaryDecoder.prototype.advance = function(se) {
    this.cursor_ += se, jspb.asserts.assert(this.cursor_ <= this.end_);
  }, jspb.BinaryDecoder.prototype.atEnd = function() {
    return this.cursor_ == this.end_;
  }, jspb.BinaryDecoder.prototype.pastEnd = function() {
    return this.cursor_ > this.end_;
  }, jspb.BinaryDecoder.prototype.getError = function() {
    return this.error_ || 0 > this.cursor_ || this.cursor_ > this.end_;
  }, jspb.BinaryDecoder.prototype.readSplitVarint64 = function(se) {
    for (var e = 128, Oe = 0, Si = 0, wi = 0; 4 > wi && 128 <= e; wi++)
      e = this.bytes_[this.cursor_++], Oe |= (e & 127) << 7 * wi;
    if (128 <= e && (e = this.bytes_[this.cursor_++], Oe |= (e & 127) << 28, Si |= (e & 127) >> 4), 128 <= e)
      for (wi = 0; 5 > wi && 128 <= e; wi++)
        e = this.bytes_[this.cursor_++], Si |= (e & 127) << 7 * wi + 3;
    if (128 > e)
      return se(Oe >>> 0, Si >>> 0);
    jspb.asserts.fail("Failed to read varint, encoding is invalid."), this.error_ = !0;
  }, jspb.BinaryDecoder.prototype.readSplitZigzagVarint64 = function(se) {
    return this.readSplitVarint64(function(e, Oe) {
      return jspb.utils.fromZigzag64(e, Oe, se);
    });
  }, jspb.BinaryDecoder.prototype.readSplitFixed64 = function(se) {
    var e = this.bytes_, Oe = this.cursor_;
    this.cursor_ += 8;
    for (var Si = 0, wi = 0, Ei = Oe + 7; Ei >= Oe; Ei--)
      Si = Si << 8 | e[Ei], wi = wi << 8 | e[Ei + 4];
    return se(Si, wi);
  }, jspb.BinaryDecoder.prototype.skipVarint = function() {
    for (; this.bytes_[this.cursor_] & 128; )
      this.cursor_++;
    this.cursor_++;
  }, jspb.BinaryDecoder.prototype.unskipVarint = function(se) {
    for (; 128 < se; )
      this.cursor_--, se >>>= 7;
    this.cursor_--;
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function() {
    var se = this.bytes_, e = se[this.cursor_ + 0], Oe = e & 127;
    return 128 > e ? (this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), Oe) : (e = se[this.cursor_ + 1], Oe |= (e & 127) << 7, 128 > e ? (this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), Oe) : (e = se[this.cursor_ + 2], Oe |= (e & 127) << 14, 128 > e ? (this.cursor_ += 3, jspb.asserts.assert(this.cursor_ <= this.end_), Oe) : (e = se[this.cursor_ + 3], Oe |= (e & 127) << 21, 128 > e ? (this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), Oe) : (e = se[this.cursor_ + 4], Oe |= (e & 15) << 28, 128 > e ? (this.cursor_ += 5, jspb.asserts.assert(this.cursor_ <= this.end_), Oe >>> 0) : (this.cursor_ += 5, 128 <= se[this.cursor_++] && 128 <= se[this.cursor_++] && 128 <= se[this.cursor_++] && 128 <= se[this.cursor_++] && 128 <= se[this.cursor_++] && jspb.asserts.assert(!1), jspb.asserts.assert(this.cursor_ <= this.end_), Oe)))));
  }, jspb.BinaryDecoder.prototype.readSignedVarint32 = function() {
    return ~~this.readUnsignedVarint32();
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function() {
    return this.readUnsignedVarint32().toString();
  }, jspb.BinaryDecoder.prototype.readSignedVarint32String = function() {
    return this.readSignedVarint32().toString();
  }, jspb.BinaryDecoder.prototype.readZigzagVarint32 = function() {
    var se = this.readUnsignedVarint32();
    return se >>> 1 ^ -(se & 1);
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinUint64);
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function() {
    return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readSignedVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinInt64);
  }, jspb.BinaryDecoder.prototype.readSignedVarint64String = function() {
    return this.readSplitVarint64(jspb.utils.joinSignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readZigzagVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinZigzag64);
  }, jspb.BinaryDecoder.prototype.readZigzagVarintHash64 = function() {
    return this.readSplitZigzagVarint64(jspb.utils.joinHash64);
  }, jspb.BinaryDecoder.prototype.readZigzagVarint64String = function() {
    return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readUint8 = function() {
    var se = this.bytes_[this.cursor_ + 0];
    return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), se;
  }, jspb.BinaryDecoder.prototype.readUint16 = function() {
    var se = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1];
    return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), se << 0 | e << 8;
  }, jspb.BinaryDecoder.prototype.readUint32 = function() {
    var se = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1], Oe = this.bytes_[this.cursor_ + 2], Si = this.bytes_[this.cursor_ + 3];
    return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), (se << 0 | e << 8 | Oe << 16 | Si << 24) >>> 0;
  }, jspb.BinaryDecoder.prototype.readUint64 = function() {
    var se = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinUint64(se, e);
  }, jspb.BinaryDecoder.prototype.readUint64String = function() {
    var se = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinUnsignedDecimalString(se, e);
  }, jspb.BinaryDecoder.prototype.readInt8 = function() {
    var se = this.bytes_[this.cursor_ + 0];
    return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), se << 24 >> 24;
  }, jspb.BinaryDecoder.prototype.readInt16 = function() {
    var se = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1];
    return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), (se << 0 | e << 8) << 16 >> 16;
  }, jspb.BinaryDecoder.prototype.readInt32 = function() {
    var se = this.bytes_[this.cursor_ + 0], e = this.bytes_[this.cursor_ + 1], Oe = this.bytes_[this.cursor_ + 2], Si = this.bytes_[this.cursor_ + 3];
    return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), se << 0 | e << 8 | Oe << 16 | Si << 24;
  }, jspb.BinaryDecoder.prototype.readInt64 = function() {
    var se = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinInt64(se, e);
  }, jspb.BinaryDecoder.prototype.readInt64String = function() {
    var se = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinSignedDecimalString(se, e);
  }, jspb.BinaryDecoder.prototype.readFloat = function() {
    var se = this.readUint32();
    return jspb.utils.joinFloat32(se, 0);
  }, jspb.BinaryDecoder.prototype.readDouble = function() {
    var se = this.readUint32(), e = this.readUint32();
    return jspb.utils.joinFloat64(se, e);
  }, jspb.BinaryDecoder.prototype.readBool = function() {
    return !!this.bytes_[this.cursor_++];
  }, jspb.BinaryDecoder.prototype.readEnum = function() {
    return this.readSignedVarint32();
  }, jspb.BinaryDecoder.prototype.readString = function(se) {
    var e = this.bytes_, Oe = this.cursor_;
    se = Oe + se;
    for (var Si = [], wi = ""; Oe < se; ) {
      var Ei = e[Oe++];
      if (128 > Ei)
        Si.push(Ei);
      else {
        if (192 > Ei)
          continue;
        if (224 > Ei) {
          var $i = e[Oe++];
          Si.push((Ei & 31) << 6 | $i & 63);
        } else if (240 > Ei) {
          $i = e[Oe++];
          var xi = e[Oe++];
          Si.push((Ei & 15) << 12 | ($i & 63) << 6 | xi & 63);
        } else if (248 > Ei) {
          $i = e[Oe++], xi = e[Oe++];
          var Ri = e[Oe++];
          Ei = (Ei & 7) << 18 | ($i & 63) << 12 | (xi & 63) << 6 | Ri & 63, Ei -= 65536, Si.push((Ei >> 10 & 1023) + 55296, (Ei & 1023) + 56320);
        }
      }
      8192 <= Si.length && (wi += String.fromCharCode.apply(null, Si), Si.length = 0);
    }
    return wi += goog.crypt.byteArrayToString(Si), this.cursor_ = Oe, wi;
  }, jspb.BinaryDecoder.prototype.readStringWithLength = function() {
    var se = this.readUnsignedVarint32();
    return this.readString(se);
  }, jspb.BinaryDecoder.prototype.readBytes = function(se) {
    if (0 > se || this.cursor_ + se > this.bytes_.length)
      return this.error_ = !0, jspb.asserts.fail("Invalid byte length!"), new Uint8Array(0);
    var e = this.bytes_.subarray(this.cursor_, this.cursor_ + se);
    return this.cursor_ += se, jspb.asserts.assert(this.cursor_ <= this.end_), e;
  }, jspb.BinaryDecoder.prototype.readVarintHash64 = function() {
    return this.readSplitVarint64(jspb.utils.joinHash64);
  }, jspb.BinaryDecoder.prototype.readFixedHash64 = function() {
    var se = this.bytes_, e = this.cursor_, Oe = se[e + 0], Si = se[e + 1], wi = se[e + 2], Ei = se[e + 3], $i = se[e + 4], xi = se[e + 5], Ri = se[e + 6];
    return se = se[e + 7], this.cursor_ += 8, String.fromCharCode(Oe, Si, wi, Ei, $i, xi, Ri, se);
  }, jspb.BinaryReader = function(se, e, Oe) {
    this.decoder_ = jspb.BinaryDecoder.alloc(se, e, Oe), this.fieldCursor_ = this.decoder_.getCursor(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = !1, this.readCallbacks_ = null;
  }, jspb.BinaryReader.instanceCache_ = [], jspb.BinaryReader.alloc = function(se, e, Oe) {
    if (jspb.BinaryReader.instanceCache_.length) {
      var Si = jspb.BinaryReader.instanceCache_.pop();
      return se && Si.decoder_.setBlock(se, e, Oe), Si;
    }
    return new jspb.BinaryReader(se, e, Oe);
  }, jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc, jspb.BinaryReader.prototype.free = function() {
    this.decoder_.clear(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = !1, this.readCallbacks_ = null, 100 > jspb.BinaryReader.instanceCache_.length && jspb.BinaryReader.instanceCache_.push(this);
  }, jspb.BinaryReader.prototype.getFieldCursor = function() {
    return this.fieldCursor_;
  }, jspb.BinaryReader.prototype.getCursor = function() {
    return this.decoder_.getCursor();
  }, jspb.BinaryReader.prototype.getBuffer = function() {
    return this.decoder_.getBuffer();
  }, jspb.BinaryReader.prototype.getFieldNumber = function() {
    return this.nextField_;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "getFieldNumber", jspb.BinaryReader.prototype.getFieldNumber), jspb.BinaryReader.prototype.getWireType = function() {
    return this.nextWireType_;
  }, jspb.BinaryReader.prototype.isDelimited = function() {
    return this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "isDelimited", jspb.BinaryReader.prototype.isDelimited), jspb.BinaryReader.prototype.isEndGroup = function() {
    return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "isEndGroup", jspb.BinaryReader.prototype.isEndGroup), jspb.BinaryReader.prototype.getError = function() {
    return this.error_ || this.decoder_.getError();
  }, jspb.BinaryReader.prototype.setBlock = function(se, e, Oe) {
    this.decoder_.setBlock(se, e, Oe), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
  }, jspb.BinaryReader.prototype.reset = function() {
    this.decoder_.reset(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
  }, jspb.BinaryReader.prototype.advance = function(se) {
    this.decoder_.advance(se);
  }, jspb.BinaryReader.prototype.nextField = function() {
    if (this.decoder_.atEnd())
      return !1;
    if (this.getError())
      return jspb.asserts.fail("Decoder hit an error"), !1;
    this.fieldCursor_ = this.decoder_.getCursor();
    var se = this.decoder_.readUnsignedVarint32(), e = se >>> 3;
    return se &= 7, se != jspb.BinaryConstants.WireType.VARINT && se != jspb.BinaryConstants.WireType.FIXED32 && se != jspb.BinaryConstants.WireType.FIXED64 && se != jspb.BinaryConstants.WireType.DELIMITED && se != jspb.BinaryConstants.WireType.START_GROUP && se != jspb.BinaryConstants.WireType.END_GROUP ? (jspb.asserts.fail(
      "Invalid wire type: %s (at position %s)",
      se,
      this.fieldCursor_
    ), this.error_ = !0, !1) : (this.nextField_ = e, this.nextWireType_ = se, !0);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "nextField", jspb.BinaryReader.prototype.nextField), jspb.BinaryReader.prototype.unskipHeader = function() {
    this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
  }, jspb.BinaryReader.prototype.skipMatchingFields = function() {
    var se = this.nextField_;
    for (this.unskipHeader(); this.nextField() && this.getFieldNumber() == se; )
      this.skipField();
    this.decoder_.atEnd() || this.unskipHeader();
  }, jspb.BinaryReader.prototype.skipVarintField = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT ? (jspb.asserts.fail("Invalid wire type for skipVarintField"), this.skipField()) : this.decoder_.skipVarint();
  }, jspb.BinaryReader.prototype.skipDelimitedField = function() {
    if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED)
      jspb.asserts.fail("Invalid wire type for skipDelimitedField"), this.skipField();
    else {
      var se = this.decoder_.readUnsignedVarint32();
      this.decoder_.advance(se);
    }
  }, jspb.BinaryReader.prototype.skipFixed32Field = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32 ? (jspb.asserts.fail("Invalid wire type for skipFixed32Field"), this.skipField()) : this.decoder_.advance(4);
  }, jspb.BinaryReader.prototype.skipFixed64Field = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64 ? (jspb.asserts.fail("Invalid wire type for skipFixed64Field"), this.skipField()) : this.decoder_.advance(8);
  }, jspb.BinaryReader.prototype.skipGroup = function() {
    var se = this.nextField_;
    do {
      if (!this.nextField()) {
        jspb.asserts.fail("Unmatched start-group tag: stream EOF"), this.error_ = !0;
        break;
      }
      if (this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP) {
        this.nextField_ != se && (jspb.asserts.fail("Unmatched end-group tag"), this.error_ = !0);
        break;
      }
      this.skipField();
    } while (1);
  }, jspb.BinaryReader.prototype.skipField = function() {
    switch (this.nextWireType_) {
      case jspb.BinaryConstants.WireType.VARINT:
        this.skipVarintField();
        break;
      case jspb.BinaryConstants.WireType.FIXED64:
        this.skipFixed64Field();
        break;
      case jspb.BinaryConstants.WireType.DELIMITED:
        this.skipDelimitedField();
        break;
      case jspb.BinaryConstants.WireType.FIXED32:
        this.skipFixed32Field();
        break;
      case jspb.BinaryConstants.WireType.START_GROUP:
        this.skipGroup();
        break;
      default:
        jspb.asserts.fail("Invalid wire encoding for field.");
    }
  }, jspb.BinaryReader.prototype.registerReadCallback = function(se, e) {
    this.readCallbacks_ === null && (this.readCallbacks_ = {}), jspb.asserts.assert(!this.readCallbacks_[se]), this.readCallbacks_[se] = e;
  }, jspb.BinaryReader.prototype.runReadCallback = function(se) {
    return jspb.asserts.assert(this.readCallbacks_ !== null), se = this.readCallbacks_[se], jspb.asserts.assert(se), se(this);
  }, jspb.BinaryReader.prototype.readAny = function(se) {
    this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(se);
    var e = jspb.BinaryConstants.FieldType;
    switch (se) {
      case e.DOUBLE:
        return this.readDouble();
      case e.FLOAT:
        return this.readFloat();
      case e.INT64:
        return this.readInt64();
      case e.UINT64:
        return this.readUint64();
      case e.INT32:
        return this.readInt32();
      case e.FIXED64:
        return this.readFixed64();
      case e.FIXED32:
        return this.readFixed32();
      case e.BOOL:
        return this.readBool();
      case e.STRING:
        return this.readString();
      case e.GROUP:
        jspb.asserts.fail("Group field type not supported in readAny()");
      case e.MESSAGE:
        jspb.asserts.fail("Message field type not supported in readAny()");
      case e.BYTES:
        return this.readBytes();
      case e.UINT32:
        return this.readUint32();
      case e.ENUM:
        return this.readEnum();
      case e.SFIXED32:
        return this.readSfixed32();
      case e.SFIXED64:
        return this.readSfixed64();
      case e.SINT32:
        return this.readSint32();
      case e.SINT64:
        return this.readSint64();
      case e.FHASH64:
        return this.readFixedHash64();
      case e.VHASH64:
        return this.readVarintHash64();
      default:
        jspb.asserts.fail("Invalid field type in readAny()");
    }
    return 0;
  }, jspb.BinaryReader.prototype.readMessage = function(se, e) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var Oe = this.decoder_.getEnd(), Si = this.decoder_.readUnsignedVarint32();
    Si = this.decoder_.getCursor() + Si, this.decoder_.setEnd(Si), e(se, this), this.decoder_.setCursor(Si), this.decoder_.setEnd(Oe);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readMessage", jspb.BinaryReader.prototype.readMessage), jspb.BinaryReader.prototype.readGroup = function(se, e, Oe) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP), jspb.asserts.assert(this.nextField_ == se), Oe(e, this), this.error_ || this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP || (jspb.asserts.fail("Group submessage did not end with an END_GROUP tag"), this.error_ = !0);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readGroup", jspb.BinaryReader.prototype.readGroup), jspb.BinaryReader.prototype.getFieldDecoder = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var se = this.decoder_.readUnsignedVarint32(), e = this.decoder_.getCursor(), Oe = e + se;
    return se = jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), e, se), this.decoder_.setCursor(Oe), se;
  }, jspb.BinaryReader.prototype.readInt32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readInt32", jspb.BinaryReader.prototype.readInt32), jspb.BinaryReader.prototype.readInt32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32String();
  }, jspb.BinaryReader.prototype.readInt64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readInt64", jspb.BinaryReader.prototype.readInt64), jspb.BinaryReader.prototype.readInt64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64String();
  }, jspb.BinaryReader.prototype.readUint32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readUint32", jspb.BinaryReader.prototype.readUint32), jspb.BinaryReader.prototype.readUint32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32String();
  }, jspb.BinaryReader.prototype.readUint64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readUint64", jspb.BinaryReader.prototype.readUint64), jspb.BinaryReader.prototype.readUint64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64String();
  }, jspb.BinaryReader.prototype.readSint32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSint32", jspb.BinaryReader.prototype.readSint32), jspb.BinaryReader.prototype.readSint64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSint64", jspb.BinaryReader.prototype.readSint64), jspb.BinaryReader.prototype.readSint64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64String();
  }, jspb.BinaryReader.prototype.readFixed32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readUint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFixed32", jspb.BinaryReader.prototype.readFixed32), jspb.BinaryReader.prototype.readFixed64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFixed64", jspb.BinaryReader.prototype.readFixed64), jspb.BinaryReader.prototype.readFixed64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64String();
  }, jspb.BinaryReader.prototype.readSfixed32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed32", jspb.BinaryReader.prototype.readSfixed32), jspb.BinaryReader.prototype.readSfixed32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32().toString();
  }, jspb.BinaryReader.prototype.readSfixed64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed64", jspb.BinaryReader.prototype.readSfixed64), jspb.BinaryReader.prototype.readSfixed64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64String();
  }, jspb.BinaryReader.prototype.readFloat = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readFloat();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFloat", jspb.BinaryReader.prototype.readFloat), jspb.BinaryReader.prototype.readDouble = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readDouble();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readDouble", jspb.BinaryReader.prototype.readDouble), jspb.BinaryReader.prototype.readBool = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), !!this.decoder_.readUnsignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readBool", jspb.BinaryReader.prototype.readBool), jspb.BinaryReader.prototype.readEnum = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readEnum", jspb.BinaryReader.prototype.readEnum), jspb.BinaryReader.prototype.readString = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var se = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(se);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readString", jspb.BinaryReader.prototype.readString), jspb.BinaryReader.prototype.readBytes = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var se = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(se);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readBytes", jspb.BinaryReader.prototype.readBytes), jspb.BinaryReader.prototype.readVarintHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readVarintHash64();
  }, jspb.BinaryReader.prototype.readSintHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarintHash64();
  }, jspb.BinaryReader.prototype.readSplitVarint64 = function(se) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(se);
  }, jspb.BinaryReader.prototype.readSplitZigzagVarint64 = function(se) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(function(e, Oe) {
      return jspb.utils.fromZigzag64(e, Oe, se);
    });
  }, jspb.BinaryReader.prototype.readFixedHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readFixedHash64();
  }, jspb.BinaryReader.prototype.readSplitFixed64 = function(se) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readSplitFixed64(se);
  }, jspb.BinaryReader.prototype.readPackedField_ = function(se) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var e = this.decoder_.readUnsignedVarint32();
    e = this.decoder_.getCursor() + e;
    for (var Oe = []; this.decoder_.getCursor() < e; )
      Oe.push(se.call(this.decoder_));
    return Oe;
  }, jspb.BinaryReader.prototype.readPackedInt32 = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt32", jspb.BinaryReader.prototype.readPackedInt32), jspb.BinaryReader.prototype.readPackedInt32String = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint32String);
  }, jspb.BinaryReader.prototype.readPackedInt64 = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt64", jspb.BinaryReader.prototype.readPackedInt64), jspb.BinaryReader.prototype.readPackedInt64String = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint64String);
  }, jspb.BinaryReader.prototype.readPackedUint32 = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint32", jspb.BinaryReader.prototype.readPackedUint32), jspb.BinaryReader.prototype.readPackedUint32String = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
  }, jspb.BinaryReader.prototype.readPackedUint64 = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint64", jspb.BinaryReader.prototype.readPackedUint64), jspb.BinaryReader.prototype.readPackedUint64String = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
  }, jspb.BinaryReader.prototype.readPackedSint32 = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint32", jspb.BinaryReader.prototype.readPackedSint32), jspb.BinaryReader.prototype.readPackedSint64 = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint64", jspb.BinaryReader.prototype.readPackedSint64), jspb.BinaryReader.prototype.readPackedSint64String = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64String);
  }, jspb.BinaryReader.prototype.readPackedFixed32 = function() {
    return this.readPackedField_(this.decoder_.readUint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed32", jspb.BinaryReader.prototype.readPackedFixed32), jspb.BinaryReader.prototype.readPackedFixed64 = function() {
    return this.readPackedField_(this.decoder_.readUint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed64", jspb.BinaryReader.prototype.readPackedFixed64), jspb.BinaryReader.prototype.readPackedFixed64String = function() {
    return this.readPackedField_(this.decoder_.readUint64String);
  }, jspb.BinaryReader.prototype.readPackedSfixed32 = function() {
    return this.readPackedField_(this.decoder_.readInt32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed32", jspb.BinaryReader.prototype.readPackedSfixed32), jspb.BinaryReader.prototype.readPackedSfixed64 = function() {
    return this.readPackedField_(this.decoder_.readInt64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed64", jspb.BinaryReader.prototype.readPackedSfixed64), jspb.BinaryReader.prototype.readPackedSfixed64String = function() {
    return this.readPackedField_(this.decoder_.readInt64String);
  }, jspb.BinaryReader.prototype.readPackedFloat = function() {
    return this.readPackedField_(this.decoder_.readFloat);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFloat", jspb.BinaryReader.prototype.readPackedFloat), jspb.BinaryReader.prototype.readPackedDouble = function() {
    return this.readPackedField_(this.decoder_.readDouble);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedDouble", jspb.BinaryReader.prototype.readPackedDouble), jspb.BinaryReader.prototype.readPackedBool = function() {
    return this.readPackedField_(this.decoder_.readBool);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedBool", jspb.BinaryReader.prototype.readPackedBool), jspb.BinaryReader.prototype.readPackedEnum = function() {
    return this.readPackedField_(this.decoder_.readEnum);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedEnum", jspb.BinaryReader.prototype.readPackedEnum), jspb.BinaryReader.prototype.readPackedVarintHash64 = function() {
    return this.readPackedField_(this.decoder_.readVarintHash64);
  }, jspb.BinaryReader.prototype.readPackedFixedHash64 = function() {
    return this.readPackedField_(this.decoder_.readFixedHash64);
  }, jspb.BinaryEncoder = function() {
    this.buffer_ = [];
  }, jspb.BinaryEncoder.prototype.length = function() {
    return this.buffer_.length;
  }, jspb.BinaryEncoder.prototype.end = function() {
    var se = this.buffer_;
    return this.buffer_ = [], se;
  }, jspb.BinaryEncoder.prototype.writeSplitVarint64 = function(se, e) {
    for (jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(e == Math.floor(e)), jspb.asserts.assert(0 <= se && se < jspb.BinaryConstants.TWO_TO_32), jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32); 0 < e || 127 < se; )
      this.buffer_.push(se & 127 | 128), se = (se >>> 7 | e << 25) >>> 0, e >>>= 7;
    this.buffer_.push(se);
  }, jspb.BinaryEncoder.prototype.writeSplitFixed64 = function(se, e) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(e == Math.floor(e)), jspb.asserts.assert(0 <= se && se < jspb.BinaryConstants.TWO_TO_32), jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeUint32(se), this.writeUint32(e);
  }, jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function(se) {
    for (jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(0 <= se && se < jspb.BinaryConstants.TWO_TO_32); 127 < se; )
      this.buffer_.push(se & 127 | 128), se >>>= 7;
    this.buffer_.push(se);
  }, jspb.BinaryEncoder.prototype.writeSignedVarint32 = function(se) {
    if (jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_31 && se < jspb.BinaryConstants.TWO_TO_31), 0 <= se)
      this.writeUnsignedVarint32(se);
    else {
      for (var e = 0; 9 > e; e++)
        this.buffer_.push(se & 127 | 128), se >>= 7;
      this.buffer_.push(1);
    }
  }, jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(0 <= se && se < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitInt64(se), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeSignedVarint64 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_63 && se < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(se), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_31 && se < jspb.BinaryConstants.TWO_TO_31), this.writeUnsignedVarint32((se << 1 ^ se >> 31) >>> 0);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_63 && se < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitZigzag64(se), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function(se) {
    this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(se));
  }, jspb.BinaryEncoder.prototype.writeZigzagVarintHash64 = function(se) {
    var e = this;
    jspb.utils.splitHash64(se), jspb.utils.toZigzag64(jspb.utils.split64Low, jspb.utils.split64High, function(Oe, Si) {
      e.writeSplitVarint64(Oe >>> 0, Si >>> 0);
    });
  }, jspb.BinaryEncoder.prototype.writeUint8 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(0 <= se && 256 > se), this.buffer_.push(se >>> 0 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint16 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(0 <= se && 65536 > se), this.buffer_.push(se >>> 0 & 255), this.buffer_.push(se >>> 8 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint32 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(0 <= se && se < jspb.BinaryConstants.TWO_TO_32), this.buffer_.push(se >>> 0 & 255), this.buffer_.push(se >>> 8 & 255), this.buffer_.push(se >>> 16 & 255), this.buffer_.push(se >>> 24 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint64 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(0 <= se && se < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitUint64(se), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeInt8 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(-128 <= se && 128 > se), this.buffer_.push(se >>> 0 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt16 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(-32768 <= se && 32768 > se), this.buffer_.push(se >>> 0 & 255), this.buffer_.push(se >>> 8 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt32 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_31 && se < jspb.BinaryConstants.TWO_TO_31), this.buffer_.push(se >>> 0 & 255), this.buffer_.push(se >>> 8 & 255), this.buffer_.push(se >>> 16 & 255), this.buffer_.push(se >>> 24 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt64 = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_63 && se < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(se), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeInt64String = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(+se >= -jspb.BinaryConstants.TWO_TO_63 && +se < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(se)), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeFloat = function(se) {
    jspb.asserts.assert(se === 1 / 0 || se === -1 / 0 || isNaN(se) || se >= -jspb.BinaryConstants.FLOAT32_MAX && se <= jspb.BinaryConstants.FLOAT32_MAX), jspb.utils.splitFloat32(se), this.writeUint32(jspb.utils.split64Low);
  }, jspb.BinaryEncoder.prototype.writeDouble = function(se) {
    jspb.asserts.assert(se === 1 / 0 || se === -1 / 0 || isNaN(se) || se >= -jspb.BinaryConstants.FLOAT64_MAX && se <= jspb.BinaryConstants.FLOAT64_MAX), jspb.utils.splitFloat64(se), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeBool = function(se) {
    jspb.asserts.assert(typeof se == "boolean" || typeof se == "number"), this.buffer_.push(se ? 1 : 0);
  }, jspb.BinaryEncoder.prototype.writeEnum = function(se) {
    jspb.asserts.assert(se == Math.floor(se)), jspb.asserts.assert(se >= -jspb.BinaryConstants.TWO_TO_31 && se < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32(se);
  }, jspb.BinaryEncoder.prototype.writeBytes = function(se) {
    this.buffer_.push.apply(this.buffer_, se);
  }, jspb.BinaryEncoder.prototype.writeVarintHash64 = function(se) {
    jspb.utils.splitHash64(se), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeFixedHash64 = function(se) {
    jspb.utils.splitHash64(se), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeString = function(se) {
    var e = this.buffer_.length;
    jspb.asserts.assertString(se);
    for (var Oe = 0; Oe < se.length; Oe++) {
      var Si = se.charCodeAt(Oe);
      if (128 > Si)
        this.buffer_.push(Si);
      else if (2048 > Si)
        this.buffer_.push(Si >> 6 | 192), this.buffer_.push(Si & 63 | 128);
      else if (65536 > Si)
        if (55296 <= Si && 56319 >= Si && Oe + 1 < se.length) {
          var wi = se.charCodeAt(Oe + 1);
          56320 <= wi && 57343 >= wi && (Si = 1024 * (Si - 55296) + wi - 56320 + 65536, this.buffer_.push(Si >> 18 | 240), this.buffer_.push(Si >> 12 & 63 | 128), this.buffer_.push(Si >> 6 & 63 | 128), this.buffer_.push(Si & 63 | 128), Oe++);
        } else
          this.buffer_.push(Si >> 12 | 224), this.buffer_.push(Si >> 6 & 63 | 128), this.buffer_.push(Si & 63 | 128);
    }
    return this.buffer_.length - e;
  }, jspb.arith = {}, jspb.arith.UInt64 = function(se, e) {
    this.lo = se, this.hi = e;
  }, jspb.arith.UInt64.prototype.cmp = function(se) {
    return this.hi < se.hi || this.hi == se.hi && this.lo < se.lo ? -1 : this.hi == se.hi && this.lo == se.lo ? 0 : 1;
  }, jspb.arith.UInt64.prototype.rightShift = function() {
    return new jspb.arith.UInt64((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
  }, jspb.arith.UInt64.prototype.leftShift = function() {
    return new jspb.arith.UInt64(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
  }, jspb.arith.UInt64.prototype.msb = function() {
    return !!(this.hi & 2147483648);
  }, jspb.arith.UInt64.prototype.lsb = function() {
    return !!(this.lo & 1);
  }, jspb.arith.UInt64.prototype.zero = function() {
    return this.lo == 0 && this.hi == 0;
  }, jspb.arith.UInt64.prototype.add = function(se) {
    return new jspb.arith.UInt64((this.lo + se.lo & 4294967295) >>> 0 >>> 0, ((this.hi + se.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + se.lo ? 1 : 0) >>> 0);
  }, jspb.arith.UInt64.prototype.sub = function(se) {
    return new jspb.arith.UInt64((this.lo - se.lo & 4294967295) >>> 0 >>> 0, ((this.hi - se.hi & 4294967295) >>> 0) - (0 > this.lo - se.lo ? 1 : 0) >>> 0);
  }, jspb.arith.UInt64.mul32x32 = function(se, e) {
    var Oe = se & 65535;
    se >>>= 16;
    var Si = e & 65535, wi = e >>> 16;
    for (e = Oe * Si + 65536 * (Oe * wi & 65535) + 65536 * (se * Si & 65535), Oe = se * wi + (Oe * wi >>> 16) + (se * Si >>> 16); 4294967296 <= e; )
      e -= 4294967296, Oe += 1;
    return new jspb.arith.UInt64(e >>> 0, Oe >>> 0);
  }, jspb.arith.UInt64.prototype.mul = function(se) {
    var e = jspb.arith.UInt64.mul32x32(this.lo, se);
    return se = jspb.arith.UInt64.mul32x32(this.hi, se), se.hi = se.lo, se.lo = 0, e.add(se);
  }, jspb.arith.UInt64.prototype.div = function(se) {
    if (se == 0)
      return [];
    var e = new jspb.arith.UInt64(0, 0), Oe = new jspb.arith.UInt64(this.lo, this.hi);
    se = new jspb.arith.UInt64(se, 0);
    for (var Si = new jspb.arith.UInt64(1, 0); !se.msb(); )
      se = se.leftShift(), Si = Si.leftShift();
    for (; !Si.zero(); )
      0 >= se.cmp(Oe) && (e = e.add(Si), Oe = Oe.sub(se)), se = se.rightShift(), Si = Si.rightShift();
    return [e, Oe];
  }, jspb.arith.UInt64.prototype.toString = function() {
    for (var se = "", e = this; !e.zero(); ) {
      e = e.div(10);
      var Oe = e[0];
      se = e[1].lo + se, e = Oe;
    }
    return se == "" && (se = "0"), se;
  }, jspb.arith.UInt64.fromString = function(se) {
    for (var e = new jspb.arith.UInt64(0, 0), Oe = new jspb.arith.UInt64(0, 0), Si = 0; Si < se.length; Si++) {
      if ("0" > se[Si] || "9" < se[Si])
        return null;
      var wi = parseInt(se[Si], 10);
      Oe.lo = wi, e = e.mul(10).add(Oe);
    }
    return e;
  }, jspb.arith.UInt64.prototype.clone = function() {
    return new jspb.arith.UInt64(this.lo, this.hi);
  }, jspb.arith.Int64 = function(se, e) {
    this.lo = se, this.hi = e;
  }, jspb.arith.Int64.prototype.add = function(se) {
    return new jspb.arith.Int64((this.lo + se.lo & 4294967295) >>> 0 >>> 0, ((this.hi + se.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + se.lo ? 1 : 0) >>> 0);
  }, jspb.arith.Int64.prototype.sub = function(se) {
    return new jspb.arith.Int64((this.lo - se.lo & 4294967295) >>> 0 >>> 0, ((this.hi - se.hi & 4294967295) >>> 0) - (0 > this.lo - se.lo ? 1 : 0) >>> 0);
  }, jspb.arith.Int64.prototype.clone = function() {
    return new jspb.arith.Int64(this.lo, this.hi);
  }, jspb.arith.Int64.prototype.toString = function() {
    var se = (this.hi & 2147483648) != 0, e = new jspb.arith.UInt64(this.lo, this.hi);
    return se && (e = new jspb.arith.UInt64(0, 0).sub(e)), (se ? "-" : "") + e.toString();
  }, jspb.arith.Int64.fromString = function(se) {
    var e = 0 < se.length && se[0] == "-";
    return e && (se = se.substring(1)), se = jspb.arith.UInt64.fromString(se), se === null ? null : (e && (se = new jspb.arith.UInt64(0, 0).sub(se)), new jspb.arith.Int64(se.lo, se.hi));
  }, jspb.BinaryWriter = function() {
    this.blocks_ = [], this.totalLength_ = 0, this.encoder_ = new jspb.BinaryEncoder(), this.bookmarks_ = [];
  }, jspb.BinaryWriter.prototype.appendUint8Array_ = function(se) {
    var e = this.encoder_.end();
    this.blocks_.push(e), this.blocks_.push(se), this.totalLength_ += e.length + se.length;
  }, jspb.BinaryWriter.prototype.beginDelimited_ = function(se) {
    return this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), se = this.encoder_.end(), this.blocks_.push(se), this.totalLength_ += se.length, se.push(this.totalLength_), se;
  }, jspb.BinaryWriter.prototype.endDelimited_ = function(se) {
    var e = se.pop();
    for (e = this.totalLength_ + this.encoder_.length() - e, jspb.asserts.assert(0 <= e); 127 < e; )
      se.push(e & 127 | 128), e >>>= 7, this.totalLength_++;
    se.push(e), this.totalLength_++;
  }, jspb.BinaryWriter.prototype.writeSerializedMessage = function(se, e, Oe) {
    this.appendUint8Array_(se.subarray(e, Oe));
  }, jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function(se, e, Oe) {
    se != null && e != null && Oe != null && this.writeSerializedMessage(se, e, Oe);
  }, jspb.BinaryWriter.prototype.reset = function() {
    this.blocks_ = [], this.encoder_.end(), this.totalLength_ = 0, this.bookmarks_ = [];
  }, jspb.BinaryWriter.prototype.getResultBuffer = function() {
    jspb.asserts.assert(this.bookmarks_.length == 0);
    for (var se = new Uint8Array(this.totalLength_ + this.encoder_.length()), e = this.blocks_, Oe = e.length, Si = 0, wi = 0; wi < Oe; wi++) {
      var Ei = e[wi];
      se.set(Ei, Si), Si += Ei.length;
    }
    return e = this.encoder_.end(), se.set(e, Si), Si += e.length, jspb.asserts.assert(Si == se.length), this.blocks_ = [se], se;
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "getResultBuffer", jspb.BinaryWriter.prototype.getResultBuffer), jspb.BinaryWriter.prototype.getResultBase64String = function(se) {
    return goog.crypt.base64.encodeByteArray(this.getResultBuffer(), se);
  }, jspb.BinaryWriter.prototype.beginSubMessage = function(se) {
    this.bookmarks_.push(this.beginDelimited_(se));
  }, jspb.BinaryWriter.prototype.endSubMessage = function() {
    jspb.asserts.assert(0 <= this.bookmarks_.length), this.endDelimited_(this.bookmarks_.pop());
  }, jspb.BinaryWriter.prototype.writeFieldHeader_ = function(se, e) {
    jspb.asserts.assert(1 <= se && se == Math.floor(se)), this.encoder_.writeUnsignedVarint32(8 * se + e);
  }, jspb.BinaryWriter.prototype.writeAny = function(se, e, Oe) {
    var Si = jspb.BinaryConstants.FieldType;
    switch (se) {
      case Si.DOUBLE:
        this.writeDouble(e, Oe);
        break;
      case Si.FLOAT:
        this.writeFloat(e, Oe);
        break;
      case Si.INT64:
        this.writeInt64(e, Oe);
        break;
      case Si.UINT64:
        this.writeUint64(e, Oe);
        break;
      case Si.INT32:
        this.writeInt32(e, Oe);
        break;
      case Si.FIXED64:
        this.writeFixed64(e, Oe);
        break;
      case Si.FIXED32:
        this.writeFixed32(e, Oe);
        break;
      case Si.BOOL:
        this.writeBool(e, Oe);
        break;
      case Si.STRING:
        this.writeString(e, Oe);
        break;
      case Si.GROUP:
        jspb.asserts.fail("Group field type not supported in writeAny()");
        break;
      case Si.MESSAGE:
        jspb.asserts.fail("Message field type not supported in writeAny()");
        break;
      case Si.BYTES:
        this.writeBytes(e, Oe);
        break;
      case Si.UINT32:
        this.writeUint32(e, Oe);
        break;
      case Si.ENUM:
        this.writeEnum(e, Oe);
        break;
      case Si.SFIXED32:
        this.writeSfixed32(e, Oe);
        break;
      case Si.SFIXED64:
        this.writeSfixed64(e, Oe);
        break;
      case Si.SINT32:
        this.writeSint32(e, Oe);
        break;
      case Si.SINT64:
        this.writeSint64(e, Oe);
        break;
      case Si.FHASH64:
        this.writeFixedHash64(e, Oe);
        break;
      case Si.VHASH64:
        this.writeVarintHash64(e, Oe);
        break;
      default:
        jspb.asserts.fail("Invalid field type in writeAny()");
    }
  }, jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint32(e));
  }, jspb.BinaryWriter.prototype.writeSignedVarint32_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(e));
  }, jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint64(e));
  }, jspb.BinaryWriter.prototype.writeSignedVarint64_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint64(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint32(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64String(e));
  }, jspb.BinaryWriter.prototype.writeZigzagVarintHash64_ = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarintHash64(e));
  }, jspb.BinaryWriter.prototype.writeInt32 = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(se, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt32", jspb.BinaryWriter.prototype.writeInt32), jspb.BinaryWriter.prototype.writeInt32String = function(se, e) {
    e != null && (e = parseInt(e, 10), jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(se, e));
  }, jspb.BinaryWriter.prototype.writeInt64 = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), this.writeSignedVarint64_(se, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt64", jspb.BinaryWriter.prototype.writeInt64), jspb.BinaryWriter.prototype.writeInt64String = function(se, e) {
    e != null && (e = jspb.arith.Int64.fromString(e), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeUint32 = function(se, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(se, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint32", jspb.BinaryWriter.prototype.writeUint32), jspb.BinaryWriter.prototype.writeUint32String = function(se, e) {
    e != null && (e = parseInt(e, 10), jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(se, e));
  }, jspb.BinaryWriter.prototype.writeUint64 = function(se, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_64), this.writeUnsignedVarint64_(se, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint64", jspb.BinaryWriter.prototype.writeUint64), jspb.BinaryWriter.prototype.writeUint64String = function(se, e) {
    e != null && (e = jspb.arith.UInt64.fromString(e), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeSint32 = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeZigzagVarint32_(se, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint32", jspb.BinaryWriter.prototype.writeSint32), jspb.BinaryWriter.prototype.writeSint64 = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64_(se, e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint64", jspb.BinaryWriter.prototype.writeSint64), jspb.BinaryWriter.prototype.writeSintHash64 = function(se, e) {
    e != null && this.writeZigzagVarintHash64_(se, e);
  }, jspb.BinaryWriter.prototype.writeSint64String = function(se, e) {
    e != null && this.writeZigzagVarint64String_(se, e);
  }, jspb.BinaryWriter.prototype.writeFixed32 = function(se, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeUint32(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed32", jspb.BinaryWriter.prototype.writeFixed32), jspb.BinaryWriter.prototype.writeFixed64 = function(se, e) {
    e != null && (jspb.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_64), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeUint64(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed64", jspb.BinaryWriter.prototype.writeFixed64), jspb.BinaryWriter.prototype.writeFixed64String = function(se, e) {
    e != null && (e = jspb.arith.UInt64.fromString(e), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeSfixed32 = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeInt32(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed32", jspb.BinaryWriter.prototype.writeSfixed32), jspb.BinaryWriter.prototype.writeSfixed64 = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeInt64(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed64", jspb.BinaryWriter.prototype.writeSfixed64), jspb.BinaryWriter.prototype.writeSfixed64String = function(se, e) {
    e != null && (e = jspb.arith.Int64.fromString(e), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(e.lo, e.hi));
  }, jspb.BinaryWriter.prototype.writeFloat = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeFloat(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFloat", jspb.BinaryWriter.prototype.writeFloat), jspb.BinaryWriter.prototype.writeDouble = function(se, e) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeDouble(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeDouble", jspb.BinaryWriter.prototype.writeDouble), jspb.BinaryWriter.prototype.writeBool = function(se, e) {
    e != null && (jspb.asserts.assert(typeof e == "boolean" || typeof e == "number"), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeBool(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeBool", jspb.BinaryWriter.prototype.writeBool), jspb.BinaryWriter.prototype.writeEnum = function(se, e) {
    e != null && (jspb.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeEnum", jspb.BinaryWriter.prototype.writeEnum), jspb.BinaryWriter.prototype.writeString = function(se, e) {
    e != null && (se = this.beginDelimited_(se), this.encoder_.writeString(e), this.endDelimited_(se));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeString", jspb.BinaryWriter.prototype.writeString), jspb.BinaryWriter.prototype.writeBytes = function(se, e) {
    e != null && (e = jspb.utils.byteSourceToUint8Array(e), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(e.length), this.appendUint8Array_(e));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeBytes", jspb.BinaryWriter.prototype.writeBytes), jspb.BinaryWriter.prototype.writeMessage = function(se, e, Oe) {
    e != null && (se = this.beginDelimited_(se), Oe(e, this), this.endDelimited_(se));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeMessage", jspb.BinaryWriter.prototype.writeMessage), jspb.BinaryWriter.prototype.writeMessageSet = function(se, e, Oe) {
    e != null && (this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.START_GROUP), this.writeFieldHeader_(2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(se), se = this.beginDelimited_(3), Oe(e, this), this.endDelimited_(se), this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.END_GROUP));
  }, jspb.BinaryWriter.prototype.writeGroup = function(se, e, Oe) {
    e != null && (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.START_GROUP), Oe(e, this), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.END_GROUP));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeGroup", jspb.BinaryWriter.prototype.writeGroup), jspb.BinaryWriter.prototype.writeFixedHash64 = function(se, e) {
    e != null && (jspb.asserts.assert(e.length == 8), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeFixedHash64(e));
  }, jspb.BinaryWriter.prototype.writeVarintHash64 = function(se, e) {
    e != null && (jspb.asserts.assert(e.length == 8), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeVarintHash64(e));
  }, jspb.BinaryWriter.prototype.writeSplitFixed64 = function(se, e, Oe) {
    this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(e, Oe);
  }, jspb.BinaryWriter.prototype.writeSplitVarint64 = function(se, e, Oe) {
    this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(e, Oe);
  }, jspb.BinaryWriter.prototype.writeSplitZigzagVarint64 = function(se, e, Oe) {
    this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.VARINT);
    var Si = this.encoder_;
    jspb.utils.toZigzag64(e, Oe, function(wi, Ei) {
      Si.writeSplitVarint64(wi >>> 0, Ei >>> 0);
    });
  }, jspb.BinaryWriter.prototype.writeRepeatedInt32 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeSignedVarint32_(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt32", jspb.BinaryWriter.prototype.writeRepeatedInt32), jspb.BinaryWriter.prototype.writeRepeatedInt32String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeInt32String(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedInt64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeSignedVarint64_(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt64", jspb.BinaryWriter.prototype.writeRepeatedInt64), jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64 = function(se, e, Oe, Si) {
    if (e != null)
      for (var wi = 0; wi < e.length; wi++)
        this.writeSplitFixed64(se, Oe(e[wi]), Si(e[wi]));
  }, jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64 = function(se, e, Oe, Si) {
    if (e != null)
      for (var wi = 0; wi < e.length; wi++)
        this.writeSplitVarint64(se, Oe(e[wi]), Si(e[wi]));
  }, jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64 = function(se, e, Oe, Si) {
    if (e != null)
      for (var wi = 0; wi < e.length; wi++)
        this.writeSplitZigzagVarint64(se, Oe(e[wi]), Si(e[wi]));
  }, jspb.BinaryWriter.prototype.writeRepeatedInt64String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeInt64String(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedUint32 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeUnsignedVarint32_(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint32", jspb.BinaryWriter.prototype.writeRepeatedUint32), jspb.BinaryWriter.prototype.writeRepeatedUint32String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeUint32String(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedUint64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeUnsignedVarint64_(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint64", jspb.BinaryWriter.prototype.writeRepeatedUint64), jspb.BinaryWriter.prototype.writeRepeatedUint64String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeUint64String(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedSint32 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeZigzagVarint32_(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint32", jspb.BinaryWriter.prototype.writeRepeatedSint32), jspb.BinaryWriter.prototype.writeRepeatedSint64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeZigzagVarint64_(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint64", jspb.BinaryWriter.prototype.writeRepeatedSint64), jspb.BinaryWriter.prototype.writeRepeatedSint64String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeZigzagVarint64String_(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedSintHash64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeZigzagVarintHash64_(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeFixed32(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed32", jspb.BinaryWriter.prototype.writeRepeatedFixed32), jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeFixed64(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64", jspb.BinaryWriter.prototype.writeRepeatedFixed64), jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeFixed64String(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64String", jspb.BinaryWriter.prototype.writeRepeatedFixed64String), jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeSfixed32(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed32", jspb.BinaryWriter.prototype.writeRepeatedSfixed32), jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeSfixed64(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed64", jspb.BinaryWriter.prototype.writeRepeatedSfixed64), jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeSfixed64String(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedFloat = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeFloat(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFloat", jspb.BinaryWriter.prototype.writeRepeatedFloat), jspb.BinaryWriter.prototype.writeRepeatedDouble = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeDouble(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedDouble", jspb.BinaryWriter.prototype.writeRepeatedDouble), jspb.BinaryWriter.prototype.writeRepeatedBool = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeBool(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBool", jspb.BinaryWriter.prototype.writeRepeatedBool), jspb.BinaryWriter.prototype.writeRepeatedEnum = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeEnum(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedEnum", jspb.BinaryWriter.prototype.writeRepeatedEnum), jspb.BinaryWriter.prototype.writeRepeatedString = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeString(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedString", jspb.BinaryWriter.prototype.writeRepeatedString), jspb.BinaryWriter.prototype.writeRepeatedBytes = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeBytes(se, e[Oe]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBytes", jspb.BinaryWriter.prototype.writeRepeatedBytes), jspb.BinaryWriter.prototype.writeRepeatedMessage = function(se, e, Oe) {
    if (e != null)
      for (var Si = 0; Si < e.length; Si++) {
        var wi = this.beginDelimited_(se);
        Oe(e[Si], this), this.endDelimited_(wi);
      }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedMessage", jspb.BinaryWriter.prototype.writeRepeatedMessage), jspb.BinaryWriter.prototype.writeRepeatedGroup = function(se, e, Oe) {
    if (e != null)
      for (var Si = 0; Si < e.length; Si++)
        this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.START_GROUP), Oe(e[Si], this), this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.END_GROUP);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedGroup", jspb.BinaryWriter.prototype.writeRepeatedGroup), jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeFixedHash64(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 = function(se, e) {
    if (e != null)
      for (var Oe = 0; Oe < e.length; Oe++)
        this.writeVarintHash64(se, e[Oe]);
  }, jspb.BinaryWriter.prototype.writePackedInt32 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeSignedVarint32(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt32", jspb.BinaryWriter.prototype.writePackedInt32), jspb.BinaryWriter.prototype.writePackedInt32String = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeSignedVarint32(parseInt(e[Oe], 10));
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedInt64 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeSignedVarint64(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt64", jspb.BinaryWriter.prototype.writePackedInt64), jspb.BinaryWriter.prototype.writePackedSplitFixed64 = function(se, e, Oe, Si) {
    if (e != null) {
      se = this.beginDelimited_(se);
      for (var wi = 0; wi < e.length; wi++)
        this.encoder_.writeSplitFixed64(Oe(e[wi]), Si(e[wi]));
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedSplitVarint64 = function(se, e, Oe, Si) {
    if (e != null) {
      se = this.beginDelimited_(se);
      for (var wi = 0; wi < e.length; wi++)
        this.encoder_.writeSplitVarint64(Oe(e[wi]), Si(e[wi]));
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64 = function(se, e, Oe, Si) {
    if (e != null) {
      se = this.beginDelimited_(se);
      for (var wi = this.encoder_, Ei = 0; Ei < e.length; Ei++)
        jspb.utils.toZigzag64(Oe(e[Ei]), Si(e[Ei]), function($i, xi) {
          wi.writeSplitVarint64($i >>> 0, xi >>> 0);
        });
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedInt64String = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++) {
        var Si = jspb.arith.Int64.fromString(e[Oe]);
        this.encoder_.writeSplitVarint64(Si.lo, Si.hi);
      }
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedUint32 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeUnsignedVarint32(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint32", jspb.BinaryWriter.prototype.writePackedUint32), jspb.BinaryWriter.prototype.writePackedUint32String = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeUnsignedVarint32(parseInt(e[Oe], 10));
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedUint64 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeUnsignedVarint64(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint64", jspb.BinaryWriter.prototype.writePackedUint64), jspb.BinaryWriter.prototype.writePackedUint64String = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++) {
        var Si = jspb.arith.UInt64.fromString(e[Oe]);
        this.encoder_.writeSplitVarint64(Si.lo, Si.hi);
      }
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedSint32 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeZigzagVarint32(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint32", jspb.BinaryWriter.prototype.writePackedSint32), jspb.BinaryWriter.prototype.writePackedSint64 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeZigzagVarint64(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint64", jspb.BinaryWriter.prototype.writePackedSint64), jspb.BinaryWriter.prototype.writePackedSint64String = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(e[Oe]));
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedSintHash64 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeZigzagVarintHash64(e[Oe]);
      this.endDelimited_(se);
    }
  }, jspb.BinaryWriter.prototype.writePackedFixed32 = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeUint32(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed32", jspb.BinaryWriter.prototype.writePackedFixed32), jspb.BinaryWriter.prototype.writePackedFixed64 = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeUint64(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed64", jspb.BinaryWriter.prototype.writePackedFixed64), jspb.BinaryWriter.prototype.writePackedFixed64String = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), se = 0; se < e.length; se++) {
        var Oe = jspb.arith.UInt64.fromString(e[se]);
        this.encoder_.writeSplitFixed64(Oe.lo, Oe.hi);
      }
  }, jspb.BinaryWriter.prototype.writePackedSfixed32 = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeInt32(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed32", jspb.BinaryWriter.prototype.writePackedSfixed32), jspb.BinaryWriter.prototype.writePackedSfixed64 = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeInt64(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed64", jspb.BinaryWriter.prototype.writePackedSfixed64), jspb.BinaryWriter.prototype.writePackedSfixed64String = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeInt64String(e[se]);
  }, jspb.BinaryWriter.prototype.writePackedFloat = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeFloat(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFloat", jspb.BinaryWriter.prototype.writePackedFloat), jspb.BinaryWriter.prototype.writePackedDouble = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeDouble(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedDouble", jspb.BinaryWriter.prototype.writePackedDouble), jspb.BinaryWriter.prototype.writePackedBool = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(e.length), se = 0; se < e.length; se++)
        this.encoder_.writeBool(e[se]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedBool", jspb.BinaryWriter.prototype.writePackedBool), jspb.BinaryWriter.prototype.writePackedEnum = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeEnum(e[Oe]);
      this.endDelimited_(se);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedEnum", jspb.BinaryWriter.prototype.writePackedEnum), jspb.BinaryWriter.prototype.writePackedFixedHash64 = function(se, e) {
    if (e != null && e.length)
      for (this.writeFieldHeader_(se, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * e.length), se = 0; se < e.length; se++)
        this.encoder_.writeFixedHash64(e[se]);
  }, jspb.BinaryWriter.prototype.writePackedVarintHash64 = function(se, e) {
    if (e != null && e.length) {
      se = this.beginDelimited_(se);
      for (var Oe = 0; Oe < e.length; Oe++)
        this.encoder_.writeVarintHash64(e[Oe]);
      this.endDelimited_(se);
    }
  }, jspb.Map = function(se, e) {
    this.arr_ = se, this.valueCtor_ = e, this.map_ = {}, this.arrClean = !0, 0 < this.arr_.length && this.loadFromArray_();
  }, goog.exportSymbol("jspb.Map", jspb.Map), jspb.Map.prototype.loadFromArray_ = function() {
    for (var se = 0; se < this.arr_.length; se++) {
      var e = this.arr_[se], Oe = e[0];
      this.map_[Oe.toString()] = new jspb.Map.Entry_(Oe, e[1]);
    }
    this.arrClean = !0;
  }, jspb.Map.prototype.toArray = function() {
    if (this.arrClean) {
      if (this.valueCtor_) {
        var se = this.map_, e;
        for (e in se)
          if (Object.prototype.hasOwnProperty.call(se, e)) {
            var Oe = se[e].valueWrapper;
            Oe && Oe.toArray();
          }
      }
    } else {
      for (this.arr_.length = 0, se = this.stringKeys_(), se.sort(), e = 0; e < se.length; e++) {
        var Si = this.map_[se[e]];
        (Oe = Si.valueWrapper) && Oe.toArray(), this.arr_.push([Si.key, Si.value]);
      }
      this.arrClean = !0;
    }
    return this.arr_;
  }, goog.exportProperty(jspb.Map.prototype, "toArray", jspb.Map.prototype.toArray), jspb.Map.prototype.toObject = function(se, e) {
    for (var Oe = this.toArray(), Si = [], wi = 0; wi < Oe.length; wi++) {
      var Ei = this.map_[Oe[wi][0].toString()];
      this.wrapEntry_(Ei);
      var $i = Ei.valueWrapper;
      $i ? (jspb.asserts.assert(e), Si.push([Ei.key, e(se, $i)])) : Si.push([Ei.key, Ei.value]);
    }
    return Si;
  }, goog.exportProperty(jspb.Map.prototype, "toObject", jspb.Map.prototype.toObject), jspb.Map.fromObject = function(se, e, Oe) {
    e = new jspb.Map([], e);
    for (var Si = 0; Si < se.length; Si++) {
      var wi = se[Si][0], Ei = Oe(se[Si][1]);
      e.set(wi, Ei);
    }
    return e;
  }, goog.exportProperty(jspb.Map, "fromObject", jspb.Map.fromObject), jspb.Map.ArrayIteratorIterable_ = function(se) {
    this.idx_ = 0, this.arr_ = se;
  }, jspb.Map.ArrayIteratorIterable_.prototype.next = function() {
    return this.idx_ < this.arr_.length ? { done: !1, value: this.arr_[this.idx_++] } : { done: !0, value: void 0 };
  }, typeof Symbol < "u" && (jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function() {
    return this;
  }), jspb.Map.prototype.getLength = function() {
    return this.stringKeys_().length;
  }, goog.exportProperty(jspb.Map.prototype, "getLength", jspb.Map.prototype.getLength), jspb.Map.prototype.clear = function() {
    this.map_ = {}, this.arrClean = !1;
  }, goog.exportProperty(jspb.Map.prototype, "clear", jspb.Map.prototype.clear), jspb.Map.prototype.del = function(se) {
    se = se.toString();
    var e = this.map_.hasOwnProperty(se);
    return delete this.map_[se], this.arrClean = !1, e;
  }, goog.exportProperty(jspb.Map.prototype, "del", jspb.Map.prototype.del), jspb.Map.prototype.getEntryList = function() {
    var se = [], e = this.stringKeys_();
    e.sort();
    for (var Oe = 0; Oe < e.length; Oe++) {
      var Si = this.map_[e[Oe]];
      se.push([Si.key, Si.value]);
    }
    return se;
  }, goog.exportProperty(jspb.Map.prototype, "getEntryList", jspb.Map.prototype.getEntryList), jspb.Map.prototype.entries = function() {
    var se = [], e = this.stringKeys_();
    e.sort();
    for (var Oe = 0; Oe < e.length; Oe++) {
      var Si = this.map_[e[Oe]];
      se.push([Si.key, this.wrapEntry_(Si)]);
    }
    return new jspb.Map.ArrayIteratorIterable_(se);
  }, goog.exportProperty(jspb.Map.prototype, "entries", jspb.Map.prototype.entries), jspb.Map.prototype.keys = function() {
    var se = [], e = this.stringKeys_();
    e.sort();
    for (var Oe = 0; Oe < e.length; Oe++)
      se.push(this.map_[e[Oe]].key);
    return new jspb.Map.ArrayIteratorIterable_(se);
  }, goog.exportProperty(jspb.Map.prototype, "keys", jspb.Map.prototype.keys), jspb.Map.prototype.values = function() {
    var se = [], e = this.stringKeys_();
    e.sort();
    for (var Oe = 0; Oe < e.length; Oe++)
      se.push(this.wrapEntry_(this.map_[e[Oe]]));
    return new jspb.Map.ArrayIteratorIterable_(se);
  }, goog.exportProperty(jspb.Map.prototype, "values", jspb.Map.prototype.values), jspb.Map.prototype.forEach = function(se, e) {
    var Oe = this.stringKeys_();
    Oe.sort();
    for (var Si = 0; Si < Oe.length; Si++) {
      var wi = this.map_[Oe[Si]];
      se.call(e, this.wrapEntry_(wi), wi.key, this);
    }
  }, goog.exportProperty(jspb.Map.prototype, "forEach", jspb.Map.prototype.forEach), jspb.Map.prototype.set = function(se, e) {
    var Oe = new jspb.Map.Entry_(se);
    return this.valueCtor_ ? (Oe.valueWrapper = e, Oe.value = e.toArray()) : Oe.value = e, this.map_[se.toString()] = Oe, this.arrClean = !1, this;
  }, goog.exportProperty(jspb.Map.prototype, "set", jspb.Map.prototype.set), jspb.Map.prototype.wrapEntry_ = function(se) {
    return this.valueCtor_ ? (se.valueWrapper || (se.valueWrapper = new this.valueCtor_(se.value)), se.valueWrapper) : se.value;
  }, jspb.Map.prototype.get = function(se) {
    if (se = this.map_[se.toString()])
      return this.wrapEntry_(se);
  }, goog.exportProperty(jspb.Map.prototype, "get", jspb.Map.prototype.get), jspb.Map.prototype.has = function(se) {
    return se.toString() in this.map_;
  }, goog.exportProperty(jspb.Map.prototype, "has", jspb.Map.prototype.has), jspb.Map.prototype.serializeBinary = function(se, e, Oe, Si, wi) {
    var Ei = this.stringKeys_();
    Ei.sort();
    for (var $i = 0; $i < Ei.length; $i++) {
      var xi = this.map_[Ei[$i]];
      e.beginSubMessage(se), Oe.call(e, 1, xi.key), this.valueCtor_ ? Si.call(e, 2, this.wrapEntry_(xi), wi) : Si.call(e, 2, xi.value), e.endSubMessage();
    }
  }, goog.exportProperty(jspb.Map.prototype, "serializeBinary", jspb.Map.prototype.serializeBinary), jspb.Map.deserializeBinary = function(se, e, Oe, Si, wi, Ei, $i) {
    for (; e.nextField() && !e.isEndGroup(); ) {
      var xi = e.getFieldNumber();
      xi == 1 ? Ei = Oe.call(e) : xi == 2 && (se.valueCtor_ ? (jspb.asserts.assert(wi), $i || ($i = new se.valueCtor_()), Si.call(e, $i, wi)) : $i = Si.call(e));
    }
    jspb.asserts.assert(Ei != null), jspb.asserts.assert($i != null), se.set(Ei, $i);
  }, goog.exportProperty(jspb.Map, "deserializeBinary", jspb.Map.deserializeBinary), jspb.Map.prototype.stringKeys_ = function() {
    var se = this.map_, e = [], Oe;
    for (Oe in se)
      Object.prototype.hasOwnProperty.call(se, Oe) && e.push(Oe);
    return e;
  }, jspb.Map.Entry_ = function(se, e) {
    this.key = se, this.value = e, this.valueWrapper = void 0;
  }, jspb.ExtensionFieldInfo = function(se, e, Oe, Si, wi) {
    this.fieldIndex = se, this.fieldName = e, this.ctor = Oe, this.toObjectFn = Si, this.isRepeated = wi;
  }, goog.exportSymbol("jspb.ExtensionFieldInfo", jspb.ExtensionFieldInfo), jspb.ExtensionFieldBinaryInfo = function(se, e, Oe, Si, wi, Ei) {
    this.fieldInfo = se, this.binaryReaderFn = e, this.binaryWriterFn = Oe, this.binaryMessageSerializeFn = Si, this.binaryMessageDeserializeFn = wi, this.isPacked = Ei;
  }, goog.exportSymbol("jspb.ExtensionFieldBinaryInfo", jspb.ExtensionFieldBinaryInfo), jspb.ExtensionFieldInfo.prototype.isMessageType = function() {
    return !!this.ctor;
  }, goog.exportProperty(jspb.ExtensionFieldInfo.prototype, "isMessageType", jspb.ExtensionFieldInfo.prototype.isMessageType), jspb.Message = function() {
  }, goog.exportSymbol("jspb.Message", jspb.Message), jspb.Message.GENERATE_TO_OBJECT = !0, goog.exportProperty(jspb.Message, "GENERATE_TO_OBJECT", jspb.Message.GENERATE_TO_OBJECT), jspb.Message.GENERATE_FROM_OBJECT = !goog.DISALLOW_TEST_ONLY_CODE, goog.exportProperty(jspb.Message, "GENERATE_FROM_OBJECT", jspb.Message.GENERATE_FROM_OBJECT), jspb.Message.GENERATE_TO_STRING = !0, jspb.Message.ASSUME_LOCAL_ARRAYS = !1, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS = !0, jspb.Message.SUPPORTS_UINT8ARRAY_ = typeof Uint8Array == "function", jspb.Message.prototype.getJsPbMessageId = function() {
    return this.messageId_;
  }, goog.exportProperty(jspb.Message.prototype, "getJsPbMessageId", jspb.Message.prototype.getJsPbMessageId), jspb.Message.getIndex_ = function(se, e) {
    return e + se.arrayIndexOffset_;
  }, jspb.Message.hiddenES6Property_ = function() {
  }, jspb.Message.getFieldNumber_ = function(se, e) {
    return e - se.arrayIndexOffset_;
  }, jspb.Message.initialize = function(se, e, Oe, Si, wi, Ei) {
    if (se.wrappers_ = null, e || (e = Oe ? [Oe] : []), se.messageId_ = Oe ? String(Oe) : void 0, se.arrayIndexOffset_ = Oe === 0 ? -1 : 0, se.array = e, jspb.Message.initPivotAndExtensionObject_(se, Si), se.convertedPrimitiveFields_ = {}, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS || (se.repeatedFields = wi), wi)
      for (e = 0; e < wi.length; e++)
        Oe = wi[e], Oe < se.pivot_ ? (Oe = jspb.Message.getIndex_(se, Oe), se.array[Oe] = se.array[Oe] || jspb.Message.EMPTY_LIST_SENTINEL_) : (jspb.Message.maybeInitEmptyExtensionObject_(se), se.extensionObject_[Oe] = se.extensionObject_[Oe] || jspb.Message.EMPTY_LIST_SENTINEL_);
    if (Ei && Ei.length)
      for (e = 0; e < Ei.length; e++)
        jspb.Message.computeOneofCase(se, Ei[e]);
  }, goog.exportProperty(jspb.Message, "initialize", jspb.Message.initialize), jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG && Object.freeze ? Object.freeze([]) : [], jspb.Message.isArray_ = function(se) {
    return jspb.Message.ASSUME_LOCAL_ARRAYS ? se instanceof Array : Array.isArray(se);
  }, jspb.Message.isExtensionObject_ = function(se) {
    return se !== null && typeof se == "object" && !jspb.Message.isArray_(se) && !(jspb.Message.SUPPORTS_UINT8ARRAY_ && se instanceof Uint8Array);
  }, jspb.Message.initPivotAndExtensionObject_ = function(se, e) {
    var Oe = se.array.length, Si = -1;
    if (Oe && (Si = Oe - 1, Oe = se.array[Si], jspb.Message.isExtensionObject_(Oe))) {
      se.pivot_ = jspb.Message.getFieldNumber_(se, Si), se.extensionObject_ = Oe;
      return;
    }
    -1 < e ? (se.pivot_ = Math.max(e, jspb.Message.getFieldNumber_(se, Si + 1)), se.extensionObject_ = null) : se.pivot_ = Number.MAX_VALUE;
  }, jspb.Message.maybeInitEmptyExtensionObject_ = function(se) {
    var e = jspb.Message.getIndex_(se, se.pivot_);
    se.array[e] || (se.extensionObject_ = se.array[e] = {});
  }, jspb.Message.toObjectList = function(se, e, Oe) {
    for (var Si = [], wi = 0; wi < se.length; wi++)
      Si[wi] = e.call(se[wi], Oe, se[wi]);
    return Si;
  }, goog.exportProperty(jspb.Message, "toObjectList", jspb.Message.toObjectList), jspb.Message.toObjectExtension = function(se, e, Oe, Si, wi) {
    for (var Ei in Oe) {
      var $i = Oe[Ei], xi = Si.call(se, $i);
      if (xi != null) {
        for (var Ri in $i.fieldName)
          if ($i.fieldName.hasOwnProperty(Ri))
            break;
        e[Ri] = $i.toObjectFn ? $i.isRepeated ? jspb.Message.toObjectList(xi, $i.toObjectFn, wi) : $i.toObjectFn(wi, xi) : xi;
      }
    }
  }, goog.exportProperty(jspb.Message, "toObjectExtension", jspb.Message.toObjectExtension), jspb.Message.serializeBinaryExtensions = function(se, e, Oe, Si) {
    for (var wi in Oe) {
      var Ei = Oe[wi], $i = Ei.fieldInfo;
      if (!Ei.binaryWriterFn)
        throw Error("Message extension present that was generated without binary serialization support");
      var xi = Si.call(se, $i);
      if (xi != null)
        if ($i.isMessageType())
          if (Ei.binaryMessageSerializeFn)
            Ei.binaryWriterFn.call(e, $i.fieldIndex, xi, Ei.binaryMessageSerializeFn);
          else
            throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
        else
          Ei.binaryWriterFn.call(e, $i.fieldIndex, xi);
    }
  }, goog.exportProperty(jspb.Message, "serializeBinaryExtensions", jspb.Message.serializeBinaryExtensions), jspb.Message.readBinaryExtension = function(se, e, Oe, Si, wi) {
    var Ei = Oe[e.getFieldNumber()];
    if (Ei) {
      if (Oe = Ei.fieldInfo, !Ei.binaryReaderFn)
        throw Error("Deserializing extension whose generated code does not support binary format");
      if (Oe.isMessageType()) {
        var $i = new Oe.ctor();
        Ei.binaryReaderFn.call(e, $i, Ei.binaryMessageDeserializeFn);
      } else
        $i = Ei.binaryReaderFn.call(e);
      Oe.isRepeated && !Ei.isPacked ? (e = Si.call(se, Oe)) ? e.push($i) : wi.call(se, Oe, [$i]) : wi.call(se, Oe, $i);
    } else
      e.skipField();
  }, goog.exportProperty(jspb.Message, "readBinaryExtension", jspb.Message.readBinaryExtension), jspb.Message.getField = function(se, e) {
    if (e < se.pivot_) {
      e = jspb.Message.getIndex_(se, e);
      var Oe = se.array[e];
      return Oe === jspb.Message.EMPTY_LIST_SENTINEL_ ? se.array[e] = [] : Oe;
    }
    if (se.extensionObject_)
      return Oe = se.extensionObject_[e], Oe === jspb.Message.EMPTY_LIST_SENTINEL_ ? se.extensionObject_[e] = [] : Oe;
  }, goog.exportProperty(jspb.Message, "getField", jspb.Message.getField), jspb.Message.getRepeatedField = function(se, e) {
    return jspb.Message.getField(se, e);
  }, goog.exportProperty(jspb.Message, "getRepeatedField", jspb.Message.getRepeatedField), jspb.Message.getOptionalFloatingPointField = function(se, e) {
    return se = jspb.Message.getField(se, e), se == null ? se : +se;
  }, goog.exportProperty(jspb.Message, "getOptionalFloatingPointField", jspb.Message.getOptionalFloatingPointField), jspb.Message.getBooleanField = function(se, e) {
    return se = jspb.Message.getField(se, e), se == null ? se : !!se;
  }, goog.exportProperty(jspb.Message, "getBooleanField", jspb.Message.getBooleanField), jspb.Message.getRepeatedFloatingPointField = function(se, e) {
    var Oe = jspb.Message.getRepeatedField(se, e);
    if (se.convertedPrimitiveFields_ || (se.convertedPrimitiveFields_ = {}), !se.convertedPrimitiveFields_[e]) {
      for (var Si = 0; Si < Oe.length; Si++)
        Oe[Si] = +Oe[Si];
      se.convertedPrimitiveFields_[e] = !0;
    }
    return Oe;
  }, goog.exportProperty(jspb.Message, "getRepeatedFloatingPointField", jspb.Message.getRepeatedFloatingPointField), jspb.Message.getRepeatedBooleanField = function(se, e) {
    var Oe = jspb.Message.getRepeatedField(se, e);
    if (se.convertedPrimitiveFields_ || (se.convertedPrimitiveFields_ = {}), !se.convertedPrimitiveFields_[e]) {
      for (var Si = 0; Si < Oe.length; Si++)
        Oe[Si] = !!Oe[Si];
      se.convertedPrimitiveFields_[e] = !0;
    }
    return Oe;
  }, goog.exportProperty(jspb.Message, "getRepeatedBooleanField", jspb.Message.getRepeatedBooleanField), jspb.Message.bytesAsB64 = function(se) {
    return se == null || typeof se == "string" ? se : jspb.Message.SUPPORTS_UINT8ARRAY_ && se instanceof Uint8Array ? goog.crypt.base64.encodeByteArray(se) : (jspb.asserts.fail("Cannot coerce to b64 string: " + goog.typeOf(se)), null);
  }, goog.exportProperty(jspb.Message, "bytesAsB64", jspb.Message.bytesAsB64), jspb.Message.bytesAsU8 = function(se) {
    return se == null || se instanceof Uint8Array ? se : typeof se == "string" ? goog.crypt.base64.decodeStringToUint8Array(se) : (jspb.asserts.fail("Cannot coerce to Uint8Array: " + goog.typeOf(se)), null);
  }, goog.exportProperty(jspb.Message, "bytesAsU8", jspb.Message.bytesAsU8), jspb.Message.bytesListAsB64 = function(se) {
    return jspb.Message.assertConsistentTypes_(se), se.length && typeof se[0] != "string" ? goog.array.map(se, jspb.Message.bytesAsB64) : se;
  }, goog.exportProperty(jspb.Message, "bytesListAsB64", jspb.Message.bytesListAsB64), jspb.Message.bytesListAsU8 = function(se) {
    return jspb.Message.assertConsistentTypes_(se), !se.length || se[0] instanceof Uint8Array ? se : goog.array.map(se, jspb.Message.bytesAsU8);
  }, goog.exportProperty(jspb.Message, "bytesListAsU8", jspb.Message.bytesListAsU8), jspb.Message.assertConsistentTypes_ = function(se) {
    if (goog.DEBUG && se && 1 < se.length) {
      var e = goog.typeOf(se[0]);
      goog.array.forEach(se, function(Oe) {
        goog.typeOf(Oe) != e && jspb.asserts.fail("Inconsistent type in JSPB repeated field array. Got " + goog.typeOf(Oe) + " expected " + e);
      });
    }
  }, jspb.Message.getFieldWithDefault = function(se, e, Oe) {
    return se = jspb.Message.getField(se, e), se ?? Oe;
  }, goog.exportProperty(jspb.Message, "getFieldWithDefault", jspb.Message.getFieldWithDefault), jspb.Message.getBooleanFieldWithDefault = function(se, e, Oe) {
    return se = jspb.Message.getBooleanField(se, e), se ?? Oe;
  }, goog.exportProperty(jspb.Message, "getBooleanFieldWithDefault", jspb.Message.getBooleanFieldWithDefault), jspb.Message.getFloatingPointFieldWithDefault = function(se, e, Oe) {
    return se = jspb.Message.getOptionalFloatingPointField(se, e), se ?? Oe;
  }, goog.exportProperty(jspb.Message, "getFloatingPointFieldWithDefault", jspb.Message.getFloatingPointFieldWithDefault), jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault, goog.exportProperty(jspb.Message, "getFieldProto3", jspb.Message.getFieldProto3), jspb.Message.getMapField = function(se, e, Oe, Si) {
    if (se.wrappers_ || (se.wrappers_ = {}), e in se.wrappers_)
      return se.wrappers_[e];
    var wi = jspb.Message.getField(se, e);
    if (!wi) {
      if (Oe)
        return;
      wi = [], jspb.Message.setField(se, e, wi);
    }
    return se.wrappers_[e] = new jspb.Map(wi, Si);
  }, goog.exportProperty(jspb.Message, "getMapField", jspb.Message.getMapField), jspb.Message.setField = function(se, e, Oe) {
    return jspb.asserts.assertInstanceof(se, jspb.Message), e < se.pivot_ ? se.array[jspb.Message.getIndex_(se, e)] = Oe : (jspb.Message.maybeInitEmptyExtensionObject_(se), se.extensionObject_[e] = Oe), se;
  }, goog.exportProperty(jspb.Message, "setField", jspb.Message.setField), jspb.Message.setProto3IntField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, 0);
  }, goog.exportProperty(jspb.Message, "setProto3IntField", jspb.Message.setProto3IntField), jspb.Message.setProto3FloatField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, 0);
  }, goog.exportProperty(jspb.Message, "setProto3FloatField", jspb.Message.setProto3FloatField), jspb.Message.setProto3BooleanField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, !1);
  }, goog.exportProperty(jspb.Message, "setProto3BooleanField", jspb.Message.setProto3BooleanField), jspb.Message.setProto3StringField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, "");
  }, goog.exportProperty(jspb.Message, "setProto3StringField", jspb.Message.setProto3StringField), jspb.Message.setProto3BytesField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, "");
  }, goog.exportProperty(jspb.Message, "setProto3BytesField", jspb.Message.setProto3BytesField), jspb.Message.setProto3EnumField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, 0);
  }, goog.exportProperty(jspb.Message, "setProto3EnumField", jspb.Message.setProto3EnumField), jspb.Message.setProto3StringIntField = function(se, e, Oe) {
    return jspb.Message.setFieldIgnoringDefault_(se, e, Oe, "0");
  }, goog.exportProperty(jspb.Message, "setProto3StringIntField", jspb.Message.setProto3StringIntField), jspb.Message.setFieldIgnoringDefault_ = function(se, e, Oe, Si) {
    return jspb.asserts.assertInstanceof(se, jspb.Message), Oe !== Si ? jspb.Message.setField(se, e, Oe) : e < se.pivot_ ? se.array[jspb.Message.getIndex_(se, e)] = null : (jspb.Message.maybeInitEmptyExtensionObject_(se), delete se.extensionObject_[e]), se;
  }, jspb.Message.addToRepeatedField = function(se, e, Oe, Si) {
    return jspb.asserts.assertInstanceof(se, jspb.Message), e = jspb.Message.getRepeatedField(se, e), Si != null ? e.splice(Si, 0, Oe) : e.push(Oe), se;
  }, goog.exportProperty(jspb.Message, "addToRepeatedField", jspb.Message.addToRepeatedField), jspb.Message.setOneofField = function(se, e, Oe, Si) {
    return jspb.asserts.assertInstanceof(se, jspb.Message), (Oe = jspb.Message.computeOneofCase(se, Oe)) && Oe !== e && Si !== void 0 && (se.wrappers_ && Oe in se.wrappers_ && (se.wrappers_[Oe] = void 0), jspb.Message.setField(se, Oe, void 0)), jspb.Message.setField(se, e, Si);
  }, goog.exportProperty(jspb.Message, "setOneofField", jspb.Message.setOneofField), jspb.Message.computeOneofCase = function(se, e) {
    for (var Oe, Si, wi = 0; wi < e.length; wi++) {
      var Ei = e[wi], $i = jspb.Message.getField(se, Ei);
      $i != null && (Oe = Ei, Si = $i, jspb.Message.setField(se, Ei, void 0));
    }
    return Oe ? (jspb.Message.setField(se, Oe, Si), Oe) : 0;
  }, goog.exportProperty(jspb.Message, "computeOneofCase", jspb.Message.computeOneofCase), jspb.Message.getWrapperField = function(se, e, Oe, Si) {
    if (se.wrappers_ || (se.wrappers_ = {}), !se.wrappers_[Oe]) {
      var wi = jspb.Message.getField(se, Oe);
      (Si || wi) && (se.wrappers_[Oe] = new e(wi));
    }
    return se.wrappers_[Oe];
  }, goog.exportProperty(jspb.Message, "getWrapperField", jspb.Message.getWrapperField), jspb.Message.getRepeatedWrapperField = function(se, e, Oe) {
    return jspb.Message.wrapRepeatedField_(se, e, Oe), e = se.wrappers_[Oe], e == jspb.Message.EMPTY_LIST_SENTINEL_ && (e = se.wrappers_[Oe] = []), e;
  }, goog.exportProperty(jspb.Message, "getRepeatedWrapperField", jspb.Message.getRepeatedWrapperField), jspb.Message.wrapRepeatedField_ = function(se, e, Oe) {
    if (se.wrappers_ || (se.wrappers_ = {}), !se.wrappers_[Oe]) {
      for (var Si = jspb.Message.getRepeatedField(se, Oe), wi = [], Ei = 0; Ei < Si.length; Ei++)
        wi[Ei] = new e(Si[Ei]);
      se.wrappers_[Oe] = wi;
    }
  }, jspb.Message.setWrapperField = function(se, e, Oe) {
    jspb.asserts.assertInstanceof(se, jspb.Message), se.wrappers_ || (se.wrappers_ = {});
    var Si = Oe && Oe.toArray();
    return se.wrappers_[e] = Oe, jspb.Message.setField(se, e, Si);
  }, goog.exportProperty(jspb.Message, "setWrapperField", jspb.Message.setWrapperField), jspb.Message.setOneofWrapperField = function(se, e, Oe, Si) {
    jspb.asserts.assertInstanceof(se, jspb.Message), se.wrappers_ || (se.wrappers_ = {});
    var wi = Si && Si.toArray();
    return se.wrappers_[e] = Si, jspb.Message.setOneofField(se, e, Oe, wi);
  }, goog.exportProperty(jspb.Message, "setOneofWrapperField", jspb.Message.setOneofWrapperField), jspb.Message.setRepeatedWrapperField = function(se, e, Oe) {
    jspb.asserts.assertInstanceof(se, jspb.Message), se.wrappers_ || (se.wrappers_ = {}), Oe = Oe || [];
    for (var Si = [], wi = 0; wi < Oe.length; wi++)
      Si[wi] = Oe[wi].toArray();
    return se.wrappers_[e] = Oe, jspb.Message.setField(se, e, Si);
  }, goog.exportProperty(jspb.Message, "setRepeatedWrapperField", jspb.Message.setRepeatedWrapperField), jspb.Message.addToRepeatedWrapperField = function(se, e, Oe, Si, wi) {
    jspb.Message.wrapRepeatedField_(se, Si, e);
    var Ei = se.wrappers_[e];
    return Ei || (Ei = se.wrappers_[e] = []), Oe = Oe || new Si(), se = jspb.Message.getRepeatedField(se, e), wi != null ? (Ei.splice(wi, 0, Oe), se.splice(wi, 0, Oe.toArray())) : (Ei.push(Oe), se.push(Oe.toArray())), Oe;
  }, goog.exportProperty(jspb.Message, "addToRepeatedWrapperField", jspb.Message.addToRepeatedWrapperField), jspb.Message.toMap = function(se, e, Oe, Si) {
    for (var wi = {}, Ei = 0; Ei < se.length; Ei++)
      wi[e.call(se[Ei])] = Oe ? Oe.call(se[Ei], Si, se[Ei]) : se[Ei];
    return wi;
  }, goog.exportProperty(jspb.Message, "toMap", jspb.Message.toMap), jspb.Message.prototype.syncMapFields_ = function() {
    if (this.wrappers_)
      for (var se in this.wrappers_) {
        var e = this.wrappers_[se];
        if (Array.isArray(e))
          for (var Oe = 0; Oe < e.length; Oe++)
            e[Oe] && e[Oe].toArray();
        else
          e && e.toArray();
      }
  }, jspb.Message.prototype.toArray = function() {
    return this.syncMapFields_(), this.array;
  }, goog.exportProperty(jspb.Message.prototype, "toArray", jspb.Message.prototype.toArray), jspb.Message.GENERATE_TO_STRING && (jspb.Message.prototype.toString = function() {
    return this.syncMapFields_(), this.array.toString();
  }), jspb.Message.prototype.getExtension = function(se) {
    if (this.extensionObject_) {
      this.wrappers_ || (this.wrappers_ = {});
      var e = se.fieldIndex;
      if (se.isRepeated) {
        if (se.isMessageType())
          return this.wrappers_[e] || (this.wrappers_[e] = goog.array.map(this.extensionObject_[e] || [], function(Oe) {
            return new se.ctor(Oe);
          })), this.wrappers_[e];
      } else if (se.isMessageType())
        return !this.wrappers_[e] && this.extensionObject_[e] && (this.wrappers_[e] = new se.ctor(this.extensionObject_[e])), this.wrappers_[e];
      return this.extensionObject_[e];
    }
  }, goog.exportProperty(jspb.Message.prototype, "getExtension", jspb.Message.prototype.getExtension), jspb.Message.prototype.setExtension = function(se, e) {
    this.wrappers_ || (this.wrappers_ = {}), jspb.Message.maybeInitEmptyExtensionObject_(this);
    var Oe = se.fieldIndex;
    return se.isRepeated ? (e = e || [], se.isMessageType() ? (this.wrappers_[Oe] = e, this.extensionObject_[Oe] = goog.array.map(e, function(Si) {
      return Si.toArray();
    })) : this.extensionObject_[Oe] = e) : se.isMessageType() ? (this.wrappers_[Oe] = e, this.extensionObject_[Oe] = e && e.toArray()) : this.extensionObject_[Oe] = e, this;
  }, goog.exportProperty(jspb.Message.prototype, "setExtension", jspb.Message.prototype.setExtension), jspb.Message.difference = function(se, e) {
    if (!(se instanceof e.constructor))
      throw Error("Messages have different types.");
    var Oe = se.toArray();
    e = e.toArray();
    var Si = [], wi = 0, Ei = Oe.length > e.length ? Oe.length : e.length;
    for (se.getJsPbMessageId() && (Si[0] = se.getJsPbMessageId(), wi = 1); wi < Ei; wi++)
      jspb.Message.compareFields(Oe[wi], e[wi]) || (Si[wi] = e[wi]);
    return new se.constructor(Si);
  }, goog.exportProperty(jspb.Message, "difference", jspb.Message.difference), jspb.Message.equals = function(se, e) {
    return se == e || !(!se || !e) && se instanceof e.constructor && jspb.Message.compareFields(se.toArray(), e.toArray());
  }, goog.exportProperty(jspb.Message, "equals", jspb.Message.equals), jspb.Message.compareExtensions = function(se, e) {
    se = se || {}, e = e || {};
    var Oe = {}, Si;
    for (Si in se)
      Oe[Si] = 0;
    for (Si in e)
      Oe[Si] = 0;
    for (Si in Oe)
      if (!jspb.Message.compareFields(se[Si], e[Si]))
        return !1;
    return !0;
  }, goog.exportProperty(jspb.Message, "compareExtensions", jspb.Message.compareExtensions), jspb.Message.compareFields = function(se, e) {
    if (se == e)
      return !0;
    if (!goog.isObject(se) || !goog.isObject(e))
      return typeof se == "number" && isNaN(se) || typeof e == "number" && isNaN(e) ? String(se) == String(e) : !1;
    if (se.constructor != e.constructor)
      return !1;
    if (jspb.Message.SUPPORTS_UINT8ARRAY_ && se.constructor === Uint8Array) {
      if (se.length != e.length)
        return !1;
      for (var Oe = 0; Oe < se.length; Oe++)
        if (se[Oe] != e[Oe])
          return !1;
      return !0;
    }
    if (se.constructor === Array) {
      var Si = void 0, wi = void 0, Ei = Math.max(se.length, e.length);
      for (Oe = 0; Oe < Ei; Oe++) {
        var $i = se[Oe], xi = e[Oe];
        if ($i && $i.constructor == Object && (jspb.asserts.assert(Si === void 0), jspb.asserts.assert(Oe === se.length - 1), Si = $i, $i = void 0), xi && xi.constructor == Object && (jspb.asserts.assert(wi === void 0), jspb.asserts.assert(Oe === e.length - 1), wi = xi, xi = void 0), !jspb.Message.compareFields($i, xi))
          return !1;
      }
      return Si || wi ? (Si = Si || {}, wi = wi || {}, jspb.Message.compareExtensions(Si, wi)) : !0;
    }
    if (se.constructor === Object)
      return jspb.Message.compareExtensions(se, e);
    throw Error("Invalid type in JSPB array");
  }, goog.exportProperty(jspb.Message, "compareFields", jspb.Message.compareFields), jspb.Message.prototype.cloneMessage = function() {
    return jspb.Message.cloneMessage(this);
  }, goog.exportProperty(jspb.Message.prototype, "cloneMessage", jspb.Message.prototype.cloneMessage), jspb.Message.prototype.clone = function() {
    return jspb.Message.cloneMessage(this);
  }, goog.exportProperty(jspb.Message.prototype, "clone", jspb.Message.prototype.clone), jspb.Message.clone = function(se) {
    return jspb.Message.cloneMessage(se);
  }, goog.exportProperty(jspb.Message, "clone", jspb.Message.clone), jspb.Message.cloneMessage = function(se) {
    return new se.constructor(jspb.Message.clone_(se.toArray()));
  }, jspb.Message.copyInto = function(se, e) {
    jspb.asserts.assertInstanceof(se, jspb.Message), jspb.asserts.assertInstanceof(e, jspb.Message), jspb.asserts.assert(se.constructor == e.constructor, "Copy source and target message should have the same type."), se = jspb.Message.clone(se);
    for (var Oe = e.toArray(), Si = se.toArray(), wi = Oe.length = 0; wi < Si.length; wi++)
      Oe[wi] = Si[wi];
    e.wrappers_ = se.wrappers_, e.extensionObject_ = se.extensionObject_;
  }, goog.exportProperty(jspb.Message, "copyInto", jspb.Message.copyInto), jspb.Message.clone_ = function(se) {
    if (Array.isArray(se)) {
      for (var e = Array(se.length), Oe = 0; Oe < se.length; Oe++) {
        var Si = se[Oe];
        Si != null && (e[Oe] = typeof Si == "object" ? jspb.Message.clone_(jspb.asserts.assert(Si)) : Si);
      }
      return e;
    }
    if (jspb.Message.SUPPORTS_UINT8ARRAY_ && se instanceof Uint8Array)
      return new Uint8Array(se);
    e = {};
    for (Oe in se)
      Si = se[Oe], Si != null && (e[Oe] = typeof Si == "object" ? jspb.Message.clone_(jspb.asserts.assert(Si)) : Si);
    return e;
  }, jspb.Message.registerMessageType = function(se, e) {
    e.messageId = se;
  }, goog.exportProperty(jspb.Message, "registerMessageType", jspb.Message.registerMessageType), jspb.Message.messageSetExtensions = {}, jspb.Message.messageSetExtensionsBinary = {}, jspb.Export = {}, exports.Map = jspb.Map, exports.Message = jspb.Message, exports.BinaryReader = jspb.BinaryReader, exports.BinaryWriter = jspb.BinaryWriter, exports.ExtensionFieldInfo = jspb.ExtensionFieldInfo, exports.ExtensionFieldBinaryInfo = jspb.ExtensionFieldBinaryInfo, exports.exportSymbol = goog.exportSymbol, exports.inherits = goog.inherits, exports.object = { extend: goog.object.extend }, exports.typeOf = goog.typeOf;
})(googleProtobuf);
(function(se) {
  var e = googleProtobuf, Oe = e, Si = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof Si < "u" && Si || typeof self < "u" && self || function() {
    return this;
  }.call(null) || Function("return this")();
  Oe.exportSymbol("proto.google.protobuf.DescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.DescriptorProto.ExtensionRange", null, Si), Oe.exportSymbol("proto.google.protobuf.DescriptorProto.ReservedRange", null, Si), Oe.exportSymbol("proto.google.protobuf.EnumDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.EnumDescriptorProto.EnumReservedRange", null, Si), Oe.exportSymbol("proto.google.protobuf.EnumOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.EnumValueDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.EnumValueOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.ExtensionRangeOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.FieldDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.FieldDescriptorProto.Label", null, Si), Oe.exportSymbol("proto.google.protobuf.FieldDescriptorProto.Type", null, Si), Oe.exportSymbol("proto.google.protobuf.FieldOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.FieldOptions.CType", null, Si), Oe.exportSymbol("proto.google.protobuf.FieldOptions.JSType", null, Si), Oe.exportSymbol("proto.google.protobuf.FileDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.FileDescriptorSet", null, Si), Oe.exportSymbol("proto.google.protobuf.FileOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.FileOptions.OptimizeMode", null, Si), Oe.exportSymbol("proto.google.protobuf.GeneratedCodeInfo", null, Si), Oe.exportSymbol("proto.google.protobuf.GeneratedCodeInfo.Annotation", null, Si), Oe.exportSymbol("proto.google.protobuf.MessageOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.MethodDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.MethodOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.MethodOptions.IdempotencyLevel", null, Si), Oe.exportSymbol("proto.google.protobuf.OneofDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.OneofOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.ServiceDescriptorProto", null, Si), Oe.exportSymbol("proto.google.protobuf.ServiceOptions", null, Si), Oe.exportSymbol("proto.google.protobuf.SourceCodeInfo", null, Si), Oe.exportSymbol("proto.google.protobuf.SourceCodeInfo.Location", null, Si), Oe.exportSymbol("proto.google.protobuf.UninterpretedOption", null, Si), Oe.exportSymbol("proto.google.protobuf.UninterpretedOption.NamePart", null, Si), proto.google.protobuf.FileDescriptorSet = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.FileDescriptorSet.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.FileDescriptorSet, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.FileDescriptorSet.displayName = "proto.google.protobuf.FileDescriptorSet"), proto.google.protobuf.FileDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.FileDescriptorProto.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.FileDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.FileDescriptorProto.displayName = "proto.google.protobuf.FileDescriptorProto"), proto.google.protobuf.DescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.DescriptorProto.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.DescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.DescriptorProto.displayName = "proto.google.protobuf.DescriptorProto"), proto.google.protobuf.DescriptorProto.ExtensionRange = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.DescriptorProto.ExtensionRange, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.DescriptorProto.ExtensionRange.displayName = "proto.google.protobuf.DescriptorProto.ExtensionRange"), proto.google.protobuf.DescriptorProto.ReservedRange = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.DescriptorProto.ReservedRange, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.DescriptorProto.ReservedRange.displayName = "proto.google.protobuf.DescriptorProto.ReservedRange"), proto.google.protobuf.ExtensionRangeOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.ExtensionRangeOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.ExtensionRangeOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.ExtensionRangeOptions.displayName = "proto.google.protobuf.ExtensionRangeOptions"), proto.google.protobuf.ExtensionRangeOptions.extensions = {}, proto.google.protobuf.ExtensionRangeOptions.extensionsBinary = {}, proto.google.protobuf.FieldDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.FieldDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.FieldDescriptorProto.displayName = "proto.google.protobuf.FieldDescriptorProto"), proto.google.protobuf.OneofDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.OneofDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.OneofDescriptorProto.displayName = "proto.google.protobuf.OneofDescriptorProto"), proto.google.protobuf.EnumDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.EnumDescriptorProto.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.EnumDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.EnumDescriptorProto.displayName = "proto.google.protobuf.EnumDescriptorProto"), proto.google.protobuf.EnumDescriptorProto.EnumReservedRange = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.displayName = "proto.google.protobuf.EnumDescriptorProto.EnumReservedRange"), proto.google.protobuf.EnumValueDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.EnumValueDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.EnumValueDescriptorProto.displayName = "proto.google.protobuf.EnumValueDescriptorProto"), proto.google.protobuf.ServiceDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.ServiceDescriptorProto.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.ServiceDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.ServiceDescriptorProto.displayName = "proto.google.protobuf.ServiceDescriptorProto"), proto.google.protobuf.MethodDescriptorProto = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.MethodDescriptorProto, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.MethodDescriptorProto.displayName = "proto.google.protobuf.MethodDescriptorProto"), proto.google.protobuf.FileOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.FileOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.FileOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.FileOptions.displayName = "proto.google.protobuf.FileOptions"), proto.google.protobuf.FileOptions.extensions = {}, proto.google.protobuf.FileOptions.extensionsBinary = {}, proto.google.protobuf.MessageOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.MessageOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.MessageOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.MessageOptions.displayName = "proto.google.protobuf.MessageOptions"), proto.google.protobuf.MessageOptions.extensions = {}, proto.google.protobuf.MessageOptions.extensionsBinary = {}, proto.google.protobuf.FieldOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.FieldOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.FieldOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.FieldOptions.displayName = "proto.google.protobuf.FieldOptions"), proto.google.protobuf.FieldOptions.extensions = {}, proto.google.protobuf.FieldOptions.extensionsBinary = {}, proto.google.protobuf.OneofOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.OneofOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.OneofOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.OneofOptions.displayName = "proto.google.protobuf.OneofOptions"), proto.google.protobuf.OneofOptions.extensions = {}, proto.google.protobuf.OneofOptions.extensionsBinary = {}, proto.google.protobuf.EnumOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.EnumOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.EnumOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.EnumOptions.displayName = "proto.google.protobuf.EnumOptions"), proto.google.protobuf.EnumOptions.extensions = {}, proto.google.protobuf.EnumOptions.extensionsBinary = {}, proto.google.protobuf.EnumValueOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.EnumValueOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.EnumValueOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.EnumValueOptions.displayName = "proto.google.protobuf.EnumValueOptions"), proto.google.protobuf.EnumValueOptions.extensions = {}, proto.google.protobuf.EnumValueOptions.extensionsBinary = {}, proto.google.protobuf.ServiceOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.ServiceOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.ServiceOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.ServiceOptions.displayName = "proto.google.protobuf.ServiceOptions"), proto.google.protobuf.ServiceOptions.extensions = {}, proto.google.protobuf.ServiceOptions.extensionsBinary = {}, proto.google.protobuf.MethodOptions = function(wi) {
    e.Message.initialize(this, wi, 0, 500, proto.google.protobuf.MethodOptions.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.MethodOptions, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.MethodOptions.displayName = "proto.google.protobuf.MethodOptions"), proto.google.protobuf.MethodOptions.extensions = {}, proto.google.protobuf.MethodOptions.extensionsBinary = {}, proto.google.protobuf.UninterpretedOption = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.UninterpretedOption.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.UninterpretedOption, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.UninterpretedOption.displayName = "proto.google.protobuf.UninterpretedOption"), proto.google.protobuf.UninterpretedOption.NamePart = function(wi) {
    e.Message.initialize(this, wi, 0, -1, null, null);
  }, Oe.inherits(proto.google.protobuf.UninterpretedOption.NamePart, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.UninterpretedOption.NamePart.displayName = "proto.google.protobuf.UninterpretedOption.NamePart"), proto.google.protobuf.SourceCodeInfo = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.SourceCodeInfo.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.SourceCodeInfo, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.SourceCodeInfo.displayName = "proto.google.protobuf.SourceCodeInfo"), proto.google.protobuf.SourceCodeInfo.Location = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.SourceCodeInfo.Location.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.SourceCodeInfo.Location, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.SourceCodeInfo.Location.displayName = "proto.google.protobuf.SourceCodeInfo.Location"), proto.google.protobuf.GeneratedCodeInfo = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.GeneratedCodeInfo.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.GeneratedCodeInfo, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.GeneratedCodeInfo.displayName = "proto.google.protobuf.GeneratedCodeInfo"), proto.google.protobuf.GeneratedCodeInfo.Annotation = function(wi) {
    e.Message.initialize(this, wi, 0, -1, proto.google.protobuf.GeneratedCodeInfo.Annotation.repeatedFields_, null);
  }, Oe.inherits(proto.google.protobuf.GeneratedCodeInfo.Annotation, e.Message), Oe.DEBUG && !COMPILED && (proto.google.protobuf.GeneratedCodeInfo.Annotation.displayName = "proto.google.protobuf.GeneratedCodeInfo.Annotation"), proto.google.protobuf.FileDescriptorSet.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FileDescriptorSet.prototype.toObject = function(wi) {
    return proto.google.protobuf.FileDescriptorSet.toObject(wi, this);
  }, proto.google.protobuf.FileDescriptorSet.toObject = function(wi, Ei) {
    var $i = {
      fileList: e.Message.toObjectList(
        Ei.getFileList(),
        proto.google.protobuf.FileDescriptorProto.toObject,
        wi
      )
    };
    return wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.FileDescriptorSet.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.FileDescriptorSet();
    return proto.google.protobuf.FileDescriptorSet.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.FileDescriptorSet.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = new proto.google.protobuf.FileDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader), wi.addFile(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.FileDescriptorSet.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.FileDescriptorSet.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.FileDescriptorSet.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getFileList(), $i.length > 0 && Ei.writeRepeatedMessage(
      1,
      $i,
      proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter
    );
  }, proto.google.protobuf.FileDescriptorSet.prototype.getFileList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FileDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FileDescriptorProto, 1)
    );
  }, proto.google.protobuf.FileDescriptorSet.prototype.setFileList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 1, wi);
  }, proto.google.protobuf.FileDescriptorSet.prototype.addFile = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 1, wi, proto.google.protobuf.FileDescriptorProto, Ei);
  }, proto.google.protobuf.FileDescriptorSet.prototype.clearFileList = function() {
    return this.setFileList([]);
  }, proto.google.protobuf.FileDescriptorProto.repeatedFields_ = [3, 10, 11, 4, 5, 6, 7], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FileDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.FileDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.FileDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      pb_package: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i,
      dependencyList: ($i = e.Message.getRepeatedField(Ei, 3)) == null ? void 0 : $i,
      publicDependencyList: ($i = e.Message.getRepeatedField(Ei, 10)) == null ? void 0 : $i,
      weakDependencyList: ($i = e.Message.getRepeatedField(Ei, 11)) == null ? void 0 : $i,
      messageTypeList: e.Message.toObjectList(
        Ei.getMessageTypeList(),
        proto.google.protobuf.DescriptorProto.toObject,
        wi
      ),
      enumTypeList: e.Message.toObjectList(
        Ei.getEnumTypeList(),
        proto.google.protobuf.EnumDescriptorProto.toObject,
        wi
      ),
      serviceList: e.Message.toObjectList(
        Ei.getServiceList(),
        proto.google.protobuf.ServiceDescriptorProto.toObject,
        wi
      ),
      extensionList: e.Message.toObjectList(
        Ei.getExtensionList(),
        proto.google.protobuf.FieldDescriptorProto.toObject,
        wi
      ),
      options: ($i = Ei.getOptions()) && proto.google.protobuf.FileOptions.toObject(wi, $i),
      sourceCodeInfo: ($i = Ei.getSourceCodeInfo()) && proto.google.protobuf.SourceCodeInfo.toObject(wi, $i),
      syntax: ($i = e.Message.getField(Ei, 12)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.FileDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.FileDescriptorProto();
    return proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(Ti);
          break;
        case 2:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setPackage(Ti);
          break;
        case 3:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.addDependency(Ti);
          break;
        case 10:
          for (var Ri = (
            /** @type {!Array<number>} */
            Ei.isDelimited() ? Ei.readPackedInt32() : [Ei.readInt32()]
          ), xi = 0; xi < Ri.length; xi++)
            wi.addPublicDependency(Ri[xi]);
          break;
        case 11:
          for (var Ri = (
            /** @type {!Array<number>} */
            Ei.isDelimited() ? Ei.readPackedInt32() : [Ei.readInt32()]
          ), xi = 0; xi < Ri.length; xi++)
            wi.addWeakDependency(Ri[xi]);
          break;
        case 4:
          var Ti = new proto.google.protobuf.DescriptorProto();
          Ei.readMessage(Ti, proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader), wi.addMessageType(Ti);
          break;
        case 5:
          var Ti = new proto.google.protobuf.EnumDescriptorProto();
          Ei.readMessage(Ti, proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader), wi.addEnumType(Ti);
          break;
        case 6:
          var Ti = new proto.google.protobuf.ServiceDescriptorProto();
          Ei.readMessage(Ti, proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader), wi.addService(Ti);
          break;
        case 7:
          var Ti = new proto.google.protobuf.FieldDescriptorProto();
          Ei.readMessage(Ti, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader), wi.addExtension$(Ti);
          break;
        case 8:
          var Ti = new proto.google.protobuf.FileOptions();
          Ei.readMessage(Ti, proto.google.protobuf.FileOptions.deserializeBinaryFromReader), wi.setOptions(Ti);
          break;
        case 9:
          var Ti = new proto.google.protobuf.SourceCodeInfo();
          Ei.readMessage(Ti, proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader), wi.setSourceCodeInfo(Ti);
          break;
        case 12:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setSyntax(Ti);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.FileDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 2), $i != null && Ei.writeString(
      2,
      $i
    ), $i = wi.getDependencyList(), $i.length > 0 && Ei.writeRepeatedString(
      3,
      $i
    ), $i = wi.getPublicDependencyList(), $i.length > 0 && Ei.writeRepeatedInt32(
      10,
      $i
    ), $i = wi.getWeakDependencyList(), $i.length > 0 && Ei.writeRepeatedInt32(
      11,
      $i
    ), $i = wi.getMessageTypeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      4,
      $i,
      proto.google.protobuf.DescriptorProto.serializeBinaryToWriter
    ), $i = wi.getEnumTypeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      5,
      $i,
      proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getServiceList(), $i.length > 0 && Ei.writeRepeatedMessage(
      6,
      $i,
      proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getExtensionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      7,
      $i,
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      8,
      $i,
      proto.google.protobuf.FileOptions.serializeBinaryToWriter
    ), $i = wi.getSourceCodeInfo(), $i != null && Ei.writeMessage(
      9,
      $i,
      proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter
    ), $i = /** @type {string} */
    e.Message.getField(wi, 12), $i != null && Ei.writeString(
      12,
      $i
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setPackage = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearPackage = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasPackage = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getDependencyList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 3)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setDependencyList = function(wi) {
    return e.Message.setField(this, 3, wi || []);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addDependency = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 3, wi, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearDependencyList = function() {
    return this.setDependencyList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getPublicDependencyList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 10)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setPublicDependencyList = function(wi) {
    return e.Message.setField(this, 10, wi || []);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addPublicDependency = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 10, wi, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearPublicDependencyList = function() {
    return this.setPublicDependencyList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getWeakDependencyList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 11)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setWeakDependencyList = function(wi) {
    return e.Message.setField(this, 11, wi || []);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addWeakDependency = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 11, wi, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearWeakDependencyList = function() {
    return this.setWeakDependencyList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getMessageTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto, 4)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setMessageTypeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 4, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addMessageType = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 4, wi, proto.google.protobuf.DescriptorProto, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearMessageTypeList = function() {
    return this.setMessageTypeList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getEnumTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto, 5)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setEnumTypeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 5, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addEnumType = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 5, wi, proto.google.protobuf.EnumDescriptorProto, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearEnumTypeList = function() {
    return this.setEnumTypeList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getServiceList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.ServiceDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.ServiceDescriptorProto, 6)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setServiceList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 6, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addService = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 6, wi, proto.google.protobuf.ServiceDescriptorProto, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearServiceList = function() {
    return this.setServiceList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getExtensionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 7)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setExtensionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 7, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.addExtension$ = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 7, wi, proto.google.protobuf.FieldDescriptorProto, Ei);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearExtensionList = function() {
    return this.setExtensionList([]);
  }, proto.google.protobuf.FileDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.FileOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.FileOptions, 8)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 8, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getSourceCodeInfo = function() {
    return (
      /** @type{?proto.google.protobuf.SourceCodeInfo} */
      e.Message.getWrapperField(this, proto.google.protobuf.SourceCodeInfo, 9)
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setSourceCodeInfo = function(wi) {
    return e.Message.setWrapperField(this, 9, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearSourceCodeInfo = function() {
    return this.setSourceCodeInfo(void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasSourceCodeInfo = function() {
    return e.Message.getField(this, 9) != null;
  }, proto.google.protobuf.FileDescriptorProto.prototype.getSyntax = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 12, "")
    );
  }, proto.google.protobuf.FileDescriptorProto.prototype.setSyntax = function(wi) {
    return e.Message.setField(this, 12, wi);
  }, proto.google.protobuf.FileDescriptorProto.prototype.clearSyntax = function() {
    return e.Message.setField(this, 12, void 0);
  }, proto.google.protobuf.FileDescriptorProto.prototype.hasSyntax = function() {
    return e.Message.getField(this, 12) != null;
  }, proto.google.protobuf.DescriptorProto.repeatedFields_ = [2, 6, 3, 4, 5, 8, 9, 10], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.DescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.DescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      fieldList: e.Message.toObjectList(
        Ei.getFieldList(),
        proto.google.protobuf.FieldDescriptorProto.toObject,
        wi
      ),
      extensionList: e.Message.toObjectList(
        Ei.getExtensionList(),
        proto.google.protobuf.FieldDescriptorProto.toObject,
        wi
      ),
      nestedTypeList: e.Message.toObjectList(
        Ei.getNestedTypeList(),
        proto.google.protobuf.DescriptorProto.toObject,
        wi
      ),
      enumTypeList: e.Message.toObjectList(
        Ei.getEnumTypeList(),
        proto.google.protobuf.EnumDescriptorProto.toObject,
        wi
      ),
      extensionRangeList: e.Message.toObjectList(
        Ei.getExtensionRangeList(),
        proto.google.protobuf.DescriptorProto.ExtensionRange.toObject,
        wi
      ),
      oneofDeclList: e.Message.toObjectList(
        Ei.getOneofDeclList(),
        proto.google.protobuf.OneofDescriptorProto.toObject,
        wi
      ),
      options: ($i = Ei.getOptions()) && proto.google.protobuf.MessageOptions.toObject(wi, $i),
      reservedRangeList: e.Message.toObjectList(
        Ei.getReservedRangeList(),
        proto.google.protobuf.DescriptorProto.ReservedRange.toObject,
        wi
      ),
      reservedNameList: ($i = e.Message.getRepeatedField(Ei, 10)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.DescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.DescriptorProto();
    return proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 2:
          var xi = new proto.google.protobuf.FieldDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader), wi.addField(xi);
          break;
        case 6:
          var xi = new proto.google.protobuf.FieldDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader), wi.addExtension$(xi);
          break;
        case 3:
          var xi = new proto.google.protobuf.DescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader), wi.addNestedType(xi);
          break;
        case 4:
          var xi = new proto.google.protobuf.EnumDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader), wi.addEnumType(xi);
          break;
        case 5:
          var xi = new proto.google.protobuf.DescriptorProto.ExtensionRange();
          Ei.readMessage(xi, proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader), wi.addExtensionRange(xi);
          break;
        case 8:
          var xi = new proto.google.protobuf.OneofDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader), wi.addOneofDecl(xi);
          break;
        case 7:
          var xi = new proto.google.protobuf.MessageOptions();
          Ei.readMessage(xi, proto.google.protobuf.MessageOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        case 9:
          var xi = new proto.google.protobuf.DescriptorProto.ReservedRange();
          Ei.readMessage(xi, proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader), wi.addReservedRange(xi);
          break;
        case 10:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.addReservedName(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.DescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.DescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.DescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = wi.getFieldList(), $i.length > 0 && Ei.writeRepeatedMessage(
      2,
      $i,
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getExtensionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      6,
      $i,
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getNestedTypeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      3,
      $i,
      proto.google.protobuf.DescriptorProto.serializeBinaryToWriter
    ), $i = wi.getEnumTypeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      4,
      $i,
      proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getExtensionRangeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      5,
      $i,
      proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter
    ), $i = wi.getOneofDeclList(), $i.length > 0 && Ei.writeRepeatedMessage(
      8,
      $i,
      proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      7,
      $i,
      proto.google.protobuf.MessageOptions.serializeBinaryToWriter
    ), $i = wi.getReservedRangeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      9,
      $i,
      proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter
    ), $i = wi.getReservedNameList(), $i.length > 0 && Ei.writeRepeatedString(
      10,
      $i
    );
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.toObject = function(wi) {
    return proto.google.protobuf.DescriptorProto.ExtensionRange.toObject(wi, this);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.toObject = function(wi, Ei) {
    var $i, xi = {
      start: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      end: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i,
      options: ($i = Ei.getOptions()) && proto.google.protobuf.ExtensionRangeOptions.toObject(wi, $i)
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.DescriptorProto.ExtensionRange();
    return proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setStart(xi);
          break;
        case 2:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setEnd(xi);
          break;
        case 3:
          var xi = new proto.google.protobuf.ExtensionRangeOptions();
          Ei.readMessage(xi, proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {number} */
    e.Message.getField(wi, 1), $i != null && Ei.writeInt32(
      1,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 2), $i != null && Ei.writeInt32(
      2,
      $i
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      3,
      $i,
      proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getStart = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setStart = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearStart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasStart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setEnd = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearEnd = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasEnd = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.ExtensionRangeOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.ExtensionRangeOptions, 3)
    );
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 3, wi);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DescriptorProto.ReservedRange.prototype.toObject = function(wi) {
    return proto.google.protobuf.DescriptorProto.ReservedRange.toObject(wi, this);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.toObject = function(wi, Ei) {
    var $i, xi = {
      start: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      end: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.DescriptorProto.ReservedRange();
    return proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setStart(xi);
          break;
        case 2:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setEnd(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {number} */
    e.Message.getField(wi, 1), $i != null && Ei.writeInt32(
      1,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 2), $i != null && Ei.writeInt32(
      2,
      $i
    );
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.getStart = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.setStart = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.clearStart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.hasStart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.setEnd = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.clearEnd = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.DescriptorProto.ReservedRange.prototype.hasEnd = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.DescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.DescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.DescriptorProto.prototype.getFieldList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 2)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setFieldList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 2, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addField = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 2, wi, proto.google.protobuf.FieldDescriptorProto, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearFieldList = function() {
    return this.setFieldList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getExtensionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 6)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setExtensionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 6, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addExtension$ = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 6, wi, proto.google.protobuf.FieldDescriptorProto, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearExtensionList = function() {
    return this.setExtensionList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getNestedTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto, 3)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setNestedTypeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 3, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addNestedType = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 3, wi, proto.google.protobuf.DescriptorProto, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearNestedTypeList = function() {
    return this.setNestedTypeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getEnumTypeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto, 4)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setEnumTypeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 4, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addEnumType = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 4, wi, proto.google.protobuf.EnumDescriptorProto, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearEnumTypeList = function() {
    return this.setEnumTypeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getExtensionRangeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto.ExtensionRange>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto.ExtensionRange, 5)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setExtensionRangeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 5, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addExtensionRange = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 5, wi, proto.google.protobuf.DescriptorProto.ExtensionRange, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearExtensionRangeList = function() {
    return this.setExtensionRangeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getOneofDeclList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.OneofDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.OneofDescriptorProto, 8)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setOneofDeclList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 8, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addOneofDecl = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 8, wi, proto.google.protobuf.OneofDescriptorProto, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearOneofDeclList = function() {
    return this.setOneofDeclList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.MessageOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.MessageOptions, 7)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 7, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.DescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.DescriptorProto.prototype.getReservedRangeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.DescriptorProto.ReservedRange>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto.ReservedRange, 9)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setReservedRangeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 9, wi);
  }, proto.google.protobuf.DescriptorProto.prototype.addReservedRange = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 9, wi, proto.google.protobuf.DescriptorProto.ReservedRange, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearReservedRangeList = function() {
    return this.setReservedRangeList([]);
  }, proto.google.protobuf.DescriptorProto.prototype.getReservedNameList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 10)
    );
  }, proto.google.protobuf.DescriptorProto.prototype.setReservedNameList = function(wi) {
    return e.Message.setField(this, 10, wi || []);
  }, proto.google.protobuf.DescriptorProto.prototype.addReservedName = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 10, wi, Ei);
  }, proto.google.protobuf.DescriptorProto.prototype.clearReservedNameList = function() {
    return this.setReservedNameList([]);
  }, proto.google.protobuf.ExtensionRangeOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.ExtensionRangeOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.ExtensionRangeOptions.toObject(wi, this);
  }, proto.google.protobuf.ExtensionRangeOptions.toObject = function(wi, Ei) {
    var $i = {
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      $i,
      proto.google.protobuf.ExtensionRangeOptions.extensions,
      proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension,
      wi
    ), wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.ExtensionRangeOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.ExtensionRangeOptions();
    return proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.ExtensionRangeOptions.extensionsBinary,
            proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension,
            proto.google.protobuf.ExtensionRangeOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.ExtensionRangeOptions.extensionsBinary,
      proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension
    );
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.ExtensionRangeOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FieldDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.FieldDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.FieldDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      number: ($i = e.Message.getField(Ei, 3)) == null ? void 0 : $i,
      label: ($i = e.Message.getField(Ei, 4)) == null ? void 0 : $i,
      type: ($i = e.Message.getField(Ei, 5)) == null ? void 0 : $i,
      typeName: ($i = e.Message.getField(Ei, 6)) == null ? void 0 : $i,
      extendee: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i,
      defaultValue: ($i = e.Message.getField(Ei, 7)) == null ? void 0 : $i,
      oneofIndex: ($i = e.Message.getField(Ei, 9)) == null ? void 0 : $i,
      jsonName: ($i = e.Message.getField(Ei, 10)) == null ? void 0 : $i,
      options: ($i = Ei.getOptions()) && proto.google.protobuf.FieldOptions.toObject(wi, $i),
      proto3Optional: ($i = e.Message.getBooleanField(Ei, 17)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.FieldDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.FieldDescriptorProto();
    return proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 3:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setNumber(xi);
          break;
        case 4:
          var xi = (
            /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */
            Ei.readEnum()
          );
          wi.setLabel(xi);
          break;
        case 5:
          var xi = (
            /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */
            Ei.readEnum()
          );
          wi.setType(xi);
          break;
        case 6:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setTypeName(xi);
          break;
        case 2:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setExtendee(xi);
          break;
        case 7:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setDefaultValue(xi);
          break;
        case 9:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setOneofIndex(xi);
          break;
        case 10:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setJsonName(xi);
          break;
        case 8:
          var xi = new proto.google.protobuf.FieldOptions();
          Ei.readMessage(xi, proto.google.protobuf.FieldOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        case 17:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setProto3Optional(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 3), $i != null && Ei.writeInt32(
      3,
      $i
    ), $i = /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */
    e.Message.getField(wi, 4), $i != null && Ei.writeEnum(
      4,
      $i
    ), $i = /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */
    e.Message.getField(wi, 5), $i != null && Ei.writeEnum(
      5,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 6), $i != null && Ei.writeString(
      6,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 2), $i != null && Ei.writeString(
      2,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 7), $i != null && Ei.writeString(
      7,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 9), $i != null && Ei.writeInt32(
      9,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 10), $i != null && Ei.writeString(
      10,
      $i
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      8,
      $i,
      proto.google.protobuf.FieldOptions.serializeBinaryToWriter
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 17), $i != null && Ei.writeBool(
      17,
      $i
    );
  }, proto.google.protobuf.FieldDescriptorProto.Type = {
    TYPE_DOUBLE: 1,
    TYPE_FLOAT: 2,
    TYPE_INT64: 3,
    TYPE_UINT64: 4,
    TYPE_INT32: 5,
    TYPE_FIXED64: 6,
    TYPE_FIXED32: 7,
    TYPE_BOOL: 8,
    TYPE_STRING: 9,
    TYPE_GROUP: 10,
    TYPE_MESSAGE: 11,
    TYPE_BYTES: 12,
    TYPE_UINT32: 13,
    TYPE_ENUM: 14,
    TYPE_SFIXED32: 15,
    TYPE_SFIXED64: 16,
    TYPE_SINT32: 17,
    TYPE_SINT64: 18
  }, proto.google.protobuf.FieldDescriptorProto.Label = {
    LABEL_OPTIONAL: 1,
    LABEL_REQUIRED: 2,
    LABEL_REPEATED: 3
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getNumber = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 3, 0)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setNumber = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearNumber = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasNumber = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getLabel = function() {
    return (
      /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */
      e.Message.getFieldWithDefault(this, 4, 1)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setLabel = function(wi) {
    return e.Message.setField(this, 4, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearLabel = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasLabel = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getType = function() {
    return (
      /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */
      e.Message.getFieldWithDefault(this, 5, 1)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setType = function(wi) {
    return e.Message.setField(this, 5, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearType = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasType = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getTypeName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 6, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setTypeName = function(wi) {
    return e.Message.setField(this, 6, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearTypeName = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasTypeName = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getExtendee = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setExtendee = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearExtendee = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasExtendee = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getDefaultValue = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 7, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setDefaultValue = function(wi) {
    return e.Message.setField(this, 7, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearDefaultValue = function() {
    return e.Message.setField(this, 7, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasDefaultValue = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getOneofIndex = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 9, 0)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setOneofIndex = function(wi) {
    return e.Message.setField(this, 9, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearOneofIndex = function() {
    return e.Message.setField(this, 9, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasOneofIndex = function() {
    return e.Message.getField(this, 9) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getJsonName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 10, "")
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setJsonName = function(wi) {
    return e.Message.setField(this, 10, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearJsonName = function() {
    return e.Message.setField(this, 10, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasJsonName = function() {
    return e.Message.getField(this, 10) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.FieldOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.FieldOptions, 8)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 8, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.FieldDescriptorProto.prototype.getProto3Optional = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 17, !1)
    );
  }, proto.google.protobuf.FieldDescriptorProto.prototype.setProto3Optional = function(wi) {
    return e.Message.setField(this, 17, wi);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.clearProto3Optional = function() {
    return e.Message.setField(this, 17, void 0);
  }, proto.google.protobuf.FieldDescriptorProto.prototype.hasProto3Optional = function() {
    return e.Message.getField(this, 17) != null;
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.OneofDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.OneofDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.OneofDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      options: ($i = Ei.getOptions()) && proto.google.protobuf.OneofOptions.toObject(wi, $i)
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.OneofDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.OneofDescriptorProto();
    return proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 2:
          var xi = new proto.google.protobuf.OneofOptions();
          Ei.readMessage(xi, proto.google.protobuf.OneofOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.OneofDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      2,
      $i,
      proto.google.protobuf.OneofOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.OneofDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.OneofDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.OneofDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.OneofOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.OneofOptions, 2)
    );
  }, proto.google.protobuf.OneofDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 2, wi);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.OneofDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumDescriptorProto.repeatedFields_ = [2, 4, 5], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.EnumDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.EnumDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      valueList: e.Message.toObjectList(
        Ei.getValueList(),
        proto.google.protobuf.EnumValueDescriptorProto.toObject,
        wi
      ),
      options: ($i = Ei.getOptions()) && proto.google.protobuf.EnumOptions.toObject(wi, $i),
      reservedRangeList: e.Message.toObjectList(
        Ei.getReservedRangeList(),
        proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject,
        wi
      ),
      reservedNameList: ($i = e.Message.getRepeatedField(Ei, 5)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.EnumDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.EnumDescriptorProto();
    return proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 2:
          var xi = new proto.google.protobuf.EnumValueDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader), wi.addValue(xi);
          break;
        case 3:
          var xi = new proto.google.protobuf.EnumOptions();
          Ei.readMessage(xi, proto.google.protobuf.EnumOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        case 4:
          var xi = new proto.google.protobuf.EnumDescriptorProto.EnumReservedRange();
          Ei.readMessage(xi, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader), wi.addReservedRange(xi);
          break;
        case 5:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.addReservedName(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = wi.getValueList(), $i.length > 0 && Ei.writeRepeatedMessage(
      2,
      $i,
      proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      3,
      $i,
      proto.google.protobuf.EnumOptions.serializeBinaryToWriter
    ), $i = wi.getReservedRangeList(), $i.length > 0 && Ei.writeRepeatedMessage(
      4,
      $i,
      proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter
    ), $i = wi.getReservedNameList(), $i.length > 0 && Ei.writeRepeatedString(
      5,
      $i
    );
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.toObject = function(wi) {
    return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(wi, this);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject = function(wi, Ei) {
    var $i, xi = {
      start: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      end: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.EnumDescriptorProto.EnumReservedRange();
    return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setStart(xi);
          break;
        case 2:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setEnd(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {number} */
    e.Message.getField(wi, 1), $i != null && Ei.writeInt32(
      1,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 2), $i != null && Ei.writeInt32(
      2,
      $i
    );
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.getStart = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.setStart = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.clearStart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.hasStart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.setEnd = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.clearEnd = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.hasEnd = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getValueList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumValueDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumValueDescriptorProto, 2)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setValueList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 2, wi);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.addValue = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 2, wi, proto.google.protobuf.EnumValueDescriptorProto, Ei);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearValueList = function() {
    return this.setValueList([]);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.EnumOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.EnumOptions, 3)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 3, wi);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getReservedRangeList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, 4)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setReservedRangeList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 4, wi);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.addReservedRange = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 4, wi, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, Ei);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearReservedRangeList = function() {
    return this.setReservedRangeList([]);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.getReservedNameList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 5)
    );
  }, proto.google.protobuf.EnumDescriptorProto.prototype.setReservedNameList = function(wi) {
    return e.Message.setField(this, 5, wi || []);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.addReservedName = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 5, wi, Ei);
  }, proto.google.protobuf.EnumDescriptorProto.prototype.clearReservedNameList = function() {
    return this.setReservedNameList([]);
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumValueDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.EnumValueDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.EnumValueDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      number: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i,
      options: ($i = Ei.getOptions()) && proto.google.protobuf.EnumValueOptions.toObject(wi, $i)
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.EnumValueDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.EnumValueDescriptorProto();
    return proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 2:
          var xi = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setNumber(xi);
          break;
        case 3:
          var xi = new proto.google.protobuf.EnumValueOptions();
          Ei.readMessage(xi, proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 2), $i != null && Ei.writeInt32(
      2,
      $i
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      3,
      $i,
      proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.getNumber = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 2, 0)
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.setNumber = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.clearNumber = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.hasNumber = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.EnumValueOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.EnumValueOptions, 3)
    );
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 3, wi);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.EnumValueDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.ServiceDescriptorProto.repeatedFields_ = [2], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.ServiceDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.ServiceDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.ServiceDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      methodList: e.Message.toObjectList(
        Ei.getMethodList(),
        proto.google.protobuf.MethodDescriptorProto.toObject,
        wi
      ),
      options: ($i = Ei.getOptions()) && proto.google.protobuf.ServiceOptions.toObject(wi, $i)
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.ServiceDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.ServiceDescriptorProto();
    return proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 2:
          var xi = new proto.google.protobuf.MethodDescriptorProto();
          Ei.readMessage(xi, proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader), wi.addMethod(xi);
          break;
        case 3:
          var xi = new proto.google.protobuf.ServiceOptions();
          Ei.readMessage(xi, proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = wi.getMethodList(), $i.length > 0 && Ei.writeRepeatedMessage(
      2,
      $i,
      proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      3,
      $i,
      proto.google.protobuf.ServiceOptions.serializeBinaryToWriter
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.getMethodList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.MethodDescriptorProto>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.MethodDescriptorProto, 2)
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.setMethodList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 2, wi);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.addMethod = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 2, wi, proto.google.protobuf.MethodDescriptorProto, Ei);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.clearMethodList = function() {
    return this.setMethodList([]);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.ServiceOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.ServiceOptions, 3)
    );
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 3, wi);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.ServiceDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 3) != null;
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.MethodDescriptorProto.prototype.toObject = function(wi) {
    return proto.google.protobuf.MethodDescriptorProto.toObject(wi, this);
  }, proto.google.protobuf.MethodDescriptorProto.toObject = function(wi, Ei) {
    var $i, xi = {
      name: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      inputType: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i,
      outputType: ($i = e.Message.getField(Ei, 3)) == null ? void 0 : $i,
      options: ($i = Ei.getOptions()) && proto.google.protobuf.MethodOptions.toObject(wi, $i),
      clientStreaming: e.Message.getBooleanFieldWithDefault(Ei, 5, !1),
      serverStreaming: e.Message.getBooleanFieldWithDefault(Ei, 6, !1)
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.MethodDescriptorProto.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.MethodDescriptorProto();
    return proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setName(xi);
          break;
        case 2:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setInputType(xi);
          break;
        case 3:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setOutputType(xi);
          break;
        case 4:
          var xi = new proto.google.protobuf.MethodOptions();
          Ei.readMessage(xi, proto.google.protobuf.MethodOptions.deserializeBinaryFromReader), wi.setOptions(xi);
          break;
        case 5:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setClientStreaming(xi);
          break;
        case 6:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setServerStreaming(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 2), $i != null && Ei.writeString(
      2,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 3), $i != null && Ei.writeString(
      3,
      $i
    ), $i = wi.getOptions(), $i != null && Ei.writeMessage(
      4,
      $i,
      proto.google.protobuf.MethodOptions.serializeBinaryToWriter
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 5), $i != null && Ei.writeBool(
      5,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 6), $i != null && Ei.writeBool(
      6,
      $i
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getName = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setName = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearName = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasName = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getInputType = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setInputType = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearInputType = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasInputType = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getOutputType = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 3, "")
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setOutputType = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearOutputType = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasOutputType = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getOptions = function() {
    return (
      /** @type{?proto.google.protobuf.MethodOptions} */
      e.Message.getWrapperField(this, proto.google.protobuf.MethodOptions, 4)
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setOptions = function(wi) {
    return e.Message.setWrapperField(this, 4, wi);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasOptions = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getClientStreaming = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 5, !1)
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setClientStreaming = function(wi) {
    return e.Message.setField(this, 5, wi);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearClientStreaming = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasClientStreaming = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.MethodDescriptorProto.prototype.getServerStreaming = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 6, !1)
    );
  }, proto.google.protobuf.MethodDescriptorProto.prototype.setServerStreaming = function(wi) {
    return e.Message.setField(this, 6, wi);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.clearServerStreaming = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.MethodDescriptorProto.prototype.hasServerStreaming = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.FileOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FileOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.FileOptions.toObject(wi, this);
  }, proto.google.protobuf.FileOptions.toObject = function(wi, Ei) {
    var $i, xi = {
      javaPackage: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      javaOuterClassname: ($i = e.Message.getField(Ei, 8)) == null ? void 0 : $i,
      javaMultipleFiles: e.Message.getBooleanFieldWithDefault(Ei, 10, !1),
      javaGenerateEqualsAndHash: ($i = e.Message.getBooleanField(Ei, 20)) == null ? void 0 : $i,
      javaStringCheckUtf8: e.Message.getBooleanFieldWithDefault(Ei, 27, !1),
      optimizeFor: e.Message.getFieldWithDefault(Ei, 9, 1),
      goPackage: ($i = e.Message.getField(Ei, 11)) == null ? void 0 : $i,
      ccGenericServices: e.Message.getBooleanFieldWithDefault(Ei, 16, !1),
      javaGenericServices: e.Message.getBooleanFieldWithDefault(Ei, 17, !1),
      pyGenericServices: e.Message.getBooleanFieldWithDefault(Ei, 18, !1),
      phpGenericServices: e.Message.getBooleanFieldWithDefault(Ei, 42, !1),
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 23, !1),
      ccEnableArenas: e.Message.getBooleanFieldWithDefault(Ei, 31, !0),
      objcClassPrefix: ($i = e.Message.getField(Ei, 36)) == null ? void 0 : $i,
      csharpNamespace: ($i = e.Message.getField(Ei, 37)) == null ? void 0 : $i,
      swiftPrefix: ($i = e.Message.getField(Ei, 39)) == null ? void 0 : $i,
      phpClassPrefix: ($i = e.Message.getField(Ei, 40)) == null ? void 0 : $i,
      phpNamespace: ($i = e.Message.getField(Ei, 41)) == null ? void 0 : $i,
      phpMetadataNamespace: ($i = e.Message.getField(Ei, 44)) == null ? void 0 : $i,
      rubyPackage: ($i = e.Message.getField(Ei, 45)) == null ? void 0 : $i,
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      xi,
      proto.google.protobuf.FileOptions.extensions,
      proto.google.protobuf.FileOptions.prototype.getExtension,
      wi
    ), wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.FileOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.FileOptions();
    return proto.google.protobuf.FileOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.FileOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setJavaPackage(xi);
          break;
        case 8:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setJavaOuterClassname(xi);
          break;
        case 10:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setJavaMultipleFiles(xi);
          break;
        case 20:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setJavaGenerateEqualsAndHash(xi);
          break;
        case 27:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setJavaStringCheckUtf8(xi);
          break;
        case 9:
          var xi = (
            /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */
            Ei.readEnum()
          );
          wi.setOptimizeFor(xi);
          break;
        case 11:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setGoPackage(xi);
          break;
        case 16:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setCcGenericServices(xi);
          break;
        case 17:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setJavaGenericServices(xi);
          break;
        case 18:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setPyGenericServices(xi);
          break;
        case 42:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setPhpGenericServices(xi);
          break;
        case 23:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 31:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setCcEnableArenas(xi);
          break;
        case 36:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setObjcClassPrefix(xi);
          break;
        case 37:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setCsharpNamespace(xi);
          break;
        case 39:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setSwiftPrefix(xi);
          break;
        case 40:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setPhpClassPrefix(xi);
          break;
        case 41:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setPhpNamespace(xi);
          break;
        case 44:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setPhpMetadataNamespace(xi);
          break;
        case 45:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setRubyPackage(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.FileOptions.extensionsBinary,
            proto.google.protobuf.FileOptions.prototype.getExtension,
            proto.google.protobuf.FileOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.FileOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.FileOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.FileOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 8), $i != null && Ei.writeString(
      8,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 10), $i != null && Ei.writeBool(
      10,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 20), $i != null && Ei.writeBool(
      20,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 27), $i != null && Ei.writeBool(
      27,
      $i
    ), $i = /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */
    e.Message.getField(wi, 9), $i != null && Ei.writeEnum(
      9,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 11), $i != null && Ei.writeString(
      11,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 16), $i != null && Ei.writeBool(
      16,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 17), $i != null && Ei.writeBool(
      17,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 18), $i != null && Ei.writeBool(
      18,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 42), $i != null && Ei.writeBool(
      42,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 23), $i != null && Ei.writeBool(
      23,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 31), $i != null && Ei.writeBool(
      31,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 36), $i != null && Ei.writeString(
      36,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 37), $i != null && Ei.writeString(
      37,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 39), $i != null && Ei.writeString(
      39,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 40), $i != null && Ei.writeString(
      40,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 41), $i != null && Ei.writeString(
      41,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 44), $i != null && Ei.writeString(
      44,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 45), $i != null && Ei.writeString(
      45,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.FileOptions.extensionsBinary,
      proto.google.protobuf.FileOptions.prototype.getExtension
    );
  }, proto.google.protobuf.FileOptions.OptimizeMode = {
    SPEED: 1,
    CODE_SIZE: 2,
    LITE_RUNTIME: 3
  }, proto.google.protobuf.FileOptions.prototype.getJavaPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaPackage = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaPackage = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaPackage = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaOuterClassname = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 8, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaOuterClassname = function(wi) {
    return e.Message.setField(this, 8, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaOuterClassname = function() {
    return e.Message.setField(this, 8, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaOuterClassname = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaMultipleFiles = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 10, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaMultipleFiles = function(wi) {
    return e.Message.setField(this, 10, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaMultipleFiles = function() {
    return e.Message.setField(this, 10, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaMultipleFiles = function() {
    return e.Message.getField(this, 10) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaGenerateEqualsAndHash = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 20, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaGenerateEqualsAndHash = function(wi) {
    return e.Message.setField(this, 20, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaGenerateEqualsAndHash = function() {
    return e.Message.setField(this, 20, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaGenerateEqualsAndHash = function() {
    return e.Message.getField(this, 20) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaStringCheckUtf8 = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 27, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaStringCheckUtf8 = function(wi) {
    return e.Message.setField(this, 27, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaStringCheckUtf8 = function() {
    return e.Message.setField(this, 27, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaStringCheckUtf8 = function() {
    return e.Message.getField(this, 27) != null;
  }, proto.google.protobuf.FileOptions.prototype.getOptimizeFor = function() {
    return (
      /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */
      e.Message.getFieldWithDefault(this, 9, 1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setOptimizeFor = function(wi) {
    return e.Message.setField(this, 9, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearOptimizeFor = function() {
    return e.Message.setField(this, 9, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasOptimizeFor = function() {
    return e.Message.getField(this, 9) != null;
  }, proto.google.protobuf.FileOptions.prototype.getGoPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 11, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setGoPackage = function(wi) {
    return e.Message.setField(this, 11, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearGoPackage = function() {
    return e.Message.setField(this, 11, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasGoPackage = function() {
    return e.Message.getField(this, 11) != null;
  }, proto.google.protobuf.FileOptions.prototype.getCcGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 16, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setCcGenericServices = function(wi) {
    return e.Message.setField(this, 16, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearCcGenericServices = function() {
    return e.Message.setField(this, 16, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasCcGenericServices = function() {
    return e.Message.getField(this, 16) != null;
  }, proto.google.protobuf.FileOptions.prototype.getJavaGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 17, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setJavaGenericServices = function(wi) {
    return e.Message.setField(this, 17, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearJavaGenericServices = function() {
    return e.Message.setField(this, 17, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasJavaGenericServices = function() {
    return e.Message.getField(this, 17) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPyGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 18, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setPyGenericServices = function(wi) {
    return e.Message.setField(this, 18, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearPyGenericServices = function() {
    return e.Message.setField(this, 18, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPyGenericServices = function() {
    return e.Message.getField(this, 18) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpGenericServices = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 42, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpGenericServices = function(wi) {
    return e.Message.setField(this, 42, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpGenericServices = function() {
    return e.Message.setField(this, 42, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpGenericServices = function() {
    return e.Message.getField(this, 42) != null;
  }, proto.google.protobuf.FileOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 23, !1)
    );
  }, proto.google.protobuf.FileOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 23, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 23, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 23) != null;
  }, proto.google.protobuf.FileOptions.prototype.getCcEnableArenas = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 31, !0)
    );
  }, proto.google.protobuf.FileOptions.prototype.setCcEnableArenas = function(wi) {
    return e.Message.setField(this, 31, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearCcEnableArenas = function() {
    return e.Message.setField(this, 31, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasCcEnableArenas = function() {
    return e.Message.getField(this, 31) != null;
  }, proto.google.protobuf.FileOptions.prototype.getObjcClassPrefix = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 36, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setObjcClassPrefix = function(wi) {
    return e.Message.setField(this, 36, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearObjcClassPrefix = function() {
    return e.Message.setField(this, 36, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasObjcClassPrefix = function() {
    return e.Message.getField(this, 36) != null;
  }, proto.google.protobuf.FileOptions.prototype.getCsharpNamespace = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 37, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setCsharpNamespace = function(wi) {
    return e.Message.setField(this, 37, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearCsharpNamespace = function() {
    return e.Message.setField(this, 37, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasCsharpNamespace = function() {
    return e.Message.getField(this, 37) != null;
  }, proto.google.protobuf.FileOptions.prototype.getSwiftPrefix = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 39, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setSwiftPrefix = function(wi) {
    return e.Message.setField(this, 39, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearSwiftPrefix = function() {
    return e.Message.setField(this, 39, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasSwiftPrefix = function() {
    return e.Message.getField(this, 39) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpClassPrefix = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 40, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpClassPrefix = function(wi) {
    return e.Message.setField(this, 40, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpClassPrefix = function() {
    return e.Message.setField(this, 40, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpClassPrefix = function() {
    return e.Message.getField(this, 40) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpNamespace = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 41, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpNamespace = function(wi) {
    return e.Message.setField(this, 41, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpNamespace = function() {
    return e.Message.setField(this, 41, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpNamespace = function() {
    return e.Message.getField(this, 41) != null;
  }, proto.google.protobuf.FileOptions.prototype.getPhpMetadataNamespace = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 44, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setPhpMetadataNamespace = function(wi) {
    return e.Message.setField(this, 44, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearPhpMetadataNamespace = function() {
    return e.Message.setField(this, 44, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasPhpMetadataNamespace = function() {
    return e.Message.getField(this, 44) != null;
  }, proto.google.protobuf.FileOptions.prototype.getRubyPackage = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 45, "")
    );
  }, proto.google.protobuf.FileOptions.prototype.setRubyPackage = function(wi) {
    return e.Message.setField(this, 45, wi);
  }, proto.google.protobuf.FileOptions.prototype.clearRubyPackage = function() {
    return e.Message.setField(this, 45, void 0);
  }, proto.google.protobuf.FileOptions.prototype.hasRubyPackage = function() {
    return e.Message.getField(this, 45) != null;
  }, proto.google.protobuf.FileOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.FileOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.FileOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.FileOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.MessageOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.MessageOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.MessageOptions.toObject(wi, this);
  }, proto.google.protobuf.MessageOptions.toObject = function(wi, Ei) {
    var $i, xi = {
      messageSetWireFormat: e.Message.getBooleanFieldWithDefault(Ei, 1, !1),
      noStandardDescriptorAccessor: e.Message.getBooleanFieldWithDefault(Ei, 2, !1),
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 3, !1),
      mapEntry: ($i = e.Message.getBooleanField(Ei, 7)) == null ? void 0 : $i,
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      xi,
      proto.google.protobuf.MessageOptions.extensions,
      proto.google.protobuf.MessageOptions.prototype.getExtension,
      wi
    ), wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.MessageOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.MessageOptions();
    return proto.google.protobuf.MessageOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.MessageOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setMessageSetWireFormat(xi);
          break;
        case 2:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setNoStandardDescriptorAccessor(xi);
          break;
        case 3:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 7:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setMapEntry(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.MessageOptions.extensionsBinary,
            proto.google.protobuf.MessageOptions.prototype.getExtension,
            proto.google.protobuf.MessageOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.MessageOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.MessageOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.MessageOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {boolean} */
    e.Message.getField(wi, 1), $i != null && Ei.writeBool(
      1,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 2), $i != null && Ei.writeBool(
      2,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 3), $i != null && Ei.writeBool(
      3,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 7), $i != null && Ei.writeBool(
      7,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.MessageOptions.extensionsBinary,
      proto.google.protobuf.MessageOptions.prototype.getExtension
    );
  }, proto.google.protobuf.MessageOptions.prototype.getMessageSetWireFormat = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 1, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setMessageSetWireFormat = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.MessageOptions.prototype.clearMessageSetWireFormat = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasMessageSetWireFormat = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getNoStandardDescriptorAccessor = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setNoStandardDescriptorAccessor = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.MessageOptions.prototype.clearNoStandardDescriptorAccessor = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasNoStandardDescriptorAccessor = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 3, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.MessageOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getMapEntry = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 7, !1)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setMapEntry = function(wi) {
    return e.Message.setField(this, 7, wi);
  }, proto.google.protobuf.MessageOptions.prototype.clearMapEntry = function() {
    return e.Message.setField(this, 7, void 0);
  }, proto.google.protobuf.MessageOptions.prototype.hasMapEntry = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.MessageOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.MessageOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.MessageOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.MessageOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.FieldOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FieldOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.FieldOptions.toObject(wi, this);
  }, proto.google.protobuf.FieldOptions.toObject = function(wi, Ei) {
    var $i, xi = {
      ctype: e.Message.getFieldWithDefault(Ei, 1, 0),
      packed: ($i = e.Message.getBooleanField(Ei, 2)) == null ? void 0 : $i,
      jstype: e.Message.getFieldWithDefault(Ei, 6, 0),
      lazy: e.Message.getBooleanFieldWithDefault(Ei, 5, !1),
      unverifiedLazy: e.Message.getBooleanFieldWithDefault(Ei, 15, !1),
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 3, !1),
      weak: e.Message.getBooleanFieldWithDefault(Ei, 10, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      xi,
      proto.google.protobuf.FieldOptions.extensions,
      proto.google.protobuf.FieldOptions.prototype.getExtension,
      wi
    ), wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.FieldOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.FieldOptions();
    return proto.google.protobuf.FieldOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.FieldOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {!proto.google.protobuf.FieldOptions.CType} */
            Ei.readEnum()
          );
          wi.setCtype(xi);
          break;
        case 2:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setPacked(xi);
          break;
        case 6:
          var xi = (
            /** @type {!proto.google.protobuf.FieldOptions.JSType} */
            Ei.readEnum()
          );
          wi.setJstype(xi);
          break;
        case 5:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setLazy(xi);
          break;
        case 15:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setUnverifiedLazy(xi);
          break;
        case 3:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 10:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setWeak(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.FieldOptions.extensionsBinary,
            proto.google.protobuf.FieldOptions.prototype.getExtension,
            proto.google.protobuf.FieldOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.FieldOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.FieldOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.FieldOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {!proto.google.protobuf.FieldOptions.CType} */
    e.Message.getField(wi, 1), $i != null && Ei.writeEnum(
      1,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 2), $i != null && Ei.writeBool(
      2,
      $i
    ), $i = /** @type {!proto.google.protobuf.FieldOptions.JSType} */
    e.Message.getField(wi, 6), $i != null && Ei.writeEnum(
      6,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 5), $i != null && Ei.writeBool(
      5,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 15), $i != null && Ei.writeBool(
      15,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 3), $i != null && Ei.writeBool(
      3,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 10), $i != null && Ei.writeBool(
      10,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.FieldOptions.extensionsBinary,
      proto.google.protobuf.FieldOptions.prototype.getExtension
    );
  }, proto.google.protobuf.FieldOptions.CType = {
    STRING: 0,
    CORD: 1,
    STRING_PIECE: 2
  }, proto.google.protobuf.FieldOptions.JSType = {
    JS_NORMAL: 0,
    JS_STRING: 1,
    JS_NUMBER: 2
  }, proto.google.protobuf.FieldOptions.prototype.getCtype = function() {
    return (
      /** @type {!proto.google.protobuf.FieldOptions.CType} */
      e.Message.getFieldWithDefault(this, 1, 0)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setCtype = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearCtype = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasCtype = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getPacked = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setPacked = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearPacked = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasPacked = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getJstype = function() {
    return (
      /** @type {!proto.google.protobuf.FieldOptions.JSType} */
      e.Message.getFieldWithDefault(this, 6, 0)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setJstype = function(wi) {
    return e.Message.setField(this, 6, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearJstype = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasJstype = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getLazy = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 5, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setLazy = function(wi) {
    return e.Message.setField(this, 5, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearLazy = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasLazy = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getUnverifiedLazy = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 15, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setUnverifiedLazy = function(wi) {
    return e.Message.setField(this, 15, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearUnverifiedLazy = function() {
    return e.Message.setField(this, 15, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasUnverifiedLazy = function() {
    return e.Message.getField(this, 15) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 3, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getWeak = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 10, !1)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setWeak = function(wi) {
    return e.Message.setField(this, 10, wi);
  }, proto.google.protobuf.FieldOptions.prototype.clearWeak = function() {
    return e.Message.setField(this, 10, void 0);
  }, proto.google.protobuf.FieldOptions.prototype.hasWeak = function() {
    return e.Message.getField(this, 10) != null;
  }, proto.google.protobuf.FieldOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.FieldOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.FieldOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.FieldOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.OneofOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.OneofOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.OneofOptions.toObject(wi, this);
  }, proto.google.protobuf.OneofOptions.toObject = function(wi, Ei) {
    var $i = {
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      $i,
      proto.google.protobuf.OneofOptions.extensions,
      proto.google.protobuf.OneofOptions.prototype.getExtension,
      wi
    ), wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.OneofOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.OneofOptions();
    return proto.google.protobuf.OneofOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.OneofOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.OneofOptions.extensionsBinary,
            proto.google.protobuf.OneofOptions.prototype.getExtension,
            proto.google.protobuf.OneofOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.OneofOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.OneofOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.OneofOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.OneofOptions.extensionsBinary,
      proto.google.protobuf.OneofOptions.prototype.getExtension
    );
  }, proto.google.protobuf.OneofOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.OneofOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.OneofOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.OneofOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.EnumOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.EnumOptions.toObject(wi, this);
  }, proto.google.protobuf.EnumOptions.toObject = function(wi, Ei) {
    var $i, xi = {
      allowAlias: ($i = e.Message.getBooleanField(Ei, 2)) == null ? void 0 : $i,
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 3, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      xi,
      proto.google.protobuf.EnumOptions.extensions,
      proto.google.protobuf.EnumOptions.prototype.getExtension,
      wi
    ), wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.EnumOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.EnumOptions();
    return proto.google.protobuf.EnumOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.EnumOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 2:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setAllowAlias(xi);
          break;
        case 3:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.EnumOptions.extensionsBinary,
            proto.google.protobuf.EnumOptions.prototype.getExtension,
            proto.google.protobuf.EnumOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.EnumOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.EnumOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.EnumOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {boolean} */
    e.Message.getField(wi, 2), $i != null && Ei.writeBool(
      2,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 3), $i != null && Ei.writeBool(
      3,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.EnumOptions.extensionsBinary,
      proto.google.protobuf.EnumOptions.prototype.getExtension
    );
  }, proto.google.protobuf.EnumOptions.prototype.getAllowAlias = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.EnumOptions.prototype.setAllowAlias = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.EnumOptions.prototype.clearAllowAlias = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.EnumOptions.prototype.hasAllowAlias = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.EnumOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 3, !1)
    );
  }, proto.google.protobuf.EnumOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.EnumOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.EnumOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.EnumOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.EnumOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.EnumOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.EnumOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.EnumValueOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.EnumValueOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.EnumValueOptions.toObject(wi, this);
  }, proto.google.protobuf.EnumValueOptions.toObject = function(wi, Ei) {
    var $i = {
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 1, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      $i,
      proto.google.protobuf.EnumValueOptions.extensions,
      proto.google.protobuf.EnumValueOptions.prototype.getExtension,
      wi
    ), wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.EnumValueOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.EnumValueOptions();
    return proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.EnumValueOptions.extensionsBinary,
            proto.google.protobuf.EnumValueOptions.prototype.getExtension,
            proto.google.protobuf.EnumValueOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.EnumValueOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {boolean} */
    e.Message.getField(wi, 1), $i != null && Ei.writeBool(
      1,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.EnumValueOptions.extensionsBinary,
      proto.google.protobuf.EnumValueOptions.prototype.getExtension
    );
  }, proto.google.protobuf.EnumValueOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 1, !1)
    );
  }, proto.google.protobuf.EnumValueOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.EnumValueOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.EnumValueOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.EnumValueOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.EnumValueOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.EnumValueOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.EnumValueOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.ServiceOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.ServiceOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.ServiceOptions.toObject(wi, this);
  }, proto.google.protobuf.ServiceOptions.toObject = function(wi, Ei) {
    var $i = {
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 33, !1),
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      $i,
      proto.google.protobuf.ServiceOptions.extensions,
      proto.google.protobuf.ServiceOptions.prototype.getExtension,
      wi
    ), wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.ServiceOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.ServiceOptions();
    return proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 33:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.ServiceOptions.extensionsBinary,
            proto.google.protobuf.ServiceOptions.prototype.getExtension,
            proto.google.protobuf.ServiceOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.ServiceOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.ServiceOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.ServiceOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {boolean} */
    e.Message.getField(wi, 33), $i != null && Ei.writeBool(
      33,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.ServiceOptions.extensionsBinary,
      proto.google.protobuf.ServiceOptions.prototype.getExtension
    );
  }, proto.google.protobuf.ServiceOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 33, !1)
    );
  }, proto.google.protobuf.ServiceOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 33, wi);
  }, proto.google.protobuf.ServiceOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 33, void 0);
  }, proto.google.protobuf.ServiceOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 33) != null;
  }, proto.google.protobuf.ServiceOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.ServiceOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.ServiceOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.ServiceOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.MethodOptions.repeatedFields_ = [999], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.MethodOptions.prototype.toObject = function(wi) {
    return proto.google.protobuf.MethodOptions.toObject(wi, this);
  }, proto.google.protobuf.MethodOptions.toObject = function(wi, Ei) {
    var $i = {
      deprecated: e.Message.getBooleanFieldWithDefault(Ei, 33, !1),
      idempotencyLevel: e.Message.getFieldWithDefault(Ei, 34, 0),
      uninterpretedOptionList: e.Message.toObjectList(
        Ei.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject,
        wi
      )
    };
    return e.Message.toObjectExtension(
      /** @type {!jspb.Message} */
      Ei,
      $i,
      proto.google.protobuf.MethodOptions.extensions,
      proto.google.protobuf.MethodOptions.prototype.getExtension,
      wi
    ), wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.MethodOptions.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.MethodOptions();
    return proto.google.protobuf.MethodOptions.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.MethodOptions.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 33:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setDeprecated(xi);
          break;
        case 34:
          var xi = (
            /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */
            Ei.readEnum()
          );
          wi.setIdempotencyLevel(xi);
          break;
        case 999:
          var xi = new proto.google.protobuf.UninterpretedOption();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader), wi.addUninterpretedOption(xi);
          break;
        default:
          e.Message.readBinaryExtension(
            wi,
            Ei,
            proto.google.protobuf.MethodOptions.extensionsBinary,
            proto.google.protobuf.MethodOptions.prototype.getExtension,
            proto.google.protobuf.MethodOptions.prototype.setExtension
          );
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.MethodOptions.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.MethodOptions.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.MethodOptions.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {boolean} */
    e.Message.getField(wi, 33), $i != null && Ei.writeBool(
      33,
      $i
    ), $i = /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */
    e.Message.getField(wi, 34), $i != null && Ei.writeEnum(
      34,
      $i
    ), $i = wi.getUninterpretedOptionList(), $i.length > 0 && Ei.writeRepeatedMessage(
      999,
      $i,
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
    ), e.Message.serializeBinaryExtensions(
      wi,
      Ei,
      proto.google.protobuf.MethodOptions.extensionsBinary,
      proto.google.protobuf.MethodOptions.prototype.getExtension
    );
  }, proto.google.protobuf.MethodOptions.IdempotencyLevel = {
    IDEMPOTENCY_UNKNOWN: 0,
    NO_SIDE_EFFECTS: 1,
    IDEMPOTENT: 2
  }, proto.google.protobuf.MethodOptions.prototype.getDeprecated = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 33, !1)
    );
  }, proto.google.protobuf.MethodOptions.prototype.setDeprecated = function(wi) {
    return e.Message.setField(this, 33, wi);
  }, proto.google.protobuf.MethodOptions.prototype.clearDeprecated = function() {
    return e.Message.setField(this, 33, void 0);
  }, proto.google.protobuf.MethodOptions.prototype.hasDeprecated = function() {
    return e.Message.getField(this, 33) != null;
  }, proto.google.protobuf.MethodOptions.prototype.getIdempotencyLevel = function() {
    return (
      /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */
      e.Message.getFieldWithDefault(this, 34, 0)
    );
  }, proto.google.protobuf.MethodOptions.prototype.setIdempotencyLevel = function(wi) {
    return e.Message.setField(this, 34, wi);
  }, proto.google.protobuf.MethodOptions.prototype.clearIdempotencyLevel = function() {
    return e.Message.setField(this, 34, void 0);
  }, proto.google.protobuf.MethodOptions.prototype.hasIdempotencyLevel = function() {
    return e.Message.getField(this, 34) != null;
  }, proto.google.protobuf.MethodOptions.prototype.getUninterpretedOptionList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999)
    );
  }, proto.google.protobuf.MethodOptions.prototype.setUninterpretedOptionList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 999, wi);
  }, proto.google.protobuf.MethodOptions.prototype.addUninterpretedOption = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 999, wi, proto.google.protobuf.UninterpretedOption, Ei);
  }, proto.google.protobuf.MethodOptions.prototype.clearUninterpretedOptionList = function() {
    return this.setUninterpretedOptionList([]);
  }, proto.google.protobuf.UninterpretedOption.repeatedFields_ = [2], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.UninterpretedOption.prototype.toObject = function(wi) {
    return proto.google.protobuf.UninterpretedOption.toObject(wi, this);
  }, proto.google.protobuf.UninterpretedOption.toObject = function(wi, Ei) {
    var $i, xi = {
      nameList: e.Message.toObjectList(
        Ei.getNameList(),
        proto.google.protobuf.UninterpretedOption.NamePart.toObject,
        wi
      ),
      identifierValue: ($i = e.Message.getField(Ei, 3)) == null ? void 0 : $i,
      positiveIntValue: ($i = e.Message.getField(Ei, 4)) == null ? void 0 : $i,
      negativeIntValue: ($i = e.Message.getField(Ei, 5)) == null ? void 0 : $i,
      doubleValue: ($i = e.Message.getOptionalFloatingPointField(Ei, 6)) == null ? void 0 : $i,
      stringValue: Ei.getStringValue_asB64(),
      aggregateValue: ($i = e.Message.getField(Ei, 8)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.UninterpretedOption.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.UninterpretedOption();
    return proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 2:
          var xi = new proto.google.protobuf.UninterpretedOption.NamePart();
          Ei.readMessage(xi, proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader), wi.addName(xi);
          break;
        case 3:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setIdentifierValue(xi);
          break;
        case 4:
          var xi = (
            /** @type {number} */
            Ei.readUint64()
          );
          wi.setPositiveIntValue(xi);
          break;
        case 5:
          var xi = (
            /** @type {number} */
            Ei.readInt64()
          );
          wi.setNegativeIntValue(xi);
          break;
        case 6:
          var xi = (
            /** @type {number} */
            Ei.readDouble()
          );
          wi.setDoubleValue(xi);
          break;
        case 7:
          var xi = (
            /** @type {!Uint8Array} */
            Ei.readBytes()
          );
          wi.setStringValue(xi);
          break;
        case 8:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setAggregateValue(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.UninterpretedOption.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getNameList(), $i.length > 0 && Ei.writeRepeatedMessage(
      2,
      $i,
      proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter
    ), $i = /** @type {string} */
    e.Message.getField(wi, 3), $i != null && Ei.writeString(
      3,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 4), $i != null && Ei.writeUint64(
      4,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 5), $i != null && Ei.writeInt64(
      5,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 6), $i != null && Ei.writeDouble(
      6,
      $i
    ), $i = /** @type {!(string|Uint8Array)} */
    e.Message.getField(wi, 7), $i != null && Ei.writeBytes(
      7,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 8), $i != null && Ei.writeString(
      8,
      $i
    );
  }, e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.UninterpretedOption.NamePart.prototype.toObject = function(wi) {
    return proto.google.protobuf.UninterpretedOption.NamePart.toObject(wi, this);
  }, proto.google.protobuf.UninterpretedOption.NamePart.toObject = function(wi, Ei) {
    var $i, xi = {
      namePart: ($i = e.Message.getField(Ei, 1)) == null ? void 0 : $i,
      isExtension: ($i = e.Message.getBooleanField(Ei, 2)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.UninterpretedOption.NamePart();
    return proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setNamePart(xi);
          break;
        case 2:
          var xi = (
            /** @type {boolean} */
            Ei.readBool()
          );
          wi.setIsExtension(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = /** @type {string} */
    e.Message.getField(wi, 1), $i != null && Ei.writeString(
      1,
      $i
    ), $i = /** @type {boolean} */
    e.Message.getField(wi, 2), $i != null && Ei.writeBool(
      2,
      $i
    );
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.getNamePart = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 1, "")
    );
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.setNamePart = function(wi) {
    return e.Message.setField(this, 1, wi);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.clearNamePart = function() {
    return e.Message.setField(this, 1, void 0);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.hasNamePart = function() {
    return e.Message.getField(this, 1) != null;
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.getIsExtension = function() {
    return (
      /** @type {boolean} */
      e.Message.getBooleanFieldWithDefault(this, 2, !1)
    );
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.setIsExtension = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.clearIsExtension = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.UninterpretedOption.NamePart.prototype.hasIsExtension = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getNameList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.UninterpretedOption.NamePart>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption.NamePart, 2)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setNameList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 2, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.addName = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 2, wi, proto.google.protobuf.UninterpretedOption.NamePart, Ei);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearNameList = function() {
    return this.setNameList([]);
  }, proto.google.protobuf.UninterpretedOption.prototype.getIdentifierValue = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 3, "")
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setIdentifierValue = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearIdentifierValue = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasIdentifierValue = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getPositiveIntValue = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 4, 0)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setPositiveIntValue = function(wi) {
    return e.Message.setField(this, 4, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearPositiveIntValue = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasPositiveIntValue = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getNegativeIntValue = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 5, 0)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setNegativeIntValue = function(wi) {
    return e.Message.setField(this, 5, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearNegativeIntValue = function() {
    return e.Message.setField(this, 5, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasNegativeIntValue = function() {
    return e.Message.getField(this, 5) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getDoubleValue = function() {
    return (
      /** @type {number} */
      e.Message.getFloatingPointFieldWithDefault(this, 6, 0)
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setDoubleValue = function(wi) {
    return e.Message.setField(this, 6, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearDoubleValue = function() {
    return e.Message.setField(this, 6, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasDoubleValue = function() {
    return e.Message.getField(this, 6) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getStringValue = function() {
    return (
      /** @type {!(string|Uint8Array)} */
      e.Message.getFieldWithDefault(this, 7, "")
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.getStringValue_asB64 = function() {
    return (
      /** @type {string} */
      e.Message.bytesAsB64(
        this.getStringValue()
      )
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.getStringValue_asU8 = function() {
    return (
      /** @type {!Uint8Array} */
      e.Message.bytesAsU8(
        this.getStringValue()
      )
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setStringValue = function(wi) {
    return e.Message.setField(this, 7, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearStringValue = function() {
    return e.Message.setField(this, 7, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasStringValue = function() {
    return e.Message.getField(this, 7) != null;
  }, proto.google.protobuf.UninterpretedOption.prototype.getAggregateValue = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 8, "")
    );
  }, proto.google.protobuf.UninterpretedOption.prototype.setAggregateValue = function(wi) {
    return e.Message.setField(this, 8, wi);
  }, proto.google.protobuf.UninterpretedOption.prototype.clearAggregateValue = function() {
    return e.Message.setField(this, 8, void 0);
  }, proto.google.protobuf.UninterpretedOption.prototype.hasAggregateValue = function() {
    return e.Message.getField(this, 8) != null;
  }, proto.google.protobuf.SourceCodeInfo.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.SourceCodeInfo.prototype.toObject = function(wi) {
    return proto.google.protobuf.SourceCodeInfo.toObject(wi, this);
  }, proto.google.protobuf.SourceCodeInfo.toObject = function(wi, Ei) {
    var $i = {
      locationList: e.Message.toObjectList(
        Ei.getLocationList(),
        proto.google.protobuf.SourceCodeInfo.Location.toObject,
        wi
      )
    };
    return wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.SourceCodeInfo.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.SourceCodeInfo();
    return proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = new proto.google.protobuf.SourceCodeInfo.Location();
          Ei.readMessage(xi, proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader), wi.addLocation(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.SourceCodeInfo.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getLocationList(), $i.length > 0 && Ei.writeRepeatedMessage(
      1,
      $i,
      proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.repeatedFields_ = [1, 2, 6], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.SourceCodeInfo.Location.prototype.toObject = function(wi) {
    return proto.google.protobuf.SourceCodeInfo.Location.toObject(wi, this);
  }, proto.google.protobuf.SourceCodeInfo.Location.toObject = function(wi, Ei) {
    var $i, xi = {
      pathList: ($i = e.Message.getRepeatedField(Ei, 1)) == null ? void 0 : $i,
      spanList: ($i = e.Message.getRepeatedField(Ei, 2)) == null ? void 0 : $i,
      leadingComments: ($i = e.Message.getField(Ei, 3)) == null ? void 0 : $i,
      trailingComments: ($i = e.Message.getField(Ei, 4)) == null ? void 0 : $i,
      leadingDetachedCommentsList: ($i = e.Message.getRepeatedField(Ei, 6)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.SourceCodeInfo.Location.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.SourceCodeInfo.Location();
    return proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          for (var Ri = (
            /** @type {!Array<number>} */
            Ei.isDelimited() ? Ei.readPackedInt32() : [Ei.readInt32()]
          ), xi = 0; xi < Ri.length; xi++)
            wi.addPath(Ri[xi]);
          break;
        case 2:
          for (var Ri = (
            /** @type {!Array<number>} */
            Ei.isDelimited() ? Ei.readPackedInt32() : [Ei.readInt32()]
          ), xi = 0; xi < Ri.length; xi++)
            wi.addSpan(Ri[xi]);
          break;
        case 3:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setLeadingComments(Ti);
          break;
        case 4:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setTrailingComments(Ti);
          break;
        case 6:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.addLeadingDetachedComments(Ti);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getPathList(), $i.length > 0 && Ei.writePackedInt32(
      1,
      $i
    ), $i = wi.getSpanList(), $i.length > 0 && Ei.writePackedInt32(
      2,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 3), $i != null && Ei.writeString(
      3,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 4), $i != null && Ei.writeString(
      4,
      $i
    ), $i = wi.getLeadingDetachedCommentsList(), $i.length > 0 && Ei.writeRepeatedString(
      6,
      $i
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getPathList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 1)
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setPathList = function(wi) {
    return e.Message.setField(this, 1, wi || []);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.addPath = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 1, wi, Ei);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearPathList = function() {
    return this.setPathList([]);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getSpanList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 2)
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setSpanList = function(wi) {
    return e.Message.setField(this, 2, wi || []);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.addSpan = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 2, wi, Ei);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearSpanList = function() {
    return this.setSpanList([]);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getLeadingComments = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 3, "")
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setLeadingComments = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearLeadingComments = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.hasLeadingComments = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getTrailingComments = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 4, "")
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setTrailingComments = function(wi) {
    return e.Message.setField(this, 4, wi);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearTrailingComments = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.hasTrailingComments = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.getLeadingDetachedCommentsList = function() {
    return (
      /** @type {!Array<string>} */
      e.Message.getRepeatedField(this, 6)
    );
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.setLeadingDetachedCommentsList = function(wi) {
    return e.Message.setField(this, 6, wi || []);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.addLeadingDetachedComments = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 6, wi, Ei);
  }, proto.google.protobuf.SourceCodeInfo.Location.prototype.clearLeadingDetachedCommentsList = function() {
    return this.setLeadingDetachedCommentsList([]);
  }, proto.google.protobuf.SourceCodeInfo.prototype.getLocationList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.SourceCodeInfo.Location>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.SourceCodeInfo.Location, 1)
    );
  }, proto.google.protobuf.SourceCodeInfo.prototype.setLocationList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 1, wi);
  }, proto.google.protobuf.SourceCodeInfo.prototype.addLocation = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 1, wi, proto.google.protobuf.SourceCodeInfo.Location, Ei);
  }, proto.google.protobuf.SourceCodeInfo.prototype.clearLocationList = function() {
    return this.setLocationList([]);
  }, proto.google.protobuf.GeneratedCodeInfo.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.GeneratedCodeInfo.prototype.toObject = function(wi) {
    return proto.google.protobuf.GeneratedCodeInfo.toObject(wi, this);
  }, proto.google.protobuf.GeneratedCodeInfo.toObject = function(wi, Ei) {
    var $i = {
      annotationList: e.Message.toObjectList(
        Ei.getAnnotationList(),
        proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject,
        wi
      )
    };
    return wi && ($i.$jspbMessageInstance = Ei), $i;
  }), proto.google.protobuf.GeneratedCodeInfo.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.GeneratedCodeInfo();
    return proto.google.protobuf.GeneratedCodeInfo.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.GeneratedCodeInfo.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          var xi = new proto.google.protobuf.GeneratedCodeInfo.Annotation();
          Ei.readMessage(xi, proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader), wi.addAnnotation(xi);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.GeneratedCodeInfo.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.GeneratedCodeInfo.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getAnnotationList(), $i.length > 0 && Ei.writeRepeatedMessage(
      1,
      $i,
      proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.repeatedFields_ = [1], e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.toObject = function(wi) {
    return proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject(wi, this);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject = function(wi, Ei) {
    var $i, xi = {
      pathList: ($i = e.Message.getRepeatedField(Ei, 1)) == null ? void 0 : $i,
      sourceFile: ($i = e.Message.getField(Ei, 2)) == null ? void 0 : $i,
      begin: ($i = e.Message.getField(Ei, 3)) == null ? void 0 : $i,
      end: ($i = e.Message.getField(Ei, 4)) == null ? void 0 : $i
    };
    return wi && (xi.$jspbMessageInstance = Ei), xi;
  }), proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinary = function(wi) {
    var Ei = new e.BinaryReader(wi), $i = new proto.google.protobuf.GeneratedCodeInfo.Annotation();
    return proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader($i, Ei);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader = function(wi, Ei) {
    for (; Ei.nextField() && !Ei.isEndGroup(); ) {
      var $i = Ei.getFieldNumber();
      switch ($i) {
        case 1:
          for (var xi = (
            /** @type {!Array<number>} */
            Ei.isDelimited() ? Ei.readPackedInt32() : [Ei.readInt32()]
          ), Ri = 0; Ri < xi.length; Ri++)
            wi.addPath(xi[Ri]);
          break;
        case 2:
          var Ti = (
            /** @type {string} */
            Ei.readString()
          );
          wi.setSourceFile(Ti);
          break;
        case 3:
          var Ti = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setBegin(Ti);
          break;
        case 4:
          var Ti = (
            /** @type {number} */
            Ei.readInt32()
          );
          wi.setEnd(Ti);
          break;
        default:
          Ei.skipField();
          break;
      }
    }
    return wi;
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.serializeBinary = function() {
    var wi = new e.BinaryWriter();
    return proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter(this, wi), wi.getResultBuffer();
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter = function(wi, Ei) {
    var $i = void 0;
    $i = wi.getPathList(), $i.length > 0 && Ei.writePackedInt32(
      1,
      $i
    ), $i = /** @type {string} */
    e.Message.getField(wi, 2), $i != null && Ei.writeString(
      2,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 3), $i != null && Ei.writeInt32(
      3,
      $i
    ), $i = /** @type {number} */
    e.Message.getField(wi, 4), $i != null && Ei.writeInt32(
      4,
      $i
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getPathList = function() {
    return (
      /** @type {!Array<number>} */
      e.Message.getRepeatedField(this, 1)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setPathList = function(wi) {
    return e.Message.setField(this, 1, wi || []);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.addPath = function(wi, Ei) {
    return e.Message.addToRepeatedField(this, 1, wi, Ei);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearPathList = function() {
    return this.setPathList([]);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getSourceFile = function() {
    return (
      /** @type {string} */
      e.Message.getFieldWithDefault(this, 2, "")
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setSourceFile = function(wi) {
    return e.Message.setField(this, 2, wi);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearSourceFile = function() {
    return e.Message.setField(this, 2, void 0);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasSourceFile = function() {
    return e.Message.getField(this, 2) != null;
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getBegin = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 3, 0)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setBegin = function(wi) {
    return e.Message.setField(this, 3, wi);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearBegin = function() {
    return e.Message.setField(this, 3, void 0);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasBegin = function() {
    return e.Message.getField(this, 3) != null;
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getEnd = function() {
    return (
      /** @type {number} */
      e.Message.getFieldWithDefault(this, 4, 0)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setEnd = function(wi) {
    return e.Message.setField(this, 4, wi);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearEnd = function() {
    return e.Message.setField(this, 4, void 0);
  }, proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasEnd = function() {
    return e.Message.getField(this, 4) != null;
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.getAnnotationList = function() {
    return (
      /** @type{!Array<!proto.google.protobuf.GeneratedCodeInfo.Annotation>} */
      e.Message.getRepeatedWrapperField(this, proto.google.protobuf.GeneratedCodeInfo.Annotation, 1)
    );
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.setAnnotationList = function(wi) {
    return e.Message.setRepeatedWrapperField(this, 1, wi);
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.addAnnotation = function(wi, Ei) {
    return e.Message.addToRepeatedWrapperField(this, 1, wi, proto.google.protobuf.GeneratedCodeInfo.Annotation, Ei);
  }, proto.google.protobuf.GeneratedCodeInfo.prototype.clearAnnotationList = function() {
    return this.setAnnotationList([]);
  }, Oe.object.extend(se, proto.google.protobuf);
})(descriptor_pb);
var util = {}, options_pb = {};
(function(se) {
  var e = googleProtobuf, Oe = e, Si = function() {
    return this ? this : typeof window < "u" ? window : typeof Si < "u" ? Si : typeof self < "u" ? self : Function("return this")();
  }.call(null), wi = descriptor_pb;
  Oe.object.extend(proto, wi), Oe.exportSymbol("proto.koinos.btype", null, Si), Oe.exportSymbol("proto.koinos.bytes_type", null, Si), proto.koinos.bytes_type = {
    BASE64: 0,
    BASE58: 1,
    HEX: 2,
    BLOCK_ID: 3,
    TRANSACTION_ID: 4,
    CONTRACT_ID: 5,
    ADDRESS: 6
  }, proto.koinos.btype = new e.ExtensionFieldInfo(
    5e4,
    { btype: 0 },
    null,
    /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */
    null,
    0
  ), wi.FieldOptions.extensionsBinary[5e4] = new e.ExtensionFieldBinaryInfo(proto.koinos.btype, e.BinaryReader.prototype.readEnum, e.BinaryWriter.prototype.writeEnum, void 0, void 0, !1), wi.FieldOptions.extensions[5e4] = proto.koinos.btype, Oe.object.extend(se, proto.koinos);
})(options_pb);
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe);
  var wi = Object.getOwnPropertyDescriptor(e, Oe);
  (!wi || ("get" in wi ? !e.__esModule : wi.writable || wi.configurable)) && (wi = { enumerable: !0, get: function() {
    return e[Oe];
  } }), Object.defineProperty(se, Si, wi);
} : function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe), se[Si] = e[Oe];
}), __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(se, e) {
  Object.defineProperty(se, "default", { enumerable: !0, value: e });
} : function(se, e) {
  se.default = e;
}), __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(se) {
  if (se && se.__esModule)
    return se;
  var e = {};
  if (se != null)
    for (var Oe in se)
      Oe !== "default" && Object.prototype.hasOwnProperty.call(se, Oe) && __createBinding$2(e, se, Oe);
  return __setModuleDefault$2(e, se), e;
};
Object.defineProperty(util, "__esModule", { value: !0 });
util.getMessage = util.getOneofs = util.getField = util.getFieldType = util.getFieldLabel = util.getbType = util.getJSType = util.getExtension = util.getEnum = util.getImport = util.getPackage = util.getSyntax = void 0;
const descriptor_pb_js_1$1 = descriptor_pb, optionspb = __importStar$2(options_pb);
function getSyntax(se) {
  return `syntax = '${se.getSyntax()}';

`;
}
util.getSyntax = getSyntax;
function getPackage(se) {
  return `package ${se.getPackage()};

`;
}
util.getPackage = getPackage;
function getImport(se) {
  return `import "${se}";

`;
}
util.getImport = getImport;
function getEnum(se) {
  const e = [];
  for (const Oe of se.getValueList())
    e.push(`${Oe.getName()} = ${Oe.getNumber()};`);
  return `
enum ${se.getName()} {
  ${e.join(`
  `)} 
}

`;
}
util.getEnum = getEnum;
function getExtension(se) {
  const e = se.hasProto3Optional() ? "optional" : "";
  return `
extend ${se.getExtendee()} {
  ${e} ${se.getTypeName()} ${se.getName()} = ${se.getNumber()};
}

`;
}
util.getExtension = getExtension;
function getJSType(se) {
  if (!se)
    return "";
  switch (se.getJstype()) {
    case descriptor_pb_js_1$1.FieldOptions.JSType.JS_NORMAL:
      return "";
    case descriptor_pb_js_1$1.FieldOptions.JSType.JS_NUMBER:
      return "jstype = JS_NUMBER";
    case descriptor_pb_js_1$1.FieldOptions.JSType.JS_STRING:
      return "jstype = JS_STRING";
    default:
      return "";
  }
}
util.getJSType = getJSType;
function getbType(se) {
  if (!se)
    return "";
  switch (se.getExtension(optionspb.btype)) {
    case optionspb.bytes_type.BASE64:
      return "(koinos.btype) = BASE64";
    case optionspb.bytes_type.BASE58:
      return "(koinos.btype) = BASE58";
    case optionspb.bytes_type.HEX:
      return "(koinos.btype) = HEX";
    case optionspb.bytes_type.BLOCK_ID:
      return "(koinos.btype) = BLOCK_ID";
    case optionspb.bytes_type.TRANSACTION_ID:
      return "(koinos.btype) = TRANSACTION_ID";
    case optionspb.bytes_type.CONTRACT_ID:
      return "(koinos.btype) = CONTRACT_ID";
    case optionspb.bytes_type.ADDRESS:
      return "(koinos.btype) = ADDRESS";
    default:
      return "";
  }
}
util.getbType = getbType;
function getFieldLabel(se) {
  switch (se.getLabel()) {
    case descriptor_pb_js_1$1.FieldDescriptorProto.Label.LABEL_REPEATED:
      return "repeated";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Label.LABEL_REQUIRED:
      return "required";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Label.LABEL_OPTIONAL:
      return "";
    default:
      throw new Error(`Label '${se.getLabel()}' is not supported`);
  }
}
util.getFieldLabel = getFieldLabel;
function getFieldType(se) {
  switch (se.getType()) {
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_INT32:
      return "int32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SINT32:
      return "sint32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_FIXED32:
      return "fixed32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SFIXED32:
      return "sfixed32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_UINT32:
      return "uint32";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_INT64:
      return "int64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SINT64:
      return "sint64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_FIXED64:
      return "fixed64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_SFIXED64:
      return "sfixed64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_UINT64:
      return "uint64";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_FLOAT:
      return "float";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_DOUBLE:
      return "double";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_BOOL:
      return "bool";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_STRING:
      return "string";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_BYTES:
      return "bytes";
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_MESSAGE:
    case descriptor_pb_js_1$1.FieldDescriptorProto.Type.TYPE_ENUM:
      return se.getTypeName();
    default:
      throw new Error(`Type '${se.getTypeName()}' is not supported`);
  }
}
util.getFieldType = getFieldType;
function getField(se) {
  const e = se.getOptions(), Oe = se.getName(), Si = se.getNumber(), wi = se.hasProto3Optional() ? "optional" : "", Ei = getJSType(e), $i = getbType(e), xi = Ei ? `[${Ei}]` : $i ? `[${$i}]` : "";
  return `${wi} ${getFieldLabel(se)} ${getFieldType(se)} ${Oe} = ${Si} ${xi};`;
}
util.getField = getField;
function getOneofs(se, e) {
  const Oe = [];
  for (const [Si, wi] of se.getOneofDeclList().entries()) {
    const Ei = wi.getName();
    e[Si] && Oe.push(`
    oneof ${Ei} {
      ${e[Si].join(`
    `)}
    }

`);
  }
  return Oe;
}
util.getOneofs = getOneofs;
function getMessage(se) {
  const e = [], Oe = [], Si = [];
  for (const Ei of se.getNestedTypeList())
    e.push(getMessage(Ei));
  for (const Ei of se.getFieldList()) {
    const $i = getField(Ei);
    if (Ei.hasOneofIndex() && !Ei.hasProto3Optional()) {
      const xi = Ei.getOneofIndex();
      if (xi === void 0)
        throw new Error("Missing one_of index.");
      let Ri = Si[xi];
      Ri === void 0 && (Ri = [], Si[xi] = Ri), Ri.push($i);
    } else
      Oe.push($i);
  }
  const wi = getOneofs(se, Si);
  return `
  message ${se.getName()} {
    ${e.join(`
  `)}
    ${Oe.join(`
  `)}
    ${wi.join(`
  `)}
  }

`;
}
util.getMessage = getMessage;
Object.defineProperty(lib$1, "__esModule", { value: !0 });
lib$1.convert = void 0;
const descriptor_pb_js_1 = descriptor_pb, util_1 = util, convert = (se) => {
  const e = typeof se == "string" ? Buffer.from(se, "base64") : se, Oe = descriptor_pb_js_1.FileDescriptorSet.deserializeBinary(e), Si = [];
  for (const wi of Oe.getFileList()) {
    const Ei = wi.getName() || "";
    let $i = "";
    wi.hasSyntax() && ($i += (0, util_1.getSyntax)(wi)), wi.hasPackage() && ($i += (0, util_1.getPackage)(wi)), wi.hasOptions();
    for (const xi of wi.getDependencyList())
      $i += (0, util_1.getImport)(xi);
    for (const xi of wi.getEnumTypeList())
      $i += (0, util_1.getEnum)(xi);
    for (const xi of wi.getExtensionList())
      $i += (0, util_1.getExtension)(xi);
    for (const xi of wi.getMessageTypeList())
      $i += (0, util_1.getMessage)(xi);
    Si.push({ file: Ei, definition: $i });
  }
  return Si;
};
lib$1.convert = convert;
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe);
  var wi = Object.getOwnPropertyDescriptor(e, Oe);
  (!wi || ("get" in wi ? !e.__esModule : wi.writable || wi.configurable)) && (wi = { enumerable: !0, get: function() {
    return e[Oe];
  } }), Object.defineProperty(se, Si, wi);
} : function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe), se[Si] = e[Oe];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(se, e) {
  Object.defineProperty(se, "default", { enumerable: !0, value: e });
} : function(se, e) {
  se.default = e;
}), __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(se) {
  if (se && se.__esModule)
    return se;
  var e = {};
  if (se != null)
    for (var Oe in se)
      Oe !== "default" && Object.prototype.hasOwnProperty.call(se, Oe) && __createBinding$1(e, se, Oe);
  return __setModuleDefault$1(e, se), e;
};
Object.defineProperty(Serializer$1, "__esModule", { value: !0 });
Serializer$1.Serializer = void 0;
const protobufjs_1 = protobufjs, koinosPbToProto = __importStar$1(lib$1), utils_1$4 = utils$1, OP_BYTES_1 = "(btype)", OP_BYTES_2 = "(koinos.btype)", nativeTypes = [
  "double",
  "float",
  "int32",
  "int64",
  "uint32",
  "uint64",
  "sint32",
  "sint64",
  "fixed32",
  "fixed64",
  "sfixed32",
  "sfixed64",
  "bool",
  "string",
  "bytes"
];
class Serializer {
  constructor(e, Oe) {
    if (this.bytesConversion = !0, this.verifyChecksum = {
      serialize: !0,
      deserialize: !1
    }, this.types = e, typeof e == "string") {
      const Si = koinosPbToProto.convert((0, utils_1$4.decodeBase64)(e));
      this.root = new protobufjs_1.Root();
      for (const wi of Si)
        (0, protobufjs_1.parse)(wi.definition, this.root, { keepCase: !0 });
    } else
      this.root = protobufjs_1.Root.fromJSON(e);
    Oe != null && Oe.defaultTypeName && (this.defaultType = this.root.lookupType(Oe.defaultTypeName)), Oe && typeof Oe.bytesConversion < "u" && (this.bytesConversion = Oe.bytesConversion);
  }
  btypeDecode(e, Oe, Si) {
    const wi = {};
    return Object.keys(Oe.fields).forEach((Ei) => {
      const { options: $i, name: xi, type: Ri, rule: Ti } = Oe.fields[Ei];
      if (!e[xi])
        return;
      const Oi = { type: Ri };
      if ($i && ($i[OP_BYTES_1] ? Oi.btype = $i[OP_BYTES_1] : $i[OP_BYTES_2] && (Oi.btype = $i[OP_BYTES_2])), Ti === "repeated") {
        wi[xi] = e[xi].map((Mi) => {
          if (!nativeTypes.includes(Ri)) {
            const Ii = this.root.lookupTypeOrEnum(Ri);
            return Ii.fields ? this.btypeDecode(Mi, Ii, Si) : Mi;
          }
          return (0, utils_1$4.btypeDecodeValue)(Mi, Oi, Si);
        });
        return;
      }
      if (!nativeTypes.includes(Ri)) {
        const Mi = this.root.lookupTypeOrEnum(Ri);
        if (!Mi.fields) {
          wi[xi] = e[xi];
          return;
        }
        wi[xi] = this.btypeDecode(e[xi], Mi, Si);
        return;
      }
      wi[xi] = (0, utils_1$4.btypeDecodeValue)(e[xi], Oi, Si);
    }), wi;
  }
  btypeEncode(e, Oe, Si) {
    const wi = {};
    return Object.keys(Oe.fields).forEach((Ei) => {
      const { options: $i, name: xi, type: Ri, rule: Ti } = Oe.fields[Ei];
      if (!e[xi])
        return;
      const Oi = { type: Ri };
      if ($i && ($i[OP_BYTES_1] ? Oi.btype = $i[OP_BYTES_1] : $i[OP_BYTES_2] && (Oi.btype = $i[OP_BYTES_2])), Ti === "repeated") {
        wi[xi] = e[xi].map((Mi) => {
          if (!nativeTypes.includes(Ri)) {
            const Ii = this.root.lookupTypeOrEnum(Ri);
            return Ii.fields ? this.btypeEncode(Mi, Ii, Si) : Mi;
          }
          return (0, utils_1$4.btypeEncodeValue)(Mi, Oi, Si);
        });
        return;
      }
      if (!nativeTypes.includes(Ri)) {
        const Mi = this.root.lookupTypeOrEnum(Ri);
        if (!Mi.fields) {
          wi[xi] = e[xi];
          return;
        }
        wi[xi] = this.btypeEncode(e[xi], Mi, Si);
        return;
      }
      wi[xi] = (0, utils_1$4.btypeEncodeValue)(e[xi], Oi, Si);
    }), wi;
  }
  /**
   * Function to encode a type using the protobuffer definitions
   * It also prepares the bytes for special cases (base58, hex string)
   * when bytesConversion param is true.
   */
  async serialize(e, Oe, Si) {
    let wi;
    if (this.defaultType)
      wi = this.defaultType;
    else if (Oe)
      wi = this.root.lookupType(Oe);
    else
      throw new Error("no typeName defined");
    let Ei = {};
    const $i = (Si == null ? void 0 : Si.bytesConversion) === void 0 ? this.bytesConversion : Si.bytesConversion, xi = (Si == null ? void 0 : Si.verifyChecksum) === void 0 ? this.verifyChecksum.serialize : Si.verifyChecksum;
    $i ? Ei = this.btypeDecode(e, wi, xi) : Ei = e;
    const Ri = wi.create(Ei);
    return wi.encode(Ri).finish();
  }
  /**
   * Function to decode bytes using the protobuffer definitions
   * It also encodes the bytes for special cases (base58, hex string)
   * when bytesConversion param is true.
   */
  async deserialize(e, Oe, Si) {
    const wi = typeof e == "string" ? (0, utils_1$4.decodeBase64url)(e) : e;
    let Ei;
    if (this.defaultType)
      Ei = this.defaultType;
    else if (Oe)
      Ei = this.root.lookupType(Oe);
    else
      throw new Error("no typeName defined");
    const $i = Ei.decode(wi), xi = Ei.toObject($i, {
      longs: String,
      defaults: !0
    }), Ri = (Si == null ? void 0 : Si.bytesConversion) === void 0 ? this.bytesConversion : Si.bytesConversion, Ti = (Si == null ? void 0 : Si.verifyChecksum) === void 0 ? this.verifyChecksum.deserialize : Si.verifyChecksum;
    return Ri ? this.btypeEncode(xi, Ei, Ti) : xi;
  }
}
Serializer$1.Serializer = Serializer;
Serializer$1.default = Serializer;
const nested = {
  koinos: {
    options: {
      go_package: "github.com/koinos/koinos-proto-golang/koinos"
    },
    nested: {
      block_topology: {
        fields: {
          id: {
            type: "bytes",
            id: 1,
            options: {
              "(btype)": "BLOCK_ID"
            }
          },
          height: {
            type: "uint64",
            id: 2,
            options: {
              jstype: "JS_STRING"
            }
          },
          previous: {
            type: "bytes",
            id: 3,
            options: {
              "(btype)": "BLOCK_ID"
            }
          }
        }
      },
      protocol: {
        options: {
          go_package: "github.com/koinos/koinos-proto-golang/koinos/protocol"
        },
        nested: {
          event_data: {
            fields: {
              sequence: {
                type: "uint32",
                id: 1
              },
              source: {
                type: "bytes",
                id: 2,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              name: {
                type: "string",
                id: 3
              },
              data: {
                type: "bytes",
                id: 4
              },
              impacted: {
                rule: "repeated",
                type: "bytes",
                id: 5,
                options: {
                  "(btype)": "ADDRESS"
                }
              }
            }
          },
          contract_call_bundle: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              entry_point: {
                type: "uint32",
                id: 2
              }
            }
          },
          system_call_target: {
            oneofs: {
              target: {
                oneof: [
                  "thunk_id",
                  "system_call_bundle"
                ]
              }
            },
            fields: {
              thunk_id: {
                type: "uint32",
                id: 1
              },
              system_call_bundle: {
                type: "contract_call_bundle",
                id: 2
              }
            }
          },
          upload_contract_operation: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              bytecode: {
                type: "bytes",
                id: 2
              },
              abi: {
                type: "string",
                id: 3
              },
              authorizes_call_contract: {
                type: "bool",
                id: 4
              },
              authorizes_transaction_application: {
                type: "bool",
                id: 5
              },
              authorizes_upload_contract: {
                type: "bool",
                id: 6
              }
            }
          },
          call_contract_operation: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              entry_point: {
                type: "uint32",
                id: 2
              },
              args: {
                type: "bytes",
                id: 3
              }
            }
          },
          set_system_call_operation: {
            fields: {
              call_id: {
                type: "uint32",
                id: 1
              },
              target: {
                type: "system_call_target",
                id: 2
              }
            }
          },
          set_system_contract_operation: {
            fields: {
              contract_id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "CONTRACT_ID"
                }
              },
              system_contract: {
                type: "bool",
                id: 2
              }
            }
          },
          operation: {
            oneofs: {
              op: {
                oneof: [
                  "upload_contract",
                  "call_contract",
                  "set_system_call",
                  "set_system_contract"
                ]
              }
            },
            fields: {
              upload_contract: {
                type: "upload_contract_operation",
                id: 1
              },
              call_contract: {
                type: "call_contract_operation",
                id: 2
              },
              set_system_call: {
                type: "set_system_call_operation",
                id: 3
              },
              set_system_contract: {
                type: "set_system_contract_operation",
                id: 4
              }
            }
          },
          transaction_header: {
            fields: {
              chain_id: {
                type: "bytes",
                id: 1
              },
              rc_limit: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              nonce: {
                type: "bytes",
                id: 3
              },
              operation_merkle_root: {
                type: "bytes",
                id: 4
              },
              payer: {
                type: "bytes",
                id: 5,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              payee: {
                type: "bytes",
                id: 6,
                options: {
                  "(btype)": "ADDRESS"
                }
              }
            }
          },
          transaction: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "TRANSACTION_ID"
                }
              },
              header: {
                type: "transaction_header",
                id: 2
              },
              operations: {
                rule: "repeated",
                type: "operation",
                id: 3
              },
              signatures: {
                rule: "repeated",
                type: "bytes",
                id: 4
              }
            }
          },
          transaction_receipt: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "TRANSACTION_ID"
                }
              },
              payer: {
                type: "bytes",
                id: 2,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              max_payer_rc: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              rc_limit: {
                type: "uint64",
                id: 4,
                options: {
                  jstype: "JS_STRING"
                }
              },
              rc_used: {
                type: "uint64",
                id: 5,
                options: {
                  jstype: "JS_STRING"
                }
              },
              disk_storage_used: {
                type: "uint64",
                id: 6,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_used: {
                type: "uint64",
                id: 7,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_used: {
                type: "uint64",
                id: 8,
                options: {
                  jstype: "JS_STRING"
                }
              },
              reverted: {
                type: "bool",
                id: 9
              },
              events: {
                rule: "repeated",
                type: "event_data",
                id: 10
              },
              logs: {
                rule: "repeated",
                type: "string",
                id: 11
              }
            }
          },
          block_header: {
            fields: {
              previous: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "BLOCK_ID"
                }
              },
              height: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              timestamp: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              previous_state_merkle_root: {
                type: "bytes",
                id: 4
              },
              transaction_merkle_root: {
                type: "bytes",
                id: 5
              },
              signer: {
                type: "bytes",
                id: 6,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              approved_proposals: {
                rule: "repeated",
                type: "bytes",
                id: 7,
                options: {
                  "(btype)": "TRANSACTION_ID"
                }
              }
            }
          },
          block: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "BLOCK_ID"
                }
              },
              header: {
                type: "block_header",
                id: 2
              },
              transactions: {
                rule: "repeated",
                type: "transaction",
                id: 3
              },
              signature: {
                type: "bytes",
                id: 4
              }
            }
          },
          block_receipt: {
            fields: {
              id: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "BLOCK_ID"
                }
              },
              height: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              disk_storage_used: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_used: {
                type: "uint64",
                id: 4,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_used: {
                type: "uint64",
                id: 5,
                options: {
                  jstype: "JS_STRING"
                }
              },
              state_merkle_root: {
                type: "bytes",
                id: 6
              },
              events: {
                rule: "repeated",
                type: "event_data",
                id: 7
              },
              transaction_receipts: {
                rule: "repeated",
                type: "transaction_receipt",
                id: 8
              },
              logs: {
                rule: "repeated",
                type: "string",
                id: 9
              }
            }
          }
        }
      },
      chain: {
        options: {
          go_package: "github.com/koinos/koinos-proto-golang/koinos/chain"
        },
        nested: {
          error_data: {
            fields: {
              message: {
                type: "string",
                id: 1
              }
            }
          },
          result: {
            oneofs: {
              value: {
                oneof: [
                  "object",
                  "error"
                ]
              }
            },
            fields: {
              object: {
                type: "bytes",
                id: 1
              },
              error: {
                type: "error_data",
                id: 2
              }
            }
          },
          object_space: {
            fields: {
              system: {
                type: "bool",
                id: 1
              },
              zone: {
                type: "bytes",
                id: 2
              },
              id: {
                type: "uint32",
                id: 3
              }
            }
          },
          database_key: {
            fields: {
              space: {
                type: "object_space",
                id: 1
              },
              key: {
                type: "bytes",
                id: 2
              }
            }
          },
          max_account_resources: {
            fields: {
              value: {
                type: "uint64",
                id: 1,
                options: {
                  jstype: "JS_STRING"
                }
              }
            }
          },
          privilege: {
            values: {
              kernel_mode: 0,
              user_mode: 1
            }
          },
          head_info: {
            fields: {
              head_topology: {
                type: "block_topology",
                id: 1
              },
              head_block_time: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              last_irreversible_block: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              }
            }
          },
          caller_data: {
            fields: {
              caller: {
                type: "bytes",
                id: 1,
                options: {
                  "(btype)": "ADDRESS"
                }
              },
              caller_privilege: {
                type: "privilege",
                id: 2
              }
            }
          },
          argument_data: {
            fields: {
              entry_point: {
                type: "uint32",
                id: 1
              },
              arguments: {
                type: "bytes",
                id: 2
              }
            }
          },
          resource_limit_data: {
            fields: {
              disk_storage_limit: {
                type: "uint64",
                id: 1,
                options: {
                  jstype: "JS_STRING"
                }
              },
              disk_storage_cost: {
                type: "uint64",
                id: 2,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_limit: {
                type: "uint64",
                id: 3,
                options: {
                  jstype: "JS_STRING"
                }
              },
              network_bandwidth_cost: {
                type: "uint64",
                id: 4,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_limit: {
                type: "uint64",
                id: 5,
                options: {
                  jstype: "JS_STRING"
                }
              },
              compute_bandwidth_cost: {
                type: "uint64",
                id: 6,
                options: {
                  jstype: "JS_STRING"
                }
              }
            }
          },
          contract_metadata_object: {
            fields: {
              hash: {
                type: "bytes",
                id: 1
              },
              system: {
                type: "bool",
                id: 2
              },
              authorizes_call_contract: {
                type: "bool",
                id: 3
              },
              authorizes_transaction_application: {
                type: "bool",
                id: 4
              },
              authorizes_upload_contract: {
                type: "bool",
                id: 5
              }
            }
          },
          compute_bandwidth_entry: {
            fields: {
              name: {
                type: "string",
                id: 1
              },
              compute: {
                type: "uint64",
                id: 2
              }
            }
          },
          compute_bandwidth_registry: {
            fields: {
              entries: {
                rule: "repeated",
                type: "compute_bandwidth_entry",
                id: 1
              }
            }
          },
          genesis_entry: {
            fields: {
              space: {
                type: "object_space",
                id: 1
              },
              key: {
                type: "bytes",
                id: 2
              },
              value: {
                type: "bytes",
                id: 3
              }
            }
          },
          genesis_data: {
            fields: {
              entries: {
                rule: "repeated",
                type: "genesis_entry",
                id: 1
              }
            }
          },
          dsa: {
            values: {
              ecdsa_secp256k1: 0
            }
          }
        }
      }
    }
  }
}, require$$3 = {
  nested
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(se) {
  return se && se.__esModule ? se : { default: se };
};
Object.defineProperty(utilsNode, "__esModule", { value: !0 });
utilsNode.ChainTypes = utilsNode.decodeGenesisData = utilsNode.encodeGenesisData = void 0;
const sha256_1$1 = sha256, Serializer_1$1 = Serializer$1, utils_1$3 = utils$1, chain_proto_json_1 = __importDefault$1(require$$3), defaultAlias = {
  "object_key::head_block": { typeName: "block" },
  "object_key::chain_id": {},
  "object_key::genesis_key": { isAddress: !0 },
  "object_key::resource_limit_data": { typeName: "resource_limit_data" },
  "object_key::max_account_resources": { typeName: "max_account_resources" },
  "object_key::protocol_descriptor": {},
  "object_key::compute_bandwidth_registry": {
    typeName: "compute_bandwidth_registry"
  },
  "object_key::block_hash_code": {}
};
function prepareDictionary(se) {
  const e = new Serializer_1$1.Serializer(chain_proto_json_1.default, { bytesConversion: !0 }), Oe = {};
  return Object.keys(defaultAlias).forEach((wi) => {
    const Ei = (0, utils_1$3.encodeBase64)((0, utils_1$3.multihash)((0, sha256_1$1.sha256)(wi)));
    Oe[Ei] = {
      serializer: e,
      alias: wi,
      ...defaultAlias[wi]
    };
  }), {
    ...Oe,
    ...se
  };
}
async function encodeGenesisData(se, e = {}) {
  const Oe = {};
  if (!se || !se.entries)
    return Oe;
  const Si = prepareDictionary(e);
  return Oe.entries = await Promise.all(se.entries.map(async (wi) => {
    const Ei = Object.keys(Si).find((Mi) => Mi === wi.key || wi.alias && Si[Mi].alias === wi.alias);
    if (!Ei)
      return {
        error: `key ${wi.key} not found in the dictionary`,
        space: wi.space,
        key: wi.key,
        value: (0, utils_1$3.encodeBase64)(new Uint8Array())
      };
    const { isAddress: $i, serializer: xi, typeName: Ri } = Si[Ei];
    let Ti, Oi = "";
    return $i ? Ti = (0, utils_1$3.decodeBase58)(wi.value) : xi && Ri ? Ti = await xi.serialize(wi.value, Ri) : (Ti = new Uint8Array(), Oi = "no serializer or typeName defined in the dictionary"), {
      ...Oi && { error: Oi },
      space: wi.space,
      key: Ei,
      value: (0, utils_1$3.encodeBase64)(Ti)
    };
  })), Oe;
}
utilsNode.encodeGenesisData = encodeGenesisData;
async function decodeGenesisData(se, e = {}) {
  const Oe = {};
  if (!se || !se.entries)
    return Oe;
  const Si = prepareDictionary(e);
  return Oe.entries = await Promise.all(se.entries.map(async (wi) => {
    const Ei = Object.keys(Si).find((Ci) => Ci === wi.key);
    if (!Ei)
      return {
        error: `key ${wi.key} not found in the dictionary`,
        ...wi
      };
    const { isAddress: $i, serializer: xi, typeName: Ri, alias: Ti } = Si[Ei], Oi = (0, utils_1$3.encodeBase64url)((0, utils_1$3.decodeBase64)(wi.value));
    let Mi, Ii = "";
    return $i ? Mi = (0, utils_1$3.encodeBase58)((0, utils_1$3.decodeBase64url)(Oi)) : xi && Ri ? Mi = await xi.deserialize(Oi, Ri) : (Mi = Oi, Ii = "no serializer or typeName defined in the dictionary"), {
      ...Ii && { error: Ii },
      space: wi.space,
      key: Ei,
      value: Mi,
      ...Ti && { alias: Ti }
    };
  })), Oe;
}
utilsNode.decodeGenesisData = decodeGenesisData;
utilsNode.ChainTypes = chain_proto_json_1.default;
(function(se) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Si, wi, Ei, $i) {
    $i === void 0 && ($i = Ei);
    var xi = Object.getOwnPropertyDescriptor(wi, Ei);
    (!xi || ("get" in xi ? !wi.__esModule : xi.writable || xi.configurable)) && (xi = { enumerable: !0, get: function() {
      return wi[Ei];
    } }), Object.defineProperty(Si, $i, xi);
  } : function(Si, wi, Ei, $i) {
    $i === void 0 && ($i = Ei), Si[$i] = wi[Ei];
  }), Oe = commonjsGlobal && commonjsGlobal.__exportStar || function(Si, wi) {
    for (var Ei in Si)
      Ei !== "default" && !Object.prototype.hasOwnProperty.call(wi, Ei) && e(wi, Si, Ei);
  };
  Object.defineProperty(se, "__esModule", { value: !0 }), Oe(utils$1, se), Oe(utilsNode, se);
})(indexUtils);
var _interface = {};
Object.defineProperty(_interface, "__esModule", { value: !0 });
var Contract$1 = {};
Object.defineProperty(Contract$1, "__esModule", { value: !0 });
Contract$1.Contract = void 0;
const Serializer_1 = Serializer$1, utils_1$2 = utils$1;
class Contract {
  constructor(e) {
    var Oe;
    if (this.signer = e.signer, e.id)
      this.id = (0, utils_1$2.decodeBase58)(e.id);
    else {
      if (!this.signer)
        throw new Error("at least signer or contract id must be defined");
      this.id = (0, utils_1$2.decodeBase58)(this.signer.getAddress());
    }
    this.provider = e.provider || ((Oe = e.signer) === null || Oe === void 0 ? void 0 : Oe.provider), this.abi = e.abi, this.bytecode = e.bytecode, e.serializer ? this.serializer = e.serializer : e.abi && e.abi.koilib_types ? this.serializer = new Serializer_1.Serializer(e.abi.koilib_types) : e.abi && e.abi.types && (this.serializer = new Serializer_1.Serializer(e.abi.types)), this.options = {
      signTransaction: !0,
      sendTransaction: !0,
      broadcast: !0,
      sendAbis: !0,
      ...e.options
    }, this.functions = {}, this.updateFunctionsFromAbi();
  }
  /**
   * Get contract Id
   */
  getId() {
    return (0, utils_1$2.encodeBase58)(this.id);
  }
  /**
   * Fetch the ABI from the contract meta store and save it in the
   * abi of the contract. The provider must have contract_meta_store
   * microservice enabled.
   * @param opts - options object with 2 boolean: 1) updateFunctions to
   * specify if the contract functions should be regenerated based on
   * the new ABI, and 2) updateSerializer to determine if the serializer
   * should be updated with the types in the new ABI.
   * @returns the new ABI saved in the contract
   */
  async fetchAbi(e = {
    updateFunctions: !0,
    updateSerializer: !0
  }) {
    if (!this.provider)
      throw new Error("provider not found");
    const Oe = await this.provider.call("contract_meta_store.get_contract_meta", {
      contract_id: this.getId()
    });
    if (!(!Oe.meta || !Oe.meta.abi))
      return this.abi = JSON.parse(Oe.meta.abi), e.updateFunctions && this.updateFunctionsFromAbi(), e.updateSerializer && (this.abi.koilib_types ? this.serializer = new Serializer_1.Serializer(this.abi.koilib_types) : this.abi.types && (this.serializer = new Serializer_1.Serializer(this.abi.types))), this.abi;
  }
  /**
   * Create the contract functions based on the ABI
   */
  updateFunctionsFromAbi() {
    return !this.abi || !this.abi.methods ? !1 : (Object.keys(this.abi.methods).forEach((e) => {
      this.functions[e] = async (Oe = {}, Si) => {
        if (!this.provider)
          throw new Error("provider not found");
        if (!this.abi || !this.abi.methods)
          throw new Error("Methods are not defined");
        if (!this.abi.methods[e])
          throw new Error(`Method ${e} not defined in the ABI`);
        const wi = {
          ...this.options,
          ...Si
        }, { read_only: Ei, return: $i, default_output: xi, preformat_argument: Ri, preformat_return: Ti } = this.abi.methods[e];
        let Oi;
        typeof Ri == "function" ? Oi = Ri(Oe) : Oi = Oe;
        const Mi = await this.encodeOperation({ name: e, args: Oi });
        if (wi.onlyOperation)
          return { operation: Mi };
        if (Ei) {
          if (!$i)
            throw new Error(`No output defined for ${e}`);
          const { result: Ro } = await this.provider.readContract(Mi.call_contract);
          let Bo = xi;
          return Ro && (Bo = await this.serializer.deserialize(Ro, $i)), typeof Ti == "function" && (Bo = Ti(Bo)), { operation: Mi, result: Bo };
        }
        if (!this.signer)
          throw new Error("signer not found");
        let Ii = await this.signer.prepareTransaction({
          header: {
            ...wi.chainId && { chain_id: wi.chainId },
            ...wi.rcLimit && { rc_limit: wi.rcLimit },
            ...wi.nonce && { nonce: wi.nonce },
            ...wi.payer && { payer: wi.payer },
            ...wi.payee && { payee: wi.payee }
          },
          operations: [
            ...wi.previousOperations ? wi.previousOperations : [],
            Mi,
            ...wi.nextOperations ? wi.nextOperations : []
          ]
        });
        if (wi.sendAbis) {
          wi.abis || (wi.abis = {});
          const Ro = this.getId();
          wi.abis[Ro] || (wi.abis[Ro] = this.abi);
        }
        if (!wi.sendTransaction) {
          const Ro = () => {
            throw new Error("This transaction was not broadcasted");
          };
          return wi.signTransaction && (Ii = await this.signer.signTransaction(Ii, wi.sendAbis ? wi.abis : void 0)), { operation: Mi, transaction: { ...Ii, wait: Ro } };
        }
        const { transaction: Ci, receipt: Oo } = await this.signer.sendTransaction(Ii, wi);
        return { operation: Mi, transaction: Ci, receipt: Oo };
      };
    }), !0);
  }
  /**
   * Function to deploy a new smart contract.
   * The Bytecode must be defined in the constructor of the class
   * @example
   * ```ts
   * const privateKey = "f186a5de49797bfd52dc42505c33d75a46822ed5b60046e09d7c336242e20200";
   * const provider = new Provider(["http://api.koinos.io:8080"]);
   * const signer = new Signer({ privateKey, provider });
   * const bytecode = new Uint8Array([1, 2, 3, 4]);
   * const contract = new Contract({ signer, provider, bytecode });
   * const { transaction, receipt } = await contract.deploy();
   * console.log(receipt);
   * // wait to be mined
   * const blockNumber = await transaction.wait();
   * console.log(`Contract uploaded in block number ${blockNumber}`);
   * ```
   *
   * @example using options
   * ```ts
   * const { transaction, receipt } = await contract.deploy({
   *   // contract options
   *   abi: "CssCChRrb2lub3Mvb3B0aW9ucy5wc...",
   *   authorizesCallContract: true,
   *   authorizesTransactionApplication: true,
   *   authorizesUploadContract: true,
   *
   *   // transaction options
   *   chainId: "EiB-hw5ABo-EXy6fGDd1Iq3gbAenxQ4Qe60pRbEVMVrR9A==",
   *   rcLimit: "100000000",
   *   nonce: "OAI=",
   *   payer: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   payee: "1Gvqdo9if6v6tFomEuTuMWP1D7H7U9yksb",
   *
   *   // sign and broadcast
   *   signTransaction: true,
   *   sendTransaction: true,
   *   broadcast: true,
   * });
   * console.log(receipt);
   * // wait to be mined
   * const blockNumber = await transaction.wait();
   * console.log(`Contract uploaded in block number ${blockNumber}`);
   * ```
   */
  async deploy(e) {
    if (!this.signer)
      throw new Error("signer not found");
    if (!this.bytecode)
      throw new Error("bytecode not found");
    const Oe = {
      ...this.options,
      ...e
    }, wi = {
      upload_contract: {
        contract_id: this.getId(),
        bytecode: (0, utils_1$2.encodeBase64url)(this.bytecode),
        ...Oe.abi && { abi: Oe.abi },
        ...Oe.authorizesCallContract && {
          authorizes_call_contract: Oe.authorizesCallContract
        },
        ...Oe.authorizesTransactionApplication && {
          authorizes_transaction_application: Oe.authorizesTransactionApplication
        },
        ...Oe.authorizesUploadContract && {
          authorizes_upload_contract: Oe.authorizesUploadContract
        }
      }
    };
    if (Oe.onlyOperation)
      return { operation: wi };
    let Ei = await this.signer.prepareTransaction({
      header: {
        ...Oe.chainId && { chain_id: Oe.chainId },
        ...Oe.rcLimit && { rc_limit: Oe.rcLimit },
        ...Oe.nonce && { nonce: Oe.nonce },
        ...Oe.payer && { payer: Oe.payer },
        ...Oe.payee && { payee: Oe.payee }
      },
      operations: [
        ...Oe.previousOperations ? Oe.previousOperations : [],
        wi,
        ...Oe.nextOperations ? Oe.nextOperations : []
      ]
    });
    if (!Oe.sendTransaction) {
      const Ri = () => {
        throw new Error("This transaction was not broadcasted");
      };
      return Oe.signTransaction && (Ei = await this.signer.signTransaction(Ei, Oe.sendAbis ? Oe.abis : void 0)), { operation: wi, transaction: { ...Ei, wait: Ri } };
    }
    const { transaction: $i, receipt: xi } = await this.signer.sendTransaction(Ei, Oe);
    return { operation: wi, transaction: $i, receipt: xi };
  }
  /**
   * Encondes a contract operation using Koinos serialization
   * and taking the contract entries as reference to build it
   * @param op - Operation to encode
   * @returns Operation encoded
   * @example
   * ```ts
   * const opEncoded = contract.encodeOperation({
   *   name: "transfer",
   *   args: {
   *     from: "12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD",
   *     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
   *     value: "1000",
   *   }
   * });
   *
   * console.log(opEncoded);
   * // {
   * //   call_contract: {
   * //     contract_id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   * //     entry_point: 670398154,
   * //     args: "ChkAEjl6vrl55V2Oym_rzsnMxIqBoie9PHmMEhkAQgjT1UACatdFY3e5QRkyG7OAzwcCCIylGOgH",
   * //   }
   * // }
   * ```
   */
  async encodeOperation(e) {
    if (!this.abi || !this.abi.methods || !this.abi.methods[e.name])
      throw new Error(`Operation ${e.name} unknown`);
    if (!this.serializer)
      throw new Error("Serializer is not defined");
    const Oe = this.abi.methods[e.name];
    let Si = new Uint8Array(0);
    if (Oe.argument) {
      if (!e.args)
        throw new Error(`No arguments defined for type '${Oe.argument}'`);
      Si = await this.serializer.serialize(e.args, Oe.argument);
    }
    return {
      call_contract: {
        contract_id: this.getId(),
        entry_point: Oe.entry_point,
        args: (0, utils_1$2.encodeBase64url)(Si)
      }
    };
  }
  /**
   * Decodes a contract operation to be human readable
   * @example
   * ```ts
   * const opDecoded = contract.decodeOperation({
   *   call_contract: {
   *     contract_id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *     entry_point: 0x27f576ca,
   *     args: "ChkAEjl6vrl55V2Oym_rzsnMxIqBoie9PHmMEhkAQgjT1UACatdFY3e5QRkyG7OAzwcCCIylGOgH",
   *   }
   * });
   * console.log(opDecoded);
   * // {
   * //   name: "transfer",
   * //   args: {
   * //     from: "12fN2CQnuJM8cMnWZ1hPtM4knjLME8E4PD",
   * //     to: "172AB1FgCsYrRAW5cwQ8KjadgxofvgPFd6",
   * //     value: "1000",
   * //   },
   * // }
   * ```
   */
  async decodeOperation(e) {
    if (!this.abi || !this.abi.methods)
      throw new Error("Methods are not defined");
    if (!this.serializer)
      throw new Error("Serializer is not defined");
    if (!e.call_contract)
      throw new Error("Operation is not CallContractOperation");
    if (e.call_contract.contract_id !== this.getId())
      throw new Error(`Invalid contract id. Expected: ${this.getId()}. Received: ${e.call_contract.contract_id}`);
    for (let Oe = 0; Oe < Object.keys(this.abi.methods).length; Oe += 1) {
      const Si = Object.keys(this.abi.methods)[Oe], wi = this.abi.methods[Si];
      if (e.call_contract.entry_point === wi.entry_point)
        return wi.argument ? {
          name: Si,
          args: await this.serializer.deserialize(e.call_contract.args, wi.argument)
        } : { name: Si };
    }
    throw new Error(`Unknown method id ${e.call_contract.entry_point}`);
  }
  /**
   * Decode an event received in a receipt
   *
   * @example
   * ```ts
   * const contract = new Contract({
   *   id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   abi: utils.tokenAbi,
   * });
   * const event = {
   *   sequence: 1,
   *   source: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   name: "koinos.contracts.token.mint_event",
   *   data: "ChkAxjdqxuwS-B50lPQ-lqhRBA3bf2b2ooAHENrw3Ek=",
   *   impacted: ["1K55BRw87nd64a7aiRarp6DLGRzYvoJo8J"],
   * };
   * const eventDecoded = await contract.decodeEvent(event);
   * console.log(eventDecoded);
   * // {
   * //   sequence: 1,
   * //   source: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   * //   name: "koinos.contracts.token.mint_event",
   * //   data: "ChkAxjdqxuwS-B50lPQ-lqhRBA3bf2b2ooAHENrw3Ek=",
   * //   impacted: ["1K55BRw87nd64a7aiRarp6DLGRzYvoJo8J"],
   * //   args: {
   * //     to: "1K55BRw87nd64a7aiRarp6DLGRzYvoJo8J",
   * //     value: "154613850",
   * //   },
   * // }
   * ```
   */
  async decodeEvent(e) {
    if (!this.serializer)
      throw new Error("Serializer is not defined");
    let Oe = e.name;
    this.abi && this.abi.events && this.abi.events[e.name] && (Oe = this.abi.events[e.name].argument);
    const Si = Oe ? await this.serializer.deserialize(e.data, Oe) : {};
    return { ...e, args: Si };
  }
}
Contract$1.Contract = Contract;
Contract$1.default = Contract;
var Signer$1 = {}, lib = {};
(function(se) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(se, "__esModule", { value: !0 }), se.utils = se.schnorr = se.verify = se.signSync = se.sign = se.getSharedSecret = se.recoverPublicKey = se.getPublicKey = se.Signature = se.Point = se.CURVE = void 0;
  const e = require$$1, Oe = BigInt(0), Si = BigInt(1), wi = BigInt(2), Ei = BigInt(3), $i = BigInt(8), xi = Object.freeze({
    a: Oe,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: Si,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  se.CURVE = xi;
  const Ri = (Ho, qo) => (Ho + qo / wi) / qo, Ti = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Ho) {
      const { n: qo } = xi, Go = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Xo = -Si * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ea = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ia = Go, oa = BigInt("0x100000000000000000000000000000000"), aa = Ri(ia * Ho, qo), ua = Ri(-Xo * Ho, qo);
      let na = xo(Ho - aa * Go - ua * ea, qo), _a = xo(-aa * Xo - ua * ia, qo);
      const pa = na > oa, la = _a > oa;
      if (pa && (na = qo - na), la && (_a = qo - _a), na > oa || _a > oa)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Ho);
      return { k1neg: pa, k1: na, k2neg: la, k2: _a };
    }
  }, Oi = 32, Mi = 32, Ii = 32, Ci = Oi + 1, Oo = 2 * Oi + 1;
  function Ro(Ho) {
    const { a: qo, b: Go } = xi, Xo = xo(Ho * Ho), ea = xo(Xo * Ho);
    return xo(ea + qo * Ho + Go);
  }
  const Bo = xi.a === Oe;
  class Fo extends Error {
    constructor(qo) {
      super(qo);
    }
  }
  function Io(Ho) {
    if (!(Ho instanceof Uo))
      throw new TypeError("JacobianPoint expected");
  }
  class Uo {
    constructor(qo, Go, Xo) {
      this.x = qo, this.y = Go, this.z = Xo;
    }
    static fromAffine(qo) {
      if (!(qo instanceof Po))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return qo.equals(Po.ZERO) ? Uo.ZERO : new Uo(qo.x, qo.y, Si);
    }
    static toAffineBatch(qo) {
      const Go = Vo(qo.map((Xo) => Xo.z));
      return qo.map((Xo, ea) => Xo.toAffine(Go[ea]));
    }
    static normalizeZ(qo) {
      return Uo.toAffineBatch(qo).map(Uo.fromAffine);
    }
    equals(qo) {
      Io(qo);
      const { x: Go, y: Xo, z: ea } = this, { x: ia, y: oa, z: aa } = qo, ua = xo(ea * ea), na = xo(aa * aa), _a = xo(Go * na), pa = xo(ia * ua), la = xo(xo(Xo * aa) * na), Ba = xo(xo(oa * ea) * ua);
      return _a === pa && la === Ba;
    }
    negate() {
      return new Uo(this.x, xo(-this.y), this.z);
    }
    double() {
      const { x: qo, y: Go, z: Xo } = this, ea = xo(qo * qo), ia = xo(Go * Go), oa = xo(ia * ia), aa = qo + ia, ua = xo(wi * (xo(aa * aa) - ea - oa)), na = xo(Ei * ea), _a = xo(na * na), pa = xo(_a - wi * ua), la = xo(na * (ua - pa) - $i * oa), Ba = xo(wi * Go * Xo);
      return new Uo(pa, la, Ba);
    }
    add(qo) {
      Io(qo);
      const { x: Go, y: Xo, z: ea } = this, { x: ia, y: oa, z: aa } = qo;
      if (ia === Oe || oa === Oe)
        return this;
      if (Go === Oe || Xo === Oe)
        return qo;
      const ua = xo(ea * ea), na = xo(aa * aa), _a = xo(Go * na), pa = xo(ia * ua), la = xo(xo(Xo * aa) * na), Ba = xo(xo(oa * ea) * ua), Da = xo(pa - _a), Ta = xo(Ba - la);
      if (Da === Oe)
        return Ta === Oe ? this.double() : Uo.ZERO;
      const Ja = xo(Da * Da), ja = xo(Da * Ja), za = xo(_a * Ja), Qa = xo(Ta * Ta - ja - wi * za), tl = xo(Ta * (za - Qa) - la * ja), Xa = xo(ea * aa * Da);
      return new Uo(Qa, tl, Xa);
    }
    subtract(qo) {
      return this.add(qo.negate());
    }
    multiplyUnsafe(qo) {
      const Go = Uo.ZERO;
      if (typeof qo == "bigint" && qo === Oe)
        return Go;
      let Xo = Fi(qo);
      if (Xo === Si)
        return this;
      if (!Bo) {
        let pa = Go, la = this;
        for (; Xo > Oe; )
          Xo & Si && (pa = pa.add(la)), la = la.double(), Xo >>= Si;
        return pa;
      }
      let { k1neg: ea, k1: ia, k2neg: oa, k2: aa } = Ti.splitScalar(Xo), ua = Go, na = Go, _a = this;
      for (; ia > Oe || aa > Oe; )
        ia & Si && (ua = ua.add(_a)), aa & Si && (na = na.add(_a)), _a = _a.double(), ia >>= Si, aa >>= Si;
      return ea && (ua = ua.negate()), oa && (na = na.negate()), na = new Uo(xo(na.x * Ti.beta), na.y, na.z), ua.add(na);
    }
    precomputeWindow(qo) {
      const Go = Bo ? 128 / qo + 1 : 256 / qo + 1, Xo = [];
      let ea = this, ia = ea;
      for (let oa = 0; oa < Go; oa++) {
        ia = ea, Xo.push(ia);
        for (let aa = 1; aa < 2 ** (qo - 1); aa++)
          ia = ia.add(ea), Xo.push(ia);
        ea = ia.double();
      }
      return Xo;
    }
    wNAF(qo, Go) {
      !Go && this.equals(Uo.BASE) && (Go = Po.BASE);
      const Xo = Go && Go._WINDOW_SIZE || 1;
      if (256 % Xo)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let ea = Go && ko.get(Go);
      ea || (ea = this.precomputeWindow(Xo), Go && Xo !== 1 && (ea = Uo.normalizeZ(ea), ko.set(Go, ea)));
      let ia = Uo.ZERO, oa = Uo.BASE;
      const aa = 1 + (Bo ? 128 / Xo : 256 / Xo), ua = 2 ** (Xo - 1), na = BigInt(2 ** Xo - 1), _a = 2 ** Xo, pa = BigInt(Xo);
      for (let la = 0; la < aa; la++) {
        const Ba = la * ua;
        let Da = Number(qo & na);
        qo >>= pa, Da > ua && (Da -= _a, qo += Si);
        const Ta = Ba, Ja = Ba + Math.abs(Da) - 1, ja = la % 2 !== 0, za = Da < 0;
        Da === 0 ? oa = oa.add(Co(ja, ea[Ta])) : ia = ia.add(Co(za, ea[Ja]));
      }
      return { p: ia, f: oa };
    }
    multiply(qo, Go) {
      let Xo = Fi(qo), ea, ia;
      if (Bo) {
        const { k1neg: oa, k1: aa, k2neg: ua, k2: na } = Ti.splitScalar(Xo);
        let { p: _a, f: pa } = this.wNAF(aa, Go), { p: la, f: Ba } = this.wNAF(na, Go);
        _a = Co(oa, _a), la = Co(ua, la), la = new Uo(xo(la.x * Ti.beta), la.y, la.z), ea = _a.add(la), ia = pa.add(Ba);
      } else {
        const { p: oa, f: aa } = this.wNAF(Xo, Go);
        ea = oa, ia = aa;
      }
      return Uo.normalizeZ([ea, ia])[0];
    }
    toAffine(qo) {
      const { x: Go, y: Xo, z: ea } = this, ia = this.equals(Uo.ZERO);
      qo == null && (qo = ia ? $i : Ko(ea));
      const oa = qo, aa = xo(oa * oa), ua = xo(aa * oa), na = xo(Go * aa), _a = xo(Xo * ua), pa = xo(ea * oa);
      if (ia)
        return Po.ZERO;
      if (pa !== Si)
        throw new Error("invZ was invalid");
      return new Po(na, _a);
    }
  }
  Uo.BASE = new Uo(xi.Gx, xi.Gy, Si), Uo.ZERO = new Uo(Oe, Si, Oe);
  function Co(Ho, qo) {
    const Go = qo.negate();
    return Ho ? Go : qo;
  }
  const ko = /* @__PURE__ */ new WeakMap();
  class Po {
    constructor(qo, Go) {
      this.x = qo, this.y = Go;
    }
    _setWindowSize(qo) {
      this._WINDOW_SIZE = qo, ko.delete(this);
    }
    hasEvenY() {
      return this.y % wi === Oe;
    }
    static fromCompressedHex(qo) {
      const Go = qo.length === 32, Xo = zi(Go ? qo : qo.subarray(1));
      if (!ra(Xo))
        throw new Error("Point is not on curve");
      const ea = Ro(Xo);
      let ia = To(ea);
      const oa = (ia & Si) === Si;
      Go ? oa && (ia = xo(-ia)) : (qo[0] & 1) === 1 !== oa && (ia = xo(-ia));
      const aa = new Po(Xo, ia);
      return aa.assertValidity(), aa;
    }
    static fromUncompressedHex(qo) {
      const Go = zi(qo.subarray(1, Oi + 1)), Xo = zi(qo.subarray(Oi + 1, Oi * 2 + 1)), ea = new Po(Go, Xo);
      return ea.assertValidity(), ea;
    }
    static fromHex(qo) {
      const Go = _o(qo), Xo = Go.length, ea = Go[0];
      if (Xo === Oi)
        return this.fromCompressedHex(Go);
      if (Xo === Ci && (ea === 2 || ea === 3))
        return this.fromCompressedHex(Go);
      if (Xo === Oo && ea === 4)
        return this.fromUncompressedHex(Go);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ci} compressed bytes or ${Oo} uncompressed bytes, not ${Xo}`);
    }
    static fromPrivateKey(qo) {
      return Po.BASE.multiply(Ma(qo));
    }
    static fromSignature(qo, Go, Xo) {
      const { r: ea, s: ia } = ma(Go);
      if (![0, 1, 2, 3].includes(Xo))
        throw new Error("Cannot recover: invalid recovery bit");
      const oa = jo(_o(qo)), { n: aa } = xi, ua = Xo === 2 || Xo === 3 ? ea + aa : ea, na = Ko(ua, aa), _a = xo(-oa * na, aa), pa = xo(ia * na, aa), la = Xo & 1 ? "03" : "02", Ba = Po.fromHex(la + Ni(ua)), Da = Po.BASE.multiplyAndAddUnsafe(Ba, _a, pa);
      if (!Da)
        throw new Error("Cannot recover signature: point at infinify");
      return Da.assertValidity(), Da;
    }
    toRawBytes(qo = !1) {
      return Eo(this.toHex(qo));
    }
    toHex(qo = !1) {
      const Go = Ni(this.x);
      return qo ? `${this.hasEvenY() ? "02" : "03"}${Go}` : `04${Go}${Ni(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const qo = "Point is not on elliptic curve", { x: Go, y: Xo } = this;
      if (!ra(Go) || !ra(Xo))
        throw new Error(qo);
      const ea = xo(Xo * Xo), ia = Ro(Go);
      if (xo(ea - ia) !== Oe)
        throw new Error(qo);
    }
    equals(qo) {
      return this.x === qo.x && this.y === qo.y;
    }
    negate() {
      return new Po(this.x, xo(-this.y));
    }
    double() {
      return Uo.fromAffine(this).double().toAffine();
    }
    add(qo) {
      return Uo.fromAffine(this).add(Uo.fromAffine(qo)).toAffine();
    }
    subtract(qo) {
      return this.add(qo.negate());
    }
    multiply(qo) {
      return Uo.fromAffine(this).multiply(qo, this).toAffine();
    }
    multiplyAndAddUnsafe(qo, Go, Xo) {
      const ea = Uo.fromAffine(this), ia = Go === Oe || Go === Si || this !== Po.BASE ? ea.multiplyUnsafe(Go) : ea.multiply(Go), oa = Uo.fromAffine(qo).multiplyUnsafe(Xo), aa = ia.add(oa);
      return aa.equals(Uo.ZERO) ? void 0 : aa.toAffine();
    }
  }
  se.Point = Po, Po.BASE = new Po(xi.Gx, xi.Gy), Po.ZERO = new Po(Oe, Oe);
  function Mo(Ho) {
    return Number.parseInt(Ho[0], 16) >= 8 ? "00" + Ho : Ho;
  }
  function No(Ho) {
    if (Ho.length < 2 || Ho[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Li(Ho)}`);
    const qo = Ho[1], Go = Ho.subarray(2, qo + 2);
    if (!qo || Go.length !== qo)
      throw new Error("Invalid signature integer: wrong length");
    if (Go[0] === 0 && Go[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: zi(Go), left: Ho.subarray(qo + 2) };
  }
  function Jo(Ho) {
    if (Ho.length < 2 || Ho[0] != 48)
      throw new Error(`Invalid signature tag: ${Li(Ho)}`);
    if (Ho[1] !== Ho.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: qo, left: Go } = No(Ho.subarray(2)), { data: Xo, left: ea } = No(Go);
    if (ea.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Li(ea)}`);
    return { r: qo, s: Xo };
  }
  class zo {
    constructor(qo, Go) {
      this.r = qo, this.s = Go, this.assertValidity();
    }
    static fromCompact(qo) {
      const Go = qo instanceof Uint8Array, Xo = "Signature.fromCompact";
      if (typeof qo != "string" && !Go)
        throw new TypeError(`${Xo}: Expected string or Uint8Array`);
      const ea = Go ? Li(qo) : qo;
      if (ea.length !== 128)
        throw new Error(`${Xo}: Expected 64-byte hex`);
      return new zo($o(ea.slice(0, 64)), $o(ea.slice(64, 128)));
    }
    static fromDER(qo) {
      const Go = qo instanceof Uint8Array;
      if (typeof qo != "string" && !Go)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Xo, s: ea } = Jo(Go ? qo : Eo(qo));
      return new zo(Xo, ea);
    }
    static fromHex(qo) {
      return this.fromDER(qo);
    }
    assertValidity() {
      const { r: qo, s: Go } = this;
      if (!An(qo))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!An(Go))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const qo = xi.n >> Si;
      return this.s > qo;
    }
    normalizeS() {
      return this.hasHighS() ? new zo(this.r, xo(-this.s, xi.n)) : this;
    }
    toDERRawBytes() {
      return Eo(this.toDERHex());
    }
    toDERHex() {
      const qo = Mo(So(this.s)), Go = Mo(So(this.r)), Xo = qo.length / 2, ea = Go.length / 2, ia = So(Xo), oa = So(ea);
      return `30${So(ea + Xo + 4)}02${oa}${Go}02${ia}${qo}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return Eo(this.toCompactHex());
    }
    toCompactHex() {
      return Ni(this.r) + Ni(this.s);
    }
  }
  se.Signature = zo;
  function Do(...Ho) {
    if (!Ho.every((Xo) => Xo instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Ho.length === 1)
      return Ho[0];
    const qo = Ho.reduce((Xo, ea) => Xo + ea.length, 0), Go = new Uint8Array(qo);
    for (let Xo = 0, ea = 0; Xo < Ho.length; Xo++) {
      const ia = Ho[Xo];
      Go.set(ia, ea), ea += ia.length;
    }
    return Go;
  }
  const wo = Array.from({ length: 256 }, (Ho, qo) => qo.toString(16).padStart(2, "0"));
  function Li(Ho) {
    if (!(Ho instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let qo = "";
    for (let Go = 0; Go < Ho.length; Go++)
      qo += wo[Ho[Go]];
    return qo;
  }
  const Ai = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Ni(Ho) {
    if (typeof Ho != "bigint")
      throw new Error("Expected bigint");
    if (!(Oe <= Ho && Ho < Ai))
      throw new Error("Expected number 0 <= n < 2^256");
    return Ho.toString(16).padStart(64, "0");
  }
  function Ui(Ho) {
    const qo = Eo(Ni(Ho));
    if (qo.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return qo;
  }
  function So(Ho) {
    const qo = Ho.toString(16);
    return qo.length & 1 ? `0${qo}` : qo;
  }
  function $o(Ho) {
    if (typeof Ho != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Ho);
    return BigInt(`0x${Ho}`);
  }
  function Eo(Ho) {
    if (typeof Ho != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Ho);
    if (Ho.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Ho.length);
    const qo = new Uint8Array(Ho.length / 2);
    for (let Go = 0; Go < qo.length; Go++) {
      const Xo = Go * 2, ea = Ho.slice(Xo, Xo + 2), ia = Number.parseInt(ea, 16);
      if (Number.isNaN(ia) || ia < 0)
        throw new Error("Invalid byte sequence");
      qo[Go] = ia;
    }
    return qo;
  }
  function zi(Ho) {
    return $o(Li(Ho));
  }
  function _o(Ho) {
    return Ho instanceof Uint8Array ? Uint8Array.from(Ho) : Eo(Ho);
  }
  function Fi(Ho) {
    if (typeof Ho == "number" && Number.isSafeInteger(Ho) && Ho > 0)
      return BigInt(Ho);
    if (typeof Ho == "bigint" && An(Ho))
      return Ho;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function xo(Ho, qo = xi.P) {
    const Go = Ho % qo;
    return Go >= Oe ? Go : qo + Go;
  }
  function Qo(Ho, qo) {
    const { P: Go } = xi;
    let Xo = Ho;
    for (; qo-- > Oe; )
      Xo *= Xo, Xo %= Go;
    return Xo;
  }
  function To(Ho) {
    const { P: qo } = xi, Go = BigInt(6), Xo = BigInt(11), ea = BigInt(22), ia = BigInt(23), oa = BigInt(44), aa = BigInt(88), ua = Ho * Ho * Ho % qo, na = ua * ua * Ho % qo, _a = Qo(na, Ei) * na % qo, pa = Qo(_a, Ei) * na % qo, la = Qo(pa, wi) * ua % qo, Ba = Qo(la, Xo) * la % qo, Da = Qo(Ba, ea) * Ba % qo, Ta = Qo(Da, oa) * Da % qo, Ja = Qo(Ta, aa) * Ta % qo, ja = Qo(Ja, oa) * Da % qo, za = Qo(ja, Ei) * na % qo, Qa = Qo(za, ia) * Ba % qo, tl = Qo(Qa, Go) * ua % qo, Xa = Qo(tl, wi);
    if (Xa * Xa % qo !== Ho)
      throw new Error("Cannot find square root");
    return Xa;
  }
  function Ko(Ho, qo = xi.P) {
    if (Ho === Oe || qo <= Oe)
      throw new Error(`invert: expected positive integers, got n=${Ho} mod=${qo}`);
    let Go = xo(Ho, qo), Xo = qo, ea = Oe, ia = Si;
    for (; Go !== Oe; ) {
      const aa = Xo / Go, ua = Xo % Go, na = ea - ia * aa;
      Xo = Go, Go = ua, ea = ia, ia = na;
    }
    if (Xo !== Si)
      throw new Error("invert: does not exist");
    return xo(ea, qo);
  }
  function Vo(Ho, qo = xi.P) {
    const Go = new Array(Ho.length), Xo = Ho.reduce((ia, oa, aa) => oa === Oe ? ia : (Go[aa] = ia, xo(ia * oa, qo)), Si), ea = Ko(Xo, qo);
    return Ho.reduceRight((ia, oa, aa) => oa === Oe ? ia : (Go[aa] = xo(ia * Go[aa], qo), xo(ia * oa, qo)), ea), Go;
  }
  function Wo(Ho) {
    const qo = Ho.length * 8 - Mi * 8, Go = zi(Ho);
    return qo > 0 ? Go >> BigInt(qo) : Go;
  }
  function jo(Ho, qo = !1) {
    const Go = Wo(Ho);
    if (qo)
      return Go;
    const { n: Xo } = xi;
    return Go >= Xo ? Go - Xo : Go;
  }
  let Ao, Lo;
  class Zo {
    constructor(qo, Go) {
      if (this.hashLen = qo, this.qByteLen = Go, typeof qo != "number" || qo < 2)
        throw new Error("hashLen must be a number");
      if (typeof Go != "number" || Go < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(qo).fill(1), this.k = new Uint8Array(qo).fill(0), this.counter = 0;
    }
    hmac(...qo) {
      return se.utils.hmacSha256(this.k, ...qo);
    }
    hmacSync(...qo) {
      return Lo(this.k, ...qo);
    }
    checkSync() {
      if (typeof Lo != "function")
        throw new Fo("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(qo = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), qo), this.v = await this.hmac(this.v), qo.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), qo), this.v = await this.hmac(this.v));
    }
    reseedSync(qo = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), qo), this.v = this.hmacSync(this.v), qo.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), qo), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let qo = 0;
      const Go = [];
      for (; qo < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Xo = this.v.slice();
        Go.push(Xo), qo += this.v.length;
      }
      return Do(...Go);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let qo = 0;
      const Go = [];
      for (; qo < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Xo = this.v.slice();
        Go.push(Xo), qo += this.v.length;
      }
      return Do(...Go);
    }
  }
  function An(Ho) {
    return Oe < Ho && Ho < xi.n;
  }
  function ra(Ho) {
    return Oe < Ho && Ho < xi.P;
  }
  function sa(Ho, qo, Go, Xo = !0) {
    const { n: ea } = xi, ia = jo(Ho, !0);
    if (!An(ia))
      return;
    const oa = Ko(ia, ea), aa = Po.BASE.multiply(ia), ua = xo(aa.x, ea);
    if (ua === Oe)
      return;
    const na = xo(oa * xo(qo + Go * ua, ea), ea);
    if (na === Oe)
      return;
    let _a = new zo(ua, na), pa = (aa.x === _a.r ? 0 : 2) | Number(aa.y & Si);
    return Xo && _a.hasHighS() && (_a = _a.normalizeS(), pa ^= 1), { sig: _a, recovery: pa };
  }
  function Ma(Ho) {
    let qo;
    if (typeof Ho == "bigint")
      qo = Ho;
    else if (typeof Ho == "number" && Number.isSafeInteger(Ho) && Ho > 0)
      qo = BigInt(Ho);
    else if (typeof Ho == "string") {
      if (Ho.length !== 2 * Mi)
        throw new Error("Expected 32 bytes of private key");
      qo = $o(Ho);
    } else if (Ho instanceof Uint8Array) {
      if (Ho.length !== Mi)
        throw new Error("Expected 32 bytes of private key");
      qo = zi(Ho);
    } else
      throw new TypeError("Expected valid private key");
    if (!An(qo))
      throw new Error("Expected private key: 0 < key < n");
    return qo;
  }
  function ba(Ho) {
    return Ho instanceof Po ? (Ho.assertValidity(), Ho) : Po.fromHex(Ho);
  }
  function ma(Ho) {
    if (Ho instanceof zo)
      return Ho.assertValidity(), Ho;
    try {
      return zo.fromDER(Ho);
    } catch {
      return zo.fromCompact(Ho);
    }
  }
  function Va(Ho, qo = !1) {
    return Po.fromPrivateKey(Ho).toRawBytes(qo);
  }
  se.getPublicKey = Va;
  function wa(Ho, qo, Go, Xo = !1) {
    return Po.fromSignature(Ho, qo, Go).toRawBytes(Xo);
  }
  se.recoverPublicKey = wa;
  function ha(Ho) {
    const qo = Ho instanceof Uint8Array, Go = typeof Ho == "string", Xo = (qo || Go) && Ho.length;
    return qo ? Xo === Ci || Xo === Oo : Go ? Xo === Ci * 2 || Xo === Oo * 2 : Ho instanceof Po;
  }
  function Fa(Ho, qo, Go = !1) {
    if (ha(Ho))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!ha(qo))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Xo = ba(qo);
    return Xo.assertValidity(), Xo.multiply(Ma(Ho)).toRawBytes(Go);
  }
  se.getSharedSecret = Fa;
  function Sa(Ho) {
    const qo = Ho.length > Oi ? Ho.slice(0, Oi) : Ho;
    return zi(qo);
  }
  function da(Ho) {
    const qo = Sa(Ho), Go = xo(qo, xi.n);
    return Pa(Go < Oe ? qo : Go);
  }
  function Pa(Ho) {
    return Ui(Ho);
  }
  function va(Ho, qo, Go) {
    if (Ho == null)
      throw new Error(`sign: expected valid message hash, not "${Ho}"`);
    const Xo = _o(Ho), ea = Ma(qo), ia = [Pa(ea), da(Xo)];
    if (Go != null) {
      Go === !0 && (Go = se.utils.randomBytes(Oi));
      const ua = _o(Go);
      if (ua.length !== Oi)
        throw new Error(`sign: Expected ${Oi} bytes of extra data`);
      ia.push(ua);
    }
    const oa = Do(...ia), aa = Sa(Xo);
    return { seed: oa, m: aa, d: ea };
  }
  function ca(Ho, qo) {
    const { sig: Go, recovery: Xo } = Ho, { der: ea, recovered: ia } = Object.assign({ canonical: !0, der: !0 }, qo), oa = ea ? Go.toDERRawBytes() : Go.toCompactRawBytes();
    return ia ? [oa, Xo] : oa;
  }
  async function Na(Ho, qo, Go = {}) {
    const { seed: Xo, m: ea, d: ia } = va(Ho, qo, Go.extraEntropy), oa = new Zo(Ii, Mi);
    await oa.reseed(Xo);
    let aa;
    for (; !(aa = sa(await oa.generate(), ea, ia, Go.canonical)); )
      await oa.reseed();
    return ca(aa, Go);
  }
  se.sign = Na;
  function Ea(Ho, qo, Go = {}) {
    const { seed: Xo, m: ea, d: ia } = va(Ho, qo, Go.extraEntropy), oa = new Zo(Ii, Mi);
    oa.reseedSync(Xo);
    let aa;
    for (; !(aa = sa(oa.generateSync(), ea, ia, Go.canonical)); )
      oa.reseedSync();
    return ca(aa, Go);
  }
  se.signSync = Ea;
  const fa = { strict: !0 };
  function Ca(Ho, qo, Go, Xo = fa) {
    let ea;
    try {
      ea = ma(Ho), qo = _o(qo);
    } catch {
      return !1;
    }
    const { r: ia, s: oa } = ea;
    if (Xo.strict && ea.hasHighS())
      return !1;
    const aa = jo(qo);
    let ua;
    try {
      ua = ba(Go);
    } catch {
      return !1;
    }
    const { n: na } = xi, _a = Ko(oa, na), pa = xo(aa * _a, na), la = xo(ia * _a, na), Ba = Po.BASE.multiplyAndAddUnsafe(ua, pa, la);
    return Ba ? xo(Ba.x, na) === ia : !1;
  }
  se.verify = Ca;
  function Oa(Ho) {
    return xo(zi(Ho), xi.n);
  }
  class ya {
    constructor(qo, Go) {
      this.r = qo, this.s = Go, this.assertValidity();
    }
    static fromHex(qo) {
      const Go = _o(qo);
      if (Go.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Go.length}`);
      const Xo = zi(Go.subarray(0, 32)), ea = zi(Go.subarray(32, 64));
      return new ya(Xo, ea);
    }
    assertValidity() {
      const { r: qo, s: Go } = this;
      if (!ra(qo) || !An(Go))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Ni(this.r) + Ni(this.s);
    }
    toRawBytes() {
      return Eo(this.toHex());
    }
  }
  function Ua(Ho) {
    return Po.fromPrivateKey(Ho).toRawX();
  }
  class xa {
    constructor(qo, Go, Xo = se.utils.randomBytes()) {
      if (qo == null)
        throw new TypeError(`sign: Expected valid message, not "${qo}"`);
      this.m = _o(qo);
      const { x: ea, scalar: ia } = this.getScalar(Ma(Go));
      if (this.px = ea, this.d = ia, this.rand = _o(Xo), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(qo) {
      const Go = Po.fromPrivateKey(qo), Xo = Go.hasEvenY() ? qo : xi.n - qo;
      return { point: Go, scalar: Xo, x: Go.toRawX() };
    }
    initNonce(qo, Go) {
      return Ui(qo ^ zi(Go));
    }
    finalizeNonce(qo) {
      const Go = xo(zi(qo), xi.n);
      if (Go === Oe)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Xo, x: ea, scalar: ia } = this.getScalar(Go);
      return { R: Xo, rx: ea, k: ia };
    }
    finalizeSig(qo, Go, Xo, ea) {
      return new ya(qo.x, xo(Go + Xo * ea, xi.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: qo, d: Go, px: Xo, rand: ea } = this, ia = se.utils.taggedHash, oa = this.initNonce(Go, await ia(qa.aux, ea)), { R: aa, rx: ua, k: na } = this.finalizeNonce(await ia(qa.nonce, oa, Xo, qo)), _a = Oa(await ia(qa.challenge, ua, Xo, qo)), pa = this.finalizeSig(aa, na, _a, Go);
      return await Ga(pa, qo, Xo) || this.error(), pa;
    }
    calcSync() {
      const { m: qo, d: Go, px: Xo, rand: ea } = this, ia = se.utils.taggedHashSync, oa = this.initNonce(Go, ia(qa.aux, ea)), { R: aa, rx: ua, k: na } = this.finalizeNonce(ia(qa.nonce, oa, Xo, qo)), _a = Oa(ia(qa.challenge, ua, Xo, qo)), pa = this.finalizeSig(aa, na, _a, Go);
      return Wa(pa, qo, Xo) || this.error(), pa;
    }
  }
  async function Ra(Ho, qo, Go) {
    return new xa(Ho, qo, Go).calc();
  }
  function Ha(Ho, qo, Go) {
    return new xa(Ho, qo, Go).calcSync();
  }
  function ka(Ho, qo, Go) {
    const Xo = Ho instanceof ya, ea = Xo ? Ho : ya.fromHex(Ho);
    return Xo && ea.assertValidity(), {
      ...ea,
      m: _o(qo),
      P: ba(Go)
    };
  }
  function Aa(Ho, qo, Go, Xo) {
    const ea = Po.BASE.multiplyAndAddUnsafe(qo, Ma(Go), xo(-Xo, xi.n));
    return !(!ea || !ea.hasEvenY() || ea.x !== Ho);
  }
  async function Ga(Ho, qo, Go) {
    try {
      const { r: Xo, s: ea, m: ia, P: oa } = ka(Ho, qo, Go), aa = Oa(await se.utils.taggedHash(qa.challenge, Ui(Xo), oa.toRawX(), ia));
      return Aa(Xo, oa, ea, aa);
    } catch {
      return !1;
    }
  }
  function Wa(Ho, qo, Go) {
    try {
      const { r: Xo, s: ea, m: ia, P: oa } = ka(Ho, qo, Go), aa = Oa(se.utils.taggedHashSync(qa.challenge, Ui(Xo), oa.toRawX(), ia));
      return Aa(Xo, oa, ea, aa);
    } catch (Xo) {
      if (Xo instanceof Fo)
        throw Xo;
      return !1;
    }
  }
  se.schnorr = {
    Signature: ya,
    getPublicKey: Ua,
    sign: Ra,
    verify: Ga,
    signSync: Ha,
    verifySync: Wa
  }, Po.BASE._setWindowSize(8);
  const $a = {
    node: e,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, qa = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Ia = {};
  se.utils = {
    bytesToHex: Li,
    hexToBytes: Eo,
    concatBytes: Do,
    mod: xo,
    invert: Ko,
    isValidPrivateKey(Ho) {
      try {
        return Ma(Ho), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: Ui,
    _normalizePrivateKey: Ma,
    hashToPrivateKey: (Ho) => {
      Ho = _o(Ho);
      const qo = Mi + 8;
      if (Ho.length < qo || Ho.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Go = xo(zi(Ho), xi.n - Si) + Si;
      return Ui(Go);
    },
    randomBytes: (Ho = 32) => {
      if ($a.web)
        return $a.web.getRandomValues(new Uint8Array(Ho));
      if ($a.node) {
        const { randomBytes: qo } = $a.node;
        return Uint8Array.from(qo(Ho));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => se.utils.hashToPrivateKey(se.utils.randomBytes(Mi + 8)),
    precompute(Ho = 8, qo = Po.BASE) {
      const Go = qo === Po.BASE ? qo : new Po(qo.x, qo.y);
      return Go._setWindowSize(Ho), Go.multiply(Ei), Go;
    },
    sha256: async (...Ho) => {
      if ($a.web) {
        const qo = await $a.web.subtle.digest("SHA-256", Do(...Ho));
        return new Uint8Array(qo);
      } else if ($a.node) {
        const { createHash: qo } = $a.node, Go = qo("sha256");
        return Ho.forEach((Xo) => Go.update(Xo)), Uint8Array.from(Go.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Ho, ...qo) => {
      if ($a.web) {
        const Go = await $a.web.subtle.importKey("raw", Ho, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Xo = Do(...qo), ea = await $a.web.subtle.sign("HMAC", Go, Xo);
        return new Uint8Array(ea);
      } else if ($a.node) {
        const { createHmac: Go } = $a.node, Xo = Go("sha256", Ho);
        return qo.forEach((ea) => Xo.update(ea)), Uint8Array.from(Xo.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Ho, ...qo) => {
      let Go = Ia[Ho];
      if (Go === void 0) {
        const Xo = await se.utils.sha256(Uint8Array.from(Ho, (ea) => ea.charCodeAt(0)));
        Go = Do(Xo, Xo), Ia[Ho] = Go;
      }
      return se.utils.sha256(Go, ...qo);
    },
    taggedHashSync: (Ho, ...qo) => {
      if (typeof Ao != "function")
        throw new Fo("sha256Sync is undefined, you need to set it");
      let Go = Ia[Ho];
      if (Go === void 0) {
        const Xo = Ao(Uint8Array.from(Ho, (ea) => ea.charCodeAt(0)));
        Go = Do(Xo, Xo), Ia[Ho] = Go;
      }
      return Ao(Go, ...qo);
    },
    _JacobianPoint: Uo
  }, Object.defineProperties(se.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return Ao;
      },
      set(Ho) {
        Ao || (Ao = Ho);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Lo;
      },
      set(Ho) {
        Lo || (Lo = Ho);
      }
    }
  });
})(lib);
var protocolProto = { exports: {} }, minimal, hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, minimal = requireIndexMinimal()), minimal;
}
(function(se) {
  (function(e, Oe) {
    typeof commonjsRequire$1 == "function" && se && se.exports && (se.exports = Oe(requireMinimal()));
  })(commonjsGlobal, function(e) {
    var Oe = e.Reader, Si = e.Writer, wi = e.util, Ei = e.roots.default || (e.roots.default = {});
    return Ei.koinos = function() {
      var $i = {};
      return $i.protocol = function() {
        var xi = {};
        return xi.event_data = function() {
          function Ri(Ti) {
            if (this.impacted = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.sequence = 0, Ri.prototype.source = wi.newBuffer([]), Ri.prototype.name = "", Ri.prototype.data = wi.newBuffer([]), Ri.prototype.impacted = wi.emptyArray, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.sequence != null && Object.hasOwnProperty.call(Oi, "sequence") && Mi.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(Oi.sequence), Oi.source != null && Object.hasOwnProperty.call(Oi, "source") && Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(Oi.source), Oi.name != null && Object.hasOwnProperty.call(Oi, "name") && Mi.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(Oi.name), Oi.data != null && Object.hasOwnProperty.call(Oi, "data") && Mi.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(Oi.data), Oi.impacted != null && Oi.impacted.length)
              for (var Ii = 0; Ii < Oi.impacted.length; ++Ii)
                Mi.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).bytes(Oi.impacted[Ii]);
            return Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.event_data(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.sequence = Oi.uint32();
                  break;
                }
                case 2: {
                  Ci.source = Oi.bytes();
                  break;
                }
                case 3: {
                  Ci.name = Oi.string();
                  break;
                }
                case 4: {
                  Ci.data = Oi.bytes();
                  break;
                }
                case 5: {
                  Ci.impacted && Ci.impacted.length || (Ci.impacted = []), Ci.impacted.push(Oi.bytes());
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.sequence != null && Oi.hasOwnProperty("sequence") && !wi.isInteger(Oi.sequence))
              return "sequence: integer expected";
            if (Oi.source != null && Oi.hasOwnProperty("source") && !(Oi.source && typeof Oi.source.length == "number" || wi.isString(Oi.source)))
              return "source: buffer expected";
            if (Oi.name != null && Oi.hasOwnProperty("name") && !wi.isString(Oi.name))
              return "name: string expected";
            if (Oi.data != null && Oi.hasOwnProperty("data") && !(Oi.data && typeof Oi.data.length == "number" || wi.isString(Oi.data)))
              return "data: buffer expected";
            if (Oi.impacted != null && Oi.hasOwnProperty("impacted")) {
              if (!Array.isArray(Oi.impacted))
                return "impacted: array expected";
              for (var Mi = 0; Mi < Oi.impacted.length; ++Mi)
                if (!(Oi.impacted[Mi] && typeof Oi.impacted[Mi].length == "number" || wi.isString(Oi.impacted[Mi])))
                  return "impacted: buffer[] expected";
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.event_data)
              return Oi;
            var Mi = new Ei.koinos.protocol.event_data();
            if (Oi.sequence != null && (Mi.sequence = Oi.sequence >>> 0), Oi.source != null && (typeof Oi.source == "string" ? wi.base64.decode(Oi.source, Mi.source = wi.newBuffer(wi.base64.length(Oi.source)), 0) : Oi.source.length >= 0 && (Mi.source = Oi.source)), Oi.name != null && (Mi.name = String(Oi.name)), Oi.data != null && (typeof Oi.data == "string" ? wi.base64.decode(Oi.data, Mi.data = wi.newBuffer(wi.base64.length(Oi.data)), 0) : Oi.data.length >= 0 && (Mi.data = Oi.data)), Oi.impacted) {
              if (!Array.isArray(Oi.impacted))
                throw TypeError(".koinos.protocol.event_data.impacted: array expected");
              Mi.impacted = [];
              for (var Ii = 0; Ii < Oi.impacted.length; ++Ii)
                typeof Oi.impacted[Ii] == "string" ? wi.base64.decode(Oi.impacted[Ii], Mi.impacted[Ii] = wi.newBuffer(wi.base64.length(Oi.impacted[Ii])), 0) : Oi.impacted[Ii].length >= 0 && (Mi.impacted[Ii] = Oi.impacted[Ii]);
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.impacted = []), Mi.defaults && (Ii.sequence = 0, Mi.bytes === String ? Ii.source = "" : (Ii.source = [], Mi.bytes !== Array && (Ii.source = wi.newBuffer(Ii.source))), Ii.name = "", Mi.bytes === String ? Ii.data = "" : (Ii.data = [], Mi.bytes !== Array && (Ii.data = wi.newBuffer(Ii.data)))), Oi.sequence != null && Oi.hasOwnProperty("sequence") && (Ii.sequence = Oi.sequence), Oi.source != null && Oi.hasOwnProperty("source") && (Ii.source = Mi.bytes === String ? wi.base64.encode(Oi.source, 0, Oi.source.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.source) : Oi.source), Oi.name != null && Oi.hasOwnProperty("name") && (Ii.name = Oi.name), Oi.data != null && Oi.hasOwnProperty("data") && (Ii.data = Mi.bytes === String ? wi.base64.encode(Oi.data, 0, Oi.data.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.data) : Oi.data), Oi.impacted && Oi.impacted.length) {
              Ii.impacted = [];
              for (var Ci = 0; Ci < Oi.impacted.length; ++Ci)
                Ii.impacted[Ci] = Mi.bytes === String ? wi.base64.encode(Oi.impacted[Ci], 0, Oi.impacted[Ci].length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.impacted[Ci]) : Oi.impacted[Ci];
            }
            return Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.event_data";
          }, Ri;
        }(), xi.contract_call_bundle = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.contract_id = wi.newBuffer([]), Ri.prototype.entry_point = 0, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.contract_id != null && Object.hasOwnProperty.call(Oi, "contract_id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.contract_id), Oi.entry_point != null && Object.hasOwnProperty.call(Oi, "entry_point") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(Oi.entry_point), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.contract_call_bundle(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.contract_id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.entry_point = Oi.uint32();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && !(Oi.contract_id && typeof Oi.contract_id.length == "number" || wi.isString(Oi.contract_id)) ? "contract_id: buffer expected" : Oi.entry_point != null && Oi.hasOwnProperty("entry_point") && !wi.isInteger(Oi.entry_point) ? "entry_point: integer expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.contract_call_bundle)
              return Oi;
            var Mi = new Ei.koinos.protocol.contract_call_bundle();
            return Oi.contract_id != null && (typeof Oi.contract_id == "string" ? wi.base64.decode(Oi.contract_id, Mi.contract_id = wi.newBuffer(wi.base64.length(Oi.contract_id)), 0) : Oi.contract_id.length >= 0 && (Mi.contract_id = Oi.contract_id)), Oi.entry_point != null && (Mi.entry_point = Oi.entry_point >>> 0), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Mi.bytes === String ? Ii.contract_id = "" : (Ii.contract_id = [], Mi.bytes !== Array && (Ii.contract_id = wi.newBuffer(Ii.contract_id))), Ii.entry_point = 0), Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && (Ii.contract_id = Mi.bytes === String ? wi.base64.encode(Oi.contract_id, 0, Oi.contract_id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.contract_id) : Oi.contract_id), Oi.entry_point != null && Oi.hasOwnProperty("entry_point") && (Ii.entry_point = Oi.entry_point), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.contract_call_bundle";
          }, Ri;
        }(), xi.system_call_target = function() {
          function Ri(Oi) {
            if (Oi)
              for (var Mi = Object.keys(Oi), Ii = 0; Ii < Mi.length; ++Ii)
                Oi[Mi[Ii]] != null && (this[Mi[Ii]] = Oi[Mi[Ii]]);
          }
          Ri.prototype.thunk_id = null, Ri.prototype.system_call_bundle = null;
          var Ti;
          return Object.defineProperty(Ri.prototype, "target", {
            get: wi.oneOfGetter(Ti = ["thunk_id", "system_call_bundle"]),
            set: wi.oneOfSetter(Ti)
          }), Ri.create = function(Mi) {
            return new Ri(Mi);
          }, Ri.encode = function(Mi, Ii) {
            return Ii || (Ii = Si.create()), Mi.thunk_id != null && Object.hasOwnProperty.call(Mi, "thunk_id") && Ii.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(Mi.thunk_id), Mi.system_call_bundle != null && Object.hasOwnProperty.call(Mi, "system_call_bundle") && Ei.koinos.protocol.contract_call_bundle.encode(Mi.system_call_bundle, Ii.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), Ii;
          }, Ri.encodeDelimited = function(Mi, Ii) {
            return this.encode(Mi, Ii).ldelim();
          }, Ri.decode = function(Mi, Ii) {
            Mi instanceof Oe || (Mi = Oe.create(Mi));
            for (var Ci = Ii === void 0 ? Mi.len : Mi.pos + Ii, Oo = new Ei.koinos.protocol.system_call_target(); Mi.pos < Ci; ) {
              var Ro = Mi.uint32();
              switch (Ro >>> 3) {
                case 1: {
                  Oo.thunk_id = Mi.uint32();
                  break;
                }
                case 2: {
                  Oo.system_call_bundle = Ei.koinos.protocol.contract_call_bundle.decode(Mi, Mi.uint32());
                  break;
                }
                default:
                  Mi.skipType(Ro & 7);
                  break;
              }
            }
            return Oo;
          }, Ri.decodeDelimited = function(Mi) {
            return Mi instanceof Oe || (Mi = new Oe(Mi)), this.decode(Mi, Mi.uint32());
          }, Ri.verify = function(Mi) {
            if (typeof Mi != "object" || Mi === null)
              return "object expected";
            var Ii = {};
            if (Mi.thunk_id != null && Mi.hasOwnProperty("thunk_id") && (Ii.target = 1, !wi.isInteger(Mi.thunk_id)))
              return "thunk_id: integer expected";
            if (Mi.system_call_bundle != null && Mi.hasOwnProperty("system_call_bundle")) {
              if (Ii.target === 1)
                return "target: multiple values";
              Ii.target = 1;
              {
                var Ci = Ei.koinos.protocol.contract_call_bundle.verify(Mi.system_call_bundle);
                if (Ci)
                  return "system_call_bundle." + Ci;
              }
            }
            return null;
          }, Ri.fromObject = function(Mi) {
            if (Mi instanceof Ei.koinos.protocol.system_call_target)
              return Mi;
            var Ii = new Ei.koinos.protocol.system_call_target();
            if (Mi.thunk_id != null && (Ii.thunk_id = Mi.thunk_id >>> 0), Mi.system_call_bundle != null) {
              if (typeof Mi.system_call_bundle != "object")
                throw TypeError(".koinos.protocol.system_call_target.system_call_bundle: object expected");
              Ii.system_call_bundle = Ei.koinos.protocol.contract_call_bundle.fromObject(Mi.system_call_bundle);
            }
            return Ii;
          }, Ri.toObject = function(Mi, Ii) {
            Ii || (Ii = {});
            var Ci = {};
            return Mi.thunk_id != null && Mi.hasOwnProperty("thunk_id") && (Ci.thunk_id = Mi.thunk_id, Ii.oneofs && (Ci.target = "thunk_id")), Mi.system_call_bundle != null && Mi.hasOwnProperty("system_call_bundle") && (Ci.system_call_bundle = Ei.koinos.protocol.contract_call_bundle.toObject(Mi.system_call_bundle, Ii), Ii.oneofs && (Ci.target = "system_call_bundle")), Ci;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Mi) {
            return Mi === void 0 && (Mi = "type.googleapis.com"), Mi + "/koinos.protocol.system_call_target";
          }, Ri;
        }(), xi.upload_contract_operation = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.contract_id = wi.newBuffer([]), Ri.prototype.bytecode = wi.newBuffer([]), Ri.prototype.abi = "", Ri.prototype.authorizes_call_contract = !1, Ri.prototype.authorizes_transaction_application = !1, Ri.prototype.authorizes_upload_contract = !1, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.contract_id != null && Object.hasOwnProperty.call(Oi, "contract_id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.contract_id), Oi.bytecode != null && Object.hasOwnProperty.call(Oi, "bytecode") && Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(Oi.bytecode), Oi.abi != null && Object.hasOwnProperty.call(Oi, "abi") && Mi.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(Oi.abi), Oi.authorizes_call_contract != null && Object.hasOwnProperty.call(Oi, "authorizes_call_contract") && Mi.uint32(
              /* id 4, wireType 0 =*/
              32
            ).bool(Oi.authorizes_call_contract), Oi.authorizes_transaction_application != null && Object.hasOwnProperty.call(Oi, "authorizes_transaction_application") && Mi.uint32(
              /* id 5, wireType 0 =*/
              40
            ).bool(Oi.authorizes_transaction_application), Oi.authorizes_upload_contract != null && Object.hasOwnProperty.call(Oi, "authorizes_upload_contract") && Mi.uint32(
              /* id 6, wireType 0 =*/
              48
            ).bool(Oi.authorizes_upload_contract), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.upload_contract_operation(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.contract_id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.bytecode = Oi.bytes();
                  break;
                }
                case 3: {
                  Ci.abi = Oi.string();
                  break;
                }
                case 4: {
                  Ci.authorizes_call_contract = Oi.bool();
                  break;
                }
                case 5: {
                  Ci.authorizes_transaction_application = Oi.bool();
                  break;
                }
                case 6: {
                  Ci.authorizes_upload_contract = Oi.bool();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && !(Oi.contract_id && typeof Oi.contract_id.length == "number" || wi.isString(Oi.contract_id)) ? "contract_id: buffer expected" : Oi.bytecode != null && Oi.hasOwnProperty("bytecode") && !(Oi.bytecode && typeof Oi.bytecode.length == "number" || wi.isString(Oi.bytecode)) ? "bytecode: buffer expected" : Oi.abi != null && Oi.hasOwnProperty("abi") && !wi.isString(Oi.abi) ? "abi: string expected" : Oi.authorizes_call_contract != null && Oi.hasOwnProperty("authorizes_call_contract") && typeof Oi.authorizes_call_contract != "boolean" ? "authorizes_call_contract: boolean expected" : Oi.authorizes_transaction_application != null && Oi.hasOwnProperty("authorizes_transaction_application") && typeof Oi.authorizes_transaction_application != "boolean" ? "authorizes_transaction_application: boolean expected" : Oi.authorizes_upload_contract != null && Oi.hasOwnProperty("authorizes_upload_contract") && typeof Oi.authorizes_upload_contract != "boolean" ? "authorizes_upload_contract: boolean expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.upload_contract_operation)
              return Oi;
            var Mi = new Ei.koinos.protocol.upload_contract_operation();
            return Oi.contract_id != null && (typeof Oi.contract_id == "string" ? wi.base64.decode(Oi.contract_id, Mi.contract_id = wi.newBuffer(wi.base64.length(Oi.contract_id)), 0) : Oi.contract_id.length >= 0 && (Mi.contract_id = Oi.contract_id)), Oi.bytecode != null && (typeof Oi.bytecode == "string" ? wi.base64.decode(Oi.bytecode, Mi.bytecode = wi.newBuffer(wi.base64.length(Oi.bytecode)), 0) : Oi.bytecode.length >= 0 && (Mi.bytecode = Oi.bytecode)), Oi.abi != null && (Mi.abi = String(Oi.abi)), Oi.authorizes_call_contract != null && (Mi.authorizes_call_contract = !!Oi.authorizes_call_contract), Oi.authorizes_transaction_application != null && (Mi.authorizes_transaction_application = !!Oi.authorizes_transaction_application), Oi.authorizes_upload_contract != null && (Mi.authorizes_upload_contract = !!Oi.authorizes_upload_contract), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Mi.bytes === String ? Ii.contract_id = "" : (Ii.contract_id = [], Mi.bytes !== Array && (Ii.contract_id = wi.newBuffer(Ii.contract_id))), Mi.bytes === String ? Ii.bytecode = "" : (Ii.bytecode = [], Mi.bytes !== Array && (Ii.bytecode = wi.newBuffer(Ii.bytecode))), Ii.abi = "", Ii.authorizes_call_contract = !1, Ii.authorizes_transaction_application = !1, Ii.authorizes_upload_contract = !1), Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && (Ii.contract_id = Mi.bytes === String ? wi.base64.encode(Oi.contract_id, 0, Oi.contract_id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.contract_id) : Oi.contract_id), Oi.bytecode != null && Oi.hasOwnProperty("bytecode") && (Ii.bytecode = Mi.bytes === String ? wi.base64.encode(Oi.bytecode, 0, Oi.bytecode.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.bytecode) : Oi.bytecode), Oi.abi != null && Oi.hasOwnProperty("abi") && (Ii.abi = Oi.abi), Oi.authorizes_call_contract != null && Oi.hasOwnProperty("authorizes_call_contract") && (Ii.authorizes_call_contract = Oi.authorizes_call_contract), Oi.authorizes_transaction_application != null && Oi.hasOwnProperty("authorizes_transaction_application") && (Ii.authorizes_transaction_application = Oi.authorizes_transaction_application), Oi.authorizes_upload_contract != null && Oi.hasOwnProperty("authorizes_upload_contract") && (Ii.authorizes_upload_contract = Oi.authorizes_upload_contract), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.upload_contract_operation";
          }, Ri;
        }(), xi.call_contract_operation = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.contract_id = wi.newBuffer([]), Ri.prototype.entry_point = 0, Ri.prototype.args = wi.newBuffer([]), Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.contract_id != null && Object.hasOwnProperty.call(Oi, "contract_id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.contract_id), Oi.entry_point != null && Object.hasOwnProperty.call(Oi, "entry_point") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(Oi.entry_point), Oi.args != null && Object.hasOwnProperty.call(Oi, "args") && Mi.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(Oi.args), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.call_contract_operation(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.contract_id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.entry_point = Oi.uint32();
                  break;
                }
                case 3: {
                  Ci.args = Oi.bytes();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && !(Oi.contract_id && typeof Oi.contract_id.length == "number" || wi.isString(Oi.contract_id)) ? "contract_id: buffer expected" : Oi.entry_point != null && Oi.hasOwnProperty("entry_point") && !wi.isInteger(Oi.entry_point) ? "entry_point: integer expected" : Oi.args != null && Oi.hasOwnProperty("args") && !(Oi.args && typeof Oi.args.length == "number" || wi.isString(Oi.args)) ? "args: buffer expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.call_contract_operation)
              return Oi;
            var Mi = new Ei.koinos.protocol.call_contract_operation();
            return Oi.contract_id != null && (typeof Oi.contract_id == "string" ? wi.base64.decode(Oi.contract_id, Mi.contract_id = wi.newBuffer(wi.base64.length(Oi.contract_id)), 0) : Oi.contract_id.length >= 0 && (Mi.contract_id = Oi.contract_id)), Oi.entry_point != null && (Mi.entry_point = Oi.entry_point >>> 0), Oi.args != null && (typeof Oi.args == "string" ? wi.base64.decode(Oi.args, Mi.args = wi.newBuffer(wi.base64.length(Oi.args)), 0) : Oi.args.length >= 0 && (Mi.args = Oi.args)), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Mi.bytes === String ? Ii.contract_id = "" : (Ii.contract_id = [], Mi.bytes !== Array && (Ii.contract_id = wi.newBuffer(Ii.contract_id))), Ii.entry_point = 0, Mi.bytes === String ? Ii.args = "" : (Ii.args = [], Mi.bytes !== Array && (Ii.args = wi.newBuffer(Ii.args)))), Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && (Ii.contract_id = Mi.bytes === String ? wi.base64.encode(Oi.contract_id, 0, Oi.contract_id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.contract_id) : Oi.contract_id), Oi.entry_point != null && Oi.hasOwnProperty("entry_point") && (Ii.entry_point = Oi.entry_point), Oi.args != null && Oi.hasOwnProperty("args") && (Ii.args = Mi.bytes === String ? wi.base64.encode(Oi.args, 0, Oi.args.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.args) : Oi.args), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.call_contract_operation";
          }, Ri;
        }(), xi.set_system_call_operation = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.call_id = 0, Ri.prototype.target = null, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.call_id != null && Object.hasOwnProperty.call(Oi, "call_id") && Mi.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(Oi.call_id), Oi.target != null && Object.hasOwnProperty.call(Oi, "target") && Ei.koinos.protocol.system_call_target.encode(Oi.target, Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.set_system_call_operation(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.call_id = Oi.uint32();
                  break;
                }
                case 2: {
                  Ci.target = Ei.koinos.protocol.system_call_target.decode(Oi, Oi.uint32());
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.call_id != null && Oi.hasOwnProperty("call_id") && !wi.isInteger(Oi.call_id))
              return "call_id: integer expected";
            if (Oi.target != null && Oi.hasOwnProperty("target")) {
              var Mi = Ei.koinos.protocol.system_call_target.verify(Oi.target);
              if (Mi)
                return "target." + Mi;
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.set_system_call_operation)
              return Oi;
            var Mi = new Ei.koinos.protocol.set_system_call_operation();
            if (Oi.call_id != null && (Mi.call_id = Oi.call_id >>> 0), Oi.target != null) {
              if (typeof Oi.target != "object")
                throw TypeError(".koinos.protocol.set_system_call_operation.target: object expected");
              Mi.target = Ei.koinos.protocol.system_call_target.fromObject(Oi.target);
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Ii.call_id = 0, Ii.target = null), Oi.call_id != null && Oi.hasOwnProperty("call_id") && (Ii.call_id = Oi.call_id), Oi.target != null && Oi.hasOwnProperty("target") && (Ii.target = Ei.koinos.protocol.system_call_target.toObject(Oi.target, Mi)), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.set_system_call_operation";
          }, Ri;
        }(), xi.set_system_contract_operation = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.contract_id = wi.newBuffer([]), Ri.prototype.system_contract = !1, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.contract_id != null && Object.hasOwnProperty.call(Oi, "contract_id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.contract_id), Oi.system_contract != null && Object.hasOwnProperty.call(Oi, "system_contract") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).bool(Oi.system_contract), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.set_system_contract_operation(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.contract_id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.system_contract = Oi.bool();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && !(Oi.contract_id && typeof Oi.contract_id.length == "number" || wi.isString(Oi.contract_id)) ? "contract_id: buffer expected" : Oi.system_contract != null && Oi.hasOwnProperty("system_contract") && typeof Oi.system_contract != "boolean" ? "system_contract: boolean expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.set_system_contract_operation)
              return Oi;
            var Mi = new Ei.koinos.protocol.set_system_contract_operation();
            return Oi.contract_id != null && (typeof Oi.contract_id == "string" ? wi.base64.decode(Oi.contract_id, Mi.contract_id = wi.newBuffer(wi.base64.length(Oi.contract_id)), 0) : Oi.contract_id.length >= 0 && (Mi.contract_id = Oi.contract_id)), Oi.system_contract != null && (Mi.system_contract = !!Oi.system_contract), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Mi.bytes === String ? Ii.contract_id = "" : (Ii.contract_id = [], Mi.bytes !== Array && (Ii.contract_id = wi.newBuffer(Ii.contract_id))), Ii.system_contract = !1), Oi.contract_id != null && Oi.hasOwnProperty("contract_id") && (Ii.contract_id = Mi.bytes === String ? wi.base64.encode(Oi.contract_id, 0, Oi.contract_id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.contract_id) : Oi.contract_id), Oi.system_contract != null && Oi.hasOwnProperty("system_contract") && (Ii.system_contract = Oi.system_contract), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.set_system_contract_operation";
          }, Ri;
        }(), xi.operation = function() {
          function Ri(Oi) {
            if (Oi)
              for (var Mi = Object.keys(Oi), Ii = 0; Ii < Mi.length; ++Ii)
                Oi[Mi[Ii]] != null && (this[Mi[Ii]] = Oi[Mi[Ii]]);
          }
          Ri.prototype.upload_contract = null, Ri.prototype.call_contract = null, Ri.prototype.set_system_call = null, Ri.prototype.set_system_contract = null;
          var Ti;
          return Object.defineProperty(Ri.prototype, "op", {
            get: wi.oneOfGetter(Ti = [
              "upload_contract",
              "call_contract",
              "set_system_call",
              "set_system_contract"
            ]),
            set: wi.oneOfSetter(Ti)
          }), Ri.create = function(Mi) {
            return new Ri(Mi);
          }, Ri.encode = function(Mi, Ii) {
            return Ii || (Ii = Si.create()), Mi.upload_contract != null && Object.hasOwnProperty.call(Mi, "upload_contract") && Ei.koinos.protocol.upload_contract_operation.encode(Mi.upload_contract, Ii.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim(), Mi.call_contract != null && Object.hasOwnProperty.call(Mi, "call_contract") && Ei.koinos.protocol.call_contract_operation.encode(Mi.call_contract, Ii.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), Mi.set_system_call != null && Object.hasOwnProperty.call(Mi, "set_system_call") && Ei.koinos.protocol.set_system_call_operation.encode(Mi.set_system_call, Ii.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim(), Mi.set_system_contract != null && Object.hasOwnProperty.call(Mi, "set_system_contract") && Ei.koinos.protocol.set_system_contract_operation.encode(Mi.set_system_contract, Ii.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim(), Ii;
          }, Ri.encodeDelimited = function(Mi, Ii) {
            return this.encode(Mi, Ii).ldelim();
          }, Ri.decode = function(Mi, Ii) {
            Mi instanceof Oe || (Mi = Oe.create(Mi));
            for (var Ci = Ii === void 0 ? Mi.len : Mi.pos + Ii, Oo = new Ei.koinos.protocol.operation(); Mi.pos < Ci; ) {
              var Ro = Mi.uint32();
              switch (Ro >>> 3) {
                case 1: {
                  Oo.upload_contract = Ei.koinos.protocol.upload_contract_operation.decode(Mi, Mi.uint32());
                  break;
                }
                case 2: {
                  Oo.call_contract = Ei.koinos.protocol.call_contract_operation.decode(Mi, Mi.uint32());
                  break;
                }
                case 3: {
                  Oo.set_system_call = Ei.koinos.protocol.set_system_call_operation.decode(Mi, Mi.uint32());
                  break;
                }
                case 4: {
                  Oo.set_system_contract = Ei.koinos.protocol.set_system_contract_operation.decode(Mi, Mi.uint32());
                  break;
                }
                default:
                  Mi.skipType(Ro & 7);
                  break;
              }
            }
            return Oo;
          }, Ri.decodeDelimited = function(Mi) {
            return Mi instanceof Oe || (Mi = new Oe(Mi)), this.decode(Mi, Mi.uint32());
          }, Ri.verify = function(Mi) {
            if (typeof Mi != "object" || Mi === null)
              return "object expected";
            var Ii = {};
            if (Mi.upload_contract != null && Mi.hasOwnProperty("upload_contract")) {
              Ii.op = 1;
              {
                var Ci = Ei.koinos.protocol.upload_contract_operation.verify(Mi.upload_contract);
                if (Ci)
                  return "upload_contract." + Ci;
              }
            }
            if (Mi.call_contract != null && Mi.hasOwnProperty("call_contract")) {
              if (Ii.op === 1)
                return "op: multiple values";
              Ii.op = 1;
              {
                var Ci = Ei.koinos.protocol.call_contract_operation.verify(Mi.call_contract);
                if (Ci)
                  return "call_contract." + Ci;
              }
            }
            if (Mi.set_system_call != null && Mi.hasOwnProperty("set_system_call")) {
              if (Ii.op === 1)
                return "op: multiple values";
              Ii.op = 1;
              {
                var Ci = Ei.koinos.protocol.set_system_call_operation.verify(Mi.set_system_call);
                if (Ci)
                  return "set_system_call." + Ci;
              }
            }
            if (Mi.set_system_contract != null && Mi.hasOwnProperty("set_system_contract")) {
              if (Ii.op === 1)
                return "op: multiple values";
              Ii.op = 1;
              {
                var Ci = Ei.koinos.protocol.set_system_contract_operation.verify(Mi.set_system_contract);
                if (Ci)
                  return "set_system_contract." + Ci;
              }
            }
            return null;
          }, Ri.fromObject = function(Mi) {
            if (Mi instanceof Ei.koinos.protocol.operation)
              return Mi;
            var Ii = new Ei.koinos.protocol.operation();
            if (Mi.upload_contract != null) {
              if (typeof Mi.upload_contract != "object")
                throw TypeError(".koinos.protocol.operation.upload_contract: object expected");
              Ii.upload_contract = Ei.koinos.protocol.upload_contract_operation.fromObject(Mi.upload_contract);
            }
            if (Mi.call_contract != null) {
              if (typeof Mi.call_contract != "object")
                throw TypeError(".koinos.protocol.operation.call_contract: object expected");
              Ii.call_contract = Ei.koinos.protocol.call_contract_operation.fromObject(Mi.call_contract);
            }
            if (Mi.set_system_call != null) {
              if (typeof Mi.set_system_call != "object")
                throw TypeError(".koinos.protocol.operation.set_system_call: object expected");
              Ii.set_system_call = Ei.koinos.protocol.set_system_call_operation.fromObject(Mi.set_system_call);
            }
            if (Mi.set_system_contract != null) {
              if (typeof Mi.set_system_contract != "object")
                throw TypeError(".koinos.protocol.operation.set_system_contract: object expected");
              Ii.set_system_contract = Ei.koinos.protocol.set_system_contract_operation.fromObject(Mi.set_system_contract);
            }
            return Ii;
          }, Ri.toObject = function(Mi, Ii) {
            Ii || (Ii = {});
            var Ci = {};
            return Mi.upload_contract != null && Mi.hasOwnProperty("upload_contract") && (Ci.upload_contract = Ei.koinos.protocol.upload_contract_operation.toObject(Mi.upload_contract, Ii), Ii.oneofs && (Ci.op = "upload_contract")), Mi.call_contract != null && Mi.hasOwnProperty("call_contract") && (Ci.call_contract = Ei.koinos.protocol.call_contract_operation.toObject(Mi.call_contract, Ii), Ii.oneofs && (Ci.op = "call_contract")), Mi.set_system_call != null && Mi.hasOwnProperty("set_system_call") && (Ci.set_system_call = Ei.koinos.protocol.set_system_call_operation.toObject(Mi.set_system_call, Ii), Ii.oneofs && (Ci.op = "set_system_call")), Mi.set_system_contract != null && Mi.hasOwnProperty("set_system_contract") && (Ci.set_system_contract = Ei.koinos.protocol.set_system_contract_operation.toObject(Mi.set_system_contract, Ii), Ii.oneofs && (Ci.op = "set_system_contract")), Ci;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Mi) {
            return Mi === void 0 && (Mi = "type.googleapis.com"), Mi + "/koinos.protocol.operation";
          }, Ri;
        }(), xi.transaction_header = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.chain_id = wi.newBuffer([]), Ri.prototype.rc_limit = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.nonce = wi.newBuffer([]), Ri.prototype.operation_merkle_root = wi.newBuffer([]), Ri.prototype.payer = wi.newBuffer([]), Ri.prototype.payee = wi.newBuffer([]), Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.chain_id != null && Object.hasOwnProperty.call(Oi, "chain_id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.chain_id), Oi.rc_limit != null && Object.hasOwnProperty.call(Oi, "rc_limit") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(Oi.rc_limit), Oi.nonce != null && Object.hasOwnProperty.call(Oi, "nonce") && Mi.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(Oi.nonce), Oi.operation_merkle_root != null && Object.hasOwnProperty.call(Oi, "operation_merkle_root") && Mi.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(Oi.operation_merkle_root), Oi.payer != null && Object.hasOwnProperty.call(Oi, "payer") && Mi.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(Oi.payer), Oi.payee != null && Object.hasOwnProperty.call(Oi, "payee") && Mi.uint32(
              /* id 6, wireType 2 =*/
              50
            ).bytes(Oi.payee), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.transaction_header(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.chain_id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.rc_limit = Oi.uint64();
                  break;
                }
                case 3: {
                  Ci.nonce = Oi.bytes();
                  break;
                }
                case 4: {
                  Ci.operation_merkle_root = Oi.bytes();
                  break;
                }
                case 5: {
                  Ci.payer = Oi.bytes();
                  break;
                }
                case 6: {
                  Ci.payee = Oi.bytes();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.chain_id != null && Oi.hasOwnProperty("chain_id") && !(Oi.chain_id && typeof Oi.chain_id.length == "number" || wi.isString(Oi.chain_id)) ? "chain_id: buffer expected" : Oi.rc_limit != null && Oi.hasOwnProperty("rc_limit") && !wi.isInteger(Oi.rc_limit) && !(Oi.rc_limit && wi.isInteger(Oi.rc_limit.low) && wi.isInteger(Oi.rc_limit.high)) ? "rc_limit: integer|Long expected" : Oi.nonce != null && Oi.hasOwnProperty("nonce") && !(Oi.nonce && typeof Oi.nonce.length == "number" || wi.isString(Oi.nonce)) ? "nonce: buffer expected" : Oi.operation_merkle_root != null && Oi.hasOwnProperty("operation_merkle_root") && !(Oi.operation_merkle_root && typeof Oi.operation_merkle_root.length == "number" || wi.isString(Oi.operation_merkle_root)) ? "operation_merkle_root: buffer expected" : Oi.payer != null && Oi.hasOwnProperty("payer") && !(Oi.payer && typeof Oi.payer.length == "number" || wi.isString(Oi.payer)) ? "payer: buffer expected" : Oi.payee != null && Oi.hasOwnProperty("payee") && !(Oi.payee && typeof Oi.payee.length == "number" || wi.isString(Oi.payee)) ? "payee: buffer expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.transaction_header)
              return Oi;
            var Mi = new Ei.koinos.protocol.transaction_header();
            return Oi.chain_id != null && (typeof Oi.chain_id == "string" ? wi.base64.decode(Oi.chain_id, Mi.chain_id = wi.newBuffer(wi.base64.length(Oi.chain_id)), 0) : Oi.chain_id.length >= 0 && (Mi.chain_id = Oi.chain_id)), Oi.rc_limit != null && (wi.Long ? (Mi.rc_limit = wi.Long.fromValue(Oi.rc_limit)).unsigned = !0 : typeof Oi.rc_limit == "string" ? Mi.rc_limit = parseInt(Oi.rc_limit, 10) : typeof Oi.rc_limit == "number" ? Mi.rc_limit = Oi.rc_limit : typeof Oi.rc_limit == "object" && (Mi.rc_limit = new wi.LongBits(Oi.rc_limit.low >>> 0, Oi.rc_limit.high >>> 0).toNumber(!0))), Oi.nonce != null && (typeof Oi.nonce == "string" ? wi.base64.decode(Oi.nonce, Mi.nonce = wi.newBuffer(wi.base64.length(Oi.nonce)), 0) : Oi.nonce.length >= 0 && (Mi.nonce = Oi.nonce)), Oi.operation_merkle_root != null && (typeof Oi.operation_merkle_root == "string" ? wi.base64.decode(Oi.operation_merkle_root, Mi.operation_merkle_root = wi.newBuffer(wi.base64.length(Oi.operation_merkle_root)), 0) : Oi.operation_merkle_root.length >= 0 && (Mi.operation_merkle_root = Oi.operation_merkle_root)), Oi.payer != null && (typeof Oi.payer == "string" ? wi.base64.decode(Oi.payer, Mi.payer = wi.newBuffer(wi.base64.length(Oi.payer)), 0) : Oi.payer.length >= 0 && (Mi.payer = Oi.payer)), Oi.payee != null && (typeof Oi.payee == "string" ? wi.base64.decode(Oi.payee, Mi.payee = wi.newBuffer(wi.base64.length(Oi.payee)), 0) : Oi.payee.length >= 0 && (Mi.payee = Oi.payee)), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if (Mi.defaults) {
              if (Mi.bytes === String ? Ii.chain_id = "" : (Ii.chain_id = [], Mi.bytes !== Array && (Ii.chain_id = wi.newBuffer(Ii.chain_id))), wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.rc_limit = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.rc_limit = Mi.longs === String ? "0" : 0;
              Mi.bytes === String ? Ii.nonce = "" : (Ii.nonce = [], Mi.bytes !== Array && (Ii.nonce = wi.newBuffer(Ii.nonce))), Mi.bytes === String ? Ii.operation_merkle_root = "" : (Ii.operation_merkle_root = [], Mi.bytes !== Array && (Ii.operation_merkle_root = wi.newBuffer(Ii.operation_merkle_root))), Mi.bytes === String ? Ii.payer = "" : (Ii.payer = [], Mi.bytes !== Array && (Ii.payer = wi.newBuffer(Ii.payer))), Mi.bytes === String ? Ii.payee = "" : (Ii.payee = [], Mi.bytes !== Array && (Ii.payee = wi.newBuffer(Ii.payee)));
            }
            return Oi.chain_id != null && Oi.hasOwnProperty("chain_id") && (Ii.chain_id = Mi.bytes === String ? wi.base64.encode(Oi.chain_id, 0, Oi.chain_id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.chain_id) : Oi.chain_id), Oi.rc_limit != null && Oi.hasOwnProperty("rc_limit") && (typeof Oi.rc_limit == "number" ? Ii.rc_limit = Mi.longs === String ? String(Oi.rc_limit) : Oi.rc_limit : Ii.rc_limit = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.rc_limit) : Mi.longs === Number ? new wi.LongBits(Oi.rc_limit.low >>> 0, Oi.rc_limit.high >>> 0).toNumber(!0) : Oi.rc_limit), Oi.nonce != null && Oi.hasOwnProperty("nonce") && (Ii.nonce = Mi.bytes === String ? wi.base64.encode(Oi.nonce, 0, Oi.nonce.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.nonce) : Oi.nonce), Oi.operation_merkle_root != null && Oi.hasOwnProperty("operation_merkle_root") && (Ii.operation_merkle_root = Mi.bytes === String ? wi.base64.encode(Oi.operation_merkle_root, 0, Oi.operation_merkle_root.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.operation_merkle_root) : Oi.operation_merkle_root), Oi.payer != null && Oi.hasOwnProperty("payer") && (Ii.payer = Mi.bytes === String ? wi.base64.encode(Oi.payer, 0, Oi.payer.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.payer) : Oi.payer), Oi.payee != null && Oi.hasOwnProperty("payee") && (Ii.payee = Mi.bytes === String ? wi.base64.encode(Oi.payee, 0, Oi.payee.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.payee) : Oi.payee), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.transaction_header";
          }, Ri;
        }(), xi.transaction = function() {
          function Ri(Ti) {
            if (this.operations = [], this.signatures = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.id = wi.newBuffer([]), Ri.prototype.header = null, Ri.prototype.operations = wi.emptyArray, Ri.prototype.signatures = wi.emptyArray, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.id != null && Object.hasOwnProperty.call(Oi, "id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.id), Oi.header != null && Object.hasOwnProperty.call(Oi, "header") && Ei.koinos.protocol.transaction_header.encode(Oi.header, Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), Oi.operations != null && Oi.operations.length)
              for (var Ii = 0; Ii < Oi.operations.length; ++Ii)
                Ei.koinos.protocol.operation.encode(Oi.operations[Ii], Mi.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (Oi.signatures != null && Oi.signatures.length)
              for (var Ii = 0; Ii < Oi.signatures.length; ++Ii)
                Mi.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).bytes(Oi.signatures[Ii]);
            return Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.transaction(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.header = Ei.koinos.protocol.transaction_header.decode(Oi, Oi.uint32());
                  break;
                }
                case 3: {
                  Ci.operations && Ci.operations.length || (Ci.operations = []), Ci.operations.push(Ei.koinos.protocol.operation.decode(Oi, Oi.uint32()));
                  break;
                }
                case 4: {
                  Ci.signatures && Ci.signatures.length || (Ci.signatures = []), Ci.signatures.push(Oi.bytes());
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.id != null && Oi.hasOwnProperty("id") && !(Oi.id && typeof Oi.id.length == "number" || wi.isString(Oi.id)))
              return "id: buffer expected";
            if (Oi.header != null && Oi.hasOwnProperty("header")) {
              var Mi = Ei.koinos.protocol.transaction_header.verify(Oi.header);
              if (Mi)
                return "header." + Mi;
            }
            if (Oi.operations != null && Oi.hasOwnProperty("operations")) {
              if (!Array.isArray(Oi.operations))
                return "operations: array expected";
              for (var Ii = 0; Ii < Oi.operations.length; ++Ii) {
                var Mi = Ei.koinos.protocol.operation.verify(Oi.operations[Ii]);
                if (Mi)
                  return "operations." + Mi;
              }
            }
            if (Oi.signatures != null && Oi.hasOwnProperty("signatures")) {
              if (!Array.isArray(Oi.signatures))
                return "signatures: array expected";
              for (var Ii = 0; Ii < Oi.signatures.length; ++Ii)
                if (!(Oi.signatures[Ii] && typeof Oi.signatures[Ii].length == "number" || wi.isString(Oi.signatures[Ii])))
                  return "signatures: buffer[] expected";
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.transaction)
              return Oi;
            var Mi = new Ei.koinos.protocol.transaction();
            if (Oi.id != null && (typeof Oi.id == "string" ? wi.base64.decode(Oi.id, Mi.id = wi.newBuffer(wi.base64.length(Oi.id)), 0) : Oi.id.length >= 0 && (Mi.id = Oi.id)), Oi.header != null) {
              if (typeof Oi.header != "object")
                throw TypeError(".koinos.protocol.transaction.header: object expected");
              Mi.header = Ei.koinos.protocol.transaction_header.fromObject(Oi.header);
            }
            if (Oi.operations) {
              if (!Array.isArray(Oi.operations))
                throw TypeError(".koinos.protocol.transaction.operations: array expected");
              Mi.operations = [];
              for (var Ii = 0; Ii < Oi.operations.length; ++Ii) {
                if (typeof Oi.operations[Ii] != "object")
                  throw TypeError(".koinos.protocol.transaction.operations: object expected");
                Mi.operations[Ii] = Ei.koinos.protocol.operation.fromObject(Oi.operations[Ii]);
              }
            }
            if (Oi.signatures) {
              if (!Array.isArray(Oi.signatures))
                throw TypeError(".koinos.protocol.transaction.signatures: array expected");
              Mi.signatures = [];
              for (var Ii = 0; Ii < Oi.signatures.length; ++Ii)
                typeof Oi.signatures[Ii] == "string" ? wi.base64.decode(Oi.signatures[Ii], Mi.signatures[Ii] = wi.newBuffer(wi.base64.length(Oi.signatures[Ii])), 0) : Oi.signatures[Ii].length >= 0 && (Mi.signatures[Ii] = Oi.signatures[Ii]);
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.operations = [], Ii.signatures = []), Mi.defaults && (Mi.bytes === String ? Ii.id = "" : (Ii.id = [], Mi.bytes !== Array && (Ii.id = wi.newBuffer(Ii.id))), Ii.header = null), Oi.id != null && Oi.hasOwnProperty("id") && (Ii.id = Mi.bytes === String ? wi.base64.encode(Oi.id, 0, Oi.id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.id) : Oi.id), Oi.header != null && Oi.hasOwnProperty("header") && (Ii.header = Ei.koinos.protocol.transaction_header.toObject(Oi.header, Mi)), Oi.operations && Oi.operations.length) {
              Ii.operations = [];
              for (var Ci = 0; Ci < Oi.operations.length; ++Ci)
                Ii.operations[Ci] = Ei.koinos.protocol.operation.toObject(Oi.operations[Ci], Mi);
            }
            if (Oi.signatures && Oi.signatures.length) {
              Ii.signatures = [];
              for (var Ci = 0; Ci < Oi.signatures.length; ++Ci)
                Ii.signatures[Ci] = Mi.bytes === String ? wi.base64.encode(Oi.signatures[Ci], 0, Oi.signatures[Ci].length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.signatures[Ci]) : Oi.signatures[Ci];
            }
            return Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.transaction";
          }, Ri;
        }(), xi.transaction_receipt = function() {
          function Ri(Ti) {
            if (this.events = [], this.logs = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.id = wi.newBuffer([]), Ri.prototype.payer = wi.newBuffer([]), Ri.prototype.max_payer_rc = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.rc_limit = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.rc_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.disk_storage_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.network_bandwidth_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.compute_bandwidth_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.reverted = !1, Ri.prototype.events = wi.emptyArray, Ri.prototype.logs = wi.emptyArray, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.id != null && Object.hasOwnProperty.call(Oi, "id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.id), Oi.payer != null && Object.hasOwnProperty.call(Oi, "payer") && Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(Oi.payer), Oi.max_payer_rc != null && Object.hasOwnProperty.call(Oi, "max_payer_rc") && Mi.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(Oi.max_payer_rc), Oi.rc_limit != null && Object.hasOwnProperty.call(Oi, "rc_limit") && Mi.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(Oi.rc_limit), Oi.rc_used != null && Object.hasOwnProperty.call(Oi, "rc_used") && Mi.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(Oi.rc_used), Oi.disk_storage_used != null && Object.hasOwnProperty.call(Oi, "disk_storage_used") && Mi.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint64(Oi.disk_storage_used), Oi.network_bandwidth_used != null && Object.hasOwnProperty.call(Oi, "network_bandwidth_used") && Mi.uint32(
              /* id 7, wireType 0 =*/
              56
            ).uint64(Oi.network_bandwidth_used), Oi.compute_bandwidth_used != null && Object.hasOwnProperty.call(Oi, "compute_bandwidth_used") && Mi.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(Oi.compute_bandwidth_used), Oi.reverted != null && Object.hasOwnProperty.call(Oi, "reverted") && Mi.uint32(
              /* id 9, wireType 0 =*/
              72
            ).bool(Oi.reverted), Oi.events != null && Oi.events.length)
              for (var Ii = 0; Ii < Oi.events.length; ++Ii)
                Ei.koinos.protocol.event_data.encode(Oi.events[Ii], Mi.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).fork()).ldelim();
            if (Oi.logs != null && Oi.logs.length)
              for (var Ii = 0; Ii < Oi.logs.length; ++Ii)
                Mi.uint32(
                  /* id 11, wireType 2 =*/
                  90
                ).string(Oi.logs[Ii]);
            return Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.transaction_receipt(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.payer = Oi.bytes();
                  break;
                }
                case 3: {
                  Ci.max_payer_rc = Oi.uint64();
                  break;
                }
                case 4: {
                  Ci.rc_limit = Oi.uint64();
                  break;
                }
                case 5: {
                  Ci.rc_used = Oi.uint64();
                  break;
                }
                case 6: {
                  Ci.disk_storage_used = Oi.uint64();
                  break;
                }
                case 7: {
                  Ci.network_bandwidth_used = Oi.uint64();
                  break;
                }
                case 8: {
                  Ci.compute_bandwidth_used = Oi.uint64();
                  break;
                }
                case 9: {
                  Ci.reverted = Oi.bool();
                  break;
                }
                case 10: {
                  Ci.events && Ci.events.length || (Ci.events = []), Ci.events.push(Ei.koinos.protocol.event_data.decode(Oi, Oi.uint32()));
                  break;
                }
                case 11: {
                  Ci.logs && Ci.logs.length || (Ci.logs = []), Ci.logs.push(Oi.string());
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.id != null && Oi.hasOwnProperty("id") && !(Oi.id && typeof Oi.id.length == "number" || wi.isString(Oi.id)))
              return "id: buffer expected";
            if (Oi.payer != null && Oi.hasOwnProperty("payer") && !(Oi.payer && typeof Oi.payer.length == "number" || wi.isString(Oi.payer)))
              return "payer: buffer expected";
            if (Oi.max_payer_rc != null && Oi.hasOwnProperty("max_payer_rc") && !wi.isInteger(Oi.max_payer_rc) && !(Oi.max_payer_rc && wi.isInteger(Oi.max_payer_rc.low) && wi.isInteger(Oi.max_payer_rc.high)))
              return "max_payer_rc: integer|Long expected";
            if (Oi.rc_limit != null && Oi.hasOwnProperty("rc_limit") && !wi.isInteger(Oi.rc_limit) && !(Oi.rc_limit && wi.isInteger(Oi.rc_limit.low) && wi.isInteger(Oi.rc_limit.high)))
              return "rc_limit: integer|Long expected";
            if (Oi.rc_used != null && Oi.hasOwnProperty("rc_used") && !wi.isInteger(Oi.rc_used) && !(Oi.rc_used && wi.isInteger(Oi.rc_used.low) && wi.isInteger(Oi.rc_used.high)))
              return "rc_used: integer|Long expected";
            if (Oi.disk_storage_used != null && Oi.hasOwnProperty("disk_storage_used") && !wi.isInteger(Oi.disk_storage_used) && !(Oi.disk_storage_used && wi.isInteger(Oi.disk_storage_used.low) && wi.isInteger(Oi.disk_storage_used.high)))
              return "disk_storage_used: integer|Long expected";
            if (Oi.network_bandwidth_used != null && Oi.hasOwnProperty("network_bandwidth_used") && !wi.isInteger(Oi.network_bandwidth_used) && !(Oi.network_bandwidth_used && wi.isInteger(Oi.network_bandwidth_used.low) && wi.isInteger(Oi.network_bandwidth_used.high)))
              return "network_bandwidth_used: integer|Long expected";
            if (Oi.compute_bandwidth_used != null && Oi.hasOwnProperty("compute_bandwidth_used") && !wi.isInteger(Oi.compute_bandwidth_used) && !(Oi.compute_bandwidth_used && wi.isInteger(Oi.compute_bandwidth_used.low) && wi.isInteger(Oi.compute_bandwidth_used.high)))
              return "compute_bandwidth_used: integer|Long expected";
            if (Oi.reverted != null && Oi.hasOwnProperty("reverted") && typeof Oi.reverted != "boolean")
              return "reverted: boolean expected";
            if (Oi.events != null && Oi.hasOwnProperty("events")) {
              if (!Array.isArray(Oi.events))
                return "events: array expected";
              for (var Mi = 0; Mi < Oi.events.length; ++Mi) {
                var Ii = Ei.koinos.protocol.event_data.verify(Oi.events[Mi]);
                if (Ii)
                  return "events." + Ii;
              }
            }
            if (Oi.logs != null && Oi.hasOwnProperty("logs")) {
              if (!Array.isArray(Oi.logs))
                return "logs: array expected";
              for (var Mi = 0; Mi < Oi.logs.length; ++Mi)
                if (!wi.isString(Oi.logs[Mi]))
                  return "logs: string[] expected";
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.transaction_receipt)
              return Oi;
            var Mi = new Ei.koinos.protocol.transaction_receipt();
            if (Oi.id != null && (typeof Oi.id == "string" ? wi.base64.decode(Oi.id, Mi.id = wi.newBuffer(wi.base64.length(Oi.id)), 0) : Oi.id.length >= 0 && (Mi.id = Oi.id)), Oi.payer != null && (typeof Oi.payer == "string" ? wi.base64.decode(Oi.payer, Mi.payer = wi.newBuffer(wi.base64.length(Oi.payer)), 0) : Oi.payer.length >= 0 && (Mi.payer = Oi.payer)), Oi.max_payer_rc != null && (wi.Long ? (Mi.max_payer_rc = wi.Long.fromValue(Oi.max_payer_rc)).unsigned = !0 : typeof Oi.max_payer_rc == "string" ? Mi.max_payer_rc = parseInt(Oi.max_payer_rc, 10) : typeof Oi.max_payer_rc == "number" ? Mi.max_payer_rc = Oi.max_payer_rc : typeof Oi.max_payer_rc == "object" && (Mi.max_payer_rc = new wi.LongBits(Oi.max_payer_rc.low >>> 0, Oi.max_payer_rc.high >>> 0).toNumber(!0))), Oi.rc_limit != null && (wi.Long ? (Mi.rc_limit = wi.Long.fromValue(Oi.rc_limit)).unsigned = !0 : typeof Oi.rc_limit == "string" ? Mi.rc_limit = parseInt(Oi.rc_limit, 10) : typeof Oi.rc_limit == "number" ? Mi.rc_limit = Oi.rc_limit : typeof Oi.rc_limit == "object" && (Mi.rc_limit = new wi.LongBits(Oi.rc_limit.low >>> 0, Oi.rc_limit.high >>> 0).toNumber(!0))), Oi.rc_used != null && (wi.Long ? (Mi.rc_used = wi.Long.fromValue(Oi.rc_used)).unsigned = !0 : typeof Oi.rc_used == "string" ? Mi.rc_used = parseInt(Oi.rc_used, 10) : typeof Oi.rc_used == "number" ? Mi.rc_used = Oi.rc_used : typeof Oi.rc_used == "object" && (Mi.rc_used = new wi.LongBits(Oi.rc_used.low >>> 0, Oi.rc_used.high >>> 0).toNumber(!0))), Oi.disk_storage_used != null && (wi.Long ? (Mi.disk_storage_used = wi.Long.fromValue(Oi.disk_storage_used)).unsigned = !0 : typeof Oi.disk_storage_used == "string" ? Mi.disk_storage_used = parseInt(Oi.disk_storage_used, 10) : typeof Oi.disk_storage_used == "number" ? Mi.disk_storage_used = Oi.disk_storage_used : typeof Oi.disk_storage_used == "object" && (Mi.disk_storage_used = new wi.LongBits(Oi.disk_storage_used.low >>> 0, Oi.disk_storage_used.high >>> 0).toNumber(!0))), Oi.network_bandwidth_used != null && (wi.Long ? (Mi.network_bandwidth_used = wi.Long.fromValue(Oi.network_bandwidth_used)).unsigned = !0 : typeof Oi.network_bandwidth_used == "string" ? Mi.network_bandwidth_used = parseInt(Oi.network_bandwidth_used, 10) : typeof Oi.network_bandwidth_used == "number" ? Mi.network_bandwidth_used = Oi.network_bandwidth_used : typeof Oi.network_bandwidth_used == "object" && (Mi.network_bandwidth_used = new wi.LongBits(Oi.network_bandwidth_used.low >>> 0, Oi.network_bandwidth_used.high >>> 0).toNumber(!0))), Oi.compute_bandwidth_used != null && (wi.Long ? (Mi.compute_bandwidth_used = wi.Long.fromValue(Oi.compute_bandwidth_used)).unsigned = !0 : typeof Oi.compute_bandwidth_used == "string" ? Mi.compute_bandwidth_used = parseInt(Oi.compute_bandwidth_used, 10) : typeof Oi.compute_bandwidth_used == "number" ? Mi.compute_bandwidth_used = Oi.compute_bandwidth_used : typeof Oi.compute_bandwidth_used == "object" && (Mi.compute_bandwidth_used = new wi.LongBits(Oi.compute_bandwidth_used.low >>> 0, Oi.compute_bandwidth_used.high >>> 0).toNumber(!0))), Oi.reverted != null && (Mi.reverted = !!Oi.reverted), Oi.events) {
              if (!Array.isArray(Oi.events))
                throw TypeError(".koinos.protocol.transaction_receipt.events: array expected");
              Mi.events = [];
              for (var Ii = 0; Ii < Oi.events.length; ++Ii) {
                if (typeof Oi.events[Ii] != "object")
                  throw TypeError(".koinos.protocol.transaction_receipt.events: object expected");
                Mi.events[Ii] = Ei.koinos.protocol.event_data.fromObject(Oi.events[Ii]);
              }
            }
            if (Oi.logs) {
              if (!Array.isArray(Oi.logs))
                throw TypeError(".koinos.protocol.transaction_receipt.logs: array expected");
              Mi.logs = [];
              for (var Ii = 0; Ii < Oi.logs.length; ++Ii)
                Mi.logs[Ii] = String(Oi.logs[Ii]);
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.events = [], Ii.logs = []), Mi.defaults) {
              if (Mi.bytes === String ? Ii.id = "" : (Ii.id = [], Mi.bytes !== Array && (Ii.id = wi.newBuffer(Ii.id))), Mi.bytes === String ? Ii.payer = "" : (Ii.payer = [], Mi.bytes !== Array && (Ii.payer = wi.newBuffer(Ii.payer))), wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.max_payer_rc = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.max_payer_rc = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.rc_limit = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.rc_limit = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.rc_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.rc_used = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.disk_storage_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.disk_storage_used = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.network_bandwidth_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.network_bandwidth_used = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.compute_bandwidth_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.compute_bandwidth_used = Mi.longs === String ? "0" : 0;
              Ii.reverted = !1;
            }
            if (Oi.id != null && Oi.hasOwnProperty("id") && (Ii.id = Mi.bytes === String ? wi.base64.encode(Oi.id, 0, Oi.id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.id) : Oi.id), Oi.payer != null && Oi.hasOwnProperty("payer") && (Ii.payer = Mi.bytes === String ? wi.base64.encode(Oi.payer, 0, Oi.payer.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.payer) : Oi.payer), Oi.max_payer_rc != null && Oi.hasOwnProperty("max_payer_rc") && (typeof Oi.max_payer_rc == "number" ? Ii.max_payer_rc = Mi.longs === String ? String(Oi.max_payer_rc) : Oi.max_payer_rc : Ii.max_payer_rc = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.max_payer_rc) : Mi.longs === Number ? new wi.LongBits(Oi.max_payer_rc.low >>> 0, Oi.max_payer_rc.high >>> 0).toNumber(!0) : Oi.max_payer_rc), Oi.rc_limit != null && Oi.hasOwnProperty("rc_limit") && (typeof Oi.rc_limit == "number" ? Ii.rc_limit = Mi.longs === String ? String(Oi.rc_limit) : Oi.rc_limit : Ii.rc_limit = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.rc_limit) : Mi.longs === Number ? new wi.LongBits(Oi.rc_limit.low >>> 0, Oi.rc_limit.high >>> 0).toNumber(!0) : Oi.rc_limit), Oi.rc_used != null && Oi.hasOwnProperty("rc_used") && (typeof Oi.rc_used == "number" ? Ii.rc_used = Mi.longs === String ? String(Oi.rc_used) : Oi.rc_used : Ii.rc_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.rc_used) : Mi.longs === Number ? new wi.LongBits(Oi.rc_used.low >>> 0, Oi.rc_used.high >>> 0).toNumber(!0) : Oi.rc_used), Oi.disk_storage_used != null && Oi.hasOwnProperty("disk_storage_used") && (typeof Oi.disk_storage_used == "number" ? Ii.disk_storage_used = Mi.longs === String ? String(Oi.disk_storage_used) : Oi.disk_storage_used : Ii.disk_storage_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.disk_storage_used) : Mi.longs === Number ? new wi.LongBits(Oi.disk_storage_used.low >>> 0, Oi.disk_storage_used.high >>> 0).toNumber(!0) : Oi.disk_storage_used), Oi.network_bandwidth_used != null && Oi.hasOwnProperty("network_bandwidth_used") && (typeof Oi.network_bandwidth_used == "number" ? Ii.network_bandwidth_used = Mi.longs === String ? String(Oi.network_bandwidth_used) : Oi.network_bandwidth_used : Ii.network_bandwidth_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.network_bandwidth_used) : Mi.longs === Number ? new wi.LongBits(Oi.network_bandwidth_used.low >>> 0, Oi.network_bandwidth_used.high >>> 0).toNumber(!0) : Oi.network_bandwidth_used), Oi.compute_bandwidth_used != null && Oi.hasOwnProperty("compute_bandwidth_used") && (typeof Oi.compute_bandwidth_used == "number" ? Ii.compute_bandwidth_used = Mi.longs === String ? String(Oi.compute_bandwidth_used) : Oi.compute_bandwidth_used : Ii.compute_bandwidth_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.compute_bandwidth_used) : Mi.longs === Number ? new wi.LongBits(Oi.compute_bandwidth_used.low >>> 0, Oi.compute_bandwidth_used.high >>> 0).toNumber(!0) : Oi.compute_bandwidth_used), Oi.reverted != null && Oi.hasOwnProperty("reverted") && (Ii.reverted = Oi.reverted), Oi.events && Oi.events.length) {
              Ii.events = [];
              for (var Oo = 0; Oo < Oi.events.length; ++Oo)
                Ii.events[Oo] = Ei.koinos.protocol.event_data.toObject(Oi.events[Oo], Mi);
            }
            if (Oi.logs && Oi.logs.length) {
              Ii.logs = [];
              for (var Oo = 0; Oo < Oi.logs.length; ++Oo)
                Ii.logs[Oo] = Oi.logs[Oo];
            }
            return Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.transaction_receipt";
          }, Ri;
        }(), xi.block_header = function() {
          function Ri(Ti) {
            if (this.approved_proposals = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.previous = wi.newBuffer([]), Ri.prototype.height = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.timestamp = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.previous_state_merkle_root = wi.newBuffer([]), Ri.prototype.transaction_merkle_root = wi.newBuffer([]), Ri.prototype.signer = wi.newBuffer([]), Ri.prototype.approved_proposals = wi.emptyArray, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.previous != null && Object.hasOwnProperty.call(Oi, "previous") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.previous), Oi.height != null && Object.hasOwnProperty.call(Oi, "height") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(Oi.height), Oi.timestamp != null && Object.hasOwnProperty.call(Oi, "timestamp") && Mi.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(Oi.timestamp), Oi.previous_state_merkle_root != null && Object.hasOwnProperty.call(Oi, "previous_state_merkle_root") && Mi.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(Oi.previous_state_merkle_root), Oi.transaction_merkle_root != null && Object.hasOwnProperty.call(Oi, "transaction_merkle_root") && Mi.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(Oi.transaction_merkle_root), Oi.signer != null && Object.hasOwnProperty.call(Oi, "signer") && Mi.uint32(
              /* id 6, wireType 2 =*/
              50
            ).bytes(Oi.signer), Oi.approved_proposals != null && Oi.approved_proposals.length)
              for (var Ii = 0; Ii < Oi.approved_proposals.length; ++Ii)
                Mi.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).bytes(Oi.approved_proposals[Ii]);
            return Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.block_header(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.previous = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.height = Oi.uint64();
                  break;
                }
                case 3: {
                  Ci.timestamp = Oi.uint64();
                  break;
                }
                case 4: {
                  Ci.previous_state_merkle_root = Oi.bytes();
                  break;
                }
                case 5: {
                  Ci.transaction_merkle_root = Oi.bytes();
                  break;
                }
                case 6: {
                  Ci.signer = Oi.bytes();
                  break;
                }
                case 7: {
                  Ci.approved_proposals && Ci.approved_proposals.length || (Ci.approved_proposals = []), Ci.approved_proposals.push(Oi.bytes());
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.previous != null && Oi.hasOwnProperty("previous") && !(Oi.previous && typeof Oi.previous.length == "number" || wi.isString(Oi.previous)))
              return "previous: buffer expected";
            if (Oi.height != null && Oi.hasOwnProperty("height") && !wi.isInteger(Oi.height) && !(Oi.height && wi.isInteger(Oi.height.low) && wi.isInteger(Oi.height.high)))
              return "height: integer|Long expected";
            if (Oi.timestamp != null && Oi.hasOwnProperty("timestamp") && !wi.isInteger(Oi.timestamp) && !(Oi.timestamp && wi.isInteger(Oi.timestamp.low) && wi.isInteger(Oi.timestamp.high)))
              return "timestamp: integer|Long expected";
            if (Oi.previous_state_merkle_root != null && Oi.hasOwnProperty("previous_state_merkle_root") && !(Oi.previous_state_merkle_root && typeof Oi.previous_state_merkle_root.length == "number" || wi.isString(Oi.previous_state_merkle_root)))
              return "previous_state_merkle_root: buffer expected";
            if (Oi.transaction_merkle_root != null && Oi.hasOwnProperty("transaction_merkle_root") && !(Oi.transaction_merkle_root && typeof Oi.transaction_merkle_root.length == "number" || wi.isString(Oi.transaction_merkle_root)))
              return "transaction_merkle_root: buffer expected";
            if (Oi.signer != null && Oi.hasOwnProperty("signer") && !(Oi.signer && typeof Oi.signer.length == "number" || wi.isString(Oi.signer)))
              return "signer: buffer expected";
            if (Oi.approved_proposals != null && Oi.hasOwnProperty("approved_proposals")) {
              if (!Array.isArray(Oi.approved_proposals))
                return "approved_proposals: array expected";
              for (var Mi = 0; Mi < Oi.approved_proposals.length; ++Mi)
                if (!(Oi.approved_proposals[Mi] && typeof Oi.approved_proposals[Mi].length == "number" || wi.isString(Oi.approved_proposals[Mi])))
                  return "approved_proposals: buffer[] expected";
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.block_header)
              return Oi;
            var Mi = new Ei.koinos.protocol.block_header();
            if (Oi.previous != null && (typeof Oi.previous == "string" ? wi.base64.decode(Oi.previous, Mi.previous = wi.newBuffer(wi.base64.length(Oi.previous)), 0) : Oi.previous.length >= 0 && (Mi.previous = Oi.previous)), Oi.height != null && (wi.Long ? (Mi.height = wi.Long.fromValue(Oi.height)).unsigned = !0 : typeof Oi.height == "string" ? Mi.height = parseInt(Oi.height, 10) : typeof Oi.height == "number" ? Mi.height = Oi.height : typeof Oi.height == "object" && (Mi.height = new wi.LongBits(Oi.height.low >>> 0, Oi.height.high >>> 0).toNumber(!0))), Oi.timestamp != null && (wi.Long ? (Mi.timestamp = wi.Long.fromValue(Oi.timestamp)).unsigned = !0 : typeof Oi.timestamp == "string" ? Mi.timestamp = parseInt(Oi.timestamp, 10) : typeof Oi.timestamp == "number" ? Mi.timestamp = Oi.timestamp : typeof Oi.timestamp == "object" && (Mi.timestamp = new wi.LongBits(Oi.timestamp.low >>> 0, Oi.timestamp.high >>> 0).toNumber(!0))), Oi.previous_state_merkle_root != null && (typeof Oi.previous_state_merkle_root == "string" ? wi.base64.decode(Oi.previous_state_merkle_root, Mi.previous_state_merkle_root = wi.newBuffer(wi.base64.length(Oi.previous_state_merkle_root)), 0) : Oi.previous_state_merkle_root.length >= 0 && (Mi.previous_state_merkle_root = Oi.previous_state_merkle_root)), Oi.transaction_merkle_root != null && (typeof Oi.transaction_merkle_root == "string" ? wi.base64.decode(Oi.transaction_merkle_root, Mi.transaction_merkle_root = wi.newBuffer(wi.base64.length(Oi.transaction_merkle_root)), 0) : Oi.transaction_merkle_root.length >= 0 && (Mi.transaction_merkle_root = Oi.transaction_merkle_root)), Oi.signer != null && (typeof Oi.signer == "string" ? wi.base64.decode(Oi.signer, Mi.signer = wi.newBuffer(wi.base64.length(Oi.signer)), 0) : Oi.signer.length >= 0 && (Mi.signer = Oi.signer)), Oi.approved_proposals) {
              if (!Array.isArray(Oi.approved_proposals))
                throw TypeError(".koinos.protocol.block_header.approved_proposals: array expected");
              Mi.approved_proposals = [];
              for (var Ii = 0; Ii < Oi.approved_proposals.length; ++Ii)
                typeof Oi.approved_proposals[Ii] == "string" ? wi.base64.decode(Oi.approved_proposals[Ii], Mi.approved_proposals[Ii] = wi.newBuffer(wi.base64.length(Oi.approved_proposals[Ii])), 0) : Oi.approved_proposals[Ii].length >= 0 && (Mi.approved_proposals[Ii] = Oi.approved_proposals[Ii]);
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.approved_proposals = []), Mi.defaults) {
              if (Mi.bytes === String ? Ii.previous = "" : (Ii.previous = [], Mi.bytes !== Array && (Ii.previous = wi.newBuffer(Ii.previous))), wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.height = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.height = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.timestamp = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.timestamp = Mi.longs === String ? "0" : 0;
              Mi.bytes === String ? Ii.previous_state_merkle_root = "" : (Ii.previous_state_merkle_root = [], Mi.bytes !== Array && (Ii.previous_state_merkle_root = wi.newBuffer(Ii.previous_state_merkle_root))), Mi.bytes === String ? Ii.transaction_merkle_root = "" : (Ii.transaction_merkle_root = [], Mi.bytes !== Array && (Ii.transaction_merkle_root = wi.newBuffer(Ii.transaction_merkle_root))), Mi.bytes === String ? Ii.signer = "" : (Ii.signer = [], Mi.bytes !== Array && (Ii.signer = wi.newBuffer(Ii.signer)));
            }
            if (Oi.previous != null && Oi.hasOwnProperty("previous") && (Ii.previous = Mi.bytes === String ? wi.base64.encode(Oi.previous, 0, Oi.previous.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.previous) : Oi.previous), Oi.height != null && Oi.hasOwnProperty("height") && (typeof Oi.height == "number" ? Ii.height = Mi.longs === String ? String(Oi.height) : Oi.height : Ii.height = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.height) : Mi.longs === Number ? new wi.LongBits(Oi.height.low >>> 0, Oi.height.high >>> 0).toNumber(!0) : Oi.height), Oi.timestamp != null && Oi.hasOwnProperty("timestamp") && (typeof Oi.timestamp == "number" ? Ii.timestamp = Mi.longs === String ? String(Oi.timestamp) : Oi.timestamp : Ii.timestamp = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.timestamp) : Mi.longs === Number ? new wi.LongBits(Oi.timestamp.low >>> 0, Oi.timestamp.high >>> 0).toNumber(!0) : Oi.timestamp), Oi.previous_state_merkle_root != null && Oi.hasOwnProperty("previous_state_merkle_root") && (Ii.previous_state_merkle_root = Mi.bytes === String ? wi.base64.encode(Oi.previous_state_merkle_root, 0, Oi.previous_state_merkle_root.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.previous_state_merkle_root) : Oi.previous_state_merkle_root), Oi.transaction_merkle_root != null && Oi.hasOwnProperty("transaction_merkle_root") && (Ii.transaction_merkle_root = Mi.bytes === String ? wi.base64.encode(Oi.transaction_merkle_root, 0, Oi.transaction_merkle_root.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.transaction_merkle_root) : Oi.transaction_merkle_root), Oi.signer != null && Oi.hasOwnProperty("signer") && (Ii.signer = Mi.bytes === String ? wi.base64.encode(Oi.signer, 0, Oi.signer.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.signer) : Oi.signer), Oi.approved_proposals && Oi.approved_proposals.length) {
              Ii.approved_proposals = [];
              for (var Oo = 0; Oo < Oi.approved_proposals.length; ++Oo)
                Ii.approved_proposals[Oo] = Mi.bytes === String ? wi.base64.encode(Oi.approved_proposals[Oo], 0, Oi.approved_proposals[Oo].length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.approved_proposals[Oo]) : Oi.approved_proposals[Oo];
            }
            return Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.block_header";
          }, Ri;
        }(), xi.block = function() {
          function Ri(Ti) {
            if (this.transactions = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.id = wi.newBuffer([]), Ri.prototype.header = null, Ri.prototype.transactions = wi.emptyArray, Ri.prototype.signature = wi.newBuffer([]), Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.id != null && Object.hasOwnProperty.call(Oi, "id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.id), Oi.header != null && Object.hasOwnProperty.call(Oi, "header") && Ei.koinos.protocol.block_header.encode(Oi.header, Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim(), Oi.transactions != null && Oi.transactions.length)
              for (var Ii = 0; Ii < Oi.transactions.length; ++Ii)
                Ei.koinos.protocol.transaction.encode(Oi.transactions[Ii], Mi.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            return Oi.signature != null && Object.hasOwnProperty.call(Oi, "signature") && Mi.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(Oi.signature), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.block(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.header = Ei.koinos.protocol.block_header.decode(Oi, Oi.uint32());
                  break;
                }
                case 3: {
                  Ci.transactions && Ci.transactions.length || (Ci.transactions = []), Ci.transactions.push(Ei.koinos.protocol.transaction.decode(Oi, Oi.uint32()));
                  break;
                }
                case 4: {
                  Ci.signature = Oi.bytes();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.id != null && Oi.hasOwnProperty("id") && !(Oi.id && typeof Oi.id.length == "number" || wi.isString(Oi.id)))
              return "id: buffer expected";
            if (Oi.header != null && Oi.hasOwnProperty("header")) {
              var Mi = Ei.koinos.protocol.block_header.verify(Oi.header);
              if (Mi)
                return "header." + Mi;
            }
            if (Oi.transactions != null && Oi.hasOwnProperty("transactions")) {
              if (!Array.isArray(Oi.transactions))
                return "transactions: array expected";
              for (var Ii = 0; Ii < Oi.transactions.length; ++Ii) {
                var Mi = Ei.koinos.protocol.transaction.verify(Oi.transactions[Ii]);
                if (Mi)
                  return "transactions." + Mi;
              }
            }
            return Oi.signature != null && Oi.hasOwnProperty("signature") && !(Oi.signature && typeof Oi.signature.length == "number" || wi.isString(Oi.signature)) ? "signature: buffer expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.block)
              return Oi;
            var Mi = new Ei.koinos.protocol.block();
            if (Oi.id != null && (typeof Oi.id == "string" ? wi.base64.decode(Oi.id, Mi.id = wi.newBuffer(wi.base64.length(Oi.id)), 0) : Oi.id.length >= 0 && (Mi.id = Oi.id)), Oi.header != null) {
              if (typeof Oi.header != "object")
                throw TypeError(".koinos.protocol.block.header: object expected");
              Mi.header = Ei.koinos.protocol.block_header.fromObject(Oi.header);
            }
            if (Oi.transactions) {
              if (!Array.isArray(Oi.transactions))
                throw TypeError(".koinos.protocol.block.transactions: array expected");
              Mi.transactions = [];
              for (var Ii = 0; Ii < Oi.transactions.length; ++Ii) {
                if (typeof Oi.transactions[Ii] != "object")
                  throw TypeError(".koinos.protocol.block.transactions: object expected");
                Mi.transactions[Ii] = Ei.koinos.protocol.transaction.fromObject(Oi.transactions[Ii]);
              }
            }
            return Oi.signature != null && (typeof Oi.signature == "string" ? wi.base64.decode(Oi.signature, Mi.signature = wi.newBuffer(wi.base64.length(Oi.signature)), 0) : Oi.signature.length >= 0 && (Mi.signature = Oi.signature)), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.transactions = []), Mi.defaults && (Mi.bytes === String ? Ii.id = "" : (Ii.id = [], Mi.bytes !== Array && (Ii.id = wi.newBuffer(Ii.id))), Ii.header = null, Mi.bytes === String ? Ii.signature = "" : (Ii.signature = [], Mi.bytes !== Array && (Ii.signature = wi.newBuffer(Ii.signature)))), Oi.id != null && Oi.hasOwnProperty("id") && (Ii.id = Mi.bytes === String ? wi.base64.encode(Oi.id, 0, Oi.id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.id) : Oi.id), Oi.header != null && Oi.hasOwnProperty("header") && (Ii.header = Ei.koinos.protocol.block_header.toObject(Oi.header, Mi)), Oi.transactions && Oi.transactions.length) {
              Ii.transactions = [];
              for (var Ci = 0; Ci < Oi.transactions.length; ++Ci)
                Ii.transactions[Ci] = Ei.koinos.protocol.transaction.toObject(Oi.transactions[Ci], Mi);
            }
            return Oi.signature != null && Oi.hasOwnProperty("signature") && (Ii.signature = Mi.bytes === String ? wi.base64.encode(Oi.signature, 0, Oi.signature.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.signature) : Oi.signature), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.block";
          }, Ri;
        }(), xi.block_receipt = function() {
          function Ri(Ti) {
            if (this.events = [], this.transaction_receipts = [], this.logs = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.id = wi.newBuffer([]), Ri.prototype.height = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.disk_storage_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.network_bandwidth_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.compute_bandwidth_used = wi.Long ? wi.Long.fromBits(0, 0, !0) : 0, Ri.prototype.state_merkle_root = wi.newBuffer([]), Ri.prototype.events = wi.emptyArray, Ri.prototype.transaction_receipts = wi.emptyArray, Ri.prototype.logs = wi.emptyArray, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.id != null && Object.hasOwnProperty.call(Oi, "id") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(Oi.id), Oi.height != null && Object.hasOwnProperty.call(Oi, "height") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(Oi.height), Oi.disk_storage_used != null && Object.hasOwnProperty.call(Oi, "disk_storage_used") && Mi.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(Oi.disk_storage_used), Oi.network_bandwidth_used != null && Object.hasOwnProperty.call(Oi, "network_bandwidth_used") && Mi.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(Oi.network_bandwidth_used), Oi.compute_bandwidth_used != null && Object.hasOwnProperty.call(Oi, "compute_bandwidth_used") && Mi.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(Oi.compute_bandwidth_used), Oi.state_merkle_root != null && Object.hasOwnProperty.call(Oi, "state_merkle_root") && Mi.uint32(
              /* id 6, wireType 2 =*/
              50
            ).bytes(Oi.state_merkle_root), Oi.events != null && Oi.events.length)
              for (var Ii = 0; Ii < Oi.events.length; ++Ii)
                Ei.koinos.protocol.event_data.encode(Oi.events[Ii], Mi.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).fork()).ldelim();
            if (Oi.transaction_receipts != null && Oi.transaction_receipts.length)
              for (var Ii = 0; Ii < Oi.transaction_receipts.length; ++Ii)
                Ei.koinos.protocol.transaction_receipt.encode(Oi.transaction_receipts[Ii], Mi.uint32(
                  /* id 8, wireType 2 =*/
                  66
                ).fork()).ldelim();
            if (Oi.logs != null && Oi.logs.length)
              for (var Ii = 0; Ii < Oi.logs.length; ++Ii)
                Mi.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).string(Oi.logs[Ii]);
            return Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.protocol.block_receipt(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.id = Oi.bytes();
                  break;
                }
                case 2: {
                  Ci.height = Oi.uint64();
                  break;
                }
                case 3: {
                  Ci.disk_storage_used = Oi.uint64();
                  break;
                }
                case 4: {
                  Ci.network_bandwidth_used = Oi.uint64();
                  break;
                }
                case 5: {
                  Ci.compute_bandwidth_used = Oi.uint64();
                  break;
                }
                case 6: {
                  Ci.state_merkle_root = Oi.bytes();
                  break;
                }
                case 7: {
                  Ci.events && Ci.events.length || (Ci.events = []), Ci.events.push(Ei.koinos.protocol.event_data.decode(Oi, Oi.uint32()));
                  break;
                }
                case 8: {
                  Ci.transaction_receipts && Ci.transaction_receipts.length || (Ci.transaction_receipts = []), Ci.transaction_receipts.push(Ei.koinos.protocol.transaction_receipt.decode(Oi, Oi.uint32()));
                  break;
                }
                case 9: {
                  Ci.logs && Ci.logs.length || (Ci.logs = []), Ci.logs.push(Oi.string());
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.id != null && Oi.hasOwnProperty("id") && !(Oi.id && typeof Oi.id.length == "number" || wi.isString(Oi.id)))
              return "id: buffer expected";
            if (Oi.height != null && Oi.hasOwnProperty("height") && !wi.isInteger(Oi.height) && !(Oi.height && wi.isInteger(Oi.height.low) && wi.isInteger(Oi.height.high)))
              return "height: integer|Long expected";
            if (Oi.disk_storage_used != null && Oi.hasOwnProperty("disk_storage_used") && !wi.isInteger(Oi.disk_storage_used) && !(Oi.disk_storage_used && wi.isInteger(Oi.disk_storage_used.low) && wi.isInteger(Oi.disk_storage_used.high)))
              return "disk_storage_used: integer|Long expected";
            if (Oi.network_bandwidth_used != null && Oi.hasOwnProperty("network_bandwidth_used") && !wi.isInteger(Oi.network_bandwidth_used) && !(Oi.network_bandwidth_used && wi.isInteger(Oi.network_bandwidth_used.low) && wi.isInteger(Oi.network_bandwidth_used.high)))
              return "network_bandwidth_used: integer|Long expected";
            if (Oi.compute_bandwidth_used != null && Oi.hasOwnProperty("compute_bandwidth_used") && !wi.isInteger(Oi.compute_bandwidth_used) && !(Oi.compute_bandwidth_used && wi.isInteger(Oi.compute_bandwidth_used.low) && wi.isInteger(Oi.compute_bandwidth_used.high)))
              return "compute_bandwidth_used: integer|Long expected";
            if (Oi.state_merkle_root != null && Oi.hasOwnProperty("state_merkle_root") && !(Oi.state_merkle_root && typeof Oi.state_merkle_root.length == "number" || wi.isString(Oi.state_merkle_root)))
              return "state_merkle_root: buffer expected";
            if (Oi.events != null && Oi.hasOwnProperty("events")) {
              if (!Array.isArray(Oi.events))
                return "events: array expected";
              for (var Mi = 0; Mi < Oi.events.length; ++Mi) {
                var Ii = Ei.koinos.protocol.event_data.verify(Oi.events[Mi]);
                if (Ii)
                  return "events." + Ii;
              }
            }
            if (Oi.transaction_receipts != null && Oi.hasOwnProperty("transaction_receipts")) {
              if (!Array.isArray(Oi.transaction_receipts))
                return "transaction_receipts: array expected";
              for (var Mi = 0; Mi < Oi.transaction_receipts.length; ++Mi) {
                var Ii = Ei.koinos.protocol.transaction_receipt.verify(Oi.transaction_receipts[Mi]);
                if (Ii)
                  return "transaction_receipts." + Ii;
              }
            }
            if (Oi.logs != null && Oi.hasOwnProperty("logs")) {
              if (!Array.isArray(Oi.logs))
                return "logs: array expected";
              for (var Mi = 0; Mi < Oi.logs.length; ++Mi)
                if (!wi.isString(Oi.logs[Mi]))
                  return "logs: string[] expected";
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.protocol.block_receipt)
              return Oi;
            var Mi = new Ei.koinos.protocol.block_receipt();
            if (Oi.id != null && (typeof Oi.id == "string" ? wi.base64.decode(Oi.id, Mi.id = wi.newBuffer(wi.base64.length(Oi.id)), 0) : Oi.id.length >= 0 && (Mi.id = Oi.id)), Oi.height != null && (wi.Long ? (Mi.height = wi.Long.fromValue(Oi.height)).unsigned = !0 : typeof Oi.height == "string" ? Mi.height = parseInt(Oi.height, 10) : typeof Oi.height == "number" ? Mi.height = Oi.height : typeof Oi.height == "object" && (Mi.height = new wi.LongBits(Oi.height.low >>> 0, Oi.height.high >>> 0).toNumber(!0))), Oi.disk_storage_used != null && (wi.Long ? (Mi.disk_storage_used = wi.Long.fromValue(Oi.disk_storage_used)).unsigned = !0 : typeof Oi.disk_storage_used == "string" ? Mi.disk_storage_used = parseInt(Oi.disk_storage_used, 10) : typeof Oi.disk_storage_used == "number" ? Mi.disk_storage_used = Oi.disk_storage_used : typeof Oi.disk_storage_used == "object" && (Mi.disk_storage_used = new wi.LongBits(Oi.disk_storage_used.low >>> 0, Oi.disk_storage_used.high >>> 0).toNumber(!0))), Oi.network_bandwidth_used != null && (wi.Long ? (Mi.network_bandwidth_used = wi.Long.fromValue(Oi.network_bandwidth_used)).unsigned = !0 : typeof Oi.network_bandwidth_used == "string" ? Mi.network_bandwidth_used = parseInt(Oi.network_bandwidth_used, 10) : typeof Oi.network_bandwidth_used == "number" ? Mi.network_bandwidth_used = Oi.network_bandwidth_used : typeof Oi.network_bandwidth_used == "object" && (Mi.network_bandwidth_used = new wi.LongBits(Oi.network_bandwidth_used.low >>> 0, Oi.network_bandwidth_used.high >>> 0).toNumber(!0))), Oi.compute_bandwidth_used != null && (wi.Long ? (Mi.compute_bandwidth_used = wi.Long.fromValue(Oi.compute_bandwidth_used)).unsigned = !0 : typeof Oi.compute_bandwidth_used == "string" ? Mi.compute_bandwidth_used = parseInt(Oi.compute_bandwidth_used, 10) : typeof Oi.compute_bandwidth_used == "number" ? Mi.compute_bandwidth_used = Oi.compute_bandwidth_used : typeof Oi.compute_bandwidth_used == "object" && (Mi.compute_bandwidth_used = new wi.LongBits(Oi.compute_bandwidth_used.low >>> 0, Oi.compute_bandwidth_used.high >>> 0).toNumber(!0))), Oi.state_merkle_root != null && (typeof Oi.state_merkle_root == "string" ? wi.base64.decode(Oi.state_merkle_root, Mi.state_merkle_root = wi.newBuffer(wi.base64.length(Oi.state_merkle_root)), 0) : Oi.state_merkle_root.length >= 0 && (Mi.state_merkle_root = Oi.state_merkle_root)), Oi.events) {
              if (!Array.isArray(Oi.events))
                throw TypeError(".koinos.protocol.block_receipt.events: array expected");
              Mi.events = [];
              for (var Ii = 0; Ii < Oi.events.length; ++Ii) {
                if (typeof Oi.events[Ii] != "object")
                  throw TypeError(".koinos.protocol.block_receipt.events: object expected");
                Mi.events[Ii] = Ei.koinos.protocol.event_data.fromObject(Oi.events[Ii]);
              }
            }
            if (Oi.transaction_receipts) {
              if (!Array.isArray(Oi.transaction_receipts))
                throw TypeError(".koinos.protocol.block_receipt.transaction_receipts: array expected");
              Mi.transaction_receipts = [];
              for (var Ii = 0; Ii < Oi.transaction_receipts.length; ++Ii) {
                if (typeof Oi.transaction_receipts[Ii] != "object")
                  throw TypeError(".koinos.protocol.block_receipt.transaction_receipts: object expected");
                Mi.transaction_receipts[Ii] = Ei.koinos.protocol.transaction_receipt.fromObject(Oi.transaction_receipts[Ii]);
              }
            }
            if (Oi.logs) {
              if (!Array.isArray(Oi.logs))
                throw TypeError(".koinos.protocol.block_receipt.logs: array expected");
              Mi.logs = [];
              for (var Ii = 0; Ii < Oi.logs.length; ++Ii)
                Mi.logs[Ii] = String(Oi.logs[Ii]);
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.events = [], Ii.transaction_receipts = [], Ii.logs = []), Mi.defaults) {
              if (Mi.bytes === String ? Ii.id = "" : (Ii.id = [], Mi.bytes !== Array && (Ii.id = wi.newBuffer(Ii.id))), wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.height = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.height = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.disk_storage_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.disk_storage_used = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.network_bandwidth_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.network_bandwidth_used = Mi.longs === String ? "0" : 0;
              if (wi.Long) {
                var Ci = new wi.Long(0, 0, !0);
                Ii.compute_bandwidth_used = Mi.longs === String ? Ci.toString() : Mi.longs === Number ? Ci.toNumber() : Ci;
              } else
                Ii.compute_bandwidth_used = Mi.longs === String ? "0" : 0;
              Mi.bytes === String ? Ii.state_merkle_root = "" : (Ii.state_merkle_root = [], Mi.bytes !== Array && (Ii.state_merkle_root = wi.newBuffer(Ii.state_merkle_root)));
            }
            if (Oi.id != null && Oi.hasOwnProperty("id") && (Ii.id = Mi.bytes === String ? wi.base64.encode(Oi.id, 0, Oi.id.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.id) : Oi.id), Oi.height != null && Oi.hasOwnProperty("height") && (typeof Oi.height == "number" ? Ii.height = Mi.longs === String ? String(Oi.height) : Oi.height : Ii.height = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.height) : Mi.longs === Number ? new wi.LongBits(Oi.height.low >>> 0, Oi.height.high >>> 0).toNumber(!0) : Oi.height), Oi.disk_storage_used != null && Oi.hasOwnProperty("disk_storage_used") && (typeof Oi.disk_storage_used == "number" ? Ii.disk_storage_used = Mi.longs === String ? String(Oi.disk_storage_used) : Oi.disk_storage_used : Ii.disk_storage_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.disk_storage_used) : Mi.longs === Number ? new wi.LongBits(Oi.disk_storage_used.low >>> 0, Oi.disk_storage_used.high >>> 0).toNumber(!0) : Oi.disk_storage_used), Oi.network_bandwidth_used != null && Oi.hasOwnProperty("network_bandwidth_used") && (typeof Oi.network_bandwidth_used == "number" ? Ii.network_bandwidth_used = Mi.longs === String ? String(Oi.network_bandwidth_used) : Oi.network_bandwidth_used : Ii.network_bandwidth_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.network_bandwidth_used) : Mi.longs === Number ? new wi.LongBits(Oi.network_bandwidth_used.low >>> 0, Oi.network_bandwidth_used.high >>> 0).toNumber(!0) : Oi.network_bandwidth_used), Oi.compute_bandwidth_used != null && Oi.hasOwnProperty("compute_bandwidth_used") && (typeof Oi.compute_bandwidth_used == "number" ? Ii.compute_bandwidth_used = Mi.longs === String ? String(Oi.compute_bandwidth_used) : Oi.compute_bandwidth_used : Ii.compute_bandwidth_used = Mi.longs === String ? wi.Long.prototype.toString.call(Oi.compute_bandwidth_used) : Mi.longs === Number ? new wi.LongBits(Oi.compute_bandwidth_used.low >>> 0, Oi.compute_bandwidth_used.high >>> 0).toNumber(!0) : Oi.compute_bandwidth_used), Oi.state_merkle_root != null && Oi.hasOwnProperty("state_merkle_root") && (Ii.state_merkle_root = Mi.bytes === String ? wi.base64.encode(Oi.state_merkle_root, 0, Oi.state_merkle_root.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.state_merkle_root) : Oi.state_merkle_root), Oi.events && Oi.events.length) {
              Ii.events = [];
              for (var Oo = 0; Oo < Oi.events.length; ++Oo)
                Ii.events[Oo] = Ei.koinos.protocol.event_data.toObject(Oi.events[Oo], Mi);
            }
            if (Oi.transaction_receipts && Oi.transaction_receipts.length) {
              Ii.transaction_receipts = [];
              for (var Oo = 0; Oo < Oi.transaction_receipts.length; ++Oo)
                Ii.transaction_receipts[Oo] = Ei.koinos.protocol.transaction_receipt.toObject(Oi.transaction_receipts[Oo], Mi);
            }
            if (Oi.logs && Oi.logs.length) {
              Ii.logs = [];
              for (var Oo = 0; Oo < Oi.logs.length; ++Oo)
                Ii.logs[Oo] = Oi.logs[Oo];
            }
            return Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.protocol.block_receipt";
          }, Ri;
        }(), xi;
      }(), $i.chain = function() {
        var xi = {};
        return xi.value_type = function() {
          function Ri(Oi) {
            if (Oi)
              for (var Mi = Object.keys(Oi), Ii = 0; Ii < Mi.length; ++Ii)
                Oi[Mi[Ii]] != null && (this[Mi[Ii]] = Oi[Mi[Ii]]);
          }
          Ri.prototype.message_value = null, Ri.prototype.int32_value = null, Ri.prototype.int64_value = null, Ri.prototype.uint32_value = null, Ri.prototype.uint64_value = null, Ri.prototype.sint32_value = null, Ri.prototype.sint64_value = null, Ri.prototype.fixed32_value = null, Ri.prototype.fixed64_value = null, Ri.prototype.sfixed32_value = null, Ri.prototype.sfixed64_value = null, Ri.prototype.bool_value = null, Ri.prototype.string_value = null, Ri.prototype.bytes_value = null;
          var Ti;
          return Object.defineProperty(Ri.prototype, "kind", {
            get: wi.oneOfGetter(Ti = [
              "message_value",
              "int32_value",
              "int64_value",
              "uint32_value",
              "uint64_value",
              "sint32_value",
              "sint64_value",
              "fixed32_value",
              "fixed64_value",
              "sfixed32_value",
              "sfixed64_value",
              "bool_value",
              "string_value",
              "bytes_value"
            ]),
            set: wi.oneOfSetter(Ti)
          }), Ri.create = function(Mi) {
            return new Ri(Mi);
          }, Ri.encode = function(Mi, Ii) {
            return Ii || (Ii = Si.create()), Mi.message_value != null && Object.hasOwnProperty.call(Mi, "message_value") && Ei.google.protobuf.Any.encode(Mi.message_value, Ii.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim(), Mi.int32_value != null && Object.hasOwnProperty.call(Mi, "int32_value") && Ii.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(Mi.int32_value), Mi.int64_value != null && Object.hasOwnProperty.call(Mi, "int64_value") && Ii.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int64(Mi.int64_value), Mi.uint32_value != null && Object.hasOwnProperty.call(Mi, "uint32_value") && Ii.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint32(Mi.uint32_value), Mi.uint64_value != null && Object.hasOwnProperty.call(Mi, "uint64_value") && Ii.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(Mi.uint64_value), Mi.sint32_value != null && Object.hasOwnProperty.call(Mi, "sint32_value") && Ii.uint32(
              /* id 6, wireType 0 =*/
              48
            ).sint32(Mi.sint32_value), Mi.sint64_value != null && Object.hasOwnProperty.call(Mi, "sint64_value") && Ii.uint32(
              /* id 7, wireType 0 =*/
              56
            ).sint64(Mi.sint64_value), Mi.fixed32_value != null && Object.hasOwnProperty.call(Mi, "fixed32_value") && Ii.uint32(
              /* id 8, wireType 5 =*/
              69
            ).fixed32(Mi.fixed32_value), Mi.fixed64_value != null && Object.hasOwnProperty.call(Mi, "fixed64_value") && Ii.uint32(
              /* id 9, wireType 1 =*/
              73
            ).fixed64(Mi.fixed64_value), Mi.sfixed32_value != null && Object.hasOwnProperty.call(Mi, "sfixed32_value") && Ii.uint32(
              /* id 10, wireType 5 =*/
              85
            ).sfixed32(Mi.sfixed32_value), Mi.sfixed64_value != null && Object.hasOwnProperty.call(Mi, "sfixed64_value") && Ii.uint32(
              /* id 11, wireType 1 =*/
              89
            ).sfixed64(Mi.sfixed64_value), Mi.bool_value != null && Object.hasOwnProperty.call(Mi, "bool_value") && Ii.uint32(
              /* id 12, wireType 0 =*/
              96
            ).bool(Mi.bool_value), Mi.string_value != null && Object.hasOwnProperty.call(Mi, "string_value") && Ii.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(Mi.string_value), Mi.bytes_value != null && Object.hasOwnProperty.call(Mi, "bytes_value") && Ii.uint32(
              /* id 14, wireType 2 =*/
              114
            ).bytes(Mi.bytes_value), Ii;
          }, Ri.encodeDelimited = function(Mi, Ii) {
            return this.encode(Mi, Ii).ldelim();
          }, Ri.decode = function(Mi, Ii) {
            Mi instanceof Oe || (Mi = Oe.create(Mi));
            for (var Ci = Ii === void 0 ? Mi.len : Mi.pos + Ii, Oo = new Ei.koinos.chain.value_type(); Mi.pos < Ci; ) {
              var Ro = Mi.uint32();
              switch (Ro >>> 3) {
                case 1: {
                  Oo.message_value = Ei.google.protobuf.Any.decode(Mi, Mi.uint32());
                  break;
                }
                case 2: {
                  Oo.int32_value = Mi.int32();
                  break;
                }
                case 3: {
                  Oo.int64_value = Mi.int64();
                  break;
                }
                case 4: {
                  Oo.uint32_value = Mi.uint32();
                  break;
                }
                case 5: {
                  Oo.uint64_value = Mi.uint64();
                  break;
                }
                case 6: {
                  Oo.sint32_value = Mi.sint32();
                  break;
                }
                case 7: {
                  Oo.sint64_value = Mi.sint64();
                  break;
                }
                case 8: {
                  Oo.fixed32_value = Mi.fixed32();
                  break;
                }
                case 9: {
                  Oo.fixed64_value = Mi.fixed64();
                  break;
                }
                case 10: {
                  Oo.sfixed32_value = Mi.sfixed32();
                  break;
                }
                case 11: {
                  Oo.sfixed64_value = Mi.sfixed64();
                  break;
                }
                case 12: {
                  Oo.bool_value = Mi.bool();
                  break;
                }
                case 13: {
                  Oo.string_value = Mi.string();
                  break;
                }
                case 14: {
                  Oo.bytes_value = Mi.bytes();
                  break;
                }
                default:
                  Mi.skipType(Ro & 7);
                  break;
              }
            }
            return Oo;
          }, Ri.decodeDelimited = function(Mi) {
            return Mi instanceof Oe || (Mi = new Oe(Mi)), this.decode(Mi, Mi.uint32());
          }, Ri.verify = function(Mi) {
            if (typeof Mi != "object" || Mi === null)
              return "object expected";
            var Ii = {};
            if (Mi.message_value != null && Mi.hasOwnProperty("message_value")) {
              Ii.kind = 1;
              {
                var Ci = Ei.google.protobuf.Any.verify(Mi.message_value);
                if (Ci)
                  return "message_value." + Ci;
              }
            }
            if (Mi.int32_value != null && Mi.hasOwnProperty("int32_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.int32_value))
                return "int32_value: integer expected";
            }
            if (Mi.int64_value != null && Mi.hasOwnProperty("int64_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.int64_value) && !(Mi.int64_value && wi.isInteger(Mi.int64_value.low) && wi.isInteger(Mi.int64_value.high)))
                return "int64_value: integer|Long expected";
            }
            if (Mi.uint32_value != null && Mi.hasOwnProperty("uint32_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.uint32_value))
                return "uint32_value: integer expected";
            }
            if (Mi.uint64_value != null && Mi.hasOwnProperty("uint64_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.uint64_value) && !(Mi.uint64_value && wi.isInteger(Mi.uint64_value.low) && wi.isInteger(Mi.uint64_value.high)))
                return "uint64_value: integer|Long expected";
            }
            if (Mi.sint32_value != null && Mi.hasOwnProperty("sint32_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.sint32_value))
                return "sint32_value: integer expected";
            }
            if (Mi.sint64_value != null && Mi.hasOwnProperty("sint64_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.sint64_value) && !(Mi.sint64_value && wi.isInteger(Mi.sint64_value.low) && wi.isInteger(Mi.sint64_value.high)))
                return "sint64_value: integer|Long expected";
            }
            if (Mi.fixed32_value != null && Mi.hasOwnProperty("fixed32_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.fixed32_value))
                return "fixed32_value: integer expected";
            }
            if (Mi.fixed64_value != null && Mi.hasOwnProperty("fixed64_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.fixed64_value) && !(Mi.fixed64_value && wi.isInteger(Mi.fixed64_value.low) && wi.isInteger(Mi.fixed64_value.high)))
                return "fixed64_value: integer|Long expected";
            }
            if (Mi.sfixed32_value != null && Mi.hasOwnProperty("sfixed32_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.sfixed32_value))
                return "sfixed32_value: integer expected";
            }
            if (Mi.sfixed64_value != null && Mi.hasOwnProperty("sfixed64_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isInteger(Mi.sfixed64_value) && !(Mi.sfixed64_value && wi.isInteger(Mi.sfixed64_value.low) && wi.isInteger(Mi.sfixed64_value.high)))
                return "sfixed64_value: integer|Long expected";
            }
            if (Mi.bool_value != null && Mi.hasOwnProperty("bool_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, typeof Mi.bool_value != "boolean")
                return "bool_value: boolean expected";
            }
            if (Mi.string_value != null && Mi.hasOwnProperty("string_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !wi.isString(Mi.string_value))
                return "string_value: string expected";
            }
            if (Mi.bytes_value != null && Mi.hasOwnProperty("bytes_value")) {
              if (Ii.kind === 1)
                return "kind: multiple values";
              if (Ii.kind = 1, !(Mi.bytes_value && typeof Mi.bytes_value.length == "number" || wi.isString(Mi.bytes_value)))
                return "bytes_value: buffer expected";
            }
            return null;
          }, Ri.fromObject = function(Mi) {
            if (Mi instanceof Ei.koinos.chain.value_type)
              return Mi;
            var Ii = new Ei.koinos.chain.value_type();
            if (Mi.message_value != null) {
              if (typeof Mi.message_value != "object")
                throw TypeError(".koinos.chain.value_type.message_value: object expected");
              Ii.message_value = Ei.google.protobuf.Any.fromObject(Mi.message_value);
            }
            return Mi.int32_value != null && (Ii.int32_value = Mi.int32_value | 0), Mi.int64_value != null && (wi.Long ? (Ii.int64_value = wi.Long.fromValue(Mi.int64_value)).unsigned = !1 : typeof Mi.int64_value == "string" ? Ii.int64_value = parseInt(Mi.int64_value, 10) : typeof Mi.int64_value == "number" ? Ii.int64_value = Mi.int64_value : typeof Mi.int64_value == "object" && (Ii.int64_value = new wi.LongBits(Mi.int64_value.low >>> 0, Mi.int64_value.high >>> 0).toNumber())), Mi.uint32_value != null && (Ii.uint32_value = Mi.uint32_value >>> 0), Mi.uint64_value != null && (wi.Long ? (Ii.uint64_value = wi.Long.fromValue(Mi.uint64_value)).unsigned = !0 : typeof Mi.uint64_value == "string" ? Ii.uint64_value = parseInt(Mi.uint64_value, 10) : typeof Mi.uint64_value == "number" ? Ii.uint64_value = Mi.uint64_value : typeof Mi.uint64_value == "object" && (Ii.uint64_value = new wi.LongBits(Mi.uint64_value.low >>> 0, Mi.uint64_value.high >>> 0).toNumber(!0))), Mi.sint32_value != null && (Ii.sint32_value = Mi.sint32_value | 0), Mi.sint64_value != null && (wi.Long ? (Ii.sint64_value = wi.Long.fromValue(Mi.sint64_value)).unsigned = !1 : typeof Mi.sint64_value == "string" ? Ii.sint64_value = parseInt(Mi.sint64_value, 10) : typeof Mi.sint64_value == "number" ? Ii.sint64_value = Mi.sint64_value : typeof Mi.sint64_value == "object" && (Ii.sint64_value = new wi.LongBits(Mi.sint64_value.low >>> 0, Mi.sint64_value.high >>> 0).toNumber())), Mi.fixed32_value != null && (Ii.fixed32_value = Mi.fixed32_value >>> 0), Mi.fixed64_value != null && (wi.Long ? (Ii.fixed64_value = wi.Long.fromValue(Mi.fixed64_value)).unsigned = !1 : typeof Mi.fixed64_value == "string" ? Ii.fixed64_value = parseInt(Mi.fixed64_value, 10) : typeof Mi.fixed64_value == "number" ? Ii.fixed64_value = Mi.fixed64_value : typeof Mi.fixed64_value == "object" && (Ii.fixed64_value = new wi.LongBits(Mi.fixed64_value.low >>> 0, Mi.fixed64_value.high >>> 0).toNumber())), Mi.sfixed32_value != null && (Ii.sfixed32_value = Mi.sfixed32_value | 0), Mi.sfixed64_value != null && (wi.Long ? (Ii.sfixed64_value = wi.Long.fromValue(Mi.sfixed64_value)).unsigned = !1 : typeof Mi.sfixed64_value == "string" ? Ii.sfixed64_value = parseInt(Mi.sfixed64_value, 10) : typeof Mi.sfixed64_value == "number" ? Ii.sfixed64_value = Mi.sfixed64_value : typeof Mi.sfixed64_value == "object" && (Ii.sfixed64_value = new wi.LongBits(Mi.sfixed64_value.low >>> 0, Mi.sfixed64_value.high >>> 0).toNumber())), Mi.bool_value != null && (Ii.bool_value = !!Mi.bool_value), Mi.string_value != null && (Ii.string_value = String(Mi.string_value)), Mi.bytes_value != null && (typeof Mi.bytes_value == "string" ? wi.base64.decode(Mi.bytes_value, Ii.bytes_value = wi.newBuffer(wi.base64.length(Mi.bytes_value)), 0) : Mi.bytes_value.length >= 0 && (Ii.bytes_value = Mi.bytes_value)), Ii;
          }, Ri.toObject = function(Mi, Ii) {
            Ii || (Ii = {});
            var Ci = {};
            return Mi.message_value != null && Mi.hasOwnProperty("message_value") && (Ci.message_value = Ei.google.protobuf.Any.toObject(Mi.message_value, Ii), Ii.oneofs && (Ci.kind = "message_value")), Mi.int32_value != null && Mi.hasOwnProperty("int32_value") && (Ci.int32_value = Mi.int32_value, Ii.oneofs && (Ci.kind = "int32_value")), Mi.int64_value != null && Mi.hasOwnProperty("int64_value") && (typeof Mi.int64_value == "number" ? Ci.int64_value = Ii.longs === String ? String(Mi.int64_value) : Mi.int64_value : Ci.int64_value = Ii.longs === String ? wi.Long.prototype.toString.call(Mi.int64_value) : Ii.longs === Number ? new wi.LongBits(Mi.int64_value.low >>> 0, Mi.int64_value.high >>> 0).toNumber() : Mi.int64_value, Ii.oneofs && (Ci.kind = "int64_value")), Mi.uint32_value != null && Mi.hasOwnProperty("uint32_value") && (Ci.uint32_value = Mi.uint32_value, Ii.oneofs && (Ci.kind = "uint32_value")), Mi.uint64_value != null && Mi.hasOwnProperty("uint64_value") && (typeof Mi.uint64_value == "number" ? Ci.uint64_value = Ii.longs === String ? String(Mi.uint64_value) : Mi.uint64_value : Ci.uint64_value = Ii.longs === String ? wi.Long.prototype.toString.call(Mi.uint64_value) : Ii.longs === Number ? new wi.LongBits(Mi.uint64_value.low >>> 0, Mi.uint64_value.high >>> 0).toNumber(!0) : Mi.uint64_value, Ii.oneofs && (Ci.kind = "uint64_value")), Mi.sint32_value != null && Mi.hasOwnProperty("sint32_value") && (Ci.sint32_value = Mi.sint32_value, Ii.oneofs && (Ci.kind = "sint32_value")), Mi.sint64_value != null && Mi.hasOwnProperty("sint64_value") && (typeof Mi.sint64_value == "number" ? Ci.sint64_value = Ii.longs === String ? String(Mi.sint64_value) : Mi.sint64_value : Ci.sint64_value = Ii.longs === String ? wi.Long.prototype.toString.call(Mi.sint64_value) : Ii.longs === Number ? new wi.LongBits(Mi.sint64_value.low >>> 0, Mi.sint64_value.high >>> 0).toNumber() : Mi.sint64_value, Ii.oneofs && (Ci.kind = "sint64_value")), Mi.fixed32_value != null && Mi.hasOwnProperty("fixed32_value") && (Ci.fixed32_value = Mi.fixed32_value, Ii.oneofs && (Ci.kind = "fixed32_value")), Mi.fixed64_value != null && Mi.hasOwnProperty("fixed64_value") && (typeof Mi.fixed64_value == "number" ? Ci.fixed64_value = Ii.longs === String ? String(Mi.fixed64_value) : Mi.fixed64_value : Ci.fixed64_value = Ii.longs === String ? wi.Long.prototype.toString.call(Mi.fixed64_value) : Ii.longs === Number ? new wi.LongBits(Mi.fixed64_value.low >>> 0, Mi.fixed64_value.high >>> 0).toNumber() : Mi.fixed64_value, Ii.oneofs && (Ci.kind = "fixed64_value")), Mi.sfixed32_value != null && Mi.hasOwnProperty("sfixed32_value") && (Ci.sfixed32_value = Mi.sfixed32_value, Ii.oneofs && (Ci.kind = "sfixed32_value")), Mi.sfixed64_value != null && Mi.hasOwnProperty("sfixed64_value") && (typeof Mi.sfixed64_value == "number" ? Ci.sfixed64_value = Ii.longs === String ? String(Mi.sfixed64_value) : Mi.sfixed64_value : Ci.sfixed64_value = Ii.longs === String ? wi.Long.prototype.toString.call(Mi.sfixed64_value) : Ii.longs === Number ? new wi.LongBits(Mi.sfixed64_value.low >>> 0, Mi.sfixed64_value.high >>> 0).toNumber() : Mi.sfixed64_value, Ii.oneofs && (Ci.kind = "sfixed64_value")), Mi.bool_value != null && Mi.hasOwnProperty("bool_value") && (Ci.bool_value = Mi.bool_value, Ii.oneofs && (Ci.kind = "bool_value")), Mi.string_value != null && Mi.hasOwnProperty("string_value") && (Ci.string_value = Mi.string_value, Ii.oneofs && (Ci.kind = "string_value")), Mi.bytes_value != null && Mi.hasOwnProperty("bytes_value") && (Ci.bytes_value = Ii.bytes === String ? wi.base64.encode(Mi.bytes_value, 0, Mi.bytes_value.length) : Ii.bytes === Array ? Array.prototype.slice.call(Mi.bytes_value) : Mi.bytes_value, Ii.oneofs && (Ci.kind = "bytes_value")), Ci;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Mi) {
            return Mi === void 0 && (Mi = "type.googleapis.com"), Mi + "/koinos.chain.value_type";
          }, Ri;
        }(), xi.enum_type = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.name = "", Ri.prototype.number = 0, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.name != null && Object.hasOwnProperty.call(Oi, "name") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(Oi.name), Oi.number != null && Object.hasOwnProperty.call(Oi, "number") && Mi.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(Oi.number), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.chain.enum_type(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.name = Oi.string();
                  break;
                }
                case 2: {
                  Ci.number = Oi.int32();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.name != null && Oi.hasOwnProperty("name") && !wi.isString(Oi.name) ? "name: string expected" : Oi.number != null && Oi.hasOwnProperty("number") && !wi.isInteger(Oi.number) ? "number: integer expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.chain.enum_type)
              return Oi;
            var Mi = new Ei.koinos.chain.enum_type();
            return Oi.name != null && (Mi.name = String(Oi.name)), Oi.number != null && (Mi.number = Oi.number | 0), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Ii.name = "", Ii.number = 0), Oi.name != null && Oi.hasOwnProperty("name") && (Ii.name = Oi.name), Oi.number != null && Oi.hasOwnProperty("number") && (Ii.number = Oi.number), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.chain.enum_type";
          }, Ri;
        }(), xi.list_type = function() {
          function Ri(Ti) {
            if (this.values = [], Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.values = wi.emptyArray, Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            if (Mi || (Mi = Si.create()), Oi.values != null && Oi.values.length)
              for (var Ii = 0; Ii < Oi.values.length; ++Ii)
                Ei.koinos.chain.value_type.encode(Oi.values[Ii], Mi.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.koinos.chain.list_type(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.values && Ci.values.length || (Ci.values = []), Ci.values.push(Ei.koinos.chain.value_type.decode(Oi, Oi.uint32()));
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            if (typeof Oi != "object" || Oi === null)
              return "object expected";
            if (Oi.values != null && Oi.hasOwnProperty("values")) {
              if (!Array.isArray(Oi.values))
                return "values: array expected";
              for (var Mi = 0; Mi < Oi.values.length; ++Mi) {
                var Ii = Ei.koinos.chain.value_type.verify(Oi.values[Mi]);
                if (Ii)
                  return "values." + Ii;
              }
            }
            return null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.koinos.chain.list_type)
              return Oi;
            var Mi = new Ei.koinos.chain.list_type();
            if (Oi.values) {
              if (!Array.isArray(Oi.values))
                throw TypeError(".koinos.chain.list_type.values: array expected");
              Mi.values = [];
              for (var Ii = 0; Ii < Oi.values.length; ++Ii) {
                if (typeof Oi.values[Ii] != "object")
                  throw TypeError(".koinos.chain.list_type.values: object expected");
                Mi.values[Ii] = Ei.koinos.chain.value_type.fromObject(Oi.values[Ii]);
              }
            }
            return Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            if ((Mi.arrays || Mi.defaults) && (Ii.values = []), Oi.values && Oi.values.length) {
              Ii.values = [];
              for (var Ci = 0; Ci < Oi.values.length; ++Ci)
                Ii.values[Ci] = Ei.koinos.chain.value_type.toObject(Oi.values[Ci], Mi);
            }
            return Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/koinos.chain.list_type";
          }, Ri;
        }(), xi;
      }(), $i;
    }(), Ei.google = function() {
      var $i = {};
      return $i.protobuf = function() {
        var xi = {};
        return xi.Any = function() {
          function Ri(Ti) {
            if (Ti)
              for (var Oi = Object.keys(Ti), Mi = 0; Mi < Oi.length; ++Mi)
                Ti[Oi[Mi]] != null && (this[Oi[Mi]] = Ti[Oi[Mi]]);
          }
          return Ri.prototype.type_url = "", Ri.prototype.value = wi.newBuffer([]), Ri.create = function(Oi) {
            return new Ri(Oi);
          }, Ri.encode = function(Oi, Mi) {
            return Mi || (Mi = Si.create()), Oi.type_url != null && Object.hasOwnProperty.call(Oi, "type_url") && Mi.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(Oi.type_url), Oi.value != null && Object.hasOwnProperty.call(Oi, "value") && Mi.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(Oi.value), Mi;
          }, Ri.encodeDelimited = function(Oi, Mi) {
            return this.encode(Oi, Mi).ldelim();
          }, Ri.decode = function(Oi, Mi) {
            Oi instanceof Oe || (Oi = Oe.create(Oi));
            for (var Ii = Mi === void 0 ? Oi.len : Oi.pos + Mi, Ci = new Ei.google.protobuf.Any(); Oi.pos < Ii; ) {
              var Oo = Oi.uint32();
              switch (Oo >>> 3) {
                case 1: {
                  Ci.type_url = Oi.string();
                  break;
                }
                case 2: {
                  Ci.value = Oi.bytes();
                  break;
                }
                default:
                  Oi.skipType(Oo & 7);
                  break;
              }
            }
            return Ci;
          }, Ri.decodeDelimited = function(Oi) {
            return Oi instanceof Oe || (Oi = new Oe(Oi)), this.decode(Oi, Oi.uint32());
          }, Ri.verify = function(Oi) {
            return typeof Oi != "object" || Oi === null ? "object expected" : Oi.type_url != null && Oi.hasOwnProperty("type_url") && !wi.isString(Oi.type_url) ? "type_url: string expected" : Oi.value != null && Oi.hasOwnProperty("value") && !(Oi.value && typeof Oi.value.length == "number" || wi.isString(Oi.value)) ? "value: buffer expected" : null;
          }, Ri.fromObject = function(Oi) {
            if (Oi instanceof Ei.google.protobuf.Any)
              return Oi;
            var Mi = new Ei.google.protobuf.Any();
            return Oi.type_url != null && (Mi.type_url = String(Oi.type_url)), Oi.value != null && (typeof Oi.value == "string" ? wi.base64.decode(Oi.value, Mi.value = wi.newBuffer(wi.base64.length(Oi.value)), 0) : Oi.value.length >= 0 && (Mi.value = Oi.value)), Mi;
          }, Ri.toObject = function(Oi, Mi) {
            Mi || (Mi = {});
            var Ii = {};
            return Mi.defaults && (Ii.type_url = "", Mi.bytes === String ? Ii.value = "" : (Ii.value = [], Mi.bytes !== Array && (Ii.value = wi.newBuffer(Ii.value)))), Oi.type_url != null && Oi.hasOwnProperty("type_url") && (Ii.type_url = Oi.type_url), Oi.value != null && Oi.hasOwnProperty("value") && (Ii.value = Mi.bytes === String ? wi.base64.encode(Oi.value, 0, Oi.value.length) : Mi.bytes === Array ? Array.prototype.slice.call(Oi.value) : Oi.value), Ii;
          }, Ri.prototype.toJSON = function() {
            return this.constructor.toObject(this, e.util.toJSONOptions);
          }, Ri.getTypeUrl = function(Oi) {
            return Oi === void 0 && (Oi = "type.googleapis.com"), Oi + "/google.protobuf.Any";
          }, Ri;
        }(), xi;
      }(), $i;
    }(), Ei;
  });
})(protocolProto);
var protocolProtoExports = protocolProto.exports, __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe);
  var wi = Object.getOwnPropertyDescriptor(e, Oe);
  (!wi || ("get" in wi ? !e.__esModule : wi.writable || wi.configurable)) && (wi = { enumerable: !0, get: function() {
    return e[Oe];
  } }), Object.defineProperty(se, Si, wi);
} : function(se, e, Oe, Si) {
  Si === void 0 && (Si = Oe), se[Si] = e[Oe];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(se, e) {
  Object.defineProperty(se, "default", { enumerable: !0, value: e });
} : function(se, e) {
  se.default = e;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(se) {
  if (se && se.__esModule)
    return se;
  var e = {};
  if (se != null)
    for (var Oe in se)
      Oe !== "default" && Object.prototype.hasOwnProperty.call(se, Oe) && __createBinding(e, se, Oe);
  return __setModuleDefault(e, se), e;
};
Object.defineProperty(Signer$1, "__esModule", { value: !0 });
Signer$1.Signer = void 0;
const sha256_1 = sha256, secp = __importStar(lib), utils_1$1 = utils$1, protocol_proto_js_1$1 = protocolProtoExports, btypeBlockHeader = {
  previous: { type: "bytes", btype: "BLOCK_ID" },
  height: { type: "uint64" },
  timestamp: { type: "uint64" },
  previous_state_merkle_root: { type: "bytes" },
  transaction_merkle_root: { type: "bytes" },
  signer: { type: "bytes", btype: "ADDRESS" }
}, btypeTransactionHeader = {
  chain_id: { type: "bytes" },
  rc_limit: { type: "uint64" },
  nonce: { type: "bytes" },
  operation_merkle_root: { type: "bytes" },
  payer: { type: "bytes", btype: "ADDRESS" },
  payee: { type: "bytes", btype: "ADDRESS" }
}, btypesOperation = {
  upload_contract: {
    type: "object",
    subtypes: {
      contract_id: { type: "bytes", btype: "CONTRACT_ID" },
      bytecode: { type: "bytes" },
      abi: { type: "string" },
      authorizes_call_contract: { type: "bool" },
      authorizes_transaction_application: { type: "bool" },
      authorizes_upload_contract: { type: "bool" }
    }
  },
  call_contract: {
    type: "object",
    subtypes: {
      contract_id: { type: "bytes", btype: "CONTRACT_ID" },
      entry_point: { type: "uint32" },
      args: { type: "bytes" }
    }
  },
  set_system_call: {
    type: "object",
    subtypes: {
      call_id: { type: "uint32" },
      target: {
        type: "object",
        subtypes: {
          thunk_id: { type: "uint32" },
          system_call_bundle: {
            type: "object",
            subtypes: {
              contract_id: { type: "bytes", btype: "CONTRACT_ID" },
              entry_point: { type: "uint32" }
            }
          }
        }
      }
    }
  },
  set_system_contract: {
    type: "object",
    subtypes: {
      contract_id: { type: "bytes", btype: "CONTRACT_ID" },
      system_contract: { type: "bool" }
    }
  }
};
class Signer {
  /**
   * The constructor receives de private key as hexstring, bigint or Uint8Array.
   * See also the functions [[Signer.fromWif]] and [[Signer.fromSeed]]
   * to create the signer from the WIF or Seed respectively.
   *
   * @param privateKey - Private key as hexstring, bigint or Uint8Array
   * @param compressed - compressed format is true by default
   * @param provider - provider to connect with the blockchain
   * @example
   * ```ts
   * const privateKey = "ec8601a24f81decd57f4b611b5ac6eb801cb3780bb02c0f9cdfe9d09daaddf9c";
   * cons signer = new Signer({ privateKey });
   * console.log(signer.getAddress());
   * // 1MbL6mG8ASAvSYdoMnGUfG3ZXkmQ2dpL5b
   * ```
   */
  constructor(e) {
    this.chainId = "", this.compressed = typeof e.compressed > "u" ? !0 : e.compressed, this.privateKey = e.privateKey, this.provider = e.provider, typeof e.privateKey == "string" ? (this.publicKey = secp.getPublicKey(e.privateKey, this.compressed), this.address = (0, utils_1$1.bitcoinAddress)(this.publicKey)) : (this.publicKey = secp.getPublicKey(e.privateKey, this.compressed), this.address = (0, utils_1$1.bitcoinAddress)(this.publicKey)), e.chainId && (this.chainId = e.chainId), this.sendOptions = {
      broadcast: !0,
      ...e.sendOptions
    };
  }
  /**
   * Function to import a private key from the WIF
   * @param wif  - Private key in WIF format
   * @example
   * ```ts
   * const signer = Signer.fromWif("L59UtJcTdNBnrH2QSBA5beSUhRufRu3g6tScDTite6Msuj7U93tM")
   * console.log(signer.getAddress());
   * // 1MbL6mG8ASAvSYdoMnGUfG3ZXkmQ2dpL5b
   * ```
   * @returns Signer object
   */
  static fromWif(e, Oe = !0) {
    const Si = Oe === void 0 ? e[0] !== "5" : Oe, wi = (0, utils_1$1.bitcoinDecode)(e);
    return new Signer({
      privateKey: (0, utils_1$1.toHexString)(wi),
      compressed: Si
    });
  }
  /**
   * Function to import a private key from the seed
   * @param seed - Seed words
   * @param compressed -
   * @example
   * ```ts
   * const signer = Signer.fromSeed("my seed");
   * console.log(signer.getAddress());
   * // 1BqtgWBcqm9cSZ97avLGZGJdgso7wx6pCA
   * ```
   * @returns Signer object
   */
  static fromSeed(e, Oe = !0) {
    const Si = (0, sha256_1.sha256)(e);
    return new Signer({ privateKey: Si, compressed: Oe });
  }
  /**
   * @param compressed - determines if the address should be
   * derived from the compressed public key (default) or the public key
   * @returns Signer address
   */
  getAddress(e = !0) {
    if (typeof this.privateKey == "string") {
      const Si = secp.getPublicKey(this.privateKey, e);
      return (0, utils_1$1.bitcoinAddress)(Si);
    }
    const Oe = secp.getPublicKey(this.privateKey, e);
    return (0, utils_1$1.bitcoinAddress)(Oe);
  }
  /**
   * Function to get the private key in hex format or wif format
   * @param format - The format must be "hex" (default) or "wif"
   * @param compressed - Optional arg when using WIF format. By default it
   * uses the compressed value defined in the signer
   * @example
   * ```ts
   * const signer = Signer.fromSeed("one two three four five six");
   * console.log(signer.getPrivateKey());
   * // bab7fd6e5bd624f4ea0c33f7e7219262a6fa93a945a8964d9f110148286b7b37
   *
   * console.log(signer.getPrivateKey("wif"));
   * // L3UfgFJWmbVziGB1uZBjkG1UjKkF7hhpXWY7mbTUdmycmvXCVtiL
   *
   * console.log(signer.getPrivateKey("wif", false));
   * // 5KEX4TMHG66fT7cM9HMZLmdp4hVq4LC4X2Fkg6zeypM5UteWmtd
   * ```
   */
  getPrivateKey(e = "hex", Oe = !1) {
    let Si;
    this.privateKey instanceof Uint8Array ? Si = (0, utils_1$1.toHexString)(this.privateKey) : typeof this.privateKey == "string" ? Si = this.privateKey : Si = BigInt(this.privateKey).toString(16).padStart(64, "0");
    const wi = Oe === void 0 ? this.compressed : Oe;
    switch (e) {
      case "hex":
        return Si;
      case "wif":
        return (0, utils_1$1.bitcoinEncode)((0, utils_1$1.toUint8Array)(Si), "private", wi);
      default:
        throw new Error(`Invalid format ${e}`);
    }
  }
  /**
   * Function to sign a hash value. It returns the bytes signature.
   * The signature is in compact format with the recovery byte
   * @param hash - Hash value. Also known as digest
   */
  async signHash(e) {
    const [Oe, Si] = await secp.sign(e, this.privateKey, {
      recovered: !0,
      canonical: !0,
      der: !1
      // compact signature
    }), wi = new Uint8Array(65);
    return wi.set([Si + 31], 0), wi.set(Oe, 1), wi;
  }
  /**
   * Function to sign a message, which could be a string or a Uint8Array
   */
  async signMessage(e) {
    return this.signHash((0, sha256_1.sha256)(e));
  }
  /**
   * Function to sign a transaction. It's important to remark that
   * the transaction parameter is modified inside this function.
   * @param tx - Unsigned transaction
   */
  async signTransaction(e, Oe) {
    if (!e.id)
      throw new Error("Missing transaction id");
    const Si = (0, utils_1$1.toUint8Array)(e.id.slice(6)), wi = await this.signHash(Si);
    return e.signatures || (e.signatures = []), e.signatures.push((0, utils_1$1.encodeBase64url)(wi)), e;
  }
  /**
   * Function to sign a block for federated consensus. That is,
   * just the ecdsa signature. For other algorithms, like PoW,
   * you have to sign the block and then process the signature
   * to add the extra data (nonce in the case of PoW).
   * @param block - Unsigned block
   */
  async signBlock(e) {
    if (!e.id)
      throw new Error("Missing block id");
    const Oe = (0, utils_1$1.toUint8Array)(e.id.slice(6)), Si = await this.signHash(Oe);
    return e.signature = (0, utils_1$1.encodeBase64url)(Si), e;
  }
  /**
   * Function to sign and send a transaction. It internally uses
   * [[Provider.sendTransaction]]
   * @param transaction - Transaction to send. It will be signed inside this
   * function if it is not signed yet
   * @param options - Options for sending the transaction
   */
  async sendTransaction(e, Oe) {
    var Si;
    if ((!e.signatures || !(!((Si = e.signatures) === null || Si === void 0) && Si.length)) && (e = await this.signTransaction(e, Oe != null && Oe.sendAbis ? Oe.abis : void 0)), !this.provider)
      throw new Error("provider is undefined");
    const wi = {
      ...this.sendOptions,
      ...Oe
    };
    return wi.beforeSend && await wi.beforeSend(e, Oe), this.provider.sendTransaction(e, wi.broadcast);
  }
  /**
   * Function to recover the public key from hash and signature
   * @param hash - hash sha256
   * @param signature - compact signature
   * @param compressed - default true
   */
  static recoverPublicKey(e, Oe, Si = !0) {
    const wi = (0, utils_1$1.toHexString)(Oe), Ei = +`0x${wi.slice(0, 2)}` - 31, $i = wi.slice(2, 66), xi = wi.slice(66), Ri = BigInt(`0x${$i}`), Ti = BigInt(`0x${xi}`), Oi = new secp.Signature(Ri, Ti), Mi = secp.recoverPublicKey((0, utils_1$1.toHexString)(e), Oi.toHex(), Ei);
    if (!Mi)
      throw new Error("Public key cannot be recovered");
    return Si ? secp.Point.fromHex(Mi).toHex(!0) : (0, utils_1$1.toHexString)(Mi);
  }
  static recoverAddress(e, Oe, Si = !0) {
    return (0, utils_1$1.bitcoinAddress)((0, utils_1$1.toUint8Array)(Signer.recoverPublicKey(e, Oe, Si)));
  }
  /**
   * Function to recover the publics keys from a signed
   * transaction or block.
   * The output format can be compressed (default) or uncompressed.
   *
   * @example
   * ```ts
   * const publicKeys = await Signer.recoverPublicKeys(tx);
   * ```
   *
   * If the signature data contains more data, like in the
   * blocks for PoW consensus, use the "transformSignature"
   * function to extract the signature.
   *
   * @example
   * ```ts
   *  const powDescriptorJson = {
   *    nested: {
   *      mypackage: {
   *        nested: {
   *          pow_signature_data: {
   *            fields: {
   *              nonce: {
   *                type: "bytes",
   *                id: 1,
   *              },
   *              recoverable_signature: {
   *                type: "bytes",
   *                id: 2,
   *              },
   *            },
   *          },
   *        },
   *      },
   *    },
   *  };
   *
   *  const serializer = new Serializer(powDescriptorJson, {
   *   defaultTypeName: "pow_signature_data",
   *  });
   *
   *  const publicKeys = await signer.recoverPublicKeys(block, {
   *    transformSignature: async (signatureData) => {
   *      const powSignatureData = await serializer.deserialize(signatureData);
   *      return powSignatureData.recoverable_signature;
   *    },
   *  });
   * ```
   */
  async recoverPublicKeys(e, Oe) {
    let Si = !0;
    Oe && Oe.compressed !== void 0 && (Si = Oe.compressed);
    let wi = [], Ei;
    const $i = e;
    if ($i.signature) {
      if (!$i.header)
        throw new Error("Missing block header");
      if (!$i.signature)
        throw new Error("Missing block signature");
      wi = [$i.signature];
      const Ri = (0, utils_1$1.btypeDecode)($i.header, btypeBlockHeader, !1), Ti = protocol_proto_js_1$1.koinos.protocol.block_header.create(Ri);
      Ei = protocol_proto_js_1$1.koinos.protocol.block_header.encode(Ti).finish();
    } else {
      const Ri = e;
      if (!Ri.header)
        throw new Error("Missing transaction header");
      if (!Ri.signatures)
        throw new Error("Missing transaction signatures");
      wi = Ri.signatures;
      const Ti = (0, utils_1$1.btypeDecode)(Ri.header, btypeTransactionHeader, !1), Oi = protocol_proto_js_1$1.koinos.protocol.transaction_header.create(Ti);
      Ei = protocol_proto_js_1$1.koinos.protocol.transaction_header.encode(Oi).finish();
    }
    const xi = (0, sha256_1.sha256)(Ei);
    return Promise.all(wi.map(async (Ri) => (Oe && typeof Oe.transformSignature == "function" && (Ri = await Oe.transformSignature(Ri)), Signer.recoverPublicKey(xi, (0, utils_1$1.decodeBase64url)(Ri), Si))));
  }
  /**
   * Function to recover the signer addresses from a signed
   * transaction or block.
   * The output format can be compressed (default) or uncompressed.
   * @example
   * ```ts
   * const addresses = await signer.recoverAddress(tx);
   * ```
   *
   * If the signature data contains more data, like in the
   * blocks for PoW consensus, use the "transformSignature"
   * function to extract the signature.
   *
   * @example
   * ```ts
   *  const powDescriptorJson = {
   *    nested: {
   *      mypackage: {
   *        nested: {
   *          pow_signature_data: {
   *            fields: {
   *              nonce: {
   *                type: "bytes",
   *                id: 1,
   *              },
   *              recoverable_signature: {
   *                type: "bytes",
   *                id: 2,
   *              },
   *            },
   *          },
   *        },
   *      },
   *    },
   *  };
   *
   *  const serializer = new Serializer(powDescriptorJson, {
   *   defaultTypeName: "pow_signature_data",
   *  });
   *
   *  const addresses = await signer.recoverAddress(block, {
   *    transformSignature: async (signatureData) => {
   *      const powSignatureData = await serializer.deserialize(signatureData);
   *      return powSignatureData.recoverable_signature;
   *    },
   *  });
   * ```
   */
  async recoverAddresses(e, Oe) {
    return (await this.recoverPublicKeys(e, Oe)).map((wi) => (0, utils_1$1.bitcoinAddress)((0, utils_1$1.toUint8Array)(wi)));
  }
  /**
   * Function to prepare a transaction
   * @param tx - Do not set the nonce to get it from the blockchain
   * using the provider. The rc_limit is 1e8 by default.
   * @returns A prepared transaction. ()
   */
  async prepareTransaction(e) {
    var Oe, Si;
    e.header || (e.header = {});
    const wi = (Oe = e.header.payer) !== null && Oe !== void 0 ? Oe : this.address, { payee: Ei } = e.header;
    let $i;
    if (e.header.nonce === void 0) {
      if (!this.provider)
        throw new Error("Cannot get the nonce because provider is undefined. To skip this call set a nonce in the transaction header");
      $i = await this.provider.getNextNonce(Ei || wi);
    } else
      $i = e.header.nonce;
    let xi;
    if (e.header.rc_limit === void 0) {
      if (!this.provider)
        throw new Error("Cannot get the rc_limit because provider is undefined. To skip this call set a rc_limit in the transaction header");
      xi = await this.provider.getAccountRc(wi);
    } else
      xi = e.header.rc_limit;
    let Ri = e.header.chain_id || this.chainId;
    if (!Ri) {
      if (!this.provider)
        throw new Error("Cannot get the chain_id because provider is undefined. To skip this call set a chain_id in the Signer");
      Ri = await this.provider.getChainId(), this.chainId = Ri;
    }
    const Ti = [];
    if (e.operations)
      for (let Ro = 0; Ro < ((Si = e.operations) === null || Si === void 0 ? void 0 : Si.length); Ro += 1) {
        const Bo = (0, utils_1$1.btypeDecode)(e.operations[Ro], btypesOperation, !1), Fo = protocol_proto_js_1$1.koinos.protocol.operation.create(Bo), Io = protocol_proto_js_1$1.koinos.protocol.operation.encode(Fo).finish();
        Ti.push((0, sha256_1.sha256)(Io));
      }
    const Oi = (0, utils_1$1.encodeBase64url)(new Uint8Array([
      // multihash sha256: 18, 32
      18,
      32,
      ...(0, utils_1$1.calculateMerkleRoot)(Ti)
    ]));
    e.header = {
      chain_id: Ri,
      rc_limit: xi,
      nonce: $i,
      operation_merkle_root: Oi,
      payer: wi,
      ...Ei && { payee: Ei }
      // TODO: Option to resolve names (payer, payee)
    };
    const Mi = (0, utils_1$1.btypeDecode)(e.header, btypeTransactionHeader, !1), Ii = protocol_proto_js_1$1.koinos.protocol.transaction_header.create(Mi), Ci = protocol_proto_js_1$1.koinos.protocol.transaction_header.encode(Ii).finish(), Oo = (0, sha256_1.sha256)(Ci);
    return e.id = `0x1220${(0, utils_1$1.toHexString)(Oo)}`, e;
  }
  /**
   * Function to prepare a block
   * @param block -
   * @returns A prepared block. ()
   */
  async prepareBlock(e) {
    var Oe;
    e.header || (e.header = {});
    const Si = [];
    if (e.transactions)
      for (let Mi = 0; Mi < e.transactions.length; Mi++) {
        const Ii = e.transactions[Mi], Ci = (0, utils_1$1.btypeDecode)(Ii.header, btypeTransactionHeader, !1), Oo = protocol_proto_js_1$1.koinos.protocol.transaction_header.create(Ci), Ro = protocol_proto_js_1$1.koinos.protocol.transaction_header.encode(Oo).finish();
        Si.push((0, sha256_1.sha256)(Ro));
        let Bo = new Uint8Array();
        (Oe = Ii.signatures) === null || Oe === void 0 || Oe.forEach((Fo) => {
          Bo = new Uint8Array([
            ...Bo,
            ...(0, utils_1$1.decodeBase64url)(Fo)
          ]);
        }), Si.push((0, sha256_1.sha256)(Bo));
      }
    let { height: wi, previous: Ei, previous_state_merkle_root: $i } = e.header;
    if (!wi || !Ei || !$i) {
      if (!this.provider)
        throw new Error("Cannot get the head info because provider is undefined.");
      const Mi = await this.provider.getHeadInfo();
      wi = wi || `${Number(Mi.head_topology.height) + 1}`, Ei = Ei || Mi.head_topology.id, $i = $i || Mi.head_state_merkle_root;
    }
    e.header = {
      height: wi,
      previous: Ei,
      previous_state_merkle_root: $i,
      timestamp: e.header.timestamp || `${Date.now()}`,
      transaction_merkle_root: (0, utils_1$1.encodeBase64url)(new Uint8Array([
        // multihash sha256: 18, 32
        18,
        32,
        ...(0, utils_1$1.calculateMerkleRoot)(Si)
      ])),
      signer: this.address
    };
    const xi = (0, utils_1$1.btypeDecode)(e.header, btypeBlockHeader, !1), Ri = protocol_proto_js_1$1.koinos.protocol.block_header.create(xi), Ti = protocol_proto_js_1$1.koinos.protocol.block_header.encode(Ri).finish(), Oi = (0, sha256_1.sha256)(Ti);
    return e.id = `0x1220${(0, utils_1$1.toHexString)(Oi)}`, e;
  }
}
Signer$1.Signer = Signer;
Signer$1.default = Signer;
var Provider$1 = {}, browserPonyfill = { exports: {} };
(function(se, e) {
  var Oe = typeof self < "u" ? self : commonjsGlobal, Si = function() {
    function Ei() {
      this.fetch = !1, this.DOMException = Oe.DOMException;
    }
    return Ei.prototype = Oe, new Ei();
  }();
  (function(Ei) {
    (function($i) {
      var xi = {
        searchParams: "URLSearchParams" in Ei,
        iterable: "Symbol" in Ei && "iterator" in Symbol,
        blob: "FileReader" in Ei && "Blob" in Ei && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in Ei,
        arrayBuffer: "ArrayBuffer" in Ei
      };
      function Ri(Ai) {
        return Ai && DataView.prototype.isPrototypeOf(Ai);
      }
      if (xi.arrayBuffer)
        var Ti = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], Oi = ArrayBuffer.isView || function(Ai) {
          return Ai && Ti.indexOf(Object.prototype.toString.call(Ai)) > -1;
        };
      function Mi(Ai) {
        if (typeof Ai != "string" && (Ai = String(Ai)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(Ai))
          throw new TypeError("Invalid character in header field name");
        return Ai.toLowerCase();
      }
      function Ii(Ai) {
        return typeof Ai != "string" && (Ai = String(Ai)), Ai;
      }
      function Ci(Ai) {
        var Ni = {
          next: function() {
            var Ui = Ai.shift();
            return { done: Ui === void 0, value: Ui };
          }
        };
        return xi.iterable && (Ni[Symbol.iterator] = function() {
          return Ni;
        }), Ni;
      }
      function Oo(Ai) {
        this.map = {}, Ai instanceof Oo ? Ai.forEach(function(Ni, Ui) {
          this.append(Ui, Ni);
        }, this) : Array.isArray(Ai) ? Ai.forEach(function(Ni) {
          this.append(Ni[0], Ni[1]);
        }, this) : Ai && Object.getOwnPropertyNames(Ai).forEach(function(Ni) {
          this.append(Ni, Ai[Ni]);
        }, this);
      }
      Oo.prototype.append = function(Ai, Ni) {
        Ai = Mi(Ai), Ni = Ii(Ni);
        var Ui = this.map[Ai];
        this.map[Ai] = Ui ? Ui + ", " + Ni : Ni;
      }, Oo.prototype.delete = function(Ai) {
        delete this.map[Mi(Ai)];
      }, Oo.prototype.get = function(Ai) {
        return Ai = Mi(Ai), this.has(Ai) ? this.map[Ai] : null;
      }, Oo.prototype.has = function(Ai) {
        return this.map.hasOwnProperty(Mi(Ai));
      }, Oo.prototype.set = function(Ai, Ni) {
        this.map[Mi(Ai)] = Ii(Ni);
      }, Oo.prototype.forEach = function(Ai, Ni) {
        for (var Ui in this.map)
          this.map.hasOwnProperty(Ui) && Ai.call(Ni, this.map[Ui], Ui, this);
      }, Oo.prototype.keys = function() {
        var Ai = [];
        return this.forEach(function(Ni, Ui) {
          Ai.push(Ui);
        }), Ci(Ai);
      }, Oo.prototype.values = function() {
        var Ai = [];
        return this.forEach(function(Ni) {
          Ai.push(Ni);
        }), Ci(Ai);
      }, Oo.prototype.entries = function() {
        var Ai = [];
        return this.forEach(function(Ni, Ui) {
          Ai.push([Ui, Ni]);
        }), Ci(Ai);
      }, xi.iterable && (Oo.prototype[Symbol.iterator] = Oo.prototype.entries);
      function Ro(Ai) {
        if (Ai.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        Ai.bodyUsed = !0;
      }
      function Bo(Ai) {
        return new Promise(function(Ni, Ui) {
          Ai.onload = function() {
            Ni(Ai.result);
          }, Ai.onerror = function() {
            Ui(Ai.error);
          };
        });
      }
      function Fo(Ai) {
        var Ni = new FileReader(), Ui = Bo(Ni);
        return Ni.readAsArrayBuffer(Ai), Ui;
      }
      function Io(Ai) {
        var Ni = new FileReader(), Ui = Bo(Ni);
        return Ni.readAsText(Ai), Ui;
      }
      function Uo(Ai) {
        for (var Ni = new Uint8Array(Ai), Ui = new Array(Ni.length), So = 0; So < Ni.length; So++)
          Ui[So] = String.fromCharCode(Ni[So]);
        return Ui.join("");
      }
      function Co(Ai) {
        if (Ai.slice)
          return Ai.slice(0);
        var Ni = new Uint8Array(Ai.byteLength);
        return Ni.set(new Uint8Array(Ai)), Ni.buffer;
      }
      function ko() {
        return this.bodyUsed = !1, this._initBody = function(Ai) {
          this._bodyInit = Ai, Ai ? typeof Ai == "string" ? this._bodyText = Ai : xi.blob && Blob.prototype.isPrototypeOf(Ai) ? this._bodyBlob = Ai : xi.formData && FormData.prototype.isPrototypeOf(Ai) ? this._bodyFormData = Ai : xi.searchParams && URLSearchParams.prototype.isPrototypeOf(Ai) ? this._bodyText = Ai.toString() : xi.arrayBuffer && xi.blob && Ri(Ai) ? (this._bodyArrayBuffer = Co(Ai.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : xi.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(Ai) || Oi(Ai)) ? this._bodyArrayBuffer = Co(Ai) : this._bodyText = Ai = Object.prototype.toString.call(Ai) : this._bodyText = "", this.headers.get("content-type") || (typeof Ai == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : xi.searchParams && URLSearchParams.prototype.isPrototypeOf(Ai) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, xi.blob && (this.blob = function() {
          var Ai = Ro(this);
          if (Ai)
            return Ai;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? Ro(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(Fo);
        }), this.text = function() {
          var Ai = Ro(this);
          if (Ai)
            return Ai;
          if (this._bodyBlob)
            return Io(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(Uo(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, xi.formData && (this.formData = function() {
          return this.text().then(Jo);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var Po = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function Mo(Ai) {
        var Ni = Ai.toUpperCase();
        return Po.indexOf(Ni) > -1 ? Ni : Ai;
      }
      function No(Ai, Ni) {
        Ni = Ni || {};
        var Ui = Ni.body;
        if (Ai instanceof No) {
          if (Ai.bodyUsed)
            throw new TypeError("Already read");
          this.url = Ai.url, this.credentials = Ai.credentials, Ni.headers || (this.headers = new Oo(Ai.headers)), this.method = Ai.method, this.mode = Ai.mode, this.signal = Ai.signal, !Ui && Ai._bodyInit != null && (Ui = Ai._bodyInit, Ai.bodyUsed = !0);
        } else
          this.url = String(Ai);
        if (this.credentials = Ni.credentials || this.credentials || "same-origin", (Ni.headers || !this.headers) && (this.headers = new Oo(Ni.headers)), this.method = Mo(Ni.method || this.method || "GET"), this.mode = Ni.mode || this.mode || null, this.signal = Ni.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && Ui)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(Ui);
      }
      No.prototype.clone = function() {
        return new No(this, { body: this._bodyInit });
      };
      function Jo(Ai) {
        var Ni = new FormData();
        return Ai.trim().split("&").forEach(function(Ui) {
          if (Ui) {
            var So = Ui.split("="), $o = So.shift().replace(/\+/g, " "), Eo = So.join("=").replace(/\+/g, " ");
            Ni.append(decodeURIComponent($o), decodeURIComponent(Eo));
          }
        }), Ni;
      }
      function zo(Ai) {
        var Ni = new Oo(), Ui = Ai.replace(/\r?\n[\t ]+/g, " ");
        return Ui.split(/\r?\n/).forEach(function(So) {
          var $o = So.split(":"), Eo = $o.shift().trim();
          if (Eo) {
            var zi = $o.join(":").trim();
            Ni.append(Eo, zi);
          }
        }), Ni;
      }
      ko.call(No.prototype);
      function Do(Ai, Ni) {
        Ni || (Ni = {}), this.type = "default", this.status = Ni.status === void 0 ? 200 : Ni.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Ni ? Ni.statusText : "OK", this.headers = new Oo(Ni.headers), this.url = Ni.url || "", this._initBody(Ai);
      }
      ko.call(Do.prototype), Do.prototype.clone = function() {
        return new Do(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Oo(this.headers),
          url: this.url
        });
      }, Do.error = function() {
        var Ai = new Do(null, { status: 0, statusText: "" });
        return Ai.type = "error", Ai;
      };
      var wo = [301, 302, 303, 307, 308];
      Do.redirect = function(Ai, Ni) {
        if (wo.indexOf(Ni) === -1)
          throw new RangeError("Invalid status code");
        return new Do(null, { status: Ni, headers: { location: Ai } });
      }, $i.DOMException = Ei.DOMException;
      try {
        new $i.DOMException();
      } catch {
        $i.DOMException = function(Ni, Ui) {
          this.message = Ni, this.name = Ui;
          var So = Error(Ni);
          this.stack = So.stack;
        }, $i.DOMException.prototype = Object.create(Error.prototype), $i.DOMException.prototype.constructor = $i.DOMException;
      }
      function Li(Ai, Ni) {
        return new Promise(function(Ui, So) {
          var $o = new No(Ai, Ni);
          if ($o.signal && $o.signal.aborted)
            return So(new $i.DOMException("Aborted", "AbortError"));
          var Eo = new XMLHttpRequest();
          function zi() {
            Eo.abort();
          }
          Eo.onload = function() {
            var _o = {
              status: Eo.status,
              statusText: Eo.statusText,
              headers: zo(Eo.getAllResponseHeaders() || "")
            };
            _o.url = "responseURL" in Eo ? Eo.responseURL : _o.headers.get("X-Request-URL");
            var Fi = "response" in Eo ? Eo.response : Eo.responseText;
            Ui(new Do(Fi, _o));
          }, Eo.onerror = function() {
            So(new TypeError("Network request failed"));
          }, Eo.ontimeout = function() {
            So(new TypeError("Network request failed"));
          }, Eo.onabort = function() {
            So(new $i.DOMException("Aborted", "AbortError"));
          }, Eo.open($o.method, $o.url, !0), $o.credentials === "include" ? Eo.withCredentials = !0 : $o.credentials === "omit" && (Eo.withCredentials = !1), "responseType" in Eo && xi.blob && (Eo.responseType = "blob"), $o.headers.forEach(function(_o, Fi) {
            Eo.setRequestHeader(Fi, _o);
          }), $o.signal && ($o.signal.addEventListener("abort", zi), Eo.onreadystatechange = function() {
            Eo.readyState === 4 && $o.signal.removeEventListener("abort", zi);
          }), Eo.send(typeof $o._bodyInit > "u" ? null : $o._bodyInit);
        });
      }
      return Li.polyfill = !0, Ei.fetch || (Ei.fetch = Li, Ei.Headers = Oo, Ei.Request = No, Ei.Response = Do), $i.Headers = Oo, $i.Request = No, $i.Response = Do, $i.fetch = Li, Object.defineProperty($i, "__esModule", { value: !0 }), $i;
    })({});
  })(Si), Si.fetch.ponyfill = !0, delete Si.fetch.polyfill;
  var wi = Si;
  e = wi.fetch, e.default = wi.fetch, e.fetch = wi.fetch, e.Headers = wi.Headers, e.Request = wi.Request, e.Response = wi.Response, se.exports = e;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(se) {
  return se && se.__esModule ? se : { default: se };
};
Object.defineProperty(Provider$1, "__esModule", { value: !0 });
Provider$1.Provider = void 0;
const cross_fetch_1 = __importDefault(browserPonyfillExports), protocol_proto_js_1 = protocolProtoExports, utils_1 = utils$1;
async function sleep(se) {
  return new Promise((e) => setTimeout(e, se));
}
class Provider {
  /**
   *
   * @param rpcNodes - URL of the rpc node, or array of urls
   * to switch between them when someone is down
   * @example
   * ```ts
   * const provider = new Provider([
   *   "http://45.56.104.152:8080",
   *   "http://159.203.119.0:8080"
   * ]);
   * ```
   */
  constructor(e) {
    Array.isArray(e) ? this.rpcNodes = e : this.rpcNodes = [e], this.currentNodeId = 0, this.onError = () => !0;
  }
  /**
   * Function to make jsonrpc requests to the RPC node
   * @param method - jsonrpc method
   * @param params - jsonrpc params
   * @returns Result of jsonrpc response
   */
  async call(e, Oe) {
    for (; ; )
      try {
        const Si = {
          id: Math.round(Math.random() * 1e3),
          jsonrpc: "2.0",
          method: e,
          params: Oe
        }, wi = this.rpcNodes[this.currentNodeId], $i = await (await (0, cross_fetch_1.default)(wi, {
          method: "POST",
          body: JSON.stringify(Si)
        })).json();
        if ($i.result !== void 0)
          return $i.result;
        if (!$i.error)
          throw new Error("undefined error");
        const { message: xi, data: Ri } = $i.error;
        if (!Ri)
          throw new Error(xi);
        let Ti;
        try {
          Ti = JSON.parse(Ri);
        } catch {
          Ti = { data: Ri };
        }
        throw new Error(JSON.stringify({
          ...xi && { error: xi },
          ...Ti
        }));
      } catch (Si) {
        const wi = this.rpcNodes[this.currentNodeId];
        this.currentNodeId = (this.currentNodeId + 1) % this.rpcNodes.length;
        const Ei = this.rpcNodes[this.currentNodeId];
        if (this.onError(Si, wi, Ei))
          throw Si;
      }
  }
  /**
   * Function to call "chain.get_account_nonce" to return the number of
   * transactions for a particular account. If you are creating a new
   * transaction consider using [[Provider.getNextNonce]].
   * @param account - account address
   * @param deserialize - If set true it will deserialize the nonce
   * and return it as number (default). If set false it will return
   * the nonce encoded as received from the RPC.
   * @returns Nonce
   */
  async getNonce(e, Oe = !0) {
    const { nonce: Si } = await this.call("chain.get_account_nonce", { account: e });
    if (!Oe)
      return Si;
    const wi = (0, utils_1.decodeBase64url)(Si), Ei = protocol_proto_js_1.koinos.chain.value_type.decode(wi), $i = protocol_proto_js_1.koinos.chain.value_type.toObject(Ei, {
      longs: String,
      defaults: !0
    });
    return Number($i.uint64_value);
  }
  /**
   * Function to call "chain.get_account_nonce" (number of
   * transactions for a particular account) and return the next nonce.
   * This call is used when creating new transactions. The result is
   * encoded in base64url
   * @param account - account address
   * @returns Nonce
   */
  async getNextNonce(e) {
    const Oe = await this.getNonce(e), Si = protocol_proto_js_1.koinos.chain.value_type.create({
      // todo: consider using bigint for big nonces
      uint64_value: String(Oe + 1)
    }), wi = protocol_proto_js_1.koinos.chain.value_type.encode(Si).finish();
    return (0, utils_1.encodeBase64url)(wi);
  }
  async getAccountRc(e) {
    const { rc: Oe } = await this.call("chain.get_account_rc", {
      account: e
    });
    return Oe || "0";
  }
  /**
   * Get transactions by id and their corresponding block ids
   */
  async getTransactionsById(e) {
    return this.call("transaction_store.get_transactions_by_id", {
      transaction_ids: e
    });
  }
  async getBlocksById(e) {
    return this.call("block_store.get_blocks_by_id", {
      block_ids: e,
      return_block: !0,
      return_receipt: !1
    });
  }
  /**
   * Function to get info from the head block in the blockchain
   */
  async getHeadInfo() {
    return this.call("chain.get_head_info", {});
  }
  /**
   * Function to get the chain
   */
  async getChainId() {
    const { chain_id: e } = await this.call("chain.get_chain_id", {});
    return e;
  }
  /**
   * Function to get consecutive blocks in descending order
   * @param height - Starting block height
   * @param numBlocks - Number of blocks to fetch
   * @param idRef - Block ID reference to speed up searching blocks.
   * This ID must be from a greater block height. By default it
   * gets the ID from the block head.
   */
  async getBlocks(e, Oe = 1, Si) {
    let wi = Si;
    return wi || (wi = (await this.getHeadInfo()).head_topology.id), (await this.call("block_store.get_blocks_by_height", {
      head_block_id: wi,
      ancestor_start_height: e,
      num_blocks: Oe,
      return_block: !0,
      return_receipt: !1
    })).block_items;
  }
  /**
   * Function to get a block by its height
   */
  async getBlock(e) {
    return (await this.getBlocks(e, 1))[0];
  }
  /**
   * Function to wait for a transaction to be mined.
   * @param txId - transaction id
   * @param type - Type must be "byBlock" (default) or "byTransactionId".
   * _byBlock_ will query the blockchain to get blocks and search for the
   * transaction there. _byTransactionId_ will query the "transaction store"
   * microservice to search the transaction by its id. If non of them is
   * specified the function will use "byBlock" (as "byTransactionId"
   * requires the transaction store, which is an optional microservice).
   *
   * When _byBlock_ is used it returns the block number.
   *
   * When _byTransactionId_ is used it returns the block id.
   *
   * @param timeout - Timeout in milliseconds. By default it is 15000
   * @example
   * ```ts
   * const blockNumber = await provider.wait(txId);
   * // const blockNumber = await provider.wait(txId, "byBlock", 15000);
   * // const blockId = await provider.wait(txId, "byTransactionId", 15000);
   * console.log("Transaction mined")
   * ```
   */
  async wait(e, Oe = "byBlock", Si = 15e3) {
    const wi = Date.now();
    if (Oe === "byTransactionId") {
      for (; Date.now() < wi + Si; ) {
        await sleep(1e3);
        const { transactions: Ti } = await this.getTransactionsById([e]);
        if (Ti && Ti[0] && Ti[0].containing_blocks)
          return {
            blockId: Ti[0].containing_blocks[0]
          };
      }
      throw new Error(`Transaction not mined after ${Si} ms`);
    }
    const Ei = async (Ti, Oi, Mi) => {
      const Ii = await this.getBlocks(Ti, Oi, Mi);
      let Ci = 0, Oo = "";
      Ii.forEach((Bo) => {
        if (!Bo || !Bo.block || !Bo.block_id || !Bo.block.transactions)
          return;
        Bo.block.transactions.find((Io) => Io.id === e) && (Ci = Number(Bo.block_height), Oo = Bo.block_id);
      });
      const Ro = Ii[Ii.length - 1].block_id;
      return [Ci, Oo, Ro];
    };
    let $i = 0, xi = 0, Ri = "";
    for (; Date.now() < wi + Si; ) {
      await sleep(1e3);
      const { head_topology: Ti } = await this.getHeadInfo();
      if ($i === 0 && ($i = Number(Ti.height), xi = $i), Number(Ti.height) === $i - 1 && Ri && Ri !== Ti.id) {
        const [Ci, Oo, Ro] = await Ei(xi, Number(Ti.height) - xi + 1, Ti.id);
        if (Ci)
          return {
            blockId: Oo,
            blockNumber: Ci
          };
        Ri = Ro, $i = Number(Ti.height) + 1;
      }
      if ($i > Number(Ti.height))
        continue;
      const [Oi, Mi, Ii] = await Ei($i, 1, Ti.id);
      if (Oi)
        return {
          blockId: Mi,
          blockNumber: Oi
        };
      Ri || (Ri = Ii), $i += 1;
    }
    throw new Error(`Transaction not mined after ${Si} ms. Blocks checked from ${xi} to ${$i}`);
  }
  /**
   * Function to call "chain.submit_transaction" to send a signed
   * transaction to the blockchain.
   *
   * It also has the option to not broadcast the transaction (to not
   * include the transaction the mempool), which is useful if you
   * want to test the interaction with a contract and check the
   * possible events triggered.
   * @param transaction - Transaction
   * @param broadcast - Option to broadcast the transaction to the
   * whole network. By default it is true.
   * @returns It returns the receipt received from the RPC node
   * and the transaction with the arrow function "wait" (see [[wait]])
   */
  async sendTransaction(e, Oe = !0) {
    const Si = await this.call("chain.submit_transaction", { transaction: e, broadcast: Oe });
    return e.wait = async (wi = "byBlock", Ei = 15e3) => this.wait(e.id, wi, Ei), { ...Si, transaction: e };
  }
  /**
   * Function to call "chain.submit_block" to send a signed
   * block to the blockchain.
   */
  async submitBlock(e) {
    return this.call("chain.submit_block", { block: e });
  }
  /**
   * Function to call "chain.read_contract" to read a contract.
   * This function is used by [[Contract]] class when read methods
   * are invoked.
   */
  async readContract(e) {
    return this.call("chain.read_contract", e);
  }
}
Provider$1.Provider = Provider;
Provider$1.default = Provider;
var Transaction$1 = {};
Object.defineProperty(Transaction$1, "__esModule", { value: !0 });
Transaction$1.Transaction = void 0;
const Signer_1 = Signer$1;
class Transaction {
  constructor(e) {
    var Oe, Si, wi, Ei, $i;
    this.signer = e == null ? void 0 : e.signer, this.provider = e == null ? void 0 : e.provider, this.options = {
      broadcast: !0,
      sendAbis: !0,
      ...e == null ? void 0 : e.options
    }, this.transaction = {
      header: {
        ...((Oe = e == null ? void 0 : e.options) === null || Oe === void 0 ? void 0 : Oe.chainId) && { chain_id: e.options.chainId },
        ...((Si = e == null ? void 0 : e.options) === null || Si === void 0 ? void 0 : Si.rcLimit) && { rc_limit: e.options.rcLimit },
        ...((wi = e == null ? void 0 : e.options) === null || wi === void 0 ? void 0 : wi.nonce) && { nonce: e.options.nonce },
        ...((Ei = e == null ? void 0 : e.options) === null || Ei === void 0 ? void 0 : Ei.payer) && { payer: e.options.payer },
        ...(($i = e == null ? void 0 : e.options) === null || $i === void 0 ? void 0 : $i.payee) && { payee: e.options.payee }
      },
      operations: []
    };
  }
  /**
   * Function to push an operation to the transaction. It can be created
   * in several ways. Example:
   *
   * @example
   * ```ts
   * const koin = new Contract({
   *   id: "19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ",
   *   abi: utils.tokenAbi,
   * }).functions;
   * const signer = Signer.fromSeed("my seed");
   * const provider = new Provider(["https://api.koinos.io"]);
   * signer.provider = provider;
   * const tx = new Transaction({ signer });
   *
   * // method 1
   * await tx.pushOperation(koin.transfer, {
   *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *   value: "1000",
   * });
   *
   * // method 2
   * await tx.pushOperation(
   *   koin.transfer({
   *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *     value: "1000",
   *   },{
   *    onlyOperation: true,
   *   })
   * );
   *
   * // method 3
   * await tx.pushOperation(
   *   await koin.transfer({
   *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *     value: "1000",
   *   },{
   *    onlyOperation: true,
   *   })
   * );
   *
   * // method 4
   * const { operation } = await koin.transfer({
   *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
   *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
   *   value: "1000",
   * },{
   *  onlyOperation: true,
   * });
   * await tx.pushOperation(operation)
   * ```
   *
   */
  async pushOperation(e, Oe) {
    let Si;
    if (typeof e == "function")
      Si = (await e(Oe, { onlyOperation: !0 })).operation;
    else {
      let wi;
      e instanceof Promise ? wi = await e : wi = e, wi.operation ? Si = wi.operation : Si = e;
    }
    this.transaction.operations || (this.transaction.operations = []), this.transaction.operations.push(Si);
  }
  /**
   * Functon to prepare the transaction (set headers, merkle
   * root, etc)
   */
  async prepare(e) {
    if (e) {
      const Oe = {
        ...(e == null ? void 0 : e.chainId) && { chain_id: e.chainId },
        ...(e == null ? void 0 : e.rcLimit) && { rc_limit: e.rcLimit },
        ...(e == null ? void 0 : e.nonce) && { nonce: e.nonce },
        ...(e == null ? void 0 : e.payer) && { payer: e.payer },
        ...(e == null ? void 0 : e.payee) && { payee: e.payee }
      };
      this.transaction.header = {
        ...this.transaction.header,
        ...Oe
      };
    }
    if (this.signer)
      this.transaction = await this.signer.prepareTransaction(this.transaction);
    else {
      if (!this.transaction.header || !this.transaction.header.payer)
        throw new Error("no payer defined");
      const Oe = Signer_1.Signer.fromSeed("0");
      Oe.provider = this.provider, this.transaction = await Oe.prepareTransaction(this.transaction);
    }
    return this.transaction;
  }
  /**
   * Function to sign the transaction
   */
  async sign(e) {
    if (!this.signer)
      throw new Error("no signer defined");
    return this.transaction.id || await this.prepare(), this.signer.signTransaction(this.transaction, this.options.sendAbis ? e : void 0);
  }
  /**
   * Function to broadcast the transaction
   */
  async send(e) {
    const Oe = {
      ...this.options,
      ...e
    };
    if (this.transaction.id || await this.prepare(), this.signer && this.signer.provider) {
      const { transaction: Ei, receipt: $i } = await this.signer.sendTransaction(this.transaction, Oe);
      return this.transaction = Ei, this.waitFunction = Ei.wait, $i;
    }
    if (!this.provider)
      throw new Error("provider not defined");
    if (!this.transaction.signatures || !this.transaction.signatures.length)
      throw new Error("transaction without signatures and no signer defined");
    Oe.beforeSend && await Oe.beforeSend(this.transaction, Oe);
    const { transaction: Si, receipt: wi } = await this.provider.sendTransaction(this.transaction, Oe.broadcast);
    return this.transaction = Si, this.waitFunction = Si.wait, wi;
  }
  async wait(e, Oe) {
    if (!this.waitFunction)
      throw new Error("no wait function defined");
    return this.waitFunction(e, Oe);
  }
}
Transaction$1.Transaction = Transaction;
(function(se) {
  var e = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Ei, $i, xi, Ri) {
    Ri === void 0 && (Ri = xi);
    var Ti = Object.getOwnPropertyDescriptor($i, xi);
    (!Ti || ("get" in Ti ? !$i.__esModule : Ti.writable || Ti.configurable)) && (Ti = { enumerable: !0, get: function() {
      return $i[xi];
    } }), Object.defineProperty(Ei, Ri, Ti);
  } : function(Ei, $i, xi, Ri) {
    Ri === void 0 && (Ri = xi), Ei[Ri] = $i[xi];
  }), Oe = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(Ei, $i) {
    Object.defineProperty(Ei, "default", { enumerable: !0, value: $i });
  } : function(Ei, $i) {
    Ei.default = $i;
  }), Si = commonjsGlobal && commonjsGlobal.__importStar || function(Ei) {
    if (Ei && Ei.__esModule)
      return Ei;
    var $i = {};
    if (Ei != null)
      for (var xi in Ei)
        xi !== "default" && Object.prototype.hasOwnProperty.call(Ei, xi) && e($i, Ei, xi);
    return Oe($i, Ei), $i;
  }, wi = commonjsGlobal && commonjsGlobal.__exportStar || function(Ei, $i) {
    for (var xi in Ei)
      xi !== "default" && !Object.prototype.hasOwnProperty.call($i, xi) && e($i, Ei, xi);
  };
  Object.defineProperty(se, "__esModule", { value: !0 }), se.interfaces = se.utils = void 0;
  /*! koilib - MIT License (c) Julian Gonzalez (joticajulian@gmail.com) */
  se.utils = Si(indexUtils), se.interfaces = Si(_interface), wi(Contract$1, se), wi(Signer$1, se), wi(Provider$1, se), wi(Transaction$1, se), wi(Serializer$1, se);
})(lib$2);
function generateSigner(se, e, Oe, Si, wi) {
  return {
    provider: wi || generateProvider(e, Oe, Si),
    getAddress: () => se,
    getPrivateKey: () => {
      throw new Error("not implemented");
    },
    signHash: async ($i) => {
      const xi = await Si.request({
        chainId: e,
        topic: Oe,
        request: {
          method: Methods.SignHash,
          params: {
            address: se,
            hash: lib$2.utils.encodeBase64($i)
          }
        }
      });
      return lib$2.utils.decodeBase64(xi);
    },
    signMessage: async ($i) => {
      const xi = await Si.request({
        chainId: e,
        topic: Oe,
        request: {
          method: Methods.SignMessage,
          params: {
            address: se,
            message: $i
          }
        }
      });
      return lib$2.utils.decodeBase64(xi);
    },
    prepareTransaction: async ($i) => {
      var xi;
      if (wi) {
        const Ri = lib$2.Signer.fromSeed("dummy_signer");
        return Ri.provider = wi, (xi = $i.header) != null && xi.payer || ($i.header = {
          ...$i.header,
          payer: se
        }), Ri.prepareTransaction($i);
      } else
        return await Si.request({
          chainId: e,
          topic: Oe,
          request: {
            method: Methods.PrepareTransaction,
            params: {
              address: se,
              transaction: $i
            }
          }
        });
    },
    signTransaction: async ($i, xi) => await Si.request({
      chainId: e,
      topic: Oe,
      request: {
        method: Methods.SignTransaction,
        params: {
          address: se,
          transaction: $i,
          options: {
            abis: xi
          }
        }
      }
    }),
    sendTransaction: async ($i, xi) => {
      const Ri = await Si.request({
        chainId: e,
        topic: Oe,
        request: {
          method: Methods.SignAndSendTransaction,
          params: {
            address: se,
            transaction: $i,
            options: xi
          }
        }
      });
      return Ri.transaction.wait = async (Ti = "byBlock", Oi = 6e4) => await Si.request({
        chainId: e,
        topic: Oe,
        request: {
          method: Methods.WaitForTransaction,
          params: {
            transactionId: Ri.transaction.id,
            type: Ti,
            timeout: Oi
          }
        }
      }), Ri;
    },
    prepareBlock: () => {
      throw new Error("not implemented");
    },
    signBlock: () => {
      throw new Error("not implemented");
    }
  };
}
class WebWalletConnectKoinos {
  constructor(e, Oe) {
    El(this, "web3Modal");
    El(this, "topic", "");
    El(this, "chainId");
    El(this, "accounts", []);
    El(this, "options", {
      logLevel: LogLevel.none
    });
    Oe && (this.options = Oe), this.web3Modal = new WalletConnectModalSign(e), (Oe == null ? void 0 : Oe.autoDisconnect) === !1 || this.web3Modal.onSessionDelete((wi) => this.onSessionDelete(wi));
  }
  close() {
    this.web3Modal.offSessionDelete((e) => this.onSessionDelete(e));
  }
  async onSessionDelete(e) {
    this.options.logLevel === LogLevel.debug && console.log("onSessionDelete", e), this.accounts = [], this.topic = "", this.chainId = void 0;
  }
  async connect(e, Oe) {
    var $i;
    this.accounts = [];
    const Si = await this.web3Modal.getSessions();
    let wi = Si.length ? Si[Si.length - 1] : void 0;
    if (wi || (wi = await this.web3Modal.connect({
      requiredNamespaces: {
        koinos: {
          methods: Oe,
          chains: e,
          events: []
        }
      }
    })), !wi)
      return [];
    this.topic = wi.topic, (($i = wi.namespaces.koinos.chains) == null ? void 0 : $i.length) === 1 && (this.chainId = wi.namespaces.koinos.chains[0]);
    const Ei = wi.namespaces.koinos.accounts.reduce((xi, Ri) => {
      const [Ti, Oi, Mi] = Ri.split(":");
      return xi.includes(Mi) || xi.push(Mi), xi;
    }, []);
    return this.accounts = Ei, Ei;
  }
  async disconnect() {
    const e = await this.web3Modal.getSessions();
    for (const Oe of e) {
      try {
        this.web3Modal.disconnect({
          topic: Oe.topic,
          reason: _$4("USER_DISCONNECTED")
        });
      } catch (Si) {
        console.error(Si);
      }
      if (Oe.pairingTopic)
        try {
          this.web3Modal.disconnect({
            topic: Oe.pairingTopic,
            reason: _$4("USER_DISCONNECTED")
          });
        } catch (Si) {
          console.error(Si);
        }
    }
    this.accounts = [], this.topic = "", this.chainId = void 0;
  }
  getAccounts() {
    return this.accounts;
  }
  getSigner(e, Oe, Si) {
    const wi = Si || this.chainId;
    if (!wi)
      throw new Error(
        "You must provide a chain id because none or several are present in this session."
      );
    return generateSigner(e, wi, this.topic, this.web3Modal, Oe);
  }
  getProvider(e) {
    const Oe = e || this.chainId;
    if (!Oe)
      throw new Error(
        "You must provide a chain id because none or several are present in this session."
      );
    return generateProvider(Oe, this.topic, this.web3Modal);
  }
}
let n$3 = class extends IEvents$1 {
  constructor(e) {
    super();
  }
};
const s = cjs$4.FIVE_SECONDS, r = { pulse: "heartbeat_pulse" };
let i$2 = class Ql extends n$3 {
  constructor(e) {
    super(e), this.events = new EventEmitter(), this.interval = s, this.interval = (e == null ? void 0 : e.interval) || s;
  }
  static async init(e) {
    const Oe = new Ql(e);
    return await Oe.init(), Oe;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), cjs$4.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(r.pulse);
  }
};
const x$5 = "idb-keyval";
var z$3 = (se = {}) => {
  const e = se.base && se.base.length > 0 ? `${se.base}:` : "", Oe = (wi) => e + wi;
  let Si;
  return se.dbName && se.storeName && (Si = createStore(se.dbName, se.storeName)), { name: x$5, options: se, async hasItem(wi) {
    return !(typeof await get(Oe(wi), Si) > "u");
  }, async getItem(wi) {
    return await get(Oe(wi), Si) ?? null;
  }, setItem(wi, Ei) {
    return set(Oe(wi), Ei, Si);
  }, removeItem(wi) {
    return del(Oe(wi), Si);
  }, getKeys() {
    return keys(Si);
  }, clear() {
    return clear(Si);
  } };
};
const D$1 = "WALLET_CONNECT_V2_INDEXED_DB", E$2 = "keyvaluestorage";
let _$3 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z$3({ dbName: D$1, storeName: E$2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const Oe = await this.indexedDb.getItem(e);
    if (Oe !== null)
      return Oe;
  }
  async setItem(e, Oe) {
    await this.indexedDb.setItem(e, safeJsonStringify(Oe));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var l$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c$2 = { exports: {} };
(function() {
  let se;
  function e() {
  }
  se = e, se.prototype.getItem = function(Oe) {
    return this.hasOwnProperty(Oe) ? String(this[Oe]) : null;
  }, se.prototype.setItem = function(Oe, Si) {
    this[Oe] = String(Si);
  }, se.prototype.removeItem = function(Oe) {
    delete this[Oe];
  }, se.prototype.clear = function() {
    const Oe = this;
    Object.keys(Oe).forEach(function(Si) {
      Oe[Si] = void 0, delete Oe[Si];
    });
  }, se.prototype.key = function(Oe) {
    return Oe = Oe || 0, Object.keys(this)[Oe];
  }, se.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$1 < "u" && l$1.localStorage ? c$2.exports = l$1.localStorage : typeof window < "u" && window.localStorage ? c$2.exports = window.localStorage : c$2.exports = new e();
})();
function k$2(se) {
  var e;
  return [se[0], safeJsonParse((e = se[1]) != null ? e : "")];
}
class K {
  constructor() {
    this.localStorage = c$2.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$2);
  }
  async getItem(e) {
    const Oe = this.localStorage.getItem(e);
    if (Oe !== null)
      return safeJsonParse(Oe);
  }
  async setItem(e, Oe) {
    this.localStorage.setItem(e, safeJsonStringify(Oe));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
}
const N = "wc_storage_version", y$3 = 1, O$1 = async (se, e, Oe) => {
  const Si = N, wi = await e.getItem(Si);
  if (wi && wi >= y$3) {
    Oe(e);
    return;
  }
  const Ei = await se.getKeys();
  if (!Ei.length) {
    Oe(e);
    return;
  }
  const $i = [];
  for (; Ei.length; ) {
    const xi = Ei.shift();
    if (!xi)
      continue;
    const Ri = xi.toLowerCase();
    if (Ri.includes("wc@") || Ri.includes("walletconnect") || Ri.includes("wc_") || Ri.includes("wallet_connect")) {
      const Ti = await se.getItem(xi);
      await e.setItem(xi, Ti), $i.push(xi);
    }
  }
  await e.setItem(Si, y$3), Oe(e), j$1(se, $i);
}, j$1 = async (se, e) => {
  e.length && e.forEach(async (Oe) => {
    await se.removeItem(Oe);
  });
};
let h$2 = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (Oe) => {
      this.storage = Oe, this.initialized = !0;
    };
    const e = new K();
    this.storage = e;
    try {
      const Oe = new _$3();
      O$1(e, Oe, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, Oe) {
    return await this.initialize(), this.storage.setItem(e, Oe);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const Oe = setInterval(() => {
        this.initialized && (clearInterval(Oe), e());
      }, 20);
    });
  }
};
var browserExports = requireBrowser();
const Tt$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports), c$1 = { level: "info" }, n$2 = "custom_context", l = 1e3 * 1024;
class O {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}
let d$2 = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const Oe = new O(e);
    if (Oe.size > this.maxSizeInBytes)
      throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${Oe.size}`);
    for (; this.size + Oe.size > this.maxSizeInBytes; )
      this.shift();
    this.head ? (this.tail && (this.tail.next = Oe), this.tail = Oe) : (this.head = Oe, this.tail = Oe), this.lengthInNodes++, this.sizeInBytes += Oe.size;
  }
  shift() {
    if (!this.head)
      return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let Oe = this.head;
    for (; Oe !== null; )
      e.push(Oe.value), Oe = Oe.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e)
        return { done: !0, value: null };
      const Oe = e.value;
      return e = e.next, { done: !1, value: Oe };
    } };
  }
};
class L {
  constructor(e, Oe = l) {
    this.level = e ?? "error", this.levelValue = browserExports.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = Oe, this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, Oe) {
    Oe === browserExports.levels.values.error ? console.error(e) : Oe === browserExports.levels.values.warn ? console.warn(e) : Oe === browserExports.levels.values.debug ? console.debug(e) : Oe === browserExports.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const Oe = typeof e == "string" ? JSON.parse(e).level : e.level;
    Oe >= this.levelValue && this.forwardToConsole(e, Oe);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const Oe = this.getLogArray();
    return Oe.push(safeJsonStringify({ extraMetadata: e })), new Blob(Oe, { type: "application/json" });
  }
}
class m {
  constructor(e, Oe = l) {
    this.baseChunkLogger = new L(e, Oe);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const Oe = URL.createObjectURL(this.logsToBlob(e)), Si = document.createElement("a");
    Si.href = Oe, Si.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(Si), Si.click(), document.body.removeChild(Si), URL.revokeObjectURL(Oe);
  }
}
class B {
  constructor(e, Oe = l) {
    this.baseChunkLogger = new L(e, Oe);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
}
var x$4 = Object.defineProperty, S$2 = Object.defineProperties, _$2 = Object.getOwnPropertyDescriptors, p$2 = Object.getOwnPropertySymbols, T$2 = Object.prototype.hasOwnProperty, z$2 = Object.prototype.propertyIsEnumerable, f$2 = (se, e, Oe) => e in se ? x$4(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, i$1 = (se, e) => {
  for (var Oe in e || (e = {}))
    T$2.call(e, Oe) && f$2(se, Oe, e[Oe]);
  if (p$2)
    for (var Oe of p$2(e))
      z$2.call(e, Oe) && f$2(se, Oe, e[Oe]);
  return se;
}, g$2 = (se, e) => S$2(se, _$2(e));
function k$1(se) {
  return g$2(i$1({}, se), { level: (se == null ? void 0 : se.level) || c$1.level });
}
function v$5(se, e = n$2) {
  return se[e] || "";
}
function b$2(se, e, Oe = n$2) {
  return se[Oe] = e, se;
}
function y$2(se, e = n$2) {
  let Oe = "";
  return typeof se.bindings > "u" ? Oe = v$5(se, e) : Oe = se.bindings().context || "", Oe;
}
function w$2(se, e, Oe = n$2) {
  const Si = y$2(se, Oe);
  return Si.trim() ? `${Si}/${e}` : e;
}
function E$1(se, e, Oe = n$2) {
  const Si = w$2(se, e, Oe), wi = se.child({ context: Si });
  return b$2(wi, Si, Oe);
}
function C$2(se) {
  var e, Oe;
  const Si = new m((e = se.opts) == null ? void 0 : e.level, se.maxSizeInBytes);
  return { logger: Tt$1(g$2(i$1({}, se.opts), { level: "trace", browser: g$2(i$1({}, (Oe = se.opts) == null ? void 0 : Oe.browser), { write: (wi) => Si.write(wi) }) })), chunkLoggerController: Si };
}
function I$1(se) {
  var e;
  const Oe = new B((e = se.opts) == null ? void 0 : e.level, se.maxSizeInBytes);
  return { logger: Tt$1(g$2(i$1({}, se.opts), { level: "trace" }), Oe), chunkLoggerController: Oe };
}
function A$1(se) {
  return typeof se.loggerOverride < "u" && typeof se.loggerOverride != "string" ? { logger: se.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C$2(se) : I$1(se);
}
let n$1 = class extends IEvents$1 {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, h$1 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.core = e, this.logger = Oe, this.records = /* @__PURE__ */ new Map();
  }
};
class a {
  constructor(e, Oe) {
    this.logger = e, this.core = Oe;
  }
}
let g$1 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.relayer = e, this.logger = Oe;
  }
};
class u extends IEvents$1 {
  constructor(e) {
    super();
  }
}
let p$1 = class {
  constructor(e, Oe, Si, wi) {
    this.core = e, this.logger = Oe, this.name = Si;
  }
}, d$1 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.relayer = e, this.logger = Oe;
  }
}, x$3 = class extends IEvents$1 {
  constructor(e, Oe) {
    super(), this.core = e, this.logger = Oe;
  }
}, y$1 = class {
  constructor(e, Oe, Si) {
    this.core = e, this.logger = Oe, this.store = Si;
  }
}, v$4 = class {
  constructor(e, Oe) {
    this.projectId = e, this.logger = Oe;
  }
}, C$1 = class {
  constructor(e, Oe, Si) {
    this.core = e, this.logger = Oe, this.telemetryEnabled = Si;
  }
};
function allocUnsafe(se = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(se) : new Uint8Array(se);
}
function createCodec(se, e, Oe, Si) {
  return {
    name: se,
    prefix: e,
    encoder: {
      name: se,
      prefix: e,
      encode: Oe
    },
    decoder: { decode: Si }
  };
}
const string = createCodec("utf8", "u", (se) => "u" + new TextDecoder("utf8").decode(se), (se) => new TextEncoder().encode(se.substring(1))), ascii = createCodec("ascii", "a", (se) => {
  let e = "a";
  for (let Oe = 0; Oe < se.length; Oe++)
    e += String.fromCharCode(se[Oe]);
  return e;
}, (se) => {
  se = se.substring(1);
  const e = allocUnsafe(se.length);
  for (let Oe = 0; Oe < se.length; Oe++)
    e[Oe] = se.charCodeAt(Oe);
  return e;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString(se, e = "utf8") {
  const Oe = BASES[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(se.buffer, se.byteOffset, se.byteLength).toString("utf8") : Oe.encoder.encode(se).substring(1);
}
class o extends IJsonRpcProvider {
  constructor(e) {
    super(e), this.events = new EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async request(e, Oe) {
    return this.requestStrict(formatJsonRpcRequest(e.method, e.params || [], e.id || getBigIntRpcId().toString()), Oe);
  }
  async requestStrict(e, Oe) {
    return new Promise(async (Si, wi) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (Ei) {
          wi(Ei);
        }
      this.events.on(`${e.id}`, (Ei) => {
        isJsonRpcError(Ei) ? wi(Ei.error) : Si(Ei.result);
      });
      try {
        await this.connection.send(e, Oe);
      } catch (Ei) {
        wi(Ei);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), isJsonRpcResponse(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
const v$3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), w$1 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", d = (se) => se.split("?")[0], h = 10, b$1 = v$3();
let f$1 = class {
  constructor(e) {
    if (this.url = e, this.events = new EventEmitter(), this.registering = !1, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, Oe) => {
      if (typeof this.socket > "u") {
        Oe(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (Si) => {
        this.onClose(Si), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (Oe) {
      this.onError(e.id, Oe);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const Oe = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= Oe || this.events.listenerCount("open") >= Oe) && this.events.setMaxListeners(Oe + 1), new Promise((Si, wi) => {
        this.events.once("register_error", (Ei) => {
          this.resetMaxListeners(), wi(Ei);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return wi(new Error("WebSocket connection is missing or invalid"));
          Si(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((Oe, Si) => {
      const wi = cjs.isReactNative() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, Ei = new b$1(e, [], wi);
      w$1() ? Ei.onerror = ($i) => {
        const xi = $i;
        Si(this.emitError(xi.error));
      } : Ei.on("error", ($i) => {
        Si(this.emitError($i));
      }), Ei.onopen = () => {
        this.onOpen(Ei), Oe(Ei);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (Oe) => this.onPayload(Oe), e.onclose = (Oe) => this.onClose(Oe), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const Oe = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", Oe);
  }
  onError(e, Oe) {
    const Si = this.parseError(Oe), wi = Si.message || Si.toString(), Ei = formatJsonRpcError(e, wi);
    this.events.emit("payload", Ei);
  }
  parseError(e, Oe = this.url) {
    return parseConnectionError(e, d(Oe), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h && this.events.setMaxListeners(h);
  }
  emitError(e) {
    const Oe = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${d(this.url)}`));
    return this.events.emit("register_error", Oe), Oe;
  }
};
const ye$1 = "wc", De$1 = 2, J = "core", A = `${ye$1}@2:${J}:`, Xe = { name: J, logger: "error" }, We = { database: ":memory:" }, Ze = "crypto", me$1 = "client_ed25519_seed", Qe = cjs$4.ONE_DAY, et = "keychain", tt = "0.3", it$1 = "messages", st = "0.3", be = cjs$4.SIX_HOURS, rt$1 = "publisher", nt$1 = "irn", ot$1 = "error", fe = "wss://relay.walletconnect.org", at$1 = "relayer", v$2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, ct$1 = "_subscription", C = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, ht$1 = 0.1, re = "2.17.3", M$1 = { link_mode: "link_mode", relay: "relay" }, lt$1 = "0.3", ut$1 = "WALLETCONNECT_CLIENT_ID", ve = "WALLETCONNECT_LINK_MODE_APPS", T$1 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, dt$1 = "subscription", pt$1 = "0.3", gt$1 = cjs$4.FIVE_SECONDS * 1e3, yt$1 = "pairing", Dt = "0.3", V = { wc_pairingDelete: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: cjs$4.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 0 } } }, j = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, R = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, mt = "history", bt = "0.3", ft = "expirer", x$2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, vt = "0.3", _t = "verify-api", Ss$1 = "https://verify.walletconnect.com", Et = "https://verify.walletconnect.org", X = Et, wt$1 = `${X}/v3`, It = [Ss$1, Et], Tt = "echo", Ct = "https://echo.walletconnect.com", z$1 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, $ = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, xs = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Os = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, As = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" }, Ns = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, Pt = 0.1, St = "event-client", Rt = 86400, xt = "https://pulse.walletconnect.org/batch";
function zs(se, e) {
  if (se.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var Oe = new Uint8Array(256), Si = 0; Si < Oe.length; Si++)
    Oe[Si] = 255;
  for (var wi = 0; wi < se.length; wi++) {
    var Ei = se.charAt(wi), $i = Ei.charCodeAt(0);
    if (Oe[$i] !== 255)
      throw new TypeError(Ei + " is ambiguous");
    Oe[$i] = wi;
  }
  var xi = se.length, Ri = se.charAt(0), Ti = Math.log(xi) / Math.log(256), Oi = Math.log(256) / Math.log(xi);
  function Mi(Oo) {
    if (Oo instanceof Uint8Array || (ArrayBuffer.isView(Oo) ? Oo = new Uint8Array(Oo.buffer, Oo.byteOffset, Oo.byteLength) : Array.isArray(Oo) && (Oo = Uint8Array.from(Oo))), !(Oo instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Oo.length === 0)
      return "";
    for (var Ro = 0, Bo = 0, Fo = 0, Io = Oo.length; Fo !== Io && Oo[Fo] === 0; )
      Fo++, Ro++;
    for (var Uo = (Io - Fo) * Oi + 1 >>> 0, Co = new Uint8Array(Uo); Fo !== Io; ) {
      for (var ko = Oo[Fo], Po = 0, Mo = Uo - 1; (ko !== 0 || Po < Bo) && Mo !== -1; Mo--, Po++)
        ko += 256 * Co[Mo] >>> 0, Co[Mo] = ko % xi >>> 0, ko = ko / xi >>> 0;
      if (ko !== 0)
        throw new Error("Non-zero carry");
      Bo = Po, Fo++;
    }
    for (var No = Uo - Bo; No !== Uo && Co[No] === 0; )
      No++;
    for (var Jo = Ri.repeat(Ro); No < Uo; ++No)
      Jo += se.charAt(Co[No]);
    return Jo;
  }
  function Ii(Oo) {
    if (typeof Oo != "string")
      throw new TypeError("Expected String");
    if (Oo.length === 0)
      return new Uint8Array();
    var Ro = 0;
    if (Oo[Ro] !== " ") {
      for (var Bo = 0, Fo = 0; Oo[Ro] === Ri; )
        Bo++, Ro++;
      for (var Io = (Oo.length - Ro) * Ti + 1 >>> 0, Uo = new Uint8Array(Io); Oo[Ro]; ) {
        var Co = Oe[Oo.charCodeAt(Ro)];
        if (Co === 255)
          return;
        for (var ko = 0, Po = Io - 1; (Co !== 0 || ko < Fo) && Po !== -1; Po--, ko++)
          Co += xi * Uo[Po] >>> 0, Uo[Po] = Co % 256 >>> 0, Co = Co / 256 >>> 0;
        if (Co !== 0)
          throw new Error("Non-zero carry");
        Fo = ko, Ro++;
      }
      if (Oo[Ro] !== " ") {
        for (var Mo = Io - Fo; Mo !== Io && Uo[Mo] === 0; )
          Mo++;
        for (var No = new Uint8Array(Bo + (Io - Mo)), Jo = Bo; Mo !== Io; )
          No[Jo++] = Uo[Mo++];
        return No;
      }
    }
  }
  function Ci(Oo) {
    var Ro = Ii(Oo);
    if (Ro)
      return Ro;
    throw new Error(`Non-${e} character`);
  }
  return { encode: Mi, decodeUnsafe: Ii, decode: Ci };
}
var Ls = zs, $s = Ls;
const Ot = (se) => {
  if (se instanceof Uint8Array && se.constructor.name === "Uint8Array")
    return se;
  if (se instanceof ArrayBuffer)
    return new Uint8Array(se);
  if (ArrayBuffer.isView(se))
    return new Uint8Array(se.buffer, se.byteOffset, se.byteLength);
  throw new Error("Unknown type, must be binary type");
}, ks = (se) => new TextEncoder().encode(se), Us = (se) => new TextDecoder().decode(se);
class Fs {
  constructor(e, Oe, Si) {
    this.name = e, this.prefix = Oe, this.baseEncode = Si;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Ms {
  constructor(e, Oe, Si) {
    if (this.name = e, this.prefix = Oe, Oe.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = Oe.codePointAt(0), this.baseDecode = Si;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return At(this, e);
  }
}
class Ks {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return At(this, e);
  }
  decode(e) {
    const Oe = e[0], Si = this.decoders[Oe];
    if (Si)
      return Si.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const At = (se, e) => new Ks({ ...se.decoders || { [se.prefix]: se }, ...e.decoders || { [e.prefix]: e } });
class Bs {
  constructor(e, Oe, Si, wi) {
    this.name = e, this.prefix = Oe, this.baseEncode = Si, this.baseDecode = wi, this.encoder = new Fs(e, Oe, Si), this.decoder = new Ms(e, Oe, wi);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const ne = ({ name: se, prefix: e, encode: Oe, decode: Si }) => new Bs(se, e, Oe, Si), W = ({ prefix: se, name: e, alphabet: Oe }) => {
  const { encode: Si, decode: wi } = $s(Oe, e);
  return ne({ prefix: se, name: e, encode: Si, decode: (Ei) => Ot(wi(Ei)) });
}, Vs = (se, e, Oe, Si) => {
  const wi = {};
  for (let Oi = 0; Oi < e.length; ++Oi)
    wi[e[Oi]] = Oi;
  let Ei = se.length;
  for (; se[Ei - 1] === "="; )
    --Ei;
  const $i = new Uint8Array(Ei * Oe / 8 | 0);
  let xi = 0, Ri = 0, Ti = 0;
  for (let Oi = 0; Oi < Ei; ++Oi) {
    const Mi = wi[se[Oi]];
    if (Mi === void 0)
      throw new SyntaxError(`Non-${Si} character`);
    Ri = Ri << Oe | Mi, xi += Oe, xi >= 8 && (xi -= 8, $i[Ti++] = 255 & Ri >> xi);
  }
  if (xi >= Oe || 255 & Ri << 8 - xi)
    throw new SyntaxError("Unexpected end of data");
  return $i;
}, js = (se, e, Oe) => {
  const Si = e[e.length - 1] === "=", wi = (1 << Oe) - 1;
  let Ei = "", $i = 0, xi = 0;
  for (let Ri = 0; Ri < se.length; ++Ri)
    for (xi = xi << 8 | se[Ri], $i += 8; $i > Oe; )
      $i -= Oe, Ei += e[wi & xi >> $i];
  if ($i && (Ei += e[wi & xi << Oe - $i]), Si)
    for (; Ei.length * Oe & 7; )
      Ei += "=";
  return Ei;
}, _$1 = ({ name: se, prefix: e, bitsPerChar: Oe, alphabet: Si }) => ne({ prefix: e, name: se, encode(wi) {
  return js(wi, Si, Oe);
}, decode(wi) {
  return Vs(wi, Si, Oe, se);
} }), qs$1 = ne({ prefix: "\0", name: "identity", encode: (se) => Us(se), decode: (se) => ks(se) });
var Gs = Object.freeze({ __proto__: null, identity: qs$1 });
const Hs = _$1({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ys = Object.freeze({ __proto__: null, base2: Hs });
const Js = _$1({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Xs = Object.freeze({ __proto__: null, base8: Js });
const Ws = W({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Zs = Object.freeze({ __proto__: null, base10: Ws });
const Qs = _$1({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), er = _$1({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var tr = Object.freeze({ __proto__: null, base16: Qs, base16upper: er });
const ir = _$1({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), sr = _$1({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), rr = _$1({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), nr = _$1({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), or = _$1({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), ar = _$1({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), cr = _$1({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), hr = _$1({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), lr = _$1({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ur = Object.freeze({ __proto__: null, base32: ir, base32upper: sr, base32pad: rr, base32padupper: nr, base32hex: or, base32hexupper: ar, base32hexpad: cr, base32hexpadupper: hr, base32z: lr });
const dr = W({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), pr = W({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var gr = Object.freeze({ __proto__: null, base36: dr, base36upper: pr });
const yr = W({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Dr = W({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var mr = Object.freeze({ __proto__: null, base58btc: yr, base58flickr: Dr });
const br = _$1({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), fr = _$1({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), vr = _$1({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), _r = _$1({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Er = Object.freeze({ __proto__: null, base64: br, base64pad: fr, base64url: vr, base64urlpad: _r });
const Nt = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), wr = Nt.reduce((se, e, Oe) => (se[Oe] = e, se), []), Ir = Nt.reduce((se, e, Oe) => (se[e.codePointAt(0)] = Oe, se), []);
function Tr(se) {
  return se.reduce((e, Oe) => (e += wr[Oe], e), "");
}
function Cr(se) {
  const e = [];
  for (const Oe of se) {
    const Si = Ir[Oe.codePointAt(0)];
    if (Si === void 0)
      throw new Error(`Non-base256emoji character: ${Oe}`);
    e.push(Si);
  }
  return new Uint8Array(e);
}
const Pr = ne({ prefix: "🚀", name: "base256emoji", encode: Tr, decode: Cr });
var Sr = Object.freeze({ __proto__: null, base256emoji: Pr }), Rr = Lt, zt = 128, xr = 127, Or = ~xr, Ar = Math.pow(2, 31);
function Lt(se, e, Oe) {
  e = e || [], Oe = Oe || 0;
  for (var Si = Oe; se >= Ar; )
    e[Oe++] = se & 255 | zt, se /= 128;
  for (; se & Or; )
    e[Oe++] = se & 255 | zt, se >>>= 7;
  return e[Oe] = se | 0, Lt.bytes = Oe - Si + 1, e;
}
var Nr = _e$1, zr = 128, $t = 127;
function _e$1(se, Si) {
  var Oe = 0, Si = Si || 0, wi = 0, Ei = Si, $i, xi = se.length;
  do {
    if (Ei >= xi)
      throw _e$1.bytes = 0, new RangeError("Could not decode varint");
    $i = se[Ei++], Oe += wi < 28 ? ($i & $t) << wi : ($i & $t) * Math.pow(2, wi), wi += 7;
  } while ($i >= zr);
  return _e$1.bytes = Ei - Si, Oe;
}
var Lr = Math.pow(2, 7), $r = Math.pow(2, 14), kr = Math.pow(2, 21), Ur = Math.pow(2, 28), Fr = Math.pow(2, 35), Mr = Math.pow(2, 42), Kr = Math.pow(2, 49), Br = Math.pow(2, 56), Vr = Math.pow(2, 63), jr = function(se) {
  return se < Lr ? 1 : se < $r ? 2 : se < kr ? 3 : se < Ur ? 4 : se < Fr ? 5 : se < Mr ? 6 : se < Kr ? 7 : se < Br ? 8 : se < Vr ? 9 : 10;
}, qr = { encode: Rr, decode: Nr, encodingLength: jr }, kt = qr;
const Ut = (se, e, Oe = 0) => (kt.encode(se, e, Oe), e), Ft = (se) => kt.encodingLength(se), Ee = (se, e) => {
  const Oe = e.byteLength, Si = Ft(se), wi = Si + Ft(Oe), Ei = new Uint8Array(wi + Oe);
  return Ut(se, Ei, 0), Ut(Oe, Ei, Si), Ei.set(e, wi), new Gr(se, Oe, e, Ei);
};
class Gr {
  constructor(e, Oe, Si, wi) {
    this.code = e, this.size = Oe, this.digest = Si, this.bytes = wi;
  }
}
const Mt = ({ name: se, code: e, encode: Oe }) => new Hr(se, e, Oe);
class Hr {
  constructor(e, Oe, Si) {
    this.name = e, this.code = Oe, this.encode = Si;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const Oe = this.encode(e);
      return Oe instanceof Uint8Array ? Ee(this.code, Oe) : Oe.then((Si) => Ee(this.code, Si));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const Kt = (se) => async (e) => new Uint8Array(await crypto.subtle.digest(se, e)), Yr = Mt({ name: "sha2-256", code: 18, encode: Kt("SHA-256") }), Jr = Mt({ name: "sha2-512", code: 19, encode: Kt("SHA-512") });
var Xr = Object.freeze({ __proto__: null, sha256: Yr, sha512: Jr });
const Bt = 0, Wr = "identity", Vt = Ot, Zr = (se) => Ee(Bt, Vt(se)), Qr = { code: Bt, name: Wr, encode: Vt, digest: Zr };
var en = Object.freeze({ __proto__: null, identity: Qr });
new TextEncoder(), new TextDecoder();
const jt = { ...Gs, ...Ys, ...Xs, ...Zs, ...tr, ...ur, ...gr, ...mr, ...Er, ...Sr };
({ ...Xr, ...en });
function tn(se = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(se) : new Uint8Array(se);
}
function qt(se, e, Oe, Si) {
  return { name: se, prefix: e, encoder: { name: se, prefix: e, encode: Oe }, decoder: { decode: Si } };
}
const Gt = qt("utf8", "u", (se) => "u" + new TextDecoder("utf8").decode(se), (se) => new TextEncoder().encode(se.substring(1))), we$1 = qt("ascii", "a", (se) => {
  let e = "a";
  for (let Oe = 0; Oe < se.length; Oe++)
    e += String.fromCharCode(se[Oe]);
  return e;
}, (se) => {
  se = se.substring(1);
  const e = tn(se.length);
  for (let Oe = 0; Oe < se.length; Oe++)
    e[Oe] = se.charCodeAt(Oe);
  return e;
}), sn = { utf8: Gt, "utf-8": Gt, hex: jt.base16, latin1: we$1, ascii: we$1, binary: we$1, ...jt };
function rn(se, e = "utf8") {
  const Oe = sn[e];
  if (!Oe)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(se, "utf8") : Oe.decoder.decode(`${Oe.prefix}${se}`);
}
class Ht {
  constructor(e, Oe) {
    this.core = e, this.logger = Oe, this.keychain = /* @__PURE__ */ new Map(), this.name = et, this.version = tt, this.initialized = !1, this.storagePrefix = A, this.init = async () => {
      if (!this.initialized) {
        const Si = await this.getKeyChain();
        typeof Si < "u" && (this.keychain = Si), this.initialized = !0;
      }
    }, this.has = (Si) => (this.isInitialized(), this.keychain.has(Si)), this.set = async (Si, wi) => {
      this.isInitialized(), this.keychain.set(Si, wi), await this.persist();
    }, this.get = (Si) => {
      this.isInitialized();
      const wi = this.keychain.get(Si);
      if (typeof wi > "u") {
        const { message: Ei } = S$3("NO_MATCHING_KEY", `${this.name}: ${Si}`);
        throw new Error(Ei);
      }
      return wi;
    }, this.del = async (Si) => {
      this.isInitialized(), this.keychain.delete(Si), await this.persist();
    }, this.core = e, this.logger = E$1(Oe, this.name);
  }
  get context() {
    return y$2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, At$1(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Ct$1(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Yt {
  constructor(e, Oe, Si) {
    this.core = e, this.logger = Oe, this.name = Ze, this.randomSessionIdentifier = yr$1(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (wi) => (this.isInitialized(), this.keychain.has(wi)), this.getClientId = async () => {
      this.isInitialized();
      const wi = await this.getClientSeed(), Ei = generateKeyPair(wi);
      return encodeIss(Ei.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const wi = hr$1();
      return this.setPrivateKey(wi.publicKey, wi.privateKey);
    }, this.signJWT = async (wi) => {
      this.isInitialized();
      const Ei = await this.getClientSeed(), $i = generateKeyPair(Ei), xi = this.randomSessionIdentifier;
      return await signJWT(xi, wi, Qe, $i);
    }, this.generateSharedKey = (wi, Ei, $i) => {
      this.isInitialized();
      const xi = this.getPrivateKey(wi), Ri = gr$1(xi, Ei);
      return this.setSymKey(Ri, $i);
    }, this.setSymKey = async (wi, Ei) => {
      this.isInitialized();
      const $i = Ei || vr$1(wi);
      return await this.keychain.set($i, wi), $i;
    }, this.deleteKeyPair = async (wi) => {
      this.isInitialized(), await this.keychain.del(wi);
    }, this.deleteSymKey = async (wi) => {
      this.isInitialized(), await this.keychain.del(wi);
    }, this.encode = async (wi, Ei, $i) => {
      this.isInitialized();
      const xi = On($i), Ri = safeJsonStringify(Ei);
      if (Rr$1(xi))
        return wr$1(Ri, $i == null ? void 0 : $i.encoding);
      if ($r$1(xi)) {
        const Ii = xi.senderPublicKey, Ci = xi.receiverPublicKey;
        wi = await this.generateSharedKey(Ii, Ci);
      }
      const Ti = this.getSymKey(wi), { type: Oi, senderPublicKey: Mi } = xi;
      return Er$1({ type: Oi, symKey: Ti, message: Ri, senderPublicKey: Mi, encoding: $i == null ? void 0 : $i.encoding });
    }, this.decode = async (wi, Ei, $i) => {
      this.isInitialized();
      const xi = Sr$1(Ei, $i);
      if (Rr$1(xi)) {
        const Ri = Nr$1(Ei, $i == null ? void 0 : $i.encoding);
        return safeJsonParse(Ri);
      }
      if ($r$1(xi)) {
        const Ri = xi.receiverPublicKey, Ti = xi.senderPublicKey;
        wi = await this.generateSharedKey(Ri, Ti);
      }
      try {
        const Ri = this.getSymKey(wi), Ti = Or$1({ symKey: Ri, encoded: Ei, encoding: $i == null ? void 0 : $i.encoding });
        return safeJsonParse(Ti);
      } catch (Ri) {
        this.logger.error(`Failed to decode message from topic: '${wi}', clientId: '${await this.getClientId()}'`), this.logger.error(Ri);
      }
    }, this.getPayloadType = (wi, Ei = ge) => {
      const $i = Q$1({ encoded: wi, encoding: Ei });
      return C$3($i.type);
    }, this.getPayloadSenderPublicKey = (wi, Ei = ge) => {
      const $i = Q$1({ encoded: wi, encoding: Ei });
      return $i.senderPublicKey ? toString($i.senderPublicKey, g$3) : void 0;
    }, this.core = e, this.logger = E$1(Oe, this.name), this.keychain = Si || new Ht(this.core, this.logger);
  }
  get context() {
    return y$2(this.logger);
  }
  async setPrivateKey(e, Oe) {
    return await this.keychain.set(e, Oe), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(me$1);
    } catch {
      e = yr$1(), await this.keychain.set(me$1, e);
    }
    return rn(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Jt extends a {
  constructor(e, Oe) {
    super(e, Oe), this.logger = e, this.core = Oe, this.messages = /* @__PURE__ */ new Map(), this.name = it$1, this.version = st, this.initialized = !1, this.storagePrefix = A, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const Si = await this.getRelayerMessages();
          typeof Si < "u" && (this.messages = Si), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (Si) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(Si);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (Si, wi) => {
      this.isInitialized();
      const Ei = br$1(wi);
      let $i = this.messages.get(Si);
      return typeof $i > "u" && ($i = {}), typeof $i[Ei] < "u" || ($i[Ei] = wi, this.messages.set(Si, $i), await this.persist()), Ei;
    }, this.get = (Si) => {
      this.isInitialized();
      let wi = this.messages.get(Si);
      return typeof wi > "u" && (wi = {}), wi;
    }, this.has = (Si, wi) => {
      this.isInitialized();
      const Ei = this.get(Si), $i = br$1(wi);
      return typeof Ei[$i] < "u";
    }, this.del = async (Si) => {
      this.isInitialized(), this.messages.delete(Si), await this.persist();
    }, this.logger = E$1(e, this.name), this.core = Oe;
  }
  get context() {
    return y$2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, At$1(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Ct$1(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var nn = Object.defineProperty, on = Object.defineProperties, an = Object.getOwnPropertyDescriptors, Xt = Object.getOwnPropertySymbols, cn = Object.prototype.hasOwnProperty, hn = Object.prototype.propertyIsEnumerable, Wt = (se, e, Oe) => e in se ? nn(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Zt = (se, e) => {
  for (var Oe in e || (e = {}))
    cn.call(e, Oe) && Wt(se, Oe, e[Oe]);
  if (Xt)
    for (var Oe of Xt(e))
      hn.call(e, Oe) && Wt(se, Oe, e[Oe]);
  return se;
}, Qt = (se, e) => on(se, an(e));
class ln extends g$1 {
  constructor(e, Oe) {
    super(e, Oe), this.relayer = e, this.logger = Oe, this.events = new EventEmitter(), this.name = rt$1, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$4.toMiliseconds(cjs$4.ONE_MINUTE), this.initialPublishTimeout = cjs$4.toMiliseconds(cjs$4.ONE_SECOND * 15), this.needsTransportRestart = !1, this.publish = async (Si, wi, Ei) => {
      var $i;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: Si, message: wi, opts: Ei } });
      const xi = (Ei == null ? void 0 : Ei.ttl) || be, Ri = Tr$1(Ei), Ti = (Ei == null ? void 0 : Ei.prompt) || !1, Oi = (Ei == null ? void 0 : Ei.tag) || 0, Mi = (Ei == null ? void 0 : Ei.id) || getBigIntRpcId().toString(), Ii = { topic: Si, message: wi, opts: { ttl: xi, relay: Ri, prompt: Ti, tag: Oi, id: Mi, attestation: Ei == null ? void 0 : Ei.attestation } }, Ci = `Failed to publish payload, please try again. id:${Mi} tag:${Oi}`;
      try {
        const Oo = new Promise(async (Ro) => {
          const Bo = ({ id: Io }) => {
            Ii.opts.id === Io && (this.removeRequestFromQueue(Io), this.relayer.events.removeListener(v$2.publish, Bo), Ro(Ii));
          };
          this.relayer.events.on(v$2.publish, Bo);
          const Fo = xt$1(new Promise((Io, Uo) => {
            this.rpcPublish({ topic: Si, message: wi, ttl: xi, prompt: Ti, tag: Oi, id: Mi, attestation: Ei == null ? void 0 : Ei.attestation }).then(Io).catch((Co) => {
              this.logger.warn(Co, Co == null ? void 0 : Co.message), Uo(Co);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${Mi} tag:${Oi}`);
          try {
            await Fo, this.events.removeListener(v$2.publish, Bo);
          } catch (Io) {
            this.queue.set(Mi, Qt(Zt({}, Ii), { attempt: 1 })), this.logger.warn(Io, Io == null ? void 0 : Io.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: Mi, topic: Si, message: wi, opts: Ei } }), await xt$1(Oo, this.publishTimeout, Ci);
      } catch (Oo) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(Oo), ($i = Ei == null ? void 0 : Ei.internal) != null && $i.throwOnFailedPublish)
          throw Oo;
      } finally {
        this.queue.delete(Mi);
      }
    }, this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.relayer = e, this.logger = E$1(Oe, this.name), this.registerEventListeners();
  }
  get context() {
    return y$2(this.logger);
  }
  async rpcPublish(e) {
    var Oe, Si, wi, Ei;
    const { topic: $i, message: xi, ttl: Ri = be, prompt: Ti, tag: Oi, id: Mi, attestation: Ii } = e, Ci = { method: Ar$1(Tr$1().protocol).publish, params: { topic: $i, message: xi, ttl: Ri, prompt: Ti, tag: Oi, attestation: Ii }, id: Mi };
    P((Oe = Ci.params) == null ? void 0 : Oe.prompt) && ((Si = Ci.params) == null || delete Si.prompt), P((wi = Ci.params) == null ? void 0 : wi.tag) && ((Ei = Ci.params) == null || delete Ei.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: Ci });
    const Oo = await this.relayer.request(Ci);
    return this.relayer.events.emit(v$2.publish, e), this.logger.debug("Successfully Published Payload"), Oo;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, Oe) => {
      const Si = e.attempt + 1;
      this.queue.set(Oe, Qt(Zt({}, e), { attempt: Si }));
      const { topic: wi, message: Ei, opts: $i, attestation: xi } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${Si}`), await this.rpcPublish({ topic: wi, message: Ei, ttl: $i.ttl, prompt: $i.prompt, tag: $i.tag, id: $i.id, attestation: xi }), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(v$2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v$2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class un {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, Oe) => {
      const Si = this.get(e);
      this.exists(e, Oe) || this.map.set(e, [...Si, Oe]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, Oe) => this.get(e).includes(Oe), this.delete = (e, Oe) => {
      if (typeof Oe > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const Si = this.get(e);
      if (!this.exists(e, Oe))
        return;
      const wi = Si.filter((Ei) => Ei !== Oe);
      if (!wi.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, wi);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var dn = Object.defineProperty, pn = Object.defineProperties, gn = Object.getOwnPropertyDescriptors, ei = Object.getOwnPropertySymbols, yn = Object.prototype.hasOwnProperty, Dn = Object.prototype.propertyIsEnumerable, ti = (se, e, Oe) => e in se ? dn(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Z = (se, e) => {
  for (var Oe in e || (e = {}))
    yn.call(e, Oe) && ti(se, Oe, e[Oe]);
  if (ei)
    for (var Oe of ei(e))
      Dn.call(e, Oe) && ti(se, Oe, e[Oe]);
  return se;
}, Ie = (se, e) => pn(se, gn(e));
class ii extends d$1 {
  constructor(e, Oe) {
    super(e, Oe), this.relayer = e, this.logger = Oe, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new un(), this.events = new EventEmitter(), this.name = dt$1, this.version = pt$1, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = A, this.subscribeTimeout = cjs$4.toMiliseconds(cjs$4.ONE_MINUTE), this.initialSubscribeTimeout = cjs$4.toMiliseconds(cjs$4.ONE_SECOND * 15), this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (Si, wi) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Si, opts: wi } });
      try {
        const Ei = Tr$1(wi), $i = { topic: Si, relay: Ei, transportType: wi == null ? void 0 : wi.transportType };
        this.pending.set(Si, $i);
        const xi = await this.rpcSubscribe(Si, Ei, wi);
        return typeof xi == "string" && (this.onSubscribe(xi, $i), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Si, opts: wi } })), xi;
      } catch (Ei) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(Ei), Ei;
      }
    }, this.unsubscribe = async (Si, wi) => {
      await this.restartToComplete(), this.isInitialized(), typeof (wi == null ? void 0 : wi.id) < "u" ? await this.unsubscribeById(Si, wi.id, wi) : await this.unsubscribeByTopic(Si, wi);
    }, this.isSubscribed = async (Si) => {
      if (this.topics.includes(Si))
        return !0;
      const wi = `${this.pendingSubscriptionWatchLabel}_${Si}`;
      return await new Promise((Ei, $i) => {
        const xi = new cjs$4.Watch();
        xi.start(wi);
        const Ri = setInterval(() => {
          (!this.pending.has(Si) && this.topics.includes(Si) || this.cached.some((Ti) => Ti.topic === Si)) && (clearInterval(Ri), xi.stop(wi), Ei(!0)), xi.elapsed(wi) >= gt$1 && (clearInterval(Ri), xi.stop(wi), $i(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      await this.restore(), await this.onRestart();
    }, this.checkPending = async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
        return;
      const Si = [];
      this.pending.forEach((wi) => {
        Si.push(wi);
      }), await this.batchSubscribe(Si);
    }, this.registerEventListeners = () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on(T$1.created, async (Si) => {
        const wi = T$1.created;
        this.logger.info(`Emitting ${wi}`), this.logger.debug({ type: "event", event: wi, data: Si }), await this.persist();
      }), this.events.on(T$1.deleted, async (Si) => {
        const wi = T$1.deleted;
        this.logger.info(`Emitting ${wi}`), this.logger.debug({ type: "event", event: wi, data: Si }), await this.persist();
      });
    }, this.relayer = e, this.logger = E$1(Oe, this.name), this.clientId = "";
  }
  get context() {
    return y$2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, Oe) {
    let Si = !1;
    try {
      Si = this.getSubscription(e).topic === Oe;
    } catch {
    }
    return Si;
  }
  reset() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, Oe) {
    const Si = this.topicMap.get(e);
    await Promise.all(Si.map(async (wi) => await this.unsubscribeById(e, wi, Oe)));
  }
  async unsubscribeById(e, Oe, Si) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: Oe, opts: Si } });
    try {
      const wi = Tr$1(Si);
      await this.rpcUnsubscribe(e, Oe, wi);
      const Ei = _$4("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, Oe, Ei), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: Oe, opts: Si } });
    } catch (wi) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(wi), wi;
    }
  }
  async rpcSubscribe(e, Oe, Si) {
    var wi;
    (Si == null ? void 0 : Si.transportType) === M$1.relay && await this.restartToComplete();
    const Ei = { method: Ar$1(Oe.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Ei });
    const $i = (wi = Si == null ? void 0 : Si.internal) == null ? void 0 : wi.throwOnFailedPublish;
    try {
      const xi = this.getSubscriptionId(e);
      if ((Si == null ? void 0 : Si.transportType) === M$1.link_mode)
        return setTimeout(() => {
          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(Ei).catch((Oi) => this.logger.warn(Oi));
        }, cjs$4.toMiliseconds(cjs$4.ONE_SECOND)), xi;
      const Ri = new Promise(async (Oi) => {
        const Mi = (Ii) => {
          Ii.topic === e && (this.events.removeListener(T$1.created, Mi), Oi(Ii.id));
        };
        this.events.on(T$1.created, Mi);
        try {
          const Ii = await xt$1(new Promise((Ci, Oo) => {
            this.relayer.request(Ei).catch((Ro) => {
              this.logger.warn(Ro, Ro == null ? void 0 : Ro.message), Oo(Ro);
            }).then(Ci);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(T$1.created, Mi), Oi(Ii);
        } catch {
        }
      }), Ti = await xt$1(Ri, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!Ti && $i)
        throw new Error(`Subscribing to ${e} failed, please try again`);
      return Ti ? xi : null;
    } catch (xi) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v$2.connection_stalled), $i)
        throw xi;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const Oe = e[0].relay, Si = { method: Ar$1(Oe.protocol).batchSubscribe, params: { topics: e.map((wi) => wi.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Si });
    try {
      await await xt$1(new Promise((wi) => {
        this.relayer.request(Si).catch((Ei) => this.logger.warn(Ei)).then(wi);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length)
      return;
    const Oe = e[0].relay, Si = { method: Ar$1(Oe.protocol).batchFetchMessages, params: { topics: e.map((Ei) => Ei.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Si });
    let wi;
    try {
      wi = await await xt$1(new Promise((Ei, $i) => {
        this.relayer.request(Si).catch((xi) => {
          this.logger.warn(xi), $i(xi);
        }).then(Ei);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
    return wi;
  }
  rpcUnsubscribe(e, Oe, Si) {
    const wi = { method: Ar$1(Si.protocol).unsubscribe, params: { topic: e, id: Oe } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: wi }), this.relayer.request(wi);
  }
  onSubscribe(e, Oe) {
    this.setSubscription(e, Ie(Z({}, Oe), { id: e })), this.pending.delete(Oe.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((Oe) => {
      this.setSubscription(Oe.id, Z({}, Oe)), this.pending.delete(Oe.topic);
    });
  }
  async onUnsubscribe(e, Oe, Si) {
    this.events.removeAllListeners(Oe), this.hasSubscription(Oe, e) && this.deleteSubscription(Oe, Si), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, Oe) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: Oe }), this.addSubscription(e, Oe);
  }
  addSubscription(e, Oe) {
    this.subscriptions.set(e, Z({}, Oe)), this.topicMap.set(Oe.topic, e), this.events.emit(T$1.created, Oe);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const Oe = this.subscriptions.get(e);
    if (!Oe) {
      const { message: Si } = S$3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(Si);
    }
    return Oe;
  }
  deleteSubscription(e, Oe) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: Oe });
    const Si = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(Si.topic, e), this.events.emit(T$1.deleted, Ie(Z({}, Si), { reason: Oe }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(T$1.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], Oe = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let Si = 0; Si < Oe; Si++) {
        const wi = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(wi);
      }
    }
    this.events.emit(T$1.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: Oe } = S$3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(e.map((Oe) => Ie(Z({}, Oe), { id: this.getSubscriptionId(Oe.topic) }))));
  }
  async batchFetchMessages(e) {
    if (!e.length)
      return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const Oe = await this.rpcBatchFetchMessages(e);
    Oe && Oe.messages && (await Gt$1(cjs$4.toMiliseconds(cjs$4.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(Oe.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen();
  }
  getSubscriptionId(e) {
    return br$1(e + this.clientId);
  }
}
var mn = Object.defineProperty, si = Object.getOwnPropertySymbols, bn = Object.prototype.hasOwnProperty, fn = Object.prototype.propertyIsEnumerable, ri = (se, e, Oe) => e in se ? mn(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, ni = (se, e) => {
  for (var Oe in e || (e = {}))
    bn.call(e, Oe) && ri(se, Oe, e[Oe]);
  if (si)
    for (var Oe of si(e))
      fn.call(e, Oe) && ri(se, Oe, e[Oe]);
  return se;
};
class oi extends u {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new EventEmitter(), this.name = at$1, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1, this.heartBeatTimeout = cjs$4.toMiliseconds(cjs$4.THIRTY_SECONDS + cjs$4.FIVE_SECONDS), this.requestsInFlight = [], this.connectTimeout = cjs$4.toMiliseconds(cjs$4.ONE_SECOND * 15), this.request = async (Oe) => {
      var Si, wi;
      this.logger.debug("Publishing Request Payload");
      const Ei = Oe.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: Ei, method: Oe.method, topic: (Si = Oe.params) == null ? void 0 : Si.topic }, "relayer.request - publishing...");
        const $i = `${Ei}:${((wi = Oe.params) == null ? void 0 : wi.tag) || ""}`;
        this.requestsInFlight.push($i);
        const xi = await this.provider.request(Oe);
        return this.requestsInFlight = this.requestsInFlight.filter((Ri) => Ri !== $i), xi;
      } catch ($i) {
        throw this.logger.debug(`Failed to Publish Request: ${Ei}`), $i;
      }
    }, this.resetPingTimeout = () => {
      if (ce())
        try {
          clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
            var Oe, Si, wi;
            this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (wi = (Si = (Oe = this.provider) == null ? void 0 : Oe.connection) == null ? void 0 : Si.socket) == null || wi.terminate();
          }, this.heartBeatTimeout);
        } catch (Oe) {
          this.logger.warn(Oe, Oe == null ? void 0 : Oe.message);
        }
    }, this.onPayloadHandler = (Oe) => {
      this.onProviderPayload(Oe), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.warn({}, "Relayer connected 🛜"), this.startPingTimeout(), this.events.emit(v$2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.warn({}, "Relayer disconnected 🛑"), this.requestsInFlight = [], this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (Oe) => {
      this.logger.fatal(Oe, `Fatal socket error: ${Oe == null ? void 0 : Oe.message}`), this.events.emit(v$2.error, Oe), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(C.payload, this.onPayloadHandler), this.provider.on(C.connect, this.onConnectHandler), this.provider.on(C.disconnect, this.onDisconnectHandler), this.provider.on(C.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E$1(e.logger, this.name) : Tt$1(k$1({ level: e.logger || ot$1 })), this.messages = new Jt(this.logger, e.core), this.subscriber = new ii(this, this.logger), this.publisher = new ln(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || fe, this.projectId = e.projectId, Ot$1() ? this.packageName = St$1() : Nt$1() && (this.bundleId = St$1()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0)
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e, e == null ? void 0 : e.message);
      }
  }
  get context() {
    return y$2(this.logger);
  }
  get connected() {
    var e, Oe, Si;
    return ((Si = (Oe = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : Oe.socket) == null ? void 0 : Si.readyState) === 1;
  }
  get connecting() {
    var e, Oe, Si;
    return ((Si = (Oe = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : Oe.socket) == null ? void 0 : Si.readyState) === 0;
  }
  async publish(e, Oe, Si) {
    this.isInitialized(), await this.publisher.publish(e, Oe, Si), await this.recordMessageEvent({ topic: e, message: Oe, publishedAt: Date.now(), transportType: M$1.relay });
  }
  async subscribe(e, Oe) {
    var Si, wi, Ei;
    this.isInitialized(), (!(Oe != null && Oe.transportType) || (Oe == null ? void 0 : Oe.transportType) === "relay") && await this.toEstablishConnection();
    const $i = typeof ((Si = Oe == null ? void 0 : Oe.internal) == null ? void 0 : Si.throwOnFailedPublish) > "u" ? !0 : (wi = Oe == null ? void 0 : Oe.internal) == null ? void 0 : wi.throwOnFailedPublish;
    let xi = ((Ei = this.subscriber.topicMap.get(e)) == null ? void 0 : Ei[0]) || "", Ri;
    const Ti = (Oi) => {
      Oi.topic === e && (this.subscriber.off(T$1.created, Ti), Ri());
    };
    return await Promise.all([new Promise((Oi) => {
      Ri = Oi, this.subscriber.on(T$1.created, Ti);
    }), new Promise(async (Oi, Mi) => {
      xi = await this.subscriber.subscribe(e, ni({ internal: { throwOnFailedPublish: $i } }, Oe)).catch((Ii) => {
        $i && Mi(Ii);
      }) || xi, Oi();
    })]), xi;
  }
  async unsubscribe(e, Oe) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, Oe);
  }
  on(e, Oe) {
    this.events.on(e, Oe);
  }
  once(e, Oe) {
    this.events.once(e, Oe);
  }
  off(e, Oe) {
    this.events.off(e, Oe);
  }
  removeListener(e, Oe) {
    this.events.removeListener(e, Oe);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await xt$1(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (Oe, Si) => {
      await this.connect(e).then(Oe).catch(Si).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected)
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await go())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const Oe = e.sort((Si, wi) => Si.publishedAt - wi.publishedAt);
    this.logger.debug(`Batch of ${Oe.length} message events sorted`);
    for (const Si of Oe)
      try {
        await this.onMessageEvent(Si);
      } catch (wi) {
        this.logger.warn(wi, "Error while processing batch message event: " + (wi == null ? void 0 : wi.message));
      }
    this.logger.trace(`Batch of ${Oe.length} message events processed`);
  }
  async onLinkMessageEvent(e, Oe) {
    const { topic: Si } = e;
    if (!Oe.sessionExists) {
      const wi = Lt$1(cjs$4.FIVE_MINUTES), Ei = { topic: Si, expiry: wi, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(Si, Ei);
    }
    this.events.emit(v$2.message, e), await this.recordMessageEvent(e);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    let Oe = 1;
    for (; Oe < 6; ) {
      try {
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${Oe}...`), await this.createProvider(), await new Promise(async (Si, wi) => {
          const Ei = () => {
            wi(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(C.disconnect, Ei), await xt$1(new Promise(($i, xi) => {
            this.provider.connect().then($i).catch(xi);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(($i) => {
            wi($i);
          }).finally(() => {
            this.provider.off(C.disconnect, Ei), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
          }), await new Promise(async ($i, xi) => {
            const Ri = () => {
              xi(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(C.disconnect, Ri), await this.subscriber.start().then($i).catch(xi).finally(() => {
              this.provider.off(C.disconnect, Ri);
            });
          }), this.hasExperiencedNetworkDisruption = !1, Si();
        });
      } catch (Si) {
        await this.subscriber.stop();
        const wi = Si;
        this.logger.warn({}, wi.message), this.hasExperiencedNetworkDisruption = !0;
      } finally {
        this.connectionAttemptInProgress = !1;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${Oe}`);
        break;
      }
      await new Promise((Si) => setTimeout(Si, cjs$4.toMiliseconds(Oe * 1))), Oe++;
    }
  }
  startPingTimeout() {
    var e, Oe, Si, wi, Ei;
    if (ce())
      try {
        (Oe = (e = this.provider) == null ? void 0 : e.connection) != null && Oe.socket && ((Ei = (wi = (Si = this.provider) == null ? void 0 : Si.connection) == null ? void 0 : wi.socket) == null || Ei.on("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch ($i) {
        this.logger.warn($i, $i == null ? void 0 : $i.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f$1(It$1({ sdkVersion: re, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: Oe, message: Si } = e;
    await this.messages.set(Oe, Si);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: Oe, message: Si } = e;
    if (!Si || Si.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${Si}`), !0;
    if (!await this.subscriber.isSubscribed(Oe))
      return this.logger.warn(`Ignoring message for non-subscribed topic ${Oe}`), !0;
    const wi = this.messages.has(Oe, Si);
    return wi && this.logger.warn(`Ignoring duplicate message: ${Si}`), wi;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ct$1))
        return;
      const Oe = e.params, { topic: Si, message: wi, publishedAt: Ei, attestation: $i } = Oe.data, xi = { topic: Si, message: wi, publishedAt: Ei, transportType: M$1.relay, attestation: $i };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ni({ type: "event", event: Oe.id }, xi)), this.events.emit(Oe.id, xi), await this.acknowledgePayload(e), await this.onMessageEvent(xi);
    } else
      isJsonRpcResponse(e) && this.events.emit(v$2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v$2.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const Oe = formatJsonRpcResult(e.id, !0);
    await this.provider.connection.send(Oe);
  }
  unregisterProviderListeners() {
    this.provider.off(C.payload, this.onPayloadHandler), this.provider.off(C.connect, this.onConnectHandler), this.provider.off(C.disconnect, this.onDisconnectHandler), this.provider.off(C.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await go();
    vo(async (Oe) => {
      e !== Oe && (e = Oe, Oe ? await this.transportOpen().catch((Si) => this.logger.error(Si, Si == null ? void 0 : Si.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), clearTimeout(this.pingTimeout), this.events.emit(v$2.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || this.connectPromise || (this.reconnectTimeout = setTimeout(async () => {
      clearTimeout(this.reconnectTimeout), await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message));
    }, cjs$4.toMiliseconds(ht$1))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.transportOpen();
  }
}
var vn = Object.defineProperty, ai = Object.getOwnPropertySymbols, _n = Object.prototype.hasOwnProperty, En = Object.prototype.propertyIsEnumerable, ci = (se, e, Oe) => e in se ? vn(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, hi = (se, e) => {
  for (var Oe in e || (e = {}))
    _n.call(e, Oe) && ci(se, Oe, e[Oe]);
  if (ai)
    for (var Oe of ai(e))
      En.call(e, Oe) && ci(se, Oe, e[Oe]);
  return se;
};
class li extends p$1 {
  constructor(e, Oe, Si, wi = A, Ei = void 0) {
    super(e, Oe, Si, wi), this.core = e, this.logger = Oe, this.name = Si, this.map = /* @__PURE__ */ new Map(), this.version = lt$1, this.cached = [], this.initialized = !1, this.storagePrefix = A, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(($i) => {
        this.getKey && $i !== null && !P($i) ? this.map.set(this.getKey($i), $i) : Xr$1($i) ? this.map.set($i.id, $i) : eo($i) && this.map.set($i.topic, $i);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async ($i, xi) => {
      this.isInitialized(), this.map.has($i) ? await this.update($i, xi) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: $i, value: xi }), this.map.set($i, xi), await this.persist());
    }, this.get = ($i) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: $i }), this.getData($i)), this.getAll = ($i) => (this.isInitialized(), $i ? this.values.filter((xi) => Object.keys($i).every((Ri) => _s$2(xi[Ri], $i[Ri]))) : this.values), this.update = async ($i, xi) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: $i, update: xi });
      const Ri = hi(hi({}, this.getData($i)), xi);
      this.map.set($i, Ri), await this.persist();
    }, this.delete = async ($i, xi) => {
      this.isInitialized(), this.map.has($i) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: $i, reason: xi }), this.map.delete($i), this.addToRecentlyDeleted($i), await this.persist());
    }, this.logger = E$1(Oe, this.name), this.storagePrefix = wi, this.getKey = Ei;
  }
  get context() {
    return y$2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const Oe = this.map.get(e);
    if (!Oe) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: wi } = S$3("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(wi), new Error(wi);
      }
      const { message: Si } = S$3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(Si), new Error(Si);
    }
    return Oe;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: Oe } = S$3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class ui {
  constructor(e, Oe) {
    this.core = e, this.logger = Oe, this.name = yt$1, this.version = Dt, this.events = new c$5(), this.initialized = !1, this.storagePrefix = A, this.ignoredPayloadTypes = [D$2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: Si }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...Si])];
    }, this.create = async (Si) => {
      this.isInitialized();
      const wi = yr$1(), Ei = await this.core.crypto.setSymKey(wi), $i = Lt$1(cjs$4.FIVE_MINUTES), xi = { protocol: nt$1 }, Ri = { topic: Ei, expiry: $i, relay: xi, active: !1, methods: Si == null ? void 0 : Si.methods }, Ti = Mr$1({ protocol: this.core.protocol, version: this.core.version, topic: Ei, symKey: wi, relay: xi, expiryTimestamp: $i, methods: Si == null ? void 0 : Si.methods });
      return this.events.emit(j.create, Ri), this.core.expirer.set(Ei, $i), await this.pairings.set(Ei, Ri), await this.core.relayer.subscribe(Ei, { transportType: Si == null ? void 0 : Si.transportType }), { topic: Ei, uri: Ti };
    }, this.pair = async (Si) => {
      this.isInitialized();
      const wi = this.core.eventClient.createEvent({ properties: { topic: Si == null ? void 0 : Si.uri, trace: [z$1.pairing_started] } });
      this.isValidPair(Si, wi);
      const { topic: Ei, symKey: $i, relay: xi, expiryTimestamp: Ri, methods: Ti } = Vr$1(Si.uri);
      wi.props.properties.topic = Ei, wi.addTrace(z$1.pairing_uri_validation_success), wi.addTrace(z$1.pairing_uri_not_expired);
      let Oi;
      if (this.pairings.keys.includes(Ei)) {
        if (Oi = this.pairings.get(Ei), wi.addTrace(z$1.existing_pairing), Oi.active)
          throw wi.setError($.active_pairing_already_exists), new Error(`Pairing already exists: ${Ei}. Please try again with a new connection URI.`);
        wi.addTrace(z$1.pairing_not_expired);
      }
      const Mi = Ri || Lt$1(cjs$4.FIVE_MINUTES), Ii = { topic: Ei, relay: xi, expiry: Mi, active: !1, methods: Ti };
      this.core.expirer.set(Ei, Mi), await this.pairings.set(Ei, Ii), wi.addTrace(z$1.store_new_pairing), Si.activatePairing && await this.activate({ topic: Ei }), this.events.emit(j.create, Ii), wi.addTrace(z$1.emit_inactive_pairing), this.core.crypto.keychain.has(Ei) || await this.core.crypto.setSymKey($i, Ei), wi.addTrace(z$1.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        wi.setError($.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(Ei, { relay: xi });
      } catch (Ci) {
        throw wi.setError($.subscribe_pairing_topic_failure), Ci;
      }
      return wi.addTrace(z$1.subscribe_pairing_topic_success), Ii;
    }, this.activate = async ({ topic: Si }) => {
      this.isInitialized();
      const wi = Lt$1(cjs$4.THIRTY_DAYS);
      this.core.expirer.set(Si, wi), await this.pairings.update(Si, { active: !0, expiry: wi });
    }, this.ping = async (Si) => {
      this.isInitialized(), await this.isValidPing(Si);
      const { topic: wi } = Si;
      if (this.pairings.keys.includes(wi)) {
        const Ei = await this.sendRequest(wi, "wc_pairingPing", {}), { done: $i, resolve: xi, reject: Ri } = Dt$1();
        this.events.once(qt$1("pairing_ping", Ei), ({ error: Ti }) => {
          Ti ? Ri(Ti) : xi();
        }), await $i();
      }
    }, this.updateExpiry = async ({ topic: Si, expiry: wi }) => {
      this.isInitialized(), await this.pairings.update(Si, { expiry: wi });
    }, this.updateMetadata = async ({ topic: Si, metadata: wi }) => {
      this.isInitialized(), await this.pairings.update(Si, { peerMetadata: wi });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (Si) => {
      this.isInitialized(), await this.isValidDisconnect(Si);
      const { topic: wi } = Si;
      this.pairings.keys.includes(wi) && (await this.sendRequest(wi, "wc_pairingDelete", _$4("USER_DISCONNECTED")), await this.deletePairing(wi));
    }, this.formatUriFromPairing = (Si) => {
      this.isInitialized();
      const { topic: wi, relay: Ei, expiry: $i, methods: xi } = Si, Ri = this.core.crypto.keychain.get(wi);
      return Mr$1({ protocol: this.core.protocol, version: this.core.version, topic: wi, symKey: Ri, relay: Ei, expiryTimestamp: $i, methods: xi });
    }, this.sendRequest = async (Si, wi, Ei) => {
      const $i = formatJsonRpcRequest(wi, Ei), xi = await this.core.crypto.encode(Si, $i), Ri = V[wi].req;
      return this.core.history.set(Si, $i), this.core.relayer.publish(Si, xi, Ri), $i.id;
    }, this.sendResult = async (Si, wi, Ei) => {
      const $i = formatJsonRpcResult(Si, Ei), xi = await this.core.crypto.encode(wi, $i), Ri = await this.core.history.get(wi, Si), Ti = V[Ri.request.method].res;
      await this.core.relayer.publish(wi, xi, Ti), await this.core.history.resolve($i);
    }, this.sendError = async (Si, wi, Ei) => {
      const $i = formatJsonRpcError(Si, Ei), xi = await this.core.crypto.encode(wi, $i), Ri = await this.core.history.get(wi, Si), Ti = V[Ri.request.method] ? V[Ri.request.method].res : V.unregistered_method.res;
      await this.core.relayer.publish(wi, xi, Ti), await this.core.history.resolve($i);
    }, this.deletePairing = async (Si, wi) => {
      await this.core.relayer.unsubscribe(Si), await Promise.all([this.pairings.delete(Si, _$4("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(Si), wi ? Promise.resolve() : this.core.expirer.del(Si)]);
    }, this.cleanup = async () => {
      const Si = this.pairings.getAll().filter((wi) => Ft$1(wi.expiry));
      await Promise.all(Si.map((wi) => this.deletePairing(wi.topic)));
    }, this.onRelayEventRequest = (Si) => {
      const { topic: wi, payload: Ei } = Si;
      switch (Ei.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(wi, Ei);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(wi, Ei);
        default:
          return this.onUnknownRpcMethodRequest(wi, Ei);
      }
    }, this.onRelayEventResponse = async (Si) => {
      const { topic: wi, payload: Ei } = Si, $i = (await this.core.history.get(wi, Ei.id)).request.method;
      switch ($i) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(wi, Ei);
        default:
          return this.onUnknownRpcMethodResponse($i);
      }
    }, this.onPairingPingRequest = async (Si, wi) => {
      const { id: Ei } = wi;
      try {
        this.isValidPing({ topic: Si }), await this.sendResult(Ei, Si, !0), this.events.emit(j.ping, { id: Ei, topic: Si });
      } catch ($i) {
        await this.sendError(Ei, Si, $i), this.logger.error($i);
      }
    }, this.onPairingPingResponse = (Si, wi) => {
      const { id: Ei } = wi;
      setTimeout(() => {
        isJsonRpcResult(wi) ? this.events.emit(qt$1("pairing_ping", Ei), {}) : isJsonRpcError(wi) && this.events.emit(qt$1("pairing_ping", Ei), { error: wi.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (Si, wi) => {
      const { id: Ei } = wi;
      try {
        this.isValidDisconnect({ topic: Si }), await this.deletePairing(Si), this.events.emit(j.delete, { id: Ei, topic: Si });
      } catch ($i) {
        await this.sendError(Ei, Si, $i), this.logger.error($i);
      }
    }, this.onUnknownRpcMethodRequest = async (Si, wi) => {
      const { id: Ei, method: $i } = wi;
      try {
        if (this.registeredMethods.includes($i))
          return;
        const xi = _$4("WC_METHOD_UNSUPPORTED", $i);
        await this.sendError(Ei, Si, xi), this.logger.error(xi);
      } catch (xi) {
        await this.sendError(Ei, Si, xi), this.logger.error(xi);
      }
    }, this.onUnknownRpcMethodResponse = (Si) => {
      this.registeredMethods.includes(Si) || this.logger.error(_$4("WC_METHOD_UNSUPPORTED", Si));
    }, this.isValidPair = (Si, wi) => {
      var Ei;
      if (!so(Si)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", `pair() params: ${Si}`);
        throw wi.setError($.malformed_pairing_uri), new Error(xi);
      }
      if (!Zr$1(Si.uri)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", `pair() uri: ${Si.uri}`);
        throw wi.setError($.malformed_pairing_uri), new Error(xi);
      }
      const $i = Vr$1(Si == null ? void 0 : Si.uri);
      if (!((Ei = $i == null ? void 0 : $i.relay) != null && Ei.protocol)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw wi.setError($.malformed_pairing_uri), new Error(xi);
      }
      if (!($i != null && $i.symKey)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", "pair() uri#symKey");
        throw wi.setError($.malformed_pairing_uri), new Error(xi);
      }
      if ($i != null && $i.expiryTimestamp && cjs$4.toMiliseconds($i == null ? void 0 : $i.expiryTimestamp) < Date.now()) {
        wi.setError($.pairing_expired);
        const { message: xi } = S$3("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(xi);
      }
    }, this.isValidPing = async (Si) => {
      if (!so(Si)) {
        const { message: Ei } = S$3("MISSING_OR_INVALID", `ping() params: ${Si}`);
        throw new Error(Ei);
      }
      const { topic: wi } = Si;
      await this.isValidPairingTopic(wi);
    }, this.isValidDisconnect = async (Si) => {
      if (!so(Si)) {
        const { message: Ei } = S$3("MISSING_OR_INVALID", `disconnect() params: ${Si}`);
        throw new Error(Ei);
      }
      const { topic: wi } = Si;
      await this.isValidPairingTopic(wi);
    }, this.isValidPairingTopic = async (Si) => {
      if (!b$3(Si, !1)) {
        const { message: wi } = S$3("MISSING_OR_INVALID", `pairing topic should be a string: ${Si}`);
        throw new Error(wi);
      }
      if (!this.pairings.keys.includes(Si)) {
        const { message: wi } = S$3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${Si}`);
        throw new Error(wi);
      }
      if (Ft$1(this.pairings.get(Si).expiry)) {
        await this.deletePairing(Si);
        const { message: wi } = S$3("EXPIRED", `pairing topic: ${Si}`);
        throw new Error(wi);
      }
    }, this.core = e, this.logger = E$1(Oe, this.name), this.pairings = new li(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y$2(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v$2.message, async (e) => {
      const { topic: Oe, message: Si, transportType: wi } = e;
      if (!this.pairings.keys.includes(Oe) || wi === M$1.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(Si)))
        return;
      const Ei = await this.core.crypto.decode(Oe, Si);
      try {
        isJsonRpcRequest(Ei) ? (this.core.history.set(Oe, Ei), this.onRelayEventRequest({ topic: Oe, payload: Ei })) : isJsonRpcResponse(Ei) && (await this.core.history.resolve(Ei), await this.onRelayEventResponse({ topic: Oe, payload: Ei }), this.core.history.delete(Oe, Ei.id));
      } catch ($i) {
        this.logger.error($i);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(x$2.expired, async (e) => {
      const { topic: Oe } = Kt$1(e.target);
      Oe && this.pairings.keys.includes(Oe) && (await this.deletePairing(Oe, !0), this.events.emit(j.expire, { topic: Oe }));
    });
  }
}
class di extends h$1 {
  constructor(e, Oe) {
    super(e, Oe), this.core = e, this.logger = Oe, this.records = /* @__PURE__ */ new Map(), this.events = new EventEmitter(), this.name = mt, this.version = bt, this.cached = [], this.initialized = !1, this.storagePrefix = A, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Si) => this.records.set(Si.id, Si)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (Si, wi, Ei) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: Si, request: wi, chainId: Ei }), this.records.has(wi.id))
        return;
      const $i = { id: wi.id, topic: Si, request: { method: wi.method, params: wi.params || null }, chainId: Ei, expiry: Lt$1(cjs$4.THIRTY_DAYS) };
      this.records.set($i.id, $i), this.persist(), this.events.emit(R.created, $i);
    }, this.resolve = async (Si) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: Si }), !this.records.has(Si.id))
        return;
      const wi = await this.getRecord(Si.id);
      typeof wi.response > "u" && (wi.response = isJsonRpcError(Si) ? { error: Si.error } : { result: Si.result }, this.records.set(wi.id, wi), this.persist(), this.events.emit(R.updated, wi));
    }, this.get = async (Si, wi) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: Si, id: wi }), await this.getRecord(wi)), this.delete = (Si, wi) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: wi }), this.values.forEach((Ei) => {
        if (Ei.topic === Si) {
          if (typeof wi < "u" && Ei.id !== wi)
            return;
          this.records.delete(Ei.id), this.events.emit(R.deleted, Ei);
        }
      }), this.persist();
    }, this.exists = async (Si, wi) => (this.isInitialized(), this.records.has(wi) ? (await this.getRecord(wi)).topic === Si : !1), this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.logger = E$1(Oe, this.name);
  }
  get context() {
    return y$2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((Oe) => {
      if (typeof Oe.response < "u")
        return;
      const Si = { topic: Oe.topic, request: formatJsonRpcRequest(Oe.request.method, Oe.request.params, Oe.id), chainId: Oe.chainId };
      return e.push(Si);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const Oe = this.records.get(e);
    if (!Oe) {
      const { message: Si } = S$3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(Si);
    }
    return Oe;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: Oe } = S$3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R.created, (e) => {
      const Oe = R.created;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, record: e });
    }), this.events.on(R.updated, (e) => {
      const Oe = R.updated;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, record: e });
    }), this.events.on(R.deleted, (e) => {
      const Oe = R.deleted;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((Oe) => {
        cjs$4.toMiliseconds(Oe.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${Oe.id}`), this.records.delete(Oe.id), this.events.emit(R.deleted, Oe, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class pi extends x$3 {
  constructor(e, Oe) {
    super(e, Oe), this.core = e, this.logger = Oe, this.expirations = /* @__PURE__ */ new Map(), this.events = new EventEmitter(), this.name = ft, this.version = vt, this.cached = [], this.initialized = !1, this.storagePrefix = A, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Si) => this.expirations.set(Si.target, Si)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (Si) => {
      try {
        const wi = this.formatTarget(Si);
        return typeof this.getExpiration(wi) < "u";
      } catch {
        return !1;
      }
    }, this.set = (Si, wi) => {
      this.isInitialized();
      const Ei = this.formatTarget(Si), $i = { target: Ei, expiry: wi };
      this.expirations.set(Ei, $i), this.checkExpiry(Ei, $i), this.events.emit(x$2.created, { target: Ei, expiration: $i });
    }, this.get = (Si) => {
      this.isInitialized();
      const wi = this.formatTarget(Si);
      return this.getExpiration(wi);
    }, this.del = (Si) => {
      if (this.isInitialized(), this.has(Si)) {
        const wi = this.formatTarget(Si), Ei = this.getExpiration(wi);
        this.expirations.delete(wi), this.events.emit(x$2.deleted, { target: wi, expiration: Ei });
      }
    }, this.on = (Si, wi) => {
      this.events.on(Si, wi);
    }, this.once = (Si, wi) => {
      this.events.once(Si, wi);
    }, this.off = (Si, wi) => {
      this.events.off(Si, wi);
    }, this.removeListener = (Si, wi) => {
      this.events.removeListener(Si, wi);
    }, this.logger = E$1(Oe, this.name);
  }
  get context() {
    return y$2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return Vt$1(e);
    if (typeof e == "number")
      return Mt$1(e);
    const { message: Oe } = S$3("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(Oe);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(x$2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: Oe } = S$3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Oe), new Error(Oe);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const Oe = this.expirations.get(e);
    if (!Oe) {
      const { message: Si } = S$3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(Si), new Error(Si);
    }
    return Oe;
  }
  checkExpiry(e, Oe) {
    const { expiry: Si } = Oe;
    cjs$4.toMiliseconds(Si) - Date.now() <= 0 && this.expire(e, Oe);
  }
  expire(e, Oe) {
    this.expirations.delete(e), this.events.emit(x$2.expired, { target: e, expiration: Oe });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, Oe) => this.checkExpiry(Oe, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(x$2.created, (e) => {
      const Oe = x$2.created;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), this.persist();
    }), this.events.on(x$2.expired, (e) => {
      const Oe = x$2.expired;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), this.persist();
    }), this.events.on(x$2.deleted, (e) => {
      const Oe = x$2.deleted;
      this.logger.info(`Emitting ${Oe}`), this.logger.debug({ type: "event", event: Oe, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class gi extends y$1 {
  constructor(e, Oe, Si) {
    super(e, Oe, Si), this.core = e, this.logger = Oe, this.store = Si, this.name = _t, this.verifyUrlV3 = wt$1, this.storagePrefix = A, this.version = De$1, this.init = async () => {
      var wi;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && cjs$4.toMiliseconds((wi = this.publicKey) == null ? void 0 : wi.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (wi) => {
      if (!V$1() || this.isDevEnv)
        return;
      const Ei = window.location.origin, { id: $i, decryptedId: xi } = wi, Ri = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${Ei}&id=${$i}&decryptedId=${xi}`;
      try {
        const Ti = getDocument_1(), Oi = this.startAbortTimer(cjs$4.ONE_SECOND * 5), Mi = await new Promise((Ii, Ci) => {
          const Oo = () => {
            window.removeEventListener("message", Bo), Ti.body.removeChild(Ro), Ci("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", Oo);
          const Ro = Ti.createElement("iframe");
          Ro.src = Ri, Ro.style.display = "none", Ro.addEventListener("error", Oo, { signal: this.abortController.signal });
          const Bo = (Fo) => {
            if (Fo.data && typeof Fo.data == "string")
              try {
                const Io = JSON.parse(Fo.data);
                if (Io.type === "verify_attestation") {
                  if (decodeJWT(Io.attestation).payload.id !== $i)
                    return;
                  clearInterval(Oi), Ti.body.removeChild(Ro), this.abortController.signal.removeEventListener("abort", Oo), window.removeEventListener("message", Bo), Ii(Io.attestation === null ? "" : Io.attestation);
                }
              } catch (Io) {
                this.logger.warn(Io);
              }
          };
          Ti.body.appendChild(Ro), window.addEventListener("message", Bo, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", Mi), Mi;
      } catch (Ti) {
        this.logger.warn(Ti);
      }
      return "";
    }, this.resolve = async (wi) => {
      if (this.isDevEnv)
        return "";
      const { attestationId: Ei, hash: $i, encryptedId: xi } = wi;
      if (Ei === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (Ei) {
        if (decodeJWT(Ei).payload.id !== xi)
          return;
        const Ti = await this.isValidJwtAttestation(Ei);
        if (Ti) {
          if (!Ti.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return Ti;
        }
      }
      if (!$i)
        return;
      const Ri = this.getVerifyUrl(wi == null ? void 0 : wi.verifyUrl);
      return this.fetchAttestation($i, Ri);
    }, this.fetchAttestation = async (wi, Ei) => {
      this.logger.debug(`resolving attestation: ${wi} from url: ${Ei}`);
      const $i = this.startAbortTimer(cjs$4.ONE_SECOND * 5), xi = await fetch(`${Ei}/attestation/${wi}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout($i), xi.status === 200 ? await xi.json() : void 0;
    }, this.getVerifyUrl = (wi) => {
      let Ei = wi || X;
      return It.includes(Ei) || (this.logger.info(`verify url: ${Ei}, not included in trusted list, assigning default: ${X}`), Ei = X), Ei;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const wi = this.startAbortTimer(cjs$4.FIVE_SECONDS), Ei = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(wi), await Ei.json();
      } catch (wi) {
        this.logger.warn(wi);
      }
    }, this.persistPublicKey = async (wi) => {
      this.logger.debug("persisting public key to local storage", wi), await this.store.setItem(this.storeKey, wi), this.publicKey = wi;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (wi) => {
      const Ei = await this.getPublicKey();
      try {
        if (Ei)
          return this.validateAttestation(wi, Ei);
      } catch (xi) {
        this.logger.error(xi), this.logger.warn("error validating attestation");
      }
      const $i = await this.fetchAndPersistPublicKey();
      try {
        if ($i)
          return this.validateAttestation(wi, $i);
      } catch (xi) {
        this.logger.error(xi), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise)
        return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (Ei) => {
        const $i = await this.fetchPublicKey();
        $i && (await this.persistPublicKey($i), Ei($i));
      });
      const wi = await this.fetchPromise;
      return this.fetchPromise = void 0, wi;
    }, this.validateAttestation = (wi, Ei) => {
      const $i = jr$1(wi, Ei.publicKey), xi = { hasExpired: cjs$4.toMiliseconds($i.exp) < Date.now(), payload: $i };
      if (xi.hasExpired)
        throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: xi.payload.origin, isScam: xi.payload.isScam, isVerified: xi.payload.isVerified };
    }, this.logger = E$1(Oe, this.name), this.abortController = new AbortController(), this.isDevEnv = zt$1(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y$2(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$4.toMiliseconds(e));
  }
}
class yi extends v$4 {
  constructor(e, Oe) {
    super(e, Oe), this.projectId = e, this.logger = Oe, this.context = Tt, this.registerDeviceToken = async (Si) => {
      const { clientId: wi, token: Ei, notificationType: $i, enableEncrypted: xi = !1 } = Si, Ri = `${Ct}/${this.projectId}/clients`;
      await fetch(Ri, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: wi, type: $i, token: Ei, always_raw: xi }) });
    }, this.logger = E$1(Oe, this.context);
  }
}
var wn = Object.defineProperty, Di = Object.getOwnPropertySymbols, In = Object.prototype.hasOwnProperty, Tn = Object.prototype.propertyIsEnumerable, mi = (se, e, Oe) => e in se ? wn(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, Q = (se, e) => {
  for (var Oe in e || (e = {}))
    In.call(e, Oe) && mi(se, Oe, e[Oe]);
  if (Di)
    for (var Oe of Di(e))
      Tn.call(e, Oe) && mi(se, Oe, e[Oe]);
  return se;
};
class bi extends C$1 {
  constructor(e, Oe, Si = !0) {
    super(e, Oe, Si), this.core = e, this.logger = Oe, this.context = St, this.storagePrefix = A, this.storageVersion = Pt, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!zt$1())
        try {
          const wi = { eventId: Jt$1(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge(this.core.relayer.protocol, this.core.relayer.version, re) } } };
          await this.sendEvent([wi]);
        } catch (wi) {
          this.logger.warn(wi);
        }
    }, this.createEvent = (wi) => {
      const { event: Ei = "ERROR", type: $i = "", properties: { topic: xi, trace: Ri } } = wi, Ti = Jt$1(), Oi = this.core.projectId || "", Mi = Date.now(), Ii = Q({ eventId: Ti, timestamp: Mi, props: { event: Ei, type: $i, properties: { topic: xi, trace: Ri } }, bundleId: Oi, domain: this.getAppDomain() }, this.setMethods(Ti));
      return this.telemetryEnabled && (this.events.set(Ti, Ii), this.shouldPersist = !0), Ii;
    }, this.getEvent = (wi) => {
      const { eventId: Ei, topic: $i } = wi;
      if (Ei)
        return this.events.get(Ei);
      const xi = Array.from(this.events.values()).find((Ri) => Ri.props.properties.topic === $i);
      if (xi)
        return Q(Q({}, xi), this.setMethods(xi.eventId));
    }, this.deleteEvent = (wi) => {
      const { eventId: Ei } = wi;
      this.events.delete(Ei), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((wi) => {
          cjs$4.fromMiliseconds(Date.now()) - cjs$4.fromMiliseconds(wi.timestamp) > Rt && (this.events.delete(wi.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (wi) => ({ addTrace: (Ei) => this.addTrace(wi, Ei), setError: (Ei) => this.setError(wi, Ei) }), this.addTrace = (wi, Ei) => {
      const $i = this.events.get(wi);
      $i && ($i.props.properties.trace.push(Ei), this.events.set(wi, $i), this.shouldPersist = !0);
    }, this.setError = (wi, Ei) => {
      const $i = this.events.get(wi);
      $i && ($i.props.type = Ei, $i.timestamp = Date.now(), this.events.set(wi, $i), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const wi = await this.core.storage.getItem(this.storageKey) || [];
        if (!wi.length)
          return;
        wi.forEach((Ei) => {
          this.events.set(Ei.eventId, Q(Q({}, Ei), this.setMethods(Ei.eventId)));
        });
      } catch (wi) {
        this.logger.warn(wi);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0)
        return;
      const wi = [];
      for (const [Ei, $i] of this.events)
        $i.props.type && wi.push($i);
      if (wi.length !== 0)
        try {
          if ((await this.sendEvent(wi)).ok)
            for (const Ei of wi)
              this.events.delete(Ei.eventId), this.shouldPersist = !0;
        } catch (Ei) {
          this.logger.warn(Ei);
        }
    }, this.sendEvent = async (wi) => {
      const Ei = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${xt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${re}${Ei}`, { method: "POST", body: JSON.stringify(wi) });
    }, this.getAppDomain = () => $t$1().url, this.logger = E$1(Oe, this.context), this.telemetryEnabled = Si, Si ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var Cn = Object.defineProperty, fi = Object.getOwnPropertySymbols, Pn = Object.prototype.hasOwnProperty, Sn = Object.prototype.propertyIsEnumerable, vi = (se, e, Oe) => e in se ? Cn(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, _i = (se, e) => {
  for (var Oe in e || (e = {}))
    Pn.call(e, Oe) && vi(se, Oe, e[Oe]);
  if (fi)
    for (var Oe of fi(e))
      Sn.call(e, Oe) && vi(se, Oe, e[Oe]);
  return se;
};
let oe$1 = class eu extends n$1 {
  constructor(e) {
    var Oe;
    super(e), this.protocol = ye$1, this.version = De$1, this.name = J, this.events = new EventEmitter(), this.initialized = !1, this.on = ($i, xi) => this.events.on($i, xi), this.once = ($i, xi) => this.events.once($i, xi), this.off = ($i, xi) => this.events.off($i, xi), this.removeListener = ($i, xi) => this.events.removeListener($i, xi), this.dispatchEnvelope = ({ topic: $i, message: xi, sessionExists: Ri }) => {
      if (!$i || !xi)
        return;
      const Ti = { topic: $i, message: xi, publishedAt: Date.now(), transportType: M$1.link_mode };
      this.relayer.onLinkMessageEvent(Ti, { sessionExists: Ri });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || fe, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const Si = k$1({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Xe.logger, name: J }), { logger: wi, chunkLoggerController: Ei } = A$1({ opts: Si, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = Ei, (Oe = this.logChunkController) != null && Oe.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var $i, xi;
      ($i = this.logChunkController) != null && $i.downloadLogsBlobInBrowser && ((xi = this.logChunkController) == null || xi.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E$1(wi, this.name), this.heartbeat = new i$2(), this.crypto = new Yt(this, this.logger, e == null ? void 0 : e.keychain), this.history = new di(this, this.logger), this.expirer = new pi(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h$2(_i(_i({}, We), e == null ? void 0 : e.storageOptions)), this.relayer = new oi({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ui(this, this.logger), this.verify = new gi(this, this.logger, this.storage), this.echoClient = new yi(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new bi(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const Oe = new eu(e);
    await Oe.initialize();
    const Si = await Oe.crypto.getClientId();
    return await Oe.storage.setItem(ut$1, Si), Oe;
  }
  get context() {
    return y$2(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ve, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(ve) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
const Rn = oe$1, c = { level: "info" }, n = "custom_context";
var x$1 = Object.defineProperty, S$1 = Object.defineProperties, _ = Object.getOwnPropertyDescriptors, p = Object.getOwnPropertySymbols, T = Object.prototype.hasOwnProperty, z = Object.prototype.propertyIsEnumerable, f = (se, e, Oe) => e in se ? x$1(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, i = (se, e) => {
  for (var Oe in e || (e = {}))
    T.call(e, Oe) && f(se, Oe, e[Oe]);
  if (p)
    for (var Oe of p(e))
      z.call(e, Oe) && f(se, Oe, e[Oe]);
  return se;
}, g = (se, e) => S$1(se, _(e));
function k(se) {
  return g(i({}, se), { level: (se == null ? void 0 : se.level) || c.level });
}
function v$1(se, e = n) {
  return se[e] || "";
}
function b(se, e, Oe = n) {
  return se[Oe] = e, se;
}
function y(se, e = n) {
  let Oe = "";
  return typeof se.bindings > "u" ? Oe = v$1(se, e) : Oe = se.bindings().context || "", Oe;
}
function w(se, e, Oe = n) {
  const Si = y(se, Oe);
  return Si.trim() ? `${Si}/${e}` : e;
}
function E(se, e, Oe = n) {
  const Si = w(se, e, Oe), wi = se.child({ context: Si });
  return b(wi, Si, Oe);
}
class S {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}
class M {
  constructor(e) {
    this.client = e;
  }
}
const Ce = "wc", Le = 2, xe = "client", ye = `${Ce}@${Le}:${xe}:`, we = { name: xe, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.org" }, De = "WALLETCONNECT_DEEPLINK_CHOICE", it = "proposal", rt = "Proposal expired", nt = "session", H = cjs$4.SEVEN_DAYS, ot = "engine", v = { wc_sessionPropose: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$4.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: cjs$4.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: cjs$4.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: cjs$4.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: cjs$4.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, me = { min: cjs$4.FIVE_MINUTES, max: cjs$4.SEVEN_DAYS }, x = { idle: "IDLE", active: "ACTIVE" }, at = "request", ct = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], lt = "wc", pt = "auth", ht = "authKeys", dt = "pairingTopics", ut = "requests", oe = `${lt}@${1.5}:${pt}:`, ae = `${oe}:PUB_KEY`;
var ys = Object.defineProperty, ws = Object.defineProperties, ms = Object.getOwnPropertyDescriptors, gt = Object.getOwnPropertySymbols, _s = Object.prototype.hasOwnProperty, Es = Object.prototype.propertyIsEnumerable, yt = (se, e, Oe) => e in se ? ys(se, e, { enumerable: !0, configurable: !0, writable: !0, value: Oe }) : se[e] = Oe, I = (se, e) => {
  for (var Oe in e || (e = {}))
    _s.call(e, Oe) && yt(se, Oe, e[Oe]);
  if (gt)
    for (var Oe of gt(e))
      Es.call(e, Oe) && yt(se, Oe, e[Oe]);
  return se;
}, D = (se, e) => ws(se, ms(e));
class Rs extends M {
  constructor(e) {
    super(e), this.name = ot, this.events = new c$5(), this.initialized = !1, this.requestQueue = { state: x.idle, queue: [] }, this.sessionRequestQueue = { state: x.idle, queue: [] }, this.requestQueueDelay = cjs$4.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$4.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const Si = D(I({}, Oe), { requiredNamespaces: Oe.requiredNamespaces || {}, optionalNamespaces: Oe.optionalNamespaces || {} });
      await this.isValidConnect(Si);
      const { pairingTopic: wi, requiredNamespaces: Ei, optionalNamespaces: $i, sessionProperties: xi, relays: Ri } = Si;
      let Ti = wi, Oi, Mi = !1;
      try {
        Ti && (Mi = this.client.core.pairing.pairings.get(Ti).active);
      } catch (Co) {
        throw this.client.logger.error(`connect() -> pairing.get(${Ti}) failed`), Co;
      }
      if (!Ti || !Mi) {
        const { topic: Co, uri: ko } = await this.client.core.pairing.create();
        Ti = Co, Oi = ko;
      }
      if (!Ti) {
        const { message: Co } = S$3("NO_MATCHING_KEY", `connect() pairing topic: ${Ti}`);
        throw new Error(Co);
      }
      const Ii = await this.client.core.crypto.generateKeyPair(), Ci = v.wc_sessionPropose.req.ttl || cjs$4.FIVE_MINUTES, Oo = Lt$1(Ci), Ro = I({ requiredNamespaces: Ei, optionalNamespaces: $i, relays: Ri ?? [{ protocol: nt$1 }], proposer: { publicKey: Ii, metadata: this.client.metadata }, expiryTimestamp: Oo, pairingTopic: Ti }, xi && { sessionProperties: xi }), { reject: Bo, resolve: Fo, done: Io } = Dt$1(Ci, rt);
      this.events.once(qt$1("session_connect"), async ({ error: Co, session: ko }) => {
        if (Co)
          Bo(Co);
        else if (ko) {
          ko.self.publicKey = Ii;
          const Po = D(I({}, ko), { pairingTopic: Ro.pairingTopic, requiredNamespaces: Ro.requiredNamespaces, optionalNamespaces: Ro.optionalNamespaces, transportType: M$1.relay });
          await this.client.session.set(ko.topic, Po), await this.setExpiry(ko.topic, ko.expiry), Ti && await this.client.core.pairing.updateMetadata({ topic: Ti, metadata: ko.peer.metadata }), this.cleanupDuplicatePairings(Po), Fo(Po);
        }
      });
      const Uo = await this.sendRequest({ topic: Ti, method: "wc_sessionPropose", params: Ro, throwOnFailedPublish: !0 });
      return await this.setProposal(Uo, I({ id: Uo }, Ro)), { uri: Oi, approval: Io };
    }, this.pair = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(Oe);
      } catch (Si) {
        throw this.client.logger.error("pair() failed"), Si;
      }
    }, this.approve = async (Oe) => {
      var Si, wi, Ei;
      const $i = this.client.core.eventClient.createEvent({ properties: { topic: (Si = Oe == null ? void 0 : Oe.id) == null ? void 0 : Si.toString(), trace: [xs.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (No) {
        throw $i.setError(Os.no_internet_connection), No;
      }
      try {
        await this.isValidProposalId(Oe == null ? void 0 : Oe.id);
      } catch (No) {
        throw this.client.logger.error(`approve() -> proposal.get(${Oe == null ? void 0 : Oe.id}) failed`), $i.setError(Os.proposal_not_found), No;
      }
      try {
        await this.isValidApprove(Oe);
      } catch (No) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), $i.setError(Os.session_approve_namespace_validation_failure), No;
      }
      const { id: xi, relayProtocol: Ri, namespaces: Ti, sessionProperties: Oi, sessionConfig: Mi } = Oe, Ii = this.client.proposal.get(xi);
      this.client.core.eventClient.deleteEvent({ eventId: $i.eventId });
      const { pairingTopic: Ci, proposer: Oo, requiredNamespaces: Ro, optionalNamespaces: Bo } = Ii;
      let Fo = (wi = this.client.core.eventClient) == null ? void 0 : wi.getEvent({ topic: Ci });
      Fo || (Fo = (Ei = this.client.core.eventClient) == null ? void 0 : Ei.createEvent({ type: xs.session_approve_started, properties: { topic: Ci, trace: [xs.session_approve_started, xs.session_namespaces_validation_success] } }));
      const Io = await this.client.core.crypto.generateKeyPair(), Uo = Oo.publicKey, Co = await this.client.core.crypto.generateSharedKey(Io, Uo), ko = I(I({ relay: { protocol: Ri ?? "irn" }, namespaces: Ti, controller: { publicKey: Io, metadata: this.client.metadata }, expiry: Lt$1(H) }, Oi && { sessionProperties: Oi }), Mi && { sessionConfig: Mi }), Po = M$1.relay;
      Fo.addTrace(xs.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(Co, { transportType: Po });
      } catch (No) {
        throw Fo.setError(Os.subscribe_session_topic_failure), No;
      }
      Fo.addTrace(xs.subscribe_session_topic_success);
      const Mo = D(I({}, ko), { topic: Co, requiredNamespaces: Ro, optionalNamespaces: Bo, pairingTopic: Ci, acknowledged: !1, self: ko.controller, peer: { publicKey: Oo.publicKey, metadata: Oo.metadata }, controller: Io, transportType: M$1.relay });
      await this.client.session.set(Co, Mo), Fo.addTrace(xs.store_session);
      try {
        Fo.addTrace(xs.publishing_session_settle), await this.sendRequest({ topic: Co, method: "wc_sessionSettle", params: ko, throwOnFailedPublish: !0 }).catch((No) => {
          throw Fo == null || Fo.setError(Os.session_settle_publish_failure), No;
        }), Fo.addTrace(xs.session_settle_publish_success), Fo.addTrace(xs.publishing_session_approve), await this.sendResult({ id: xi, topic: Ci, result: { relay: { protocol: Ri ?? "irn" }, responderPublicKey: Io }, throwOnFailedPublish: !0 }).catch((No) => {
          throw Fo == null || Fo.setError(Os.session_approve_publish_failure), No;
        }), Fo.addTrace(xs.session_approve_publish_success);
      } catch (No) {
        throw this.client.logger.error(No), this.client.session.delete(Co, _$4("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(Co), No;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: Fo.eventId }), await this.client.core.pairing.updateMetadata({ topic: Ci, metadata: Oo.metadata }), await this.client.proposal.delete(xi, _$4("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: Ci }), await this.setExpiry(Co, Lt$1(H)), { topic: Co, acknowledged: () => Promise.resolve(this.client.session.get(Co)) };
    }, this.reject = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(Oe);
      } catch ($i) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), $i;
      }
      const { id: Si, reason: wi } = Oe;
      let Ei;
      try {
        Ei = this.client.proposal.get(Si).pairingTopic;
      } catch ($i) {
        throw this.client.logger.error(`reject() -> proposal.get(${Si}) failed`), $i;
      }
      Ei && (await this.sendError({ id: Si, topic: Ei, error: wi, rpcOpts: v.wc_sessionPropose.reject }), await this.client.proposal.delete(Si, _$4("USER_DISCONNECTED")));
    }, this.update = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(Oe);
      } catch (Mi) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), Mi;
      }
      const { topic: Si, namespaces: wi } = Oe, { done: Ei, resolve: $i, reject: xi } = Dt$1(), Ri = payloadId(), Ti = getBigIntRpcId().toString(), Oi = this.client.session.get(Si).namespaces;
      return this.events.once(qt$1("session_update", Ri), ({ error: Mi }) => {
        Mi ? xi(Mi) : $i();
      }), await this.client.session.update(Si, { namespaces: wi }), await this.sendRequest({ topic: Si, method: "wc_sessionUpdate", params: { namespaces: wi }, throwOnFailedPublish: !0, clientRpcId: Ri, relayRpcId: Ti }).catch((Mi) => {
        this.client.logger.error(Mi), this.client.session.update(Si, { namespaces: Oi }), xi(Mi);
      }), { acknowledged: Ei };
    }, this.extend = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(Oe);
      } catch (Ri) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), Ri;
      }
      const { topic: Si } = Oe, wi = payloadId(), { done: Ei, resolve: $i, reject: xi } = Dt$1();
      return this.events.once(qt$1("session_extend", wi), ({ error: Ri }) => {
        Ri ? xi(Ri) : $i();
      }), await this.setExpiry(Si, Lt$1(H)), this.sendRequest({ topic: Si, method: "wc_sessionExtend", params: {}, clientRpcId: wi, throwOnFailedPublish: !0 }).catch((Ri) => {
        xi(Ri);
      }), { acknowledged: Ei };
    }, this.request = async (Oe) => {
      this.isInitialized();
      try {
        await this.isValidRequest(Oe);
      } catch (Oo) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), Oo;
      }
      const { chainId: Si, request: wi, topic: Ei, expiry: $i = v.wc_sessionRequest.req.ttl } = Oe, xi = this.client.session.get(Ei);
      (xi == null ? void 0 : xi.transportType) === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ri = payloadId(), Ti = getBigIntRpcId().toString(), { done: Oi, resolve: Mi, reject: Ii } = Dt$1($i, "Request expired. Please try again.");
      this.events.once(qt$1("session_request", Ri), ({ error: Oo, result: Ro }) => {
        Oo ? Ii(Oo) : Mi(Ro);
      });
      const Ci = this.getAppLinkIfEnabled(xi.peer.metadata, xi.transportType);
      return Ci ? (await this.sendRequest({ clientRpcId: Ri, relayRpcId: Ti, topic: Ei, method: "wc_sessionRequest", params: { request: D(I({}, wi), { expiryTimestamp: Lt$1($i) }), chainId: Si }, expiry: $i, throwOnFailedPublish: !0, appLink: Ci }).catch((Oo) => Ii(Oo)), this.client.events.emit("session_request_sent", { topic: Ei, request: wi, chainId: Si, id: Ri }), await Oi()) : await Promise.all([new Promise(async (Oo) => {
        await this.sendRequest({ clientRpcId: Ri, relayRpcId: Ti, topic: Ei, method: "wc_sessionRequest", params: { request: D(I({}, wi), { expiryTimestamp: Lt$1($i) }), chainId: Si }, expiry: $i, throwOnFailedPublish: !0 }).catch((Ro) => Ii(Ro)), this.client.events.emit("session_request_sent", { topic: Ei, request: wi, chainId: Si, id: Ri }), Oo();
      }), new Promise(async (Oo) => {
        var Ro;
        if (!((Ro = xi.sessionConfig) != null && Ro.disableDeepLink)) {
          const Bo = await Ht$1(this.client.core.storage, De);
          await Bt$1({ id: Ri, topic: Ei, wcDeepLink: Bo });
        }
        Oo();
      }), Oi()]).then((Oo) => Oo[2]);
    }, this.respond = async (Oe) => {
      this.isInitialized(), await this.isValidRespond(Oe);
      const { topic: Si, response: wi } = Oe, { id: Ei } = wi, $i = this.client.session.get(Si);
      $i.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const xi = this.getAppLinkIfEnabled($i.peer.metadata, $i.transportType);
      isJsonRpcResult(wi) ? await this.sendResult({ id: Ei, topic: Si, result: wi.result, throwOnFailedPublish: !0, appLink: xi }) : isJsonRpcError(wi) && await this.sendError({ id: Ei, topic: Si, error: wi.error, appLink: xi }), this.cleanupAfterResponse(Oe);
    }, this.ping = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(Oe);
      } catch (wi) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), wi;
      }
      const { topic: Si } = Oe;
      if (this.client.session.keys.includes(Si)) {
        const wi = payloadId(), Ei = getBigIntRpcId().toString(), { done: $i, resolve: xi, reject: Ri } = Dt$1();
        this.events.once(qt$1("session_ping", wi), ({ error: Ti }) => {
          Ti ? Ri(Ti) : xi();
        }), await Promise.all([this.sendRequest({ topic: Si, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: wi, relayRpcId: Ei }), $i()]);
      } else
        this.client.core.pairing.pairings.keys.includes(Si) && await this.client.core.pairing.ping({ topic: Si });
    }, this.emit = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(Oe);
      const { topic: Si, event: wi, chainId: Ei } = Oe, $i = getBigIntRpcId().toString(), xi = payloadId();
      await this.sendRequest({ topic: Si, method: "wc_sessionEvent", params: { event: wi, chainId: Ei }, throwOnFailedPublish: !0, relayRpcId: $i, clientRpcId: xi });
    }, this.disconnect = async (Oe) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(Oe);
      const { topic: Si } = Oe;
      if (this.client.session.keys.includes(Si))
        await this.sendRequest({ topic: Si, method: "wc_sessionDelete", params: _$4("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: Si, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(Si))
        await this.client.core.pairing.disconnect({ topic: Si });
      else {
        const { message: wi } = S$3("MISMATCHED_TOPIC", `Session or pairing topic not found: ${Si}`);
        throw new Error(wi);
      }
    }, this.find = (Oe) => (this.isInitialized(), this.client.session.getAll().filter((Si) => Qr$1(Si, Oe))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (Oe, Si) => {
      var wi;
      this.isInitialized(), this.isValidAuthenticate(Oe);
      const Ei = Si && this.client.core.linkModeSupportedApps.includes(Si) && ((wi = this.client.metadata.redirect) == null ? void 0 : wi.linkMode), $i = Ei ? M$1.link_mode : M$1.relay;
      $i === M$1.relay && await this.confirmOnlineStateOrThrow();
      const { chains: xi, statement: Ri = "", uri: Ti, domain: Oi, nonce: Mi, type: Ii, exp: Ci, nbf: Oo, methods: Ro = [], expiry: Bo } = Oe, Fo = [...Oe.resources || []], { topic: Io, uri: Uo } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: $i });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: Io, uri: Uo } });
      const Co = await this.client.core.crypto.generateKeyPair(), ko = vr$1(Co);
      if (await Promise.all([this.client.auth.authKeys.set(ae, { responseTopic: ko, publicKey: Co }), this.client.auth.pairingTopics.set(ko, { topic: ko, pairingTopic: Io })]), await this.client.core.relayer.subscribe(ko, { transportType: $i }), this.client.logger.info(`sending request to new pairing topic: ${Io}`), Ro.length > 0) {
        const { namespace: $o } = re$1(xi[0]);
        let Eo = ur$1($o, "request", Ro);
        Y(Fo) && (Eo = lr$1(Eo, Fo.pop())), Fo.push(Eo);
      }
      const Po = Bo && Bo > v.wc_sessionAuthenticate.req.ttl ? Bo : v.wc_sessionAuthenticate.req.ttl, Mo = { authPayload: { type: Ii ?? "caip122", chains: xi, statement: Ri, aud: Ti, domain: Oi, version: "1", nonce: Mi, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: Ci, nbf: Oo, resources: Fo }, requester: { publicKey: Co, metadata: this.client.metadata }, expiryTimestamp: Lt$1(Po) }, No = { eip155: { chains: xi, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...Ro])], events: ["chainChanged", "accountsChanged"] } }, Jo = { requiredNamespaces: {}, optionalNamespaces: No, relays: [{ protocol: "irn" }], pairingTopic: Io, proposer: { publicKey: Co, metadata: this.client.metadata }, expiryTimestamp: Lt$1(v.wc_sessionPropose.req.ttl) }, { done: zo, resolve: Do, reject: wo } = Dt$1(Po, "Request expired"), Li = async ({ error: $o, session: Eo }) => {
        if (this.events.off(qt$1("session_request", Ni), Ai), $o)
          wo($o);
        else if (Eo) {
          Eo.self.publicKey = Co, await this.client.session.set(Eo.topic, Eo), await this.setExpiry(Eo.topic, Eo.expiry), Io && await this.client.core.pairing.updateMetadata({ topic: Io, metadata: Eo.peer.metadata });
          const zi = this.client.session.get(Eo.topic);
          await this.deleteProposal(Ui), Do({ session: zi });
        }
      }, Ai = async ($o) => {
        var Eo, zi, _o;
        if (await this.deletePendingAuthRequest(Ni, { message: "fulfilled", code: 0 }), $o.error) {
          const Wo = _$4("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return $o.error.code === Wo.code ? void 0 : (this.events.off(qt$1("session_connect"), Li), wo($o.error.message));
        }
        await this.deleteProposal(Ui), this.events.off(qt$1("session_connect"), Li);
        const { cacaos: Fi, responder: xo } = $o.result, Qo = [], To = [];
        for (const Wo of Fi) {
          await or$1({ cacao: Wo, projectId: this.client.core.projectId }) || (this.client.logger.error(Wo, "Signature verification failed"), wo(_$4("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: jo } = Wo, Ao = Y(jo.resources), Lo = [ln$1(jo.iss)], Zo = fe$1(jo.iss);
          if (Ao) {
            const An = dr$1(Ao), ra = fr$1(Ao);
            Qo.push(...An), Lo.push(...ra);
          }
          for (const An of Lo)
            To.push(`${An}:${Zo}`);
        }
        const Ko = await this.client.core.crypto.generateSharedKey(Co, xo.publicKey);
        let Vo;
        Qo.length > 0 && (Vo = { topic: Ko, acknowledged: !0, self: { publicKey: Co, metadata: this.client.metadata }, peer: xo, controller: xo.publicKey, expiry: Lt$1(H), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: Io, namespaces: Yr$1([...new Set(Qo)], [...new Set(To)]), transportType: $i }, await this.client.core.relayer.subscribe(Ko, { transportType: $i }), await this.client.session.set(Ko, Vo), Io && await this.client.core.pairing.updateMetadata({ topic: Io, metadata: xo.metadata }), Vo = this.client.session.get(Ko)), (Eo = this.client.metadata.redirect) != null && Eo.linkMode && (zi = xo.metadata.redirect) != null && zi.linkMode && (_o = xo.metadata.redirect) != null && _o.universal && Si && (this.client.core.addLinkModeSupportedApp(xo.metadata.redirect.universal), this.client.session.update(Ko, { transportType: M$1.link_mode })), Do({ auths: Fi, session: Vo });
      }, Ni = payloadId(), Ui = payloadId();
      this.events.once(qt$1("session_connect"), Li), this.events.once(qt$1("session_request", Ni), Ai);
      let So;
      try {
        if (Ei) {
          const $o = formatJsonRpcRequest("wc_sessionAuthenticate", Mo, Ni);
          this.client.core.history.set(Io, $o);
          const Eo = await this.client.core.crypto.encode("", $o, { type: M$2, encoding: pr$1 });
          So = Kr$2(Si, Io, Eo);
        } else
          await Promise.all([this.sendRequest({ topic: Io, method: "wc_sessionAuthenticate", params: Mo, expiry: Oe.expiry, throwOnFailedPublish: !0, clientRpcId: Ni }), this.sendRequest({ topic: Io, method: "wc_sessionPropose", params: Jo, expiry: v.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: Ui })]);
      } catch ($o) {
        throw this.events.off(qt$1("session_connect"), Li), this.events.off(qt$1("session_request", Ni), Ai), $o;
      }
      return await this.setProposal(Ui, I({ id: Ui }, Jo)), await this.setAuthRequest(Ni, { request: D(I({}, Mo), { verifyContext: {} }), pairingTopic: Io, transportType: $i }), { uri: So ?? Uo, response: zo };
    }, this.approveSessionAuthenticate = async (Oe) => {
      const { id: Si, auths: wi } = Oe, Ei = this.client.core.eventClient.createEvent({ properties: { topic: Si.toString(), trace: [As.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (Bo) {
        throw Ei.setError(Ns.no_internet_connection), Bo;
      }
      const $i = this.getPendingAuthRequest(Si);
      if (!$i)
        throw Ei.setError(Ns.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${Si}`);
      const xi = $i.transportType || M$1.relay;
      xi === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ri = $i.requester.publicKey, Ti = await this.client.core.crypto.generateKeyPair(), Oi = vr$1(Ri), Mi = { type: D$2, receiverPublicKey: Ri, senderPublicKey: Ti }, Ii = [], Ci = [];
      for (const Bo of wi) {
        if (!await or$1({ cacao: Bo, projectId: this.client.core.projectId })) {
          Ei.setError(Ns.invalid_cacao);
          const ko = _$4("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: Si, topic: Oi, error: ko, encodeOpts: Mi }), new Error(ko.message);
        }
        Ei.addTrace(As.cacaos_verified);
        const { p: Fo } = Bo, Io = Y(Fo.resources), Uo = [ln$1(Fo.iss)], Co = fe$1(Fo.iss);
        if (Io) {
          const ko = dr$1(Io), Po = fr$1(Io);
          Ii.push(...ko), Uo.push(...Po);
        }
        for (const ko of Uo)
          Ci.push(`${ko}:${Co}`);
      }
      const Oo = await this.client.core.crypto.generateSharedKey(Ti, Ri);
      Ei.addTrace(As.create_authenticated_session_topic);
      let Ro;
      if ((Ii == null ? void 0 : Ii.length) > 0) {
        Ro = { topic: Oo, acknowledged: !0, self: { publicKey: Ti, metadata: this.client.metadata }, peer: { publicKey: Ri, metadata: $i.requester.metadata }, controller: Ri, expiry: Lt$1(H), authentication: wi, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: $i.pairingTopic, namespaces: Yr$1([...new Set(Ii)], [...new Set(Ci)]), transportType: xi }, Ei.addTrace(As.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(Oo, { transportType: xi });
        } catch (Bo) {
          throw Ei.setError(Ns.subscribe_authenticated_session_topic_failure), Bo;
        }
        Ei.addTrace(As.subscribe_authenticated_session_topic_success), await this.client.session.set(Oo, Ro), Ei.addTrace(As.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: $i.pairingTopic, metadata: $i.requester.metadata });
      }
      Ei.addTrace(As.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: Oi, id: Si, result: { cacaos: wi, responder: { publicKey: Ti, metadata: this.client.metadata } }, encodeOpts: Mi, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled($i.requester.metadata, xi) });
      } catch (Bo) {
        throw Ei.setError(Ns.authenticated_session_approve_publish_failure), Bo;
      }
      return await this.client.auth.requests.delete(Si, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: $i.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: Ei.eventId }), { session: Ro };
    }, this.rejectSessionAuthenticate = async (Oe) => {
      this.isInitialized();
      const { id: Si, reason: wi } = Oe, Ei = this.getPendingAuthRequest(Si);
      if (!Ei)
        throw new Error(`Could not find pending auth request with id ${Si}`);
      Ei.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const $i = Ei.requester.publicKey, xi = await this.client.core.crypto.generateKeyPair(), Ri = vr$1($i), Ti = { type: D$2, receiverPublicKey: $i, senderPublicKey: xi };
      await this.sendError({ id: Si, topic: Ri, error: wi, encodeOpts: Ti, rpcOpts: v.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(Ei.requester.metadata, Ei.transportType) }), await this.client.auth.requests.delete(Si, { message: "rejected", code: 0 }), await this.client.proposal.delete(Si, _$4("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (Oe) => {
      this.isInitialized();
      const { request: Si, iss: wi } = Oe;
      return dn$1(Si, wi);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0)
          for (; this.relayMessageCache.length > 0; )
            try {
              const Oe = this.relayMessageCache.shift();
              Oe && await this.onRelayMessage(Oe);
            } catch (Oe) {
              this.client.logger.error(Oe);
            }
      }, 50);
    }, this.cleanupDuplicatePairings = async (Oe) => {
      if (Oe.pairingTopic)
        try {
          const Si = this.client.core.pairing.pairings.get(Oe.pairingTopic), wi = this.client.core.pairing.pairings.getAll().filter((Ei) => {
            var $i, xi;
            return (($i = Ei.peerMetadata) == null ? void 0 : $i.url) && ((xi = Ei.peerMetadata) == null ? void 0 : xi.url) === Oe.peer.metadata.url && Ei.topic && Ei.topic !== Si.topic;
          });
          if (wi.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${wi.length} duplicate pairing(s)`), await Promise.all(wi.map((Ei) => this.client.core.pairing.disconnect({ topic: Ei.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (Si) {
          this.client.logger.error(Si);
        }
    }, this.deleteSession = async (Oe) => {
      var Si;
      const { topic: wi, expirerHasDeleted: Ei = !1, emitEvent: $i = !0, id: xi = 0 } = Oe, { self: Ri } = this.client.session.get(wi);
      await this.client.core.relayer.unsubscribe(wi), await this.client.session.delete(wi, _$4("USER_DISCONNECTED")), this.addToRecentlyDeleted(wi, "session"), this.client.core.crypto.keychain.has(Ri.publicKey) && await this.client.core.crypto.deleteKeyPair(Ri.publicKey), this.client.core.crypto.keychain.has(wi) && await this.client.core.crypto.deleteSymKey(wi), Ei || this.client.core.expirer.del(wi), this.client.core.storage.removeItem(De).catch((Ti) => this.client.logger.warn(Ti)), this.getPendingSessionRequests().forEach((Ti) => {
        Ti.topic === wi && this.deletePendingSessionRequest(Ti.id, _$4("USER_DISCONNECTED"));
      }), wi === ((Si = this.sessionRequestQueue.queue[0]) == null ? void 0 : Si.topic) && (this.sessionRequestQueue.state = x.idle), $i && this.client.events.emit("session_delete", { id: xi, topic: wi });
    }, this.deleteProposal = async (Oe, Si) => {
      if (Si)
        try {
          const wi = this.client.proposal.get(Oe), Ei = this.client.core.eventClient.getEvent({ topic: wi.pairingTopic });
          Ei == null || Ei.setError(Os.proposal_expired);
        } catch {
        }
      await Promise.all([this.client.proposal.delete(Oe, _$4("USER_DISCONNECTED")), Si ? Promise.resolve() : this.client.core.expirer.del(Oe)]), this.addToRecentlyDeleted(Oe, "proposal");
    }, this.deletePendingSessionRequest = async (Oe, Si, wi = !1) => {
      await Promise.all([this.client.pendingRequest.delete(Oe, Si), wi ? Promise.resolve() : this.client.core.expirer.del(Oe)]), this.addToRecentlyDeleted(Oe, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((Ei) => Ei.id !== Oe), wi && (this.sessionRequestQueue.state = x.idle, this.client.events.emit("session_request_expire", { id: Oe }));
    }, this.deletePendingAuthRequest = async (Oe, Si, wi = !1) => {
      await Promise.all([this.client.auth.requests.delete(Oe, Si), wi ? Promise.resolve() : this.client.core.expirer.del(Oe)]);
    }, this.setExpiry = async (Oe, Si) => {
      this.client.session.keys.includes(Oe) && (this.client.core.expirer.set(Oe, Si), await this.client.session.update(Oe, { expiry: Si }));
    }, this.setProposal = async (Oe, Si) => {
      this.client.core.expirer.set(Oe, Lt$1(v.wc_sessionPropose.req.ttl)), await this.client.proposal.set(Oe, Si);
    }, this.setAuthRequest = async (Oe, Si) => {
      const { request: wi, pairingTopic: Ei, transportType: $i = M$1.relay } = Si;
      this.client.core.expirer.set(Oe, wi.expiryTimestamp), await this.client.auth.requests.set(Oe, { authPayload: wi.authPayload, requester: wi.requester, expiryTimestamp: wi.expiryTimestamp, id: Oe, pairingTopic: Ei, verifyContext: wi.verifyContext, transportType: $i });
    }, this.setPendingSessionRequest = async (Oe) => {
      const { id: Si, topic: wi, params: Ei, verifyContext: $i } = Oe, xi = Ei.request.expiryTimestamp || Lt$1(v.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(Si, xi), await this.client.pendingRequest.set(Si, { id: Si, topic: wi, params: Ei, verifyContext: $i });
    }, this.sendRequest = async (Oe) => {
      const { topic: Si, method: wi, params: Ei, expiry: $i, relayRpcId: xi, clientRpcId: Ri, throwOnFailedPublish: Ti, appLink: Oi } = Oe, Mi = formatJsonRpcRequest(wi, Ei, Ri);
      let Ii;
      const Ci = !!Oi;
      try {
        const Bo = Ci ? pr$1 : ge;
        Ii = await this.client.core.crypto.encode(Si, Mi, { encoding: Bo });
      } catch (Bo) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${Si} failed`), Bo;
      }
      let Oo;
      if (ct.includes(wi)) {
        const Bo = br$1(JSON.stringify(Mi)), Fo = br$1(Ii);
        Oo = await this.client.core.verify.register({ id: Fo, decryptedId: Bo });
      }
      const Ro = v[wi].req;
      if (Ro.attestation = Oo, $i && (Ro.ttl = $i), xi && (Ro.id = xi), this.client.core.history.set(Si, Mi), Ci) {
        const Bo = Kr$2(Oi, Si, Ii);
        await global.Linking.openURL(Bo, this.client.name);
      } else {
        const Bo = v[wi].req;
        $i && (Bo.ttl = $i), xi && (Bo.id = xi), Ti ? (Bo.internal = D(I({}, Bo.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Si, Ii, Bo)) : this.client.core.relayer.publish(Si, Ii, Bo).catch((Fo) => this.client.logger.error(Fo));
      }
      return Mi.id;
    }, this.sendResult = async (Oe) => {
      const { id: Si, topic: wi, result: Ei, throwOnFailedPublish: $i, encodeOpts: xi, appLink: Ri } = Oe, Ti = formatJsonRpcResult(Si, Ei);
      let Oi;
      const Mi = Ri && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const Ci = Mi ? pr$1 : ge;
        Oi = await this.client.core.crypto.encode(wi, Ti, D(I({}, xi || {}), { encoding: Ci }));
      } catch (Ci) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${wi} failed`), Ci;
      }
      let Ii;
      try {
        Ii = await this.client.core.history.get(wi, Si);
      } catch (Ci) {
        throw this.client.logger.error(`sendResult() -> history.get(${wi}, ${Si}) failed`), Ci;
      }
      if (Mi) {
        const Ci = Kr$2(Ri, wi, Oi);
        await global.Linking.openURL(Ci, this.client.name);
      } else {
        const Ci = v[Ii.request.method].res;
        $i ? (Ci.internal = D(I({}, Ci.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(wi, Oi, Ci)) : this.client.core.relayer.publish(wi, Oi, Ci).catch((Oo) => this.client.logger.error(Oo));
      }
      await this.client.core.history.resolve(Ti);
    }, this.sendError = async (Oe) => {
      const { id: Si, topic: wi, error: Ei, encodeOpts: $i, rpcOpts: xi, appLink: Ri } = Oe, Ti = formatJsonRpcError(Si, Ei);
      let Oi;
      const Mi = Ri && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const Ci = Mi ? pr$1 : ge;
        Oi = await this.client.core.crypto.encode(wi, Ti, D(I({}, $i || {}), { encoding: Ci }));
      } catch (Ci) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${wi} failed`), Ci;
      }
      let Ii;
      try {
        Ii = await this.client.core.history.get(wi, Si);
      } catch (Ci) {
        throw this.client.logger.error(`sendError() -> history.get(${wi}, ${Si}) failed`), Ci;
      }
      if (Mi) {
        const Ci = Kr$2(Ri, wi, Oi);
        await global.Linking.openURL(Ci, this.client.name);
      } else {
        const Ci = xi || v[Ii.request.method].res;
        this.client.core.relayer.publish(wi, Oi, Ci);
      }
      await this.client.core.history.resolve(Ti);
    }, this.cleanup = async () => {
      const Oe = [], Si = [];
      this.client.session.getAll().forEach((wi) => {
        let Ei = !1;
        Ft$1(wi.expiry) && (Ei = !0), this.client.core.crypto.keychain.has(wi.topic) || (Ei = !0), Ei && Oe.push(wi.topic);
      }), this.client.proposal.getAll().forEach((wi) => {
        Ft$1(wi.expiryTimestamp) && Si.push(wi.id);
      }), await Promise.all([...Oe.map((wi) => this.deleteSession({ topic: wi })), ...Si.map((wi) => this.deleteProposal(wi))]);
    }, this.onRelayEventRequest = async (Oe) => {
      this.requestQueue.queue.push(Oe), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x.active;
        const Oe = this.requestQueue.queue.shift();
        if (Oe)
          try {
            await this.processRequest(Oe);
          } catch (Si) {
            this.client.logger.warn(Si);
          }
      }
      this.requestQueue.state = x.idle;
    }, this.processRequest = async (Oe) => {
      const { topic: Si, payload: wi, attestation: Ei, transportType: $i, encryptedId: xi } = Oe, Ri = wi.method;
      if (!this.shouldIgnorePairingRequest({ topic: Si, requestMethod: Ri }))
        switch (Ri) {
          case "wc_sessionPropose":
            return await this.onSessionProposeRequest({ topic: Si, payload: wi, attestation: Ei, encryptedId: xi });
          case "wc_sessionSettle":
            return await this.onSessionSettleRequest(Si, wi);
          case "wc_sessionUpdate":
            return await this.onSessionUpdateRequest(Si, wi);
          case "wc_sessionExtend":
            return await this.onSessionExtendRequest(Si, wi);
          case "wc_sessionPing":
            return await this.onSessionPingRequest(Si, wi);
          case "wc_sessionDelete":
            return await this.onSessionDeleteRequest(Si, wi);
          case "wc_sessionRequest":
            return await this.onSessionRequest({ topic: Si, payload: wi, attestation: Ei, encryptedId: xi, transportType: $i });
          case "wc_sessionEvent":
            return await this.onSessionEventRequest(Si, wi);
          case "wc_sessionAuthenticate":
            return await this.onSessionAuthenticateRequest({ topic: Si, payload: wi, attestation: Ei, encryptedId: xi, transportType: $i });
          default:
            return this.client.logger.info(`Unsupported request method ${Ri}`);
        }
    }, this.onRelayEventResponse = async (Oe) => {
      const { topic: Si, payload: wi, transportType: Ei } = Oe, $i = (await this.client.core.history.get(Si, wi.id)).request.method;
      switch ($i) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(Si, wi, Ei);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(Si, wi);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(Si, wi);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(Si, wi);
        case "wc_sessionPing":
          return this.onSessionPingResponse(Si, wi);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(Si, wi);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(Si, wi);
        default:
          return this.client.logger.info(`Unsupported response method ${$i}`);
      }
    }, this.onRelayEventUnknownPayload = (Oe) => {
      const { topic: Si } = Oe, { message: wi } = S$3("MISSING_OR_INVALID", `Decoded payload on topic ${Si} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(wi);
    }, this.shouldIgnorePairingRequest = (Oe) => {
      const { topic: Si, requestMethod: wi } = Oe, Ei = this.expectedPairingMethodMap.get(Si);
      return !Ei || Ei.includes(wi) ? !1 : !!(Ei.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (Oe) => {
      const { topic: Si, payload: wi, attestation: Ei, encryptedId: $i } = Oe, { params: xi, id: Ri } = wi;
      try {
        const Ti = this.client.core.eventClient.getEvent({ topic: Si });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), Ti == null || Ti.setError($.proposal_listener_not_found)), this.isValidConnect(I({}, wi.params));
        const Oi = xi.expiryTimestamp || Lt$1(v.wc_sessionPropose.req.ttl), Mi = I({ id: Ri, pairingTopic: Si, expiryTimestamp: Oi }, xi);
        await this.setProposal(Ri, Mi);
        const Ii = await this.getVerifyContext({ attestationId: Ei, hash: br$1(JSON.stringify(wi)), encryptedId: $i, metadata: Mi.proposer.metadata });
        Ti == null || Ti.addTrace(z$1.emit_session_proposal), this.client.events.emit("session_proposal", { id: Ri, params: Mi, verifyContext: Ii });
      } catch (Ti) {
        await this.sendError({ id: Ri, topic: Si, error: Ti, rpcOpts: v.wc_sessionPropose.autoReject }), this.client.logger.error(Ti);
      }
    }, this.onSessionProposeResponse = async (Oe, Si, wi) => {
      const { id: Ei } = Si;
      if (isJsonRpcResult(Si)) {
        const { result: $i } = Si;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: $i });
        const xi = this.client.proposal.get(Ei);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: xi });
        const Ri = xi.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: Ri });
        const Ti = $i.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: Ti });
        const Oi = await this.client.core.crypto.generateSharedKey(Ri, Ti);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: Oi });
        const Mi = await this.client.core.relayer.subscribe(Oi, { transportType: wi });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: Mi }), await this.client.core.pairing.activate({ topic: Oe });
      } else if (isJsonRpcError(Si)) {
        await this.client.proposal.delete(Ei, _$4("USER_DISCONNECTED"));
        const $i = qt$1("session_connect");
        if (this.events.listenerCount($i) === 0)
          throw new Error(`emitting ${$i} without any listeners, 954`);
        this.events.emit(qt$1("session_connect"), { error: Si.error });
      }
    }, this.onSessionSettleRequest = async (Oe, Si) => {
      const { id: wi, params: Ei } = Si;
      try {
        this.isValidSessionSettleRequest(Ei);
        const { relay: $i, controller: xi, expiry: Ri, namespaces: Ti, sessionProperties: Oi, sessionConfig: Mi } = Si.params, Ii = D(I(I({ topic: Oe, relay: $i, expiry: Ri, namespaces: Ti, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: xi.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: xi.publicKey, metadata: xi.metadata } }, Oi && { sessionProperties: Oi }), Mi && { sessionConfig: Mi }), { transportType: M$1.relay }), Ci = qt$1("session_connect");
        if (this.events.listenerCount(Ci) === 0)
          throw new Error(`emitting ${Ci} without any listeners 997`);
        this.events.emit(qt$1("session_connect"), { session: Ii }), await this.sendResult({ id: Si.id, topic: Oe, result: !0, throwOnFailedPublish: !0 });
      } catch ($i) {
        await this.sendError({ id: wi, topic: Oe, error: $i }), this.client.logger.error($i);
      }
    }, this.onSessionSettleResponse = async (Oe, Si) => {
      const { id: wi } = Si;
      isJsonRpcResult(Si) ? (await this.client.session.update(Oe, { acknowledged: !0 }), this.events.emit(qt$1("session_approve", wi), {})) : isJsonRpcError(Si) && (await this.client.session.delete(Oe, _$4("USER_DISCONNECTED")), this.events.emit(qt$1("session_approve", wi), { error: Si.error }));
    }, this.onSessionUpdateRequest = async (Oe, Si) => {
      const { params: wi, id: Ei } = Si;
      try {
        const $i = `${Oe}_session_update`, xi = bo.get($i);
        if (xi && this.isRequestOutOfSync(xi, Ei)) {
          this.client.logger.warn(`Discarding out of sync request - ${Ei}`), this.sendError({ id: Ei, topic: Oe, error: _$4("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I({ topic: Oe }, wi));
        try {
          bo.set($i, Ei), await this.client.session.update(Oe, { namespaces: wi.namespaces }), await this.sendResult({ id: Ei, topic: Oe, result: !0, throwOnFailedPublish: !0 });
        } catch (Ri) {
          throw bo.delete($i), Ri;
        }
        this.client.events.emit("session_update", { id: Ei, topic: Oe, params: wi });
      } catch ($i) {
        await this.sendError({ id: Ei, topic: Oe, error: $i }), this.client.logger.error($i);
      }
    }, this.isRequestOutOfSync = (Oe, Si) => Si.toString().slice(0, -3) < Oe.toString().slice(0, -3), this.onSessionUpdateResponse = (Oe, Si) => {
      const { id: wi } = Si, Ei = qt$1("session_update", wi);
      if (this.events.listenerCount(Ei) === 0)
        throw new Error(`emitting ${Ei} without any listeners`);
      isJsonRpcResult(Si) ? this.events.emit(qt$1("session_update", wi), {}) : isJsonRpcError(Si) && this.events.emit(qt$1("session_update", wi), { error: Si.error });
    }, this.onSessionExtendRequest = async (Oe, Si) => {
      const { id: wi } = Si;
      try {
        this.isValidExtend({ topic: Oe }), await this.setExpiry(Oe, Lt$1(H)), await this.sendResult({ id: wi, topic: Oe, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: wi, topic: Oe });
      } catch (Ei) {
        await this.sendError({ id: wi, topic: Oe, error: Ei }), this.client.logger.error(Ei);
      }
    }, this.onSessionExtendResponse = (Oe, Si) => {
      const { id: wi } = Si, Ei = qt$1("session_extend", wi);
      if (this.events.listenerCount(Ei) === 0)
        throw new Error(`emitting ${Ei} without any listeners`);
      isJsonRpcResult(Si) ? this.events.emit(qt$1("session_extend", wi), {}) : isJsonRpcError(Si) && this.events.emit(qt$1("session_extend", wi), { error: Si.error });
    }, this.onSessionPingRequest = async (Oe, Si) => {
      const { id: wi } = Si;
      try {
        this.isValidPing({ topic: Oe }), await this.sendResult({ id: wi, topic: Oe, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: wi, topic: Oe });
      } catch (Ei) {
        await this.sendError({ id: wi, topic: Oe, error: Ei }), this.client.logger.error(Ei);
      }
    }, this.onSessionPingResponse = (Oe, Si) => {
      const { id: wi } = Si, Ei = qt$1("session_ping", wi);
      if (this.events.listenerCount(Ei) === 0)
        throw new Error(`emitting ${Ei} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(Si) ? this.events.emit(qt$1("session_ping", wi), {}) : isJsonRpcError(Si) && this.events.emit(qt$1("session_ping", wi), { error: Si.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (Oe, Si) => {
      const { id: wi } = Si;
      try {
        this.isValidDisconnect({ topic: Oe, reason: Si.params }), Promise.all([new Promise((Ei) => {
          this.client.core.relayer.once(v$2.publish, async () => {
            Ei(await this.deleteSession({ topic: Oe, id: wi }));
          });
        }), this.sendResult({ id: wi, topic: Oe, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: Oe, error: _$4("USER_DISCONNECTED") })]).catch((Ei) => this.client.logger.error(Ei));
      } catch (Ei) {
        this.client.logger.error(Ei);
      }
    }, this.onSessionRequest = async (Oe) => {
      var Si, wi, Ei;
      const { topic: $i, payload: xi, attestation: Ri, encryptedId: Ti, transportType: Oi } = Oe, { id: Mi, params: Ii } = xi;
      try {
        await this.isValidRequest(I({ topic: $i }, Ii));
        const Ci = this.client.session.get($i), Oo = await this.getVerifyContext({ attestationId: Ri, hash: br$1(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", Ii, Mi))), encryptedId: Ti, metadata: Ci.peer.metadata, transportType: Oi }), Ro = { id: Mi, topic: $i, params: Ii, verifyContext: Oo };
        await this.setPendingSessionRequest(Ro), Oi === M$1.link_mode && (Si = Ci.peer.metadata.redirect) != null && Si.universal && this.client.core.addLinkModeSupportedApp((wi = Ci.peer.metadata.redirect) == null ? void 0 : wi.universal), (Ei = this.client.signConfig) != null && Ei.disableRequestQueue ? this.emitSessionRequest(Ro) : (this.addSessionRequestToSessionRequestQueue(Ro), this.processSessionRequestQueue());
      } catch (Ci) {
        await this.sendError({ id: Mi, topic: $i, error: Ci }), this.client.logger.error(Ci);
      }
    }, this.onSessionRequestResponse = (Oe, Si) => {
      const { id: wi } = Si, Ei = qt$1("session_request", wi);
      if (this.events.listenerCount(Ei) === 0)
        throw new Error(`emitting ${Ei} without any listeners`);
      isJsonRpcResult(Si) ? this.events.emit(qt$1("session_request", wi), { result: Si.result }) : isJsonRpcError(Si) && this.events.emit(qt$1("session_request", wi), { error: Si.error });
    }, this.onSessionEventRequest = async (Oe, Si) => {
      const { id: wi, params: Ei } = Si;
      try {
        const $i = `${Oe}_session_event_${Ei.event.name}`, xi = bo.get($i);
        if (xi && this.isRequestOutOfSync(xi, wi)) {
          this.client.logger.info(`Discarding out of sync request - ${wi}`);
          return;
        }
        this.isValidEmit(I({ topic: Oe }, Ei)), this.client.events.emit("session_event", { id: wi, topic: Oe, params: Ei }), bo.set($i, wi);
      } catch ($i) {
        await this.sendError({ id: wi, topic: Oe, error: $i }), this.client.logger.error($i);
      }
    }, this.onSessionAuthenticateResponse = (Oe, Si) => {
      const { id: wi } = Si;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: Oe, payload: Si }), isJsonRpcResult(Si) ? this.events.emit(qt$1("session_request", wi), { result: Si.result }) : isJsonRpcError(Si) && this.events.emit(qt$1("session_request", wi), { error: Si.error });
    }, this.onSessionAuthenticateRequest = async (Oe) => {
      var Si;
      const { topic: wi, payload: Ei, attestation: $i, encryptedId: xi, transportType: Ri } = Oe;
      try {
        const { requester: Ti, authPayload: Oi, expiryTimestamp: Mi } = Ei.params, Ii = await this.getVerifyContext({ attestationId: $i, hash: br$1(JSON.stringify(Ei)), encryptedId: xi, metadata: Ti.metadata, transportType: Ri }), Ci = { requester: Ti, pairingTopic: wi, id: Ei.id, authPayload: Oi, verifyContext: Ii, expiryTimestamp: Mi };
        await this.setAuthRequest(Ei.id, { request: Ci, pairingTopic: wi, transportType: Ri }), Ri === M$1.link_mode && (Si = Ti.metadata.redirect) != null && Si.universal && this.client.core.addLinkModeSupportedApp(Ti.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: wi, params: Ei.params, id: Ei.id, verifyContext: Ii });
      } catch (Ti) {
        this.client.logger.error(Ti);
        const Oi = Ei.params.requester.publicKey, Mi = await this.client.core.crypto.generateKeyPair(), Ii = this.getAppLinkIfEnabled(Ei.params.requester.metadata, Ri), Ci = { type: D$2, receiverPublicKey: Oi, senderPublicKey: Mi };
        await this.sendError({ id: Ei.id, topic: wi, error: Ti, encodeOpts: Ci, rpcOpts: v.wc_sessionAuthenticate.autoReject, appLink: Ii });
      }
    }, this.addSessionRequestToSessionRequestQueue = (Oe) => {
      this.sessionRequestQueue.queue.push(Oe);
    }, this.cleanupAfterResponse = (Oe) => {
      this.deletePendingSessionRequest(Oe.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x.idle, this.processSessionRequestQueue();
      }, cjs$4.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: Oe, error: Si }) => {
      const wi = this.client.core.history.pending;
      wi.length > 0 && wi.filter((Ei) => Ei.topic === Oe && Ei.request.method === "wc_sessionRequest").forEach((Ei) => {
        const $i = Ei.request.id, xi = qt$1("session_request", $i);
        if (this.events.listenerCount(xi) === 0)
          throw new Error(`emitting ${xi} without any listeners`);
        this.events.emit(qt$1("session_request", Ei.request.id), { error: Si });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const Oe = this.sessionRequestQueue.queue[0];
      if (!Oe) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x.active, this.emitSessionRequest(Oe);
      } catch (Si) {
        this.client.logger.error(Si);
      }
    }, this.emitSessionRequest = (Oe) => {
      this.client.events.emit("session_request", Oe);
    }, this.onPairingCreated = (Oe) => {
      if (Oe.methods && this.expectedPairingMethodMap.set(Oe.topic, Oe.methods), Oe.active)
        return;
      const Si = this.client.proposal.getAll().find((wi) => wi.pairingTopic === Oe.topic);
      Si && this.onSessionProposeRequest({ topic: Oe.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: Si.requiredNamespaces, optionalNamespaces: Si.optionalNamespaces, relays: Si.relays, proposer: Si.proposer, sessionProperties: Si.sessionProperties }, Si.id) });
    }, this.isValidConnect = async (Oe) => {
      if (!so(Oe)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(Oe)}`);
        throw new Error(Ri);
      }
      const { pairingTopic: Si, requiredNamespaces: wi, optionalNamespaces: Ei, sessionProperties: $i, relays: xi } = Oe;
      if (P(Si) || await this.isValidPairingTopic(Si), !ro(xi, !0)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `connect() relays: ${xi}`);
        throw new Error(Ri);
      }
      !P(wi) && Z$1(wi) !== 0 && this.validateNamespaces(wi, "requiredNamespaces"), !P(Ei) && Z$1(Ei) !== 0 && this.validateNamespaces(Ei, "optionalNamespaces"), P($i) || this.validateSessionProps($i, "sessionProperties");
    }, this.validateNamespaces = (Oe, Si) => {
      const wi = to(Oe, "connect()", Si);
      if (wi)
        throw new Error(wi.message);
    }, this.isValidApprove = async (Oe) => {
      if (!so(Oe))
        throw new Error(S$3("MISSING_OR_INVALID", `approve() params: ${Oe}`).message);
      const { id: Si, namespaces: wi, relayProtocol: Ei, sessionProperties: $i } = Oe;
      this.checkRecentlyDeleted(Si), await this.isValidProposalId(Si);
      const xi = this.client.proposal.get(Si), Ri = Wn(wi, "approve()");
      if (Ri)
        throw new Error(Ri.message);
      const Ti = zn(xi.requiredNamespaces, wi, "approve()");
      if (Ti)
        throw new Error(Ti.message);
      if (!b$3(Ei, !0)) {
        const { message: Oi } = S$3("MISSING_OR_INVALID", `approve() relayProtocol: ${Ei}`);
        throw new Error(Oi);
      }
      P($i) || this.validateSessionProps($i, "sessionProperties");
    }, this.isValidReject = async (Oe) => {
      if (!so(Oe)) {
        const { message: Ei } = S$3("MISSING_OR_INVALID", `reject() params: ${Oe}`);
        throw new Error(Ei);
      }
      const { id: Si, reason: wi } = Oe;
      if (this.checkRecentlyDeleted(Si), await this.isValidProposalId(Si), !io(wi)) {
        const { message: Ei } = S$3("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(wi)}`);
        throw new Error(Ei);
      }
    }, this.isValidSessionSettleRequest = (Oe) => {
      if (!so(Oe)) {
        const { message: Ti } = S$3("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${Oe}`);
        throw new Error(Ti);
      }
      const { relay: Si, controller: wi, namespaces: Ei, expiry: $i } = Oe;
      if (!Jn(Si)) {
        const { message: Ti } = S$3("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(Ti);
      }
      const xi = no(wi, "onSessionSettleRequest()");
      if (xi)
        throw new Error(xi.message);
      const Ri = Wn(Ei, "onSessionSettleRequest()");
      if (Ri)
        throw new Error(Ri.message);
      if (Ft$1($i)) {
        const { message: Ti } = S$3("EXPIRED", "onSessionSettleRequest()");
        throw new Error(Ti);
      }
    }, this.isValidUpdate = async (Oe) => {
      if (!so(Oe)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `update() params: ${Oe}`);
        throw new Error(Ri);
      }
      const { topic: Si, namespaces: wi } = Oe;
      this.checkRecentlyDeleted(Si), await this.isValidSessionTopic(Si);
      const Ei = this.client.session.get(Si), $i = Wn(wi, "update()");
      if ($i)
        throw new Error($i.message);
      const xi = zn(Ei.requiredNamespaces, wi, "update()");
      if (xi)
        throw new Error(xi.message);
    }, this.isValidExtend = async (Oe) => {
      if (!so(Oe)) {
        const { message: wi } = S$3("MISSING_OR_INVALID", `extend() params: ${Oe}`);
        throw new Error(wi);
      }
      const { topic: Si } = Oe;
      this.checkRecentlyDeleted(Si), await this.isValidSessionTopic(Si);
    }, this.isValidRequest = async (Oe) => {
      if (!so(Oe)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `request() params: ${Oe}`);
        throw new Error(Ri);
      }
      const { topic: Si, request: wi, chainId: Ei, expiry: $i } = Oe;
      this.checkRecentlyDeleted(Si), await this.isValidSessionTopic(Si);
      const { namespaces: xi } = this.client.session.get(Si);
      if (!lo(xi, Ei)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `request() chainId: ${Ei}`);
        throw new Error(Ri);
      }
      if (!co(wi)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `request() ${JSON.stringify(wi)}`);
        throw new Error(Ri);
      }
      if (!fo(xi, Ei, wi.method)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `request() method: ${wi.method}`);
        throw new Error(Ri);
      }
      if ($i && !yo($i, me)) {
        const { message: Ri } = S$3("MISSING_OR_INVALID", `request() expiry: ${$i}. Expiry must be a number (in seconds) between ${me.min} and ${me.max}`);
        throw new Error(Ri);
      }
    }, this.isValidRespond = async (Oe) => {
      var Si;
      if (!so(Oe)) {
        const { message: $i } = S$3("MISSING_OR_INVALID", `respond() params: ${Oe}`);
        throw new Error($i);
      }
      const { topic: wi, response: Ei } = Oe;
      try {
        await this.isValidSessionTopic(wi);
      } catch ($i) {
        throw (Si = Oe == null ? void 0 : Oe.response) != null && Si.id && this.cleanupAfterResponse(Oe), $i;
      }
      if (!ao(Ei)) {
        const { message: $i } = S$3("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(Ei)}`);
        throw new Error($i);
      }
    }, this.isValidPing = async (Oe) => {
      if (!so(Oe)) {
        const { message: wi } = S$3("MISSING_OR_INVALID", `ping() params: ${Oe}`);
        throw new Error(wi);
      }
      const { topic: Si } = Oe;
      await this.isValidSessionOrPairingTopic(Si);
    }, this.isValidEmit = async (Oe) => {
      if (!so(Oe)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", `emit() params: ${Oe}`);
        throw new Error(xi);
      }
      const { topic: Si, event: wi, chainId: Ei } = Oe;
      await this.isValidSessionTopic(Si);
      const { namespaces: $i } = this.client.session.get(Si);
      if (!lo($i, Ei)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", `emit() chainId: ${Ei}`);
        throw new Error(xi);
      }
      if (!uo(wi)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(wi)}`);
        throw new Error(xi);
      }
      if (!po($i, Ei, wi.name)) {
        const { message: xi } = S$3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(wi)}`);
        throw new Error(xi);
      }
    }, this.isValidDisconnect = async (Oe) => {
      if (!so(Oe)) {
        const { message: wi } = S$3("MISSING_OR_INVALID", `disconnect() params: ${Oe}`);
        throw new Error(wi);
      }
      const { topic: Si } = Oe;
      await this.isValidSessionOrPairingTopic(Si);
    }, this.isValidAuthenticate = (Oe) => {
      const { chains: Si, uri: wi, domain: Ei, nonce: $i } = Oe;
      if (!Array.isArray(Si) || Si.length === 0)
        throw new Error("chains is required and must be a non-empty array");
      if (!b$3(wi, !1))
        throw new Error("uri is required parameter");
      if (!b$3(Ei, !1))
        throw new Error("domain is required parameter");
      if (!b$3($i, !1))
        throw new Error("nonce is required parameter");
      if ([...new Set(Si.map((Ri) => re$1(Ri).namespace))].length > 1)
        throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: xi } = re$1(Si[0]);
      if (xi !== "eip155")
        throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (Oe) => {
      const { attestationId: Si, hash: wi, encryptedId: Ei, metadata: $i, transportType: xi } = Oe, Ri = { verified: { verifyUrl: $i.verifyUrl || X, validation: "UNKNOWN", origin: $i.url || "" } };
      try {
        if (xi === M$1.link_mode) {
          const Oi = this.getAppLinkIfEnabled($i, xi);
          return Ri.verified.validation = Oi && new URL(Oi).origin === new URL($i.url).origin ? "VALID" : "INVALID", Ri;
        }
        const Ti = await this.client.core.verify.resolve({ attestationId: Si, hash: wi, encryptedId: Ei, verifyUrl: $i.verifyUrl });
        Ti && (Ri.verified.origin = Ti.origin, Ri.verified.isScam = Ti.isScam, Ri.verified.validation = Ti.origin === new URL($i.url).origin ? "VALID" : "INVALID");
      } catch (Ti) {
        this.client.logger.warn(Ti);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(Ri)}`), Ri;
    }, this.validateSessionProps = (Oe, Si) => {
      Object.values(Oe).forEach((wi) => {
        if (!b$3(wi, !1)) {
          const { message: Ei } = S$3("MISSING_OR_INVALID", `${Si} must be in Record<string, string> format. Received: ${JSON.stringify(wi)}`);
          throw new Error(Ei);
        }
      });
    }, this.getPendingAuthRequest = (Oe) => {
      const Si = this.client.auth.requests.get(Oe);
      return typeof Si == "object" ? Si : void 0;
    }, this.addToRecentlyDeleted = (Oe, Si) => {
      if (this.recentlyDeletedMap.set(Oe, Si), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let wi = 0;
        const Ei = this.recentlyDeletedLimit / 2;
        for (const $i of this.recentlyDeletedMap.keys()) {
          if (wi++ >= Ei)
            break;
          this.recentlyDeletedMap.delete($i);
        }
      }
    }, this.checkRecentlyDeleted = (Oe) => {
      const Si = this.recentlyDeletedMap.get(Oe);
      if (Si) {
        const { message: wi } = S$3("MISSING_OR_INVALID", `Record was recently deleted - ${Si}: ${Oe}`);
        throw new Error(wi);
      }
    }, this.isLinkModeEnabled = (Oe, Si) => {
      var wi, Ei, $i, xi, Ri, Ti, Oi, Mi, Ii;
      return !Oe || Si !== M$1.link_mode ? !1 : ((Ei = (wi = this.client.metadata) == null ? void 0 : wi.redirect) == null ? void 0 : Ei.linkMode) === !0 && ((xi = ($i = this.client.metadata) == null ? void 0 : $i.redirect) == null ? void 0 : xi.universal) !== void 0 && ((Ti = (Ri = this.client.metadata) == null ? void 0 : Ri.redirect) == null ? void 0 : Ti.universal) !== "" && ((Oi = Oe == null ? void 0 : Oe.redirect) == null ? void 0 : Oi.universal) !== void 0 && ((Mi = Oe == null ? void 0 : Oe.redirect) == null ? void 0 : Mi.universal) !== "" && ((Ii = Oe == null ? void 0 : Oe.redirect) == null ? void 0 : Ii.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(Oe.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (Oe, Si) => {
      var wi;
      return this.isLinkModeEnabled(Oe, Si) ? (wi = Oe == null ? void 0 : Oe.redirect) == null ? void 0 : wi.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: Oe }) => {
      if (!Oe || !Oe.includes("wc_ev") || !Oe.includes("topic"))
        return;
      const Si = Wt$1(Oe, "topic") || "", wi = decodeURIComponent(Wt$1(Oe, "wc_ev") || ""), Ei = this.client.session.keys.includes(Si);
      Ei && this.client.session.update(Si, { transportType: M$1.link_mode }), this.client.core.dispatchEnvelope({ topic: Si, message: wi, sessionExists: Ei });
    }, this.registerLinkModeListeners = async () => {
      var Oe;
      if (zt$1() || $$1() && (Oe = this.client.metadata.redirect) != null && Oe.linkMode) {
        const Si = global == null ? void 0 : global.Linking;
        if (typeof Si < "u") {
          Si.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const wi = await Si.getInitialURL();
          wi && setTimeout(() => {
            this.handleLinkModeMessage({ url: wi });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S$3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : this.onRelayMessage(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: Oe, message: Si, attestation: wi, transportType: Ei } = e, { publicKey: $i } = this.client.auth.authKeys.keys.includes(ae) ? this.client.auth.authKeys.get(ae) : { responseTopic: void 0, publicKey: void 0 }, xi = await this.client.core.crypto.decode(Oe, Si, { receiverPublicKey: $i, encoding: Ei === M$1.link_mode ? pr$1 : ge });
    try {
      isJsonRpcRequest(xi) ? (this.client.core.history.set(Oe, xi), this.onRelayEventRequest({ topic: Oe, payload: xi, attestation: wi, transportType: Ei, encryptedId: br$1(Si) })) : isJsonRpcResponse(xi) ? (await this.client.core.history.resolve(xi), await this.onRelayEventResponse({ topic: Oe, payload: xi, transportType: Ei }), this.client.core.history.delete(Oe, xi.id)) : this.onRelayEventUnknownPayload({ topic: Oe, payload: xi, transportType: Ei });
    } catch (Ri) {
      this.client.logger.error(Ri);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(x$2.expired, async (e) => {
      const { topic: Oe, id: Si } = Kt$1(e.target);
      if (Si && this.client.pendingRequest.keys.includes(Si))
        return await this.deletePendingSessionRequest(Si, S$3("EXPIRED"), !0);
      if (Si && this.client.auth.requests.keys.includes(Si))
        return await this.deletePendingAuthRequest(Si, S$3("EXPIRED"), !0);
      Oe ? this.client.session.keys.includes(Oe) && (await this.deleteSession({ topic: Oe, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: Oe })) : Si && (await this.deleteProposal(Si, !0), this.client.events.emit("proposal_expire", { id: Si }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(j.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(j.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!b$3(e, !1)) {
      const { message: Oe } = S$3("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(Oe);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: Oe } = S$3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(Oe);
    }
    if (Ft$1(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: Oe } = S$3("EXPIRED", `pairing topic: ${e}`);
      throw new Error(Oe);
    }
  }
  async isValidSessionTopic(e) {
    if (!b$3(e, !1)) {
      const { message: Oe } = S$3("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(Oe);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: Oe } = S$3("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(Oe);
    }
    if (Ft$1(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: Oe } = S$3("EXPIRED", `session topic: ${e}`);
      throw new Error(Oe);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: Oe } = S$3("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(Oe);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (b$3(e, !1)) {
      const { message: Oe } = S$3("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(Oe);
    } else {
      const { message: Oe } = S$3("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(Oe);
    }
  }
  async isValidProposalId(e) {
    if (!oo(e)) {
      const { message: Oe } = S$3("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(Oe);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: Oe } = S$3("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(Oe);
    }
    if (Ft$1(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: Oe } = S$3("EXPIRED", `proposal id: ${e}`);
      throw new Error(Oe);
    }
  }
}
class Ss extends li {
  constructor(e, Oe) {
    super(e, Oe, it, ye), this.core = e, this.logger = Oe;
  }
}
class wt extends li {
  constructor(e, Oe) {
    super(e, Oe, nt, ye), this.core = e, this.logger = Oe;
  }
}
class Is extends li {
  constructor(e, Oe) {
    super(e, Oe, at, ye, (Si) => Si.id), this.core = e, this.logger = Oe;
  }
}
class fs extends li {
  constructor(e, Oe) {
    super(e, Oe, ht, oe, () => ae), this.core = e, this.logger = Oe;
  }
}
class vs extends li {
  constructor(e, Oe) {
    super(e, Oe, dt, oe), this.core = e, this.logger = Oe;
  }
}
class qs extends li {
  constructor(e, Oe) {
    super(e, Oe, ut, oe, (Si) => Si.id), this.core = e, this.logger = Oe;
  }
}
class Ts {
  constructor(e, Oe) {
    this.core = e, this.logger = Oe, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class _e extends S {
  constructor(e) {
    super(e), this.protocol = Ce, this.version = Le, this.name = we.name, this.events = new EventEmitter(), this.on = (Si, wi) => this.events.on(Si, wi), this.once = (Si, wi) => this.events.once(Si, wi), this.off = (Si, wi) => this.events.off(Si, wi), this.removeListener = (Si, wi) => this.events.removeListener(Si, wi), this.removeAllListeners = (Si) => this.events.removeAllListeners(Si), this.connect = async (Si) => {
      try {
        return await this.engine.connect(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.pair = async (Si) => {
      try {
        return await this.engine.pair(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.approve = async (Si) => {
      try {
        return await this.engine.approve(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.reject = async (Si) => {
      try {
        return await this.engine.reject(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.update = async (Si) => {
      try {
        return await this.engine.update(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.extend = async (Si) => {
      try {
        return await this.engine.extend(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.request = async (Si) => {
      try {
        return await this.engine.request(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.respond = async (Si) => {
      try {
        return await this.engine.respond(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.ping = async (Si) => {
      try {
        return await this.engine.ping(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.emit = async (Si) => {
      try {
        return await this.engine.emit(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.disconnect = async (Si) => {
      try {
        return await this.engine.disconnect(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.find = (Si) => {
      try {
        return this.engine.find(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (Si) {
        throw this.logger.error(Si.message), Si;
      }
    }, this.authenticate = async (Si, wi) => {
      try {
        return await this.engine.authenticate(Si, wi);
      } catch (Ei) {
        throw this.logger.error(Ei.message), Ei;
      }
    }, this.formatAuthMessage = (Si) => {
      try {
        return this.engine.formatAuthMessage(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.approveSessionAuthenticate = async (Si) => {
      try {
        return await this.engine.approveSessionAuthenticate(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.rejectSessionAuthenticate = async (Si) => {
      try {
        return await this.engine.rejectSessionAuthenticate(Si);
      } catch (wi) {
        throw this.logger.error(wi.message), wi;
      }
    }, this.name = (e == null ? void 0 : e.name) || we.name, this.metadata = (e == null ? void 0 : e.metadata) || $t$1(), this.signConfig = e == null ? void 0 : e.signConfig;
    const Oe = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : Tt$1(k({ level: (e == null ? void 0 : e.logger) || we.logger }));
    this.core = (e == null ? void 0 : e.core) || new Rn(e), this.logger = E(Oe, this.name), this.session = new wt(this.core, this.logger), this.proposal = new Ss(this.core, this.logger), this.pendingRequest = new Is(this.core, this.logger), this.engine = new Rs(this), this.auth = new Ts(this.core, this.logger);
  }
  static async init(e) {
    const Oe = new _e(e);
    return await Oe.initialize(), Oe;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, cjs$4.toMiliseconds(cjs$4.ONE_SECOND));
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
const Ps = _e;
class NodeWalletConnectKoinos {
  constructor() {
    El(this, "signClient");
    El(this, "topic", "");
    El(this, "chainId");
    El(this, "accounts", []);
    El(this, "options", {
      logLevel: LogLevel.none
    });
  }
  async init(e, Oe) {
    Oe && (this.options = Oe);
    const Si = await Ps.init({
      projectId: e.projectId,
      //@ts-expect-error types are compatible here
      metadata: {
        ...e.metadata
      },
      ...(Oe == null ? void 0 : Oe.nodeStorage) && { storage: Oe == null ? void 0 : Oe.nodeStorage }
    });
    (Oe == null ? void 0 : Oe.autoDisconnect) === !1 || Si.on(
      "session_delete",
      (Ei) => this.onSessionDelete(Ei)
    ), this.signClient = Si;
  }
  async close() {
    var e, Oe, Si, wi, Ei, $i, xi, Ri, Ti;
    (e = this.signClient) == null || e.core.events.removeAllListeners(), (Oe = this.signClient) == null || Oe.core.relayer.events.removeAllListeners(), (Si = this.signClient) == null || Si.core.heartbeat.stop(), (wi = this.signClient) == null || wi.core.relayer.provider.events.removeAllListeners(), (Ei = this.signClient) == null || Ei.core.relayer.subscriber.events.removeAllListeners(), ($i = this.signClient) == null || $i.core.relayer.provider.connection.events.removeAllListeners(), (xi = this.signClient) == null || xi.events.removeAllListeners("session_delete"), (Ri = this.signClient) != null && Ri.core.relayer.connected && await ((Ti = this.signClient) == null ? void 0 : Ti.core.relayer.transportClose()), this.signClient = void 0;
  }
  async onSessionDelete(e) {
    this.options.logLevel === LogLevel.debug && console.log("onSessionDelete", e), this.accounts = [], this.topic = "", this.chainId = void 0;
  }
  checkIfInitialized() {
    if (!this.signClient)
      throw new Error("Please call init(...) first");
  }
  async connect(e, Oe) {
    var $i;
    this.checkIfInitialized(), this.accounts = [];
    const Si = this.signClient.session.getAll();
    let wi = Si.length ? Si[Si.length - 1] : void 0;
    if (!wi) {
      const { uri: xi, approval: Ri } = await this.signClient.connect({
        requiredNamespaces: {
          koinos: {
            methods: Oe,
            chains: e,
            events: []
          }
        }
      });
      if (!xi)
        throw new Error("Could not generate WalletConnect URI");
      console.log("Please copy the following WalletConnect Pairing URI into your wallet:"), console.log(xi), wi = await Ri();
    }
    if (!wi)
      return [];
    this.topic = wi.topic, (($i = wi.namespaces.koinos.chains) == null ? void 0 : $i.length) === 1 && (this.chainId = wi.namespaces.koinos.chains[0]);
    const Ei = wi.namespaces.koinos.accounts.reduce((xi, Ri) => {
      const [Ti, Oi, Mi] = Ri.split(":");
      return xi.includes(Mi) || xi.push(Mi), xi;
    }, []);
    return this.accounts = Ei, Ei;
  }
  async disconnect() {
    this.checkIfInitialized();
    const e = await this.signClient.session.getAll();
    for (const Oe of e) {
      try {
        this.signClient.disconnect({
          topic: Oe.topic,
          reason: _$4("USER_DISCONNECTED")
        });
      } catch (Si) {
        console.error(Si);
      }
      if (Oe.pairingTopic)
        try {
          this.signClient.disconnect({
            topic: Oe.pairingTopic,
            reason: _$4("USER_DISCONNECTED")
          });
        } catch (Si) {
          console.error(Si);
        }
    }
    this.accounts = [], this.topic = "", this.chainId = void 0;
  }
  getAccounts() {
    return this.accounts;
  }
  getSigner(e, Oe, Si) {
    const wi = Si || this.chainId;
    if (!wi)
      throw new Error(
        "You must provide a chain id because none or several are present in this session."
      );
    return generateSigner(e, wi, this.topic, this.signClient, Oe);
  }
  getProvider(e) {
    const Oe = e || this.chainId;
    if (!Oe)
      throw new Error(
        "You must provide a chain id because none or several are present in this session."
      );
    return generateProvider(Oe, this.topic, this.signClient);
  }
}
var ChainIds = /* @__PURE__ */ ((se) => (se.Mainnet = "koinos:EiBZK_GGVP0H_fXVAM3j6EAuz3-B-l3e", se.Harbinger = "koinos:EiBncD4pKRIQWco_WRqo5Q-xnXR7JuO3", se))(ChainIds || {}), Methods = /* @__PURE__ */ ((se) => (se.SignMessage = "koinos_signMessage", se.SignHash = "koinos_signHash", se.SignTransaction = "koinos_signTransaction", se.SignAndSendTransaction = "koinos_signAndSendTransaction", se.PrepareTransaction = "koinos_prepareTransaction", se.WaitForTransaction = "koinos_waitForTransaction", se.JsonRpcCall = "koinos_JsonRpcCall", se.GetNonce = "koinos_getNonce", se.GetNextNonce = "koinos_getNextNonce", se.GetAccountRc = "koinos_getAccountRc", se.GetTransactionsById = "koinos_getTransactionsById", se.GetBlocksById = "koinos_getBlocksById", se.GetHeadInfo = "koinos_getHeadInfo", se.GetChainId = "koinos_getChainId", se.GetBlocks = "koinos_getBlocks", se.GetBlock = "koinos_getBlock", se.SendTransaction = "koinos_sendTransaction", se.ReadContract = "koinos_readContract", se.SubmitBlock = "koinos_submitBlock", se))(Methods || {}), LogLevel = /* @__PURE__ */ ((se) => (se[se.none = 0] = "none", se[se.debug = 1] = "debug", se))(LogLevel || {});
export {
  CoreUtil as C,
  EventsCtrl as E,
  LogLevel as L,
  ModalCtrl as M,
  NodeWalletConnectKoinos as N,
  OptionsCtrl as O,
  RouterCtrl as R,
  ThemeCtrl as T,
  WebWalletConnectKoinos as W,
  ToastCtrl as a,
  ExplorerCtrl as b,
  ConfigCtrl as c,
  ChainIds as d,
  Methods as e
};
